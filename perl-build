#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"CPAN/Perl/Releases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_PERL_RELEASES';
  package CPAN::Perl::Releases;$CPAN::Perl::Releases::VERSION='5.20210220';use strict;use warnings;use vars qw[@ISA @EXPORT_OK];use Exporter;@ISA=qw(Exporter);@EXPORT_OK=qw(perl_tarballs perl_versions perl_pumpkins);our$cache={};our$data={"5.004"=>{id=>'CHIPS' },"5.004_01"=>{id=>'TIMB' },"5.004_02"=>{id=>'TIMB' },"5.004_03"=>{id=>'TIMB' },"5.004_04"=>{id=>'TIMB' },"5.004_05"=>{id=>'CHIPS' },"5.005"=>{id=>'GSAR' },"5.005_01"=>{id=>'GSAR' },"5.005_02"=>{id=>'GSAR' },"5.005_03"=>{id=>'GBARR' },"5.005_04"=>{id=>'LBROCARD' },"5.6.0"=>{id=>'GSAR' },"5.6.1-TRIAL1"=>{id=>'GSAR' },"5.6.1-TRIAL2"=>{id=>'GSAR' },"5.6.1-TRIAL3"=>{id=>'GSAR' },"5.6.1"=>{id=>'GSAR' },"5.6.2"=>{id=>'RGARCIA' },"5.7.0"=>{id=>'JHI' },"5.7.2"=>{id=>'JHI' },"5.7.3"=>{id=>'JHI' },"5.8.0"=>{id=>'JHI' },"5.8.1"=>{id=>'JHI' },"5.8.2"=>{id=>'NWCLARK' },"5.8.3"=>{id=>'NWCLARK' },"5.8.4"=>{id=>'NWCLARK' },"5.8.5"=>{id=>'NWCLARK' },"5.8.6"=>{id=>'NWCLARK' },"5.8.7"=>{id=>'NWCLARK' },"5.8.8"=>{id=>'NWCLARK' },"5.8.9"=>{id=>'NWCLARK' },"5.9.0"=>{id=>'HVDS' },"5.9.1"=>{id=>'RGARCIA' },"5.9.2"=>{id=>'RGARCIA' },"5.9.3"=>{id=>'RGARCIA' },"5.9.4"=>{id=>'RGARCIA' },"5.9.5"=>{id=>'RGARCIA' },"5.10.0"=>{id=>'RGARCIA' },"5.10.1"=>{id=>'DAPM' },"5.11.0"=>{id=>'JESSE' },"5.11.1"=>{id=>'JESSE' },"5.11.2"=>{id=>'LBROCARD' },"5.11.3"=>{id=>'JESSE' },"5.11.4"=>{id=>'RJBS' },"5.11.5"=>{id=>'SHAY' },"5.12.0"=>{id=>'JESSE' },"5.12.1"=>{id=>'JESSE' },"5.12.2"=>{id=>'JESSE' },"5.12.3"=>{id=>'RJBS' },"5.12.4"=>{id=>'LBROCARD' },"5.12.5"=>{id=>'DOM' },"5.13.0"=>{id=>'LBROCARD' },"5.13.1"=>{id=>'RJBS' },"5.13.2"=>{id=>'MSTROUT' },"5.13.3"=>{id=>'DAGOLDEN' },"5.13.4"=>{id=>'FLORA' },"5.13.5"=>{id=>'SHAY' },"5.13.6"=>{id=>'MIYAGAWA' },"5.13.7"=>{id=>'BINGOS' },"5.13.8"=>{id=>'ZEFRAM' },"5.13.9"=>{id=>'JESSE' },"5.13.10"=>{id=>'AVAR' },"5.13.11"=>{id=>'FLORA' },"5.14.0"=>{id=>'JESSE' },"5.14.1"=>{id=>'JESSE' },"5.14.2-RC1"=>{id=>'FLORA' },"5.14.2"=>{id=>'FLORA' },"5.14.3"=>{id=>'DOM' },"5.14.4-RC1"=>{id=>'DAPM' },"5.14.4-RC2"=>{id=>'DAPM' },"5.14.4"=>{id=>'DAPM' },"5.15.0"=>{id=>'DAGOLDEN' },"5.15.1"=>{id=>'ZEFRAM' },"5.15.2"=>{id=>'RJBS' },"5.15.3"=>{id=>'STEVAN' },"5.15.4"=>{id=>'FLORA' },"5.15.5"=>{id=>'SHAY' },"5.15.6"=>{id=>'DROLSKY' },"5.15.7"=>{id=>'BINGOS' },"5.15.8"=>{id=>'CORION' },"5.15.9"=>{id=>'ABIGAIL' },"5.16.0"=>{id=>'RJBS' },"5.16.1"=>{id=>'RJBS' },"5.16.2"=>{id=>'RJBS' },"5.16.3"=>{id=>'RJBS' },"5.17.0"=>{id=>'ZEFRAM' },"5.17.1"=>{id=>'DOY' },"5.17.2"=>{id=>'TONYC' },"5.17.3"=>{id=>'SHAY' },"5.17.4"=>{id=>'FLORA' },"5.17.5"=>{id=>'FLORA' },"5.17.6"=>{id=>'RJBS' },"5.17.7"=>{id=>'DROLSKY' },"5.17.8"=>{id=>'ARC' },"5.17.9"=>{id=>'BINGOS' },"5.17.10"=>{id=>'CORION' },"5.17.11"=>{id=>'RJBS' },"5.18.0"=>{id=>'RJBS' },"5.18.1"=>{id=>'RJBS' },"5.19.0"=>{id=>'RJBS' },"5.19.1"=>{id=>'DAGOLDEN' },"5.19.2"=>{id=>'ARISTOTLE' },"5.19.3"=>{id=>'SHAY' },"5.19.4"=>{id=>'SHAY' },"5.19.5"=>{id=>'SHAY' },"5.19.6"=>{id=>'BINGOS' },"5.19.7"=>{id=>'ABIGAIL' },"5.18.2"=>{id=>'RJBS' },"5.19.8"=>{id=>'RJBS' },"5.19.9"=>{id=>'TONYC' },"5.19.10"=>{id=>'ARC' },"5.19.11"=>{id=>'SHAY' },"5.20.0"=>{id=>'RJBS' },"5.21.0"=>{id=>'RJBS' },"5.21.1"=>{id=>'WOLFSAGE' },"5.21.2"=>{id=>'ABIGAIL' },"5.21.3"=>{id=>'PCM' },"5.20.1-RC1"=>{id=>'SHAY' },"5.20.1-RC2"=>{id=>'SHAY' },"5.20.1"=>{id=>'SHAY' },"5.21.4"=>{id=>'SHAY' },"5.18.3"=>{id=>'RJBS' },"5.18.4"=>{id=>'RJBS' },"5.21.5"=>{id=>'ABIGAIL' },"5.21.6"=>{id=>'BINGOS' },"5.21.7"=>{id=>'CORION' },"5.21.8"=>{id=>'WOLFSAGE' },"5.20.2-RC1"=>{id=>'SHAY' },"5.20.2"=>{id=>'SHAY' },"5.21.10"=>{id=>'SHAY' },"5.21.11"=>{id=>'SHAY' },"5.22.0"=>{id=>'RJBS' },"5.23.0"=>{id=>'RJBS' },"5.23.1"=>{id=>'WOLFSAGE' },"5.23.2"=>{id=>'WOLFSAGE' },"5.20.3-RC1"=>{id=>'SHAY' },"5.20.3-RC2"=>{id=>'SHAY' },"5.20.3"=>{id=>'SHAY' },"5.23.3"=>{id=>'PCM' },"5.23.4"=>{id=>'SHAY' },"5.22.1-RC1"=>{id=>'SHAY' },"5.22.1-RC2"=>{id=>'SHAY' },"5.23.5"=>{id=>'ABIGAIL' },"5.22.1-RC3"=>{id=>'SHAY' },"5.22.1-RC4"=>{id=>'SHAY' },"5.22.1"=>{id=>'SHAY' },"5.23.6"=>{id=>'DAGOLDEN',noxz=>1 },"5.23.7"=>{id=>'STEVAN' },"5.23.9"=>{id=>'ABIGAIL' },"5.22.2-RC1"=>{id=>'SHAY' },"5.24.0-RC1"=>{id=>'RJBS' },"5.24.0-RC2"=>{id=>'RJBS' },"5.24.0-RC3"=>{id=>'RJBS' },"5.22.2"=>{id=>'SHAY' },"5.24.0-RC4"=>{id=>'RJBS' },"5.24.0-RC5"=>{id=>'RJBS' },"5.24.0"=>{id=>'RJBS' },"5.25.0"=>{id=>'RJBS' },"5.25.2"=>{id=>'WOLFSAGE' },"5.22.3-RC1"=>{id=>'SHAY' },"5.24.1-RC1"=>{id=>'SHAY' },"5.25.3"=>{id=>'SHAY' },"5.22.3-RC2"=>{id=>'SHAY' },"5.24.1-RC2"=>{id=>'SHAY' },"5.22.3-RC3"=>{id=>'SHAY' },"5.24.1-RC3"=>{id=>'SHAY' },"5.25.4"=>{id=>'BINGOS' },"5.25.5"=>{id=>'STEVAN' },"5.22.3-RC4"=>{id=>'SHAY' },"5.24.1-RC4"=>{id=>'SHAY' },"5.25.6"=>{id=>'ARC' },"5.25.7"=>{id=>'EXODIST' },"5.22.3-RC5"=>{id=>'SHAY' },"5.24.1-RC5"=>{id=>'SHAY' },"5.22.3"=>{id=>'SHAY' },"5.24.1"=>{id=>'SHAY' },"5.25.9"=>{id=>'ABIGAIL' },"5.25.10"=>{id=>'RENEEB' },"5.26.0"=>{id=>'XSAWYERX' },"5.27.1"=>{id=>'EHERMAN' },"5.22.4-RC1"=>{id=>'SHAY' },"5.24.2-RC1"=>{id=>'SHAY' },"5.22.4"=>{id=>'SHAY' },"5.24.2"=>{id=>'SHAY' },"5.27.2"=>{id=>'ARC' },"5.27.3"=>{id=>'WOLFSAGE' },"5.24.3-RC1"=>{id=>'SHAY' },"5.26.1-RC1"=>{id=>'SHAY' },"5.27.4"=>{id=>'GENEHACK' },"5.24.3"=>{id=>'SHAY' },"5.26.1"=>{id=>'SHAY' },"5.27.5"=>{id=>'SHAY' },"5.27.6"=>{id=>'ETHER' },"5.27.7"=>{id=>'BINGOS' },"5.27.8"=>{id=>'ABIGAIL' },"5.27.9"=>{id=>'RENEEB' },"5.27.10"=>{id=>'TODDR' },"5.24.4-RC1"=>{id=>'SHAY' },"5.26.2-RC1"=>{id=>'SHAY' },"5.24.4"=>{id=>'SHAY' },"5.26.2"=>{id=>'SHAY' },"5.27.11"=>{id=>'XSAWYERX' },"5.28.0-RC1"=>{id=>'XSAWYERX' },"5.28.0-RC2"=>{id=>'XSAWYERX' },"5.28.0-RC3"=>{id=>'XSAWYERX' },"5.28.0-RC4"=>{id=>'XSAWYERX' },"5.28.0"=>{id=>'XSAWYERX' },"5.29.0"=>{id=>'XSAWYERX' },"5.29.1"=>{id=>'SHAY' },"5.29.2"=>{id=>'BINGOS' },"5.29.3"=>{id=>'GENEHACK' },"5.29.4"=>{id=>'ARC' },"5.29.5"=>{id=>'ETHER' },"5.26.3"=>{id=>'SHAY' },"5.28.1"=>{id=>'SHAY' },"5.29.6"=>{id=>'ABIGAIL' },"5.29.7"=>{id=>'ABIGAIL' },"5.29.8"=>{id=>'ATOOMIC' },"5.29.9"=>{id=>'ZAKAME' },"5.28.2-RC1"=>{id=>'SHAY' },"5.28.2"=>{id=>'SHAY' },"5.29.10"=>{id=>'XSAWYERX' },"5.30.0-RC1"=>{id=>'XSAWYERX' },"5.30.0-RC2"=>{id=>'XSAWYERX' },"5.30.0"=>{id=>'XSAWYERX' },"5.31.0"=>{id=>'XSAWYERX' },"5.31.1"=>{id=>'ETHER' },"5.31.2"=>{id=>'SHAY' },"5.31.3"=>{id=>'TOMHUKINS' },"5.31.4"=>{id=>'CORION' },"5.31.5"=>{id=>'SHAY' },"5.30.1-RC1"=>{id=>'SHAY' },"5.30.1"=>{id=>'SHAY' },"5.31.6"=>{id=>'BINGOS' },"5.31.7"=>{id=>'ATOOMIC' },"5.31.8"=>{id=>'WOLFSAGE' },"5.31.9"=>{id=>'RENEEB' },"5.30.2-RC1"=>{id=>'SHAY' },"5.30.2"=>{id=>'SHAY' },"5.31.10"=>{id=>'XSAWYERX' },"5.31.11"=>{id=>'XSAWYERX' },"5.32.0-RC0"=>{id=>'XSAWYERX' },"5.28.3-RC1"=>{id=>'XSAWYERX' },"5.28.3"=>{id=>'XSAWYERX' },"5.30.3-RC1"=>{id=>'XSAWYERX' },"5.30.3"=>{id=>'XSAWYERX' },"5.32.0-RC1"=>{id=>'XSAWYERX' },"5.32.0"=>{id=>'XSAWYERX' },"5.33.0"=>{id=>'XSAWYERX' },"5.33.1"=>{id=>'ETHER' },"5.33.2"=>{id=>'XSAWYERX' },"5.33.3"=>{id=>'SHAY' },"5.33.4"=>{id=>'TOMHUKINS' },"5.33.5"=>{id=>'CORION' },"5.32.1-RC1"=>{id=>'SHAY' },"5.33.6"=>{id=>'HYDAHY' },"5.32.1"=>{id=>'SHAY' },"5.33.7"=>{id=>'RENEEB' },};sub perl_tarballs {my$vers=shift;return unless defined$vers;$vers=shift if eval {$vers->isa(__PACKAGE__)};return unless exists$data->{$vers };if (exists$cache->{$vers }){return {%{$cache->{$vers }}}}my$pumpkin=$data->{$vers }->{id};my$path=join '/',substr($pumpkin,0,1),substr($pumpkin,0,2),$pumpkin;my$sep=($vers =~ m!^5\.0! ? '' : '-');my$perl=join$sep,'perl',$vers;my$onlygz=1 if$vers =~ m!(?-xism:5.(?:00(?:4(?:_0[12345])?|5(?:_0[1234])?|3_07)|1(?:0.0(?:-RC[12])?|6.0-RC0)|6.(?:[02]|1(?:-TRIAL[123])?)|9.[12345]|7.[0123]|8.[01]))! || $data->{$vers }->{onlygz};my$onlybz2=1 if$data->{$vers }->{onlybz2};my$noxz=1 if$data->{$vers }->{noxz};my$lvers;{my$tvers=$vers;$tvers =~ s!\-?(TRIAL|RC)\d*!!g;$tvers =~ s!_!.!g;my@parts=split m!\.!,$tvers;push@parts,0 if scalar@parts < 3;$lvers=sprintf("%d.%03d%03d",@parts)}my$foo={};$foo->{'tar.gz'}="$path/$perl.tar.gz" unless$onlybz2;$foo->{'tar.bz2'}="$path/$perl.tar.bz2" unless$onlygz || $lvers > 5.027005;$foo->{'tar.xz'}="$path/$perl.tar.xz" if$lvers > 5.021005 &&!$noxz;$cache->{$vers }=$foo;return {%$foo }}sub perl_versions {return sort _by_version keys %$data}sub _by_version {my%v=map {my@v=split(qr/[-._]0*/,$_);$v[2]||= 0;$v[3]||= 'Z';($_=>sprintf '%d.%03d%03d-%s',@v)}$a,$b;$v{$a}cmp $v{$b}}sub perl_pumpkins {my%pumps=map {($data->{$_}->{id}=>1)}keys %$data;return sort keys%pumps}q|Acme::Why::Did::I::Not::Read::The::Fecking::Memo|;
CPAN_PERL_RELEASES

$fatpacked{"CPAN/Perl/Releases/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_PERL_RELEASES_METACPAN';
  package CPAN::Perl::Releases::MetaCPAN;use strict;use warnings;our$VERSION='0.006';use JSON::PP ();use HTTP::Tinyish;use Exporter 'import';our@EXPORT_OK=qw(perl_tarballs perl_versions perl_pumpkins);sub new {my ($class,%option)=@_;my$uri=$option{uri}|| "https://fastapi.metacpan.org/v1/release";$uri =~ s{/$}{};my$cache=exists$option{cache}? $option{cache}: 1;my$http=HTTP::Tinyish->new(verify_SSL=>1,agent=>__PACKAGE__ ."/$VERSION");my$json=JSON::PP->new->canonical(1);bless {uri=>$uri,http=>$http,cache=>$cache,json=>$json },$class}sub get {my$self=shift;return$self->{_releases}if$self->{cache}and $self->{_releases};my@release;my$from=0;my$total;my$uri="$self->{uri}/_search";for (1..5){my$query={query=>{bool=>{must=>[{term=>{distribution=>"perl" }},{term=>{authorized=>JSON::PP::true }},],},},size=>1000,from=>$from,sort=>[{date=>'desc' }],fields=>[qw(name date author version status maturity download_url)],};my$res=$self->{http}->post($uri,{content=>$self->{json}->encode($query),headers=>{'content-type'=>'application/json' },});if (!$res->{success}){my$message=$res->{status}==599 ? ", $res->{content}" : "";chomp$message;$message =~ s/\n/ /g;die "$res->{status} $res->{reason}, $uri$message\n"}my$hash=$self->{json}->decode($res->{content});$total=$hash->{hits}{total}unless defined$total;push@release,map {$_->{fields}}@{$hash->{hits}{hits}};last if$total <= @release;$from=@release}if ($total!=@release){die sprintf "metacpan returns %d perl releases, but expected %d\n",(scalar@release),$total}$self->{_releases}=\@release if$self->{cache};\@release}sub _self {my$self=eval {$_[0]->isa(__PACKAGE__)}? shift : __PACKAGE__->new;wantarray ? ($self,@_): $self}sub perl_tarballs {my ($self,$arg)=_self @_;my$releases=$self->get;my%tarballs=map {my$url=$_->{download_url};$url =~ s{.*authors/id/}{};if ($url =~ /\.(tar\.\S+)$/){($1,$url)}else {()}}grep {my$name=$_->{name};$name =~ s/^perl-?//;$name eq $arg}grep {$_->{status}=~ /^(?:cpan|latest)$/}@$releases;\%tarballs}sub perl_versions {my$self=_self @_;my$releases=$self->get;my@versions=map {my$name=$_->{name};$name =~ s/^perl-?//;$name}grep {$_->{status}=~ /^(?:cpan|latest)$/}@$releases;@versions}sub perl_pumpkins {my$self=_self @_;my$releases=$self->get;my%author=map {$_->{author}=>1}grep {$_->{status}=~ /^(?:cpan|latest)$/}@$releases;sort keys%author}1;
CPAN_PERL_RELEASES_METACPAN

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;use strict;use Exporter 5.57 'import';use vars qw($VERSION @EXPORT_OK);use if $] > 5.017,'deprecate';$VERSION='0.4';@EXPORT_OK=qw(list_packages);sub list_packages {my$pack=shift;$pack .= "::" unless$pack =~ m!::$!;no strict 'refs';my@packs;my@stuff=grep!/^(main|)::$/,keys %{$pack};for my$cand (grep /::$/,@stuff){$cand =~ s!::$!!;my@children=list_packages($pack.$cand);push@packs,"$pack$cand" unless$cand =~ /^::/ || !__PACKAGE__->_loaded($pack.$cand);push@packs,@children}return grep {$_ !~ /::(::ISA::CACHE|SUPER)/}@packs}sub _loaded {my ($class,$name)=@_;no strict 'refs';return 1 if defined ${"${name}::VERSION"};return 1 if @{"${name}::ISA"};for (keys %{"${name}::"}){next if substr($_,-2,2)eq '::';return 1 if defined &{"${name}::$_"}}my$filename=join('/',split /(?:'|::)/,$name).'.pm';return 1 if defined$INC{$filename};''}1;
DEVEL_INNERPACKAGE

$fatpacked{"Devel/PatchPerl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL';
  package Devel::PatchPerl;$Devel::PatchPerl::VERSION='2.08';use strict;use warnings;use File::pushd qw[pushd];use File::Spec;use IO::File;use Devel::PatchPerl::Hints qw[hint_file];use MIME::Base64 qw[decode_base64];use Module::Pluggable search_path=>['Devel::PatchPerl::Plugin'];use vars qw[@ISA @EXPORT_OK];use constant CERTIFIED=>5.033005;use constant HINTSCERT=>5.033004;@ISA=qw(Exporter);@EXPORT_OK=qw(patch_source);my$patch_exe=_can_run('gpatch')|| _can_run('patch');my@patch=({perl=>[qw/5.005/,],subs=>[[\&_patch_5_005,1 ],],},{perl=>[qw/5.005_01/,],subs=>[[\&_patch_5_005_01,1 ],],},{perl=>[qw/5.005_02/,],subs=>[[\&_patch_5_005_02,1 ],],},{perl=>[qr/^5\.00[2345]/,qw/5.001n/,],subs=>[[\&_patch_handy,1 ],],},{perl=>[qw/5.005 5.005_01 5.005_02 5.005_03 5.005_04/,],subs=>[[\&_replace_makedepend,1 ],],},{perl=>[qr/^5\.00[01234]/,qw/5.005 5.005_01 5.005_02 5.005_03/,],subs=>[[\&_patch_db,1 ],],},{perl=>[qr/^5\.6\.[1-2]$/,qr/^5\.7\.[0-1]$/,],subs=>[[\&_patch_makefile_sh_phony ],],},{perl=>[qw/5.6.0 5.6.1 5.7.0 5.7.1 5.7.2 5.7.3 5.8.0/,],subs=>[[\&_patch_db,3 ],],},{perl=>[qr/^5\.004_0[1234]$/,],subs=>[[\&_patch_doio ],],},{perl=>[qw/5.005 5.005_01 5.005_02/,],subs=>[[\&_patch_sysv,old_format=>1 ],],},{perl=>[qw/5.005_03 5.005_04/,qr/^5\.6\.[0-2]$/,qr/^5\.7\.[0-3]$/,qr/^5\.8\.[0-8]$/,qr/^5\.9\.[0-5]$/ ],subs=>[[\&_patch_sysv,old_format=>0 ],],},{perl=>[qr/^5\.004_05$/,qr/^5\.005(?:_0[1-4])?$/,qr/^5\.6\.[01]$/,],subs=>[[\&_patch_configure ],[\&_patch_makedepend_lc ],],},{perl=>[qr/^5\.6\.[0-2]$/,],subs=>[[\&_patch_conf_gconvert ],[\&_patch_sort_N ],],},{perl=>['5.8.0',],subs=>[[\&_patch_makedepend_lc ],],},{perl=>[qr/.*/,],subs=>[[\&_patch_conf_solaris ],[\&_patch_bitrig ],[\&_patch_patchlevel ],[\&_patch_develpatchperlversion ],[\&_patch_errno_gcc5 ],[\&_patch_conf_fwrapv ],[\&_patch_utils_h2ph ],[\&_patch_lib_h2ph ],[\&_patch_sdbm_file_c ],[\&_patch_mmaix_pm ],[\&_patch_time_local_t ],[\&_patch_pp_c_libc ],[\&_patch_conf_gcc10 ],[\&_patch_dynaloader_mac ],[\&_patch_eumm_darwin ],],},{perl=>[qr/^5\.6\.[0-2]$/,qr/^5\.7\.[0-3]$/,qr/^5\.8\.[0-8]$/,qr/^5\.9\.[0-4]$/,],subs=>[[\&_patch_makedepend_SH ],],},{perl=>[qr/^5\.1[0-2]/,],subs=>[[\&_patch_archive_tar_tests ],[\&_patch_odbm_file_hints_linux ],],},{perl=>[qr/^5.1([24].\d+|0.1)/,],subs=>[[\&_patch_make_ext_pl ],],},{perl=>[qr/^5\.8\.9$/,],subs=>[[\&_patch_589_perlio_c ],],},{perl=>[qr/^5\.8\.[89]$/ ],subs=>[[\&_patch_hsplit_rehash_58 ]],},{perl=>[qr/^5\.10\.1$/,qr/^5\.12\.5$/,],subs=>[[\&_patch_hsplit_rehash_510 ]],},{perl=>[qr/^5\.18\.0$/,],subs=>[[\&_patch_regmatch_pointer_5180 ]],},{perl=>[qr/^5\.20\.0$/,],subs=>[[\&_patch_cow_speed ]],},{perl=>[qr/^5\.6\.[012]$/,qr/^5\.8\.[89]$/,qr/^5\.10\.[01]$/,],subs=>[[\&_patch_preprocess_options ]],},{perl=>[qr/^5\.18\.3$/,],subs=>[[\&_patch_5183_metajson ]],},{perl=>[qr/^5\.24\.[012]$/,],subs=>[[\&_patch_time_hires ]],},{perl=>[qr/^5\.24\.3$/,qr/^5\.25\.(?:[4-9]|10)$/,qr/^5\.26\.[01]$/,qr/^5\.27\.[0-4]$/,],subs=>[[\&_patch_fp_class_denorm ]],},{perl=>[qr/^5\.28\.[01]$/,],subs=>[[\&_patch_useshrplib ]],},);sub patch_source {my$vers=shift;$vers=shift if eval {$vers->isa(__PACKAGE__)};my$source=shift || '.';if (!$vers){$vers=_determine_version($source);if ($vers){warn "Auto-guessed '$vers'\n"}else {die "You didn't provide a perl version and I don't appear to be in a perl source tree\n"}}my$normver=_norm_ver($vers);$source=File::Spec->rel2abs($source);if ($normver < HINTSCERT){my$dir=pushd($source);_patch_hints()}if ($normver >= CERTIFIED){warn "Nothing else to do, '$vers' is fine\n";return}{my$dir=pushd($source);for my$p (grep {_is($_->{perl},$vers)}@patch){for my$s (@{$p->{subs}}){my($sub,@args)=@$s;push@args,$vers unless scalar@args;$sub->(@args)}}_process_plugin(version=>$vers,source=>$source,patchexe=>$patch_exe)}}sub _process_plugin {my%args=@_;return unless my$possible=$ENV{PERL5_PATCHPERL_PLUGIN};my ($plugin)=grep {$possible eq $_ or /\Q$possible\E$/}__PACKAGE__->plugins;unless ($plugin){warn "# You specified a plugin '",$ENV{PERL5_PATCHPERL_PLUGIN},"' that isn't installed, just thought you might be interested.\n";return}{local $@;eval "require $plugin";if ($@){die "# I tried to load '",$ENV{PERL5_PATCHPERL_PLUGIN},"' but it didn't work out. Here is what happened '$@'\n"}}{local $@;eval {$plugin->patchperl(%args,)};if ($@){warn "# Warnings from the plugin: '$@'\n"}}return 1}sub _can_run {my$command=shift;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}require File::Spec;require ExtUtils::MakeMaker;my@possibles;if(File::Spec->file_name_is_absolute($command)){return MM->maybe_command($command)}else {for my$dir (File::Spec->path,File::Spec->curdir){next if!$dir ||!-d $dir;my$abs=File::Spec->catfile($^O eq 'MSWin32' ? Win32::GetShortPathName($dir): $dir,$command);push@possibles,$abs if$abs=MM->maybe_command($abs)}}return@possibles if wantarray;return shift@possibles}sub _is {my($s1,$s2)=@_;defined$s1!=defined$s2 and return 0;ref$s2 and ($s1,$s2)=($s2,$s1);if (ref$s1){if (ref$s1 eq 'ARRAY'){_is($_,$s2)and return 1 for @$s1;return 0}return$s2 =~ $s1}return$s1 eq $s2}sub _patch_b64 {my($base64)=@_;my$patch=decode_base64($base64);_patch($patch)}sub _patch {my($patch)=@_;my%mode;for my$file ($patch =~ /^\+{3}\s+(\S+)/gm){print "patching $file\n";if (-r $file and not -w _){my$mode=(stat$file)[2];$mode{$file}=$mode;chmod$mode | 0200,$file}}my$diff='tmp.diff';_write_or_die($diff,$patch);die "No patch utility found\n" unless$patch_exe;local$ENV{PATCH_GET}=0;_run_or_die("$patch_exe -f -s -p0 <$diff");unlink$diff or die "unlink $diff: $!\n";for my$file (sort keys%mode){chmod$mode{$file},$file}}sub _write_or_die {my($file,$data)=@_;my$fh=IO::File->new(">$file")or die "$file: $!\n";$fh->print($data)}sub _run_or_die {die unless system(@_)==0}sub determine_version {my$src=shift;$src=shift if eval {$src->isa(__PACKAGE__)};$src='.' unless$src;_determine_version($src)}sub _determine_version {my ($source)=@_;my$patchlevel_h=File::Spec->catfile($source,'patchlevel.h');return unless -e $patchlevel_h;my$version;{my%defines;open my$fh,'<',$patchlevel_h;my@vers;while (<$fh>){chomp;next unless /^#define/;my ($foo,$bar)=(split /\s+/)[1,2];$defines{$foo}=$bar}if (my@wotsits=grep {defined$defines{$_}}qw(PERL_REVISION PERL_VERSION PERL_SUBVERSION)){$version=join '.',map {$defines{$_}}@wotsits}elsif (my@watsits=grep {defined$defines{$_}}qw(PATCHLEVEL SUBVERSION)){$version=sprintf '5.%03d_%02d',map {$defines{$_}}@watsits}else {return}}return$version}sub _patchperl_version {return$Devel::PatchPerl::VERSION || "(unreleased)"}sub _patch_patchlevel {return if -d '.git' and!$ENV{PERL5_PATCHPERL_PATCHLEVEL};my$dpv=$Devel::PatchPerl::VERSION || "(unreleased)";open my$plin,"patchlevel.h" or die "Couldn't open patchlevel.h : $!";open my$plout,">patchlevel.new" or die "Couldn't write on patchlevel.new : $!";my$seen=0;while (<$plin>){if (/\t,NULL/ and $seen){print {$plout}qq{\t,"Devel::PatchPerl $dpv"\n}}$seen++ if /local_patches\[\]/;print {$plout}$_}close$plout or die "Couldn't close filehandle writing to patchlevel.new : $!";close$plin or die "Couldn't close filehandle reading from patchlevel.h : $!";unlink "patchlevel.bak" or warn "Couldn't unlink patchlevel.bak : $!" if -e "patchlevel.bak";rename "patchlevel.h","patchlevel.bak" or die "Couldn't rename patchlevel.h to patchlevel.bak : $!";rename "patchlevel.new","patchlevel.h" or die "Couldn't rename patchlevel.new to patchlevel.h : $!"}sub _patch_hints {my@os;push@os,$^O;push@os,'linux' if $^O eq 'gnukfreebsd';for my$os (@os){return unless my ($file,$data)=hint_file($os);my$path=File::Spec->catfile('hints',$file);warn "Patching '$path'\n";if (-e $path){chmod 0644,$path or die "$!\n"}open my$fh,'>',$path or die "$!\n";print$fh $data;close$fh}return 1}sub _patch_db {my$ver=shift;for my$file ('ext/DB_File/DB_File.xs','Configure'){print "patching $file\n";_run_or_die($^X,'-pi.bak','-e',"s/<db.h>/<db$ver\\/db.h>/",$file);unlink "$file.bak" if -e "$file.bak"}}sub _patch_doio {_patch(<<'END')}sub _patch_sysv {my%opt=@_;return if $^O ne 'linux' or -f '/usr/include/asm/page.h';if ($opt{old_format}){_patch(<<'END')}else {_patch(<<'END')}}sub _patch_configure {_patch(<<'END')}sub _patch_makedepend_lc {_patch(<<'END')}sub _patch_makedepend_SH {my$perl=shift;SWITCH: {if ($perl eq '5.6.0'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.6.1'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.6.2'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.7.0'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.7.1'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.7.2'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.7.3'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.8.0'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.9.4'){_patch_b64(<<'BADGER');last SWITCH}_patch(<<'BADGER')}}sub _patch_conf_gconvert {my$perl=shift;_patch(<<'END')}sub _patch_sort_N {system($^X,'-pi.bak','-e','s!\$sort \-n \+1!(\$sort -n -k 2 2>/dev/null || \$sort -n +1)!','Configure')}sub _patch_archive_tar_tests {my$perl=shift;if ($perl =~ /^5\.10/){_patch(<<'END')}else {_patch(<<'END')}}sub _patch_odbm_file_hints_linux {_patch(<<'END')}sub _patch_make_ext_pl {_patch(<<'END')}sub _patch_589_perlio_c {_patch(<<'END')}sub _patch_hsplit_rehash_58 {my$perl=shift;my$patch=<<'END';if ($perl =~ qr/^5\.8\.8$/){$patch =~ s/non-pathological/non-pathalogical/;$patch =~ s/triggering/triggerring/}_patch($patch)}sub _patch_hsplit_rehash_510 {_patch(<<'END')}sub _patch_bitrig {return unless $^O eq 'bitrig';my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.019004;unless ($num < 5.00800){_patch(<<'BOOGLE')}if ($num < 5.008009){_patch(<<'BITRIGM1')}else {_patch(<<'BITRIGMX')}if ($num < 5.008001){}elsif ($num < 5.008007){_patch(<<'BITRIGC3')}elsif ($num < 5.008009){_patch(<<'BITRIGC2')}elsif ($num < 5.013000){_patch(<<'BITRIGC1')}else {_patch(<<'BITRIGCX')}}sub _patch_conf_solaris {return unless $^O eq 'solaris';my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.018000;_patch(<<'BUBBLE')}sub _patch_regmatch_pointer_5180 {_patch(<<'BOBBLE')}sub _patch_makefile_sh_phony {_patch(<<'END')}sub _patch_cow_speed {_patch(<<'COWSAY')}sub _patch_preprocess_options {my$perl=shift;if ($perl =~ /^5\.(?:8|10)\./){_patch(<<'END')}elsif ($perl =~ /^5\.6\./){_patch(<<'END')}}sub _patch_5183_metajson {_patch(<<'DOGSAY')}sub _patch_handy {_patch(<<'END')}sub _replace_makedepend {_write_or_die('makedepend.SH',<<'END')}sub _patch_5_005_02 {_patch(<<'END')}sub _patch_5_005_01 {_patch(<<'END')}sub _patch_5_005 {_patch(<<'END')}sub _patch_errno_gcc5 {my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.021009;return if$num > 5.020002 && $num < 5.021;if ($num < 5.006){warn "The Errno GCC 5 patch only goes back as far as v5.6.0\n";warn "You will have to generate your own patch to go farther back\n";return}elsif ($num < 5.006001){_patch(<<'END')}elsif ($num==5.00700){_patch_b64(<<'END')}elsif ($num < 5.007002){_patch(<<'END')}elsif ($num < 5.007003){_patch(<<'END')}elsif ($num < 5.008009){_patch(<<'END')}elsif ($num > 5.008009 and $num < 5.009003){_patch_b64(<<'END')}else {_patch(<<'END')}}sub _patch_time_hires {_patch(<<'END')}sub _patch_fp_class_denorm {my$perlver=shift;my$num=_norm_ver($perlver);if ($num < 5.025004){_patch(<<'END')}else {_patch(<<'END')}}sub _norm_ver {my$ver=shift;my@v=split(qr/[._]0*/,$ver);$v[2]||= 0;return sprintf '%d.%03d%03d',@v}sub _patch_develpatchperlversion {return if -d '.git';my$dpv=$Devel::PatchPerl::VERSION || "(unreleased)";_patch(<<"END")}sub _patch_conf_fwrapv {my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.019011;_patch(<<'FWRAPV')}sub _patch_utils_h2ph {my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.021009;return if$num==5.020003;if ($num < 5.006001){return _patch_b64(<<'UH2PH560')}if ($num < 5.007000){return _patch_b64(<<'UH2PH562')}if ($num < 5.007001){_patch_b64(<<'UH2PH570')}elsif ($num < 5.007002){_patch_b64(<<'UH2PH571')}elsif ($num < 5.007003){_patch_b64(<<'UH2PH572')}if ($num < 5.008000){return _patch_b64(<<'UH2PH573')}if ($num < 5.008001){return _patch_b64(<<'UH2PH580')}if ($num < 5.008009){return _patch_b64(<<'UH2PH588')}if ($num > 5.008009 and $num < 5.009002){_patch_b64(<<'UH2PH592')}if ($num > 5.008009 and $num < 5.009003){_patch_b64(<<'UH2PH593')}if ($num > 5.008009 and $num < 5.009004){_patch_b64(<<'UH2PH594')}_patch(<<'UH2PH')}sub _patch_lib_h2ph {my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.021010;return if$num==5.020003;if ($num >= 5.013005){_patch(<<'LH2PH1')}elsif ($num >= 5.013001){_patch(<<'LH2PH2')}elsif ($num >= 5.010001){_patch(<<'LH2PH3')}}sub _patch_sdbm_file_c {my$perlver=shift;my$num=_norm_ver($perlver);return unless$num > 5.010000;return unless$num < 5.014004;_patch_b64(<<'SDBMFILEC')}sub _patch_mmaix_pm {my$perlver=shift;return unless $^O eq 'aix';my$num=_norm_ver($perlver);return unless$num > 5.027000;return unless$num < 5.031001;_patch_b64(<<'MMAIXPM')}sub _patch_time_local_t {my$perlver=shift;my$num=_norm_ver($perlver);if ($num < 5.029000 && $num > 5.025003){return _patch_b64(<<'TIMELOCALT1')}if ($num < 5.025004 && $num > 5.013008){return _patch_b64(<<'TIMELOCALT2')}if ($num < 5.013009 && $num > 5.010001){return _patch_b64(<<'TIMELOCALT3')}if (($num <= 5.010001 && $num > 5.009003)|| $num==5.008009){return _patch_b64(<<'TIMELOCALT4')}if (($num==5.009002 || $num==5.009003)|| ($num==5.008008 || $num==5.008007)){return _patch_b64(<<'TIMELOCALT5')}}sub _patch_pp_c_libc {my$perlver=shift;my$num=_norm_ver($perlver);return unless$num > 5.008000;return unless$num < 5.028000;_patch_b64(<<'PPCLIBC')}sub _patch_conf_gcc10 {my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.031006;return if$num >= 5.030002;if ($num <= 5.006001 or ($num >= 5.00700 and $num < 5.00800)){return _patch_b64(<<'CONFGCC10561')}if ($num <= 5.008008 or ($num > 5.008009 and $num < 5.009004)){return _patch_b64(<<'CONFGCC10588')}if ($num <= 5.010000){return _patch_b64(<<'CONFGCC10510')}if ($num < 5.021002){return _patch_b64(<<'CONFGCC10520')}if ($num < 5.023005 and!($num >= 5.022002 and $num < 5.023000)){return _patch_b64(<<'CONFGCC10522')}if (($num <= 5.026000 or ($num >= 5.027000 and $num < 5.027003))and!($num >= 5.024003 and $num < 5.025000)){return _patch_b64(<<'CONFGCC10526')}if ($num < 5.029003){return _patch_b64(<<'CONFGCC10528')}_patch_b64(<<'CONFGCC10')}sub _patch_dynaloader_mac {return unless $^O eq 'darwin';my$perlver=shift;my$num=_norm_ver($perlver);return if ($num > 5.032000 && $num < 5.033000)or $num > 5.033005;_patch_b64(<<'BIGSURDL')}sub _patch_eumm_darwin {return unless $^O eq 'darwin';my$perlver=shift;my$num=_norm_ver($perlver);return if ($num > 5.032000 && $num < 5.033000)or $num > 5.033005;if ($num!=5.006002 && $num < 5.008000){return _patch_b64(<<'EUMMBIGSUR580')}if ($num < 5.011000){return _patch_b64(<<'EUMMBIGSUR511')}if ($num < 5.013005){return _patch_b64(<<'EUMMBIGSUR513')}if ($num < 5.015001){return _patch_b64(<<'EUMMBIGSUR515')}_patch_b64(<<'EUMMBIGSUR')}sub _patch_useshrplib {_patch(<<'END')}qq[patchin'];
  --- doio.c.org  2004-06-07 23:14:45.000000000 +0200
  +++ doio.c  2003-11-04 08:03:03.000000000 +0100
  @@ -75,6 +75,16 @@
   #  endif
   #endif
  
  +#if _SEM_SEMUN_UNDEFINED
  +union semun
  +{
  +  int val;
  +  struct semid_ds *buf;
  +  unsigned short int *array;
  +  struct seminfo *__buf;
  +};
  +#endif
  +
   bool
   do_open(gv,name,len,as_raw,rawmode,rawperm,supplied_fp)
   GV *gv;
  END
  --- ext/IPC/SysV/SysV.xs.org  1998-07-20 10:20:07.000000000 +0200
  +++ ext/IPC/SysV/SysV.xs  2007-08-12 10:51:06.000000000 +0200
  @@ -3,9 +3,6 @@
   #include "XSUB.h"
   
   #include <sys/types.h>
  -#ifdef __linux__
  -#include <asm/page.h>
  -#endif
   #if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
   #include <sys/ipc.h>
   #ifdef HAS_MSG
  END
  --- ext/IPC/SysV/SysV.xs.org  2007-08-11 00:12:46.000000000 +0200
  +++ ext/IPC/SysV/SysV.xs  2007-08-11 00:10:51.000000000 +0200
  @@ -3,9 +3,6 @@
   #include "XSUB.h"
   
   #include <sys/types.h>
  -#ifdef __linux__
  -#   include <asm/page.h>
  -#endif
   #if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
   #ifndef HAS_SEM
   #   include <sys/ipc.h>
  END
  --- Configure
  +++ Configure
  @@ -3380,6 +3380,18 @@
   test "X$gfpthkeep" != Xy && gfpth=""
   EOSC
   
  +# gcc 3.1 complains about adding -Idirectories that it already knows about,
  +# so we will take those off from locincpth.
  +case "$gccversion" in
  +3*)
  +    echo "main(){}">try.c
  +    for incdir in `$cc -v -c try.c 2>&1 | \
  +       sed '1,/^#include <\.\.\.>/d;/^End of search list/,$d;s/^ //'` ; do
  +       locincpth=`echo $locincpth | sed s!$incdir!!`
  +    done
  +    $rm -f try try.*
  +esac
  +
   : What should the include directory be ?
   echo " "
   $echo $n "Hmm...  $c"
  END
  --- makedepend.SH
  +++ makedepend.SH
  @@ -58,6 +58,10 @@ case $PERL_CONFIG_SH in
         ;;
   esac
   
  +# Avoid localized gcc/cc messages
  +LC_ALL=C
  +export LC_ALL
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  END
  --- makedepend.SH.org	2000-03-02 18:12:26.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:13:37.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,25 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				uwinfix=
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -130,22 +140,45 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
       if [ "$osname" = os390 -a "$file" = perly.c ]; then
           $echo '#endif' >>UU/$file.c
       fi
  -    $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  -    $sed \
  -	-e '1d' \
  -	-e '/^#.*<stdin>/d' \
  -	-e '/^#.*"-"/d' \
  -	-e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  -	-e 's/^[	 ]*#[	 ]*line/#/' \
  -	-e '/^# *[0-9][0-9]* *[".\/]/!d' \
  -	-e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  -	-e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  -	-e 's|: \./|: |' \
  -	-e 's|\.c\.c|.c|' $uwinfix | \
  -    $uniq | $sort | $uniq >> .deptmp
  +
  +    if [ "$osname" = os390 ]; then
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $sed \
  +    	    -e '/^#.*<stdin>/d' \
  +	    -e '/^#.*"-"/d' \
  +	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  +	    -e 's/^[	 ]*#[	 ]*line/#/' \
  +	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  +	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's|: \./|: |' \
  +	    -e 's|\.c\.c|.c|' $uwinfix | \
  +        $uniq | $sort | $uniq >> .deptmp
  +    else
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
  +        $sed \
  +	    -e '1d' \
  +	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
  +	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
  +	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  +	    -e 's/^[	 ]*#[	 ]*line/#/' \
  +	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  +	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's|: \./|: |' \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
  +        $uniq | $sort | $uniq >> .deptmp
  +    fi
   done
   
   $sed <$mf >$mf.new -e '1,/^# AUTOMATICALLY/!d'
  @@ -177,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -208,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2001-03-19 07:33:17.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:14:47.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -134,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -151,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -196,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -227,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2003-07-30 23:46:59.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:15:47.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -63,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -72,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -104,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -139,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -156,21 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  -	    -e '/^#.*<builtin>/d' \
  -	    -e '/^#.*<built-in>/d' \
  -	    -e '/^#.*<command line>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -204,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -235,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2000-08-13 19:35:04.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:47:14.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,25 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				uwinfix=
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -130,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -147,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -192,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -223,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2001-03-11 16:30:08.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:44:54.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -134,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -151,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -196,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -227,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2001-07-09 15:11:05.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:45:32.000000000 +0100
  @@ -18,10 +18,6 @@
   */*) cd `expr X$0 : 'X\(.*\)/'` ;;
   esac
   
  -case "$osname" in
  -amigaos) cat=/bin/cat ;; # must be absolute
  -esac
  -
   echo "Extracting makedepend (with variable substitutions)"
   rm -f makedepend
   $spitshell >makedepend <<!GROK!THIS!
  @@ -33,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -55,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -62,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -71,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -103,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -138,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -155,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -200,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -231,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2002-03-05 01:10:22.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:46:13.000000000 +0100
  @@ -18,10 +18,6 @@
   */*) cd `expr X$0 : 'X\(.*\)/'` ;;
   esac
   
  -case "$osname" in
  -amigaos) cat=/bin/cat ;; # must be absolute
  -esac
  -
   echo "Extracting makedepend (with variable substitutions)"
   rm -f makedepend
   $spitshell >makedepend <<!GROK!THIS!
  @@ -33,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -55,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -62,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -71,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -116,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -129,6 +140,11 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
  @@ -143,13 +159,16 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c 2>&1 |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
               -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -157,7 +176,7 @@
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -191,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -222,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2002-07-09 15:06:42.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:16:37.000000000 +0100
  @@ -58,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -78,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -123,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -136,6 +140,11 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
  @@ -157,7 +166,9 @@
               -e '/^#.*<builtin>/d' \
               -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -199,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  BADGER
  LS0tIG1ha2VkZXBlbmQuU0gJMjAyMC0wNi0wOSAxNjoxNDo1NC43Njc2MTI2OTAgKzAxMDAKKysr
  IG1ha2VkZXBlbmQuU0gJMjAyMC0wNi0wOSAxNjoxNTowNC40MTEwODI2ODUgKzAxMDAKQEAgLTEy
  OCw3ICsxMjgsNyBAQAogICAgICoueSkgZmlsZWJhc2U9YGJhc2VuYW1lICRmaWxlIC55YCA7Owog
  ICAgIGVzYWMKICAgICBjYXNlICIkZmlsZSIgaW4KLSAgICAqLyopIGZpbmM9Ii1JYGVjaG8gJGZp
  bGUgfCBzZWQgJ3MjL1teL10qJCMjYCIgOzsKKyAgICAqLyopIGZpbmM9Ii1JYGVjaG8gJGZpbGUg
  fCBzZWQgJ3MjL1teL10qJCMjJ2AiIDs7CiAgICAgKikgICBmaW5jPSA7OwogICAgIGVzYWMKICAg
  ICAkZWNobyAiRmluZGluZyBkZXBlbmRlbmNpZXMgZm9yICRmaWxlYmFzZSRfby4iCkBAIC0xNjks
  NiArMTY5LDcgQEAKICAgICAgICAgICAgIC1lICcvXiMuKjxjb21tYW5kIGxpbmU+L2QnIFwKICAg
  ICAgICAgICAgIC1lICcvXiMuKjxjb21tYW5kLWxpbmU+L2QnIFwKIAkgICAgLWUgJy9eIy4qIi0i
  L2QnIFwKKwkgICAgLWUgJy9eIy4qIlwvLipcLyIvZCcgXAogCSAgICAtZSAnLzogZmlsZSBwYXRo
  IHByZWZpeCAuKiBuZXZlciB1c2VkJC9kJyBcCiAJICAgIC1lICdzI1wuWzAtOV1bMC05XSpcLmMj
  JyIkZmlsZS5jIyIgXAogCSAgICAtZSAncy9eWwkgXSojWwkgXSpsaW5lLyMvJyBcCg==
  BADGER
  --- makedepend.SH.org	2003-06-05 19:11:10.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:24:39.000000000 +0100
  @@ -83,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -128,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -167,7 +166,9 @@
               -e '/^#.*<builtin>/d' \
               -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -209,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  BADGER
  --- Configure
  +++ Configure
  @@ -7851,6 +7851,21 @@ int main()
   	Gconvert((DOUBLETYPE)0.1, 8, 0, buf);
   	checkit("0.1", buf);
   
  +	Gconvert((DOUBLETYPE)0.01, 8, 0, buf);
  +	checkit("0.01", buf);
  +
  +	Gconvert((DOUBLETYPE)0.001, 8, 0, buf);
  +	checkit("0.001", buf);
  +
  +	Gconvert((DOUBLETYPE)0.0001, 8, 0, buf);
  +	checkit("0.0001", buf);
  +
  +	Gconvert((DOUBLETYPE)0.00009, 8, 0, buf);
  +	if (strlen(buf) > 5)
  +	    checkit("9e-005", buf); /* for Microsoft ?? */
  +	else
  +	    checkit("9e-05", buf);
  +
   	Gconvert((DOUBLETYPE)1.0, 8, 0, buf); 
   	checkit("1", buf);
   
  @@ -7889,6 +7904,19 @@ int main()
   	Gconvert((DOUBLETYPE)123.456, 8, 0, buf); 
   	checkit("123.456", buf);
   
  +	/* Testing of 1e+129 in bigintpm.t must not get extra '.' here. */
  +	Gconvert((DOUBLETYPE)1e34, 8, 0, buf);
  +	/* 34 should be enough to scare even long double
  +	 * places into using the e notation. */
  +	if (strlen(buf) > 5)
  +	    checkit("1e+034", buf); /* for Microsoft */
  +	else
  +	    checkit("1e+34", buf);
  +
  +	/* For Perl, if you add additional tests here, also add them to
  +	 * t/base/num.t for benefit of platforms not using Configure or
  +	 * overriding d_Gconvert */
  +
   	exit(0);
   }
   EOP
  END
  --- lib/Archive/Tar/t/02_methods.t
  +++ lib/Archive/Tar/t/02_methods.t
  @@ -70,6 +70,20 @@ my $LONG_FILE = qq[directory/really-really-really-really-really-really-really-re
   my $TOO_LONG    =   ($^O eq 'MSWin32' or $^O eq 'cygwin' or $^O eq 'VMS')
                       && length( cwd(). $LONG_FILE ) > 247;
   
  +if(!$TOO_LONG) {
  +    my $alt = File::Spec->catfile( cwd(), $LONG_FILE);
  +    eval 'mkpath([$alt]);';
  +    if($@)
  +    {
  +        $TOO_LONG = 1;
  +    }
  +    else
  +    {
  +        $@ = '';
  +        my $base = File::Spec->catfile( cwd(), 'directory');
  +        rmtree $base;
  +    }
  +}
   ### warn if we are going to skip long file names
   if ($TOO_LONG) {
       diag("No long filename support - long filename extraction disabled") if ! $ENV{PERL_CORE};
  END
  --- cpan/Archive-Tar/t/02_methods.t
  +++ cpan/Archive-Tar/t/02_methods.t
  @@ -70,6 +70,20 @@ my $LONG_FILE = qq[directory/really-really-really-really-really-really-really-re
   my $TOO_LONG    =   ($^O eq 'MSWin32' or $^O eq 'cygwin' or $^O eq 'VMS')
                       && length( cwd(). $LONG_FILE ) > 247;
   
  +if(!$TOO_LONG) {
  +    my $alt = File::Spec->catfile( cwd(), $LONG_FILE);
  +    eval 'mkpath([$alt]);';
  +    if($@)
  +    {
  +        $TOO_LONG = 1;
  +    }
  +    else
  +    {
  +        $@ = '';
  +        my $base = File::Spec->catfile( cwd(), 'directory');
  +        rmtree $base;
  +    }
  +}
   ### warn if we are going to skip long file names
   if ($TOO_LONG) {
       diag("No long filename support - long filename extraction disabled") if ! $ENV{PERL_CORE};
  END
  --- ext/ODBM_File/hints/linux.pl
  +++ ext/ODBM_File/hints/linux.pl
  @@ -1,8 +1,8 @@
   # uses GDBM dbm compatibility feature - at least on SuSE 8.0
   $self->{LIBS} = ['-lgdbm'];
   
  -# Debian/Ubuntu have /usr/lib/libgdbm_compat.so.3* but not this file,
  +# Debian/Ubuntu have libgdbm_compat.so but not this file,
   # so linking may fail
  -if (-e '/usr/lib/libgdbm_compat.so' or -e '/usr/lib64/libgdbm_compat.so') {
  -    $self->{LIBS}->[0] .= ' -lgdbm_compat';
  +foreach (split / /, $Config{libpth}) {
  +    $self->{LIBS}->[0] .= ' -lgdbm_compat' if -e $_.'/libgdbm_compat.so';
   }
  END
  --- make_ext.pl
  +++ make_ext.pl
  @@ -377,6 +377,10 @@ WriteMakefile(
   EOM
   	    close $fh or die "Can't close Makefile.PL: $!";
   	}
  +  eval {
  +    my $ftime = time - 4;
  +    utime $ftime, $ftime, 'Makefile.PL';
  +  };
   	print "\nRunning Makefile.PL in $ext_dir\n";
   
   	# Presumably this can be simplified
  END
  --- perlio.c
  +++ perlio.c
  @@ -2323,6 +2323,12 @@ PerlIO_init(pTHX)
   {
       /* MUTEX_INIT(&PL_perlio_mutex) is done in PERL_SYS_INIT3(). */
       PERL_UNUSED_CONTEXT;
  +    /*
  +     * No, for backwards compatibility (before PERL_SYS_INIT3 changed to be
  +     * defined as a separate function call), we need to call
  +     * MUTEX_INIT(&PL_perlio_mutex) (via the PERLIO_INIT macro).
  +     */
  +    PERLIO_INIT;
   }
   
   void
  END
  --- hv.c
  +++ hv.c
  @@ -31,7 +31,8 @@ holds the key and hash value.
   #define PERL_HASH_INTERNAL_ACCESS
   #include "perl.h"
   
  -#define HV_MAX_LENGTH_BEFORE_SPLIT 14
  +#define HV_MAX_LENGTH_BEFORE_REHASH 14
  +#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
   
   STATIC void
   S_more_he(pTHX)
  @@ -705,23 +706,8 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!counter) {				/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
   	    hsplit(hv);
  -	} else if(!HvREHASH(hv)) {
  -	    U32 n_links = 1;
  -
  -	    while ((counter = HeNEXT(counter)))
  -		n_links++;
  -
  -	    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {
  -		/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit
  -		   bucket splits on a rehashed hash, as we're not going to
  -		   split it again, and if someone is lucky (evil) enough to
  -		   get all the keys in one list they could exhaust our memory
  -		   as we repeatedly double the number of buckets on every
  -		   entry. Linear search feels a less worse thing to do.  */
  -		hsplit(hv);
  -	    }
   	}
       }
   
  @@ -1048,7 +1034,7 @@ S_hsplit(pTHX_ HV *hv)
   
   
       /* Pick your policy for "hashing isn't working" here:  */
  -    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT /* split worked?  */
  +    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
   	|| HvREHASH(hv)) {
   	return;
       }
  @@ -1966,8 +1952,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!next) {			/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */) {
  -		hsplit(PL_strtab);
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
  +            hsplit(PL_strtab);
   	}
       }
   
  --- t/op/hash.t
  +++ t/op/hash.t
  @@ -39,22 +39,36 @@ use constant THRESHOLD => 14;
   use constant START     => "a";
   
   # some initial hash data
  -my %h2 = map {$_ => 1} 'a'..'cc';
  +my %h2;
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
   
       # the minimum of bits required to mount the attack on a hash
       my $min_bits = log(THRESHOLD)/log(2);
  -
       # if the hash has already been populated with a significant amount
       # of entries the number of mask bits can be higher
       my $keys = scalar keys %$hr;
  -- 
  1.7.4.1
  
  END
  --- ext/Hash-Util-FieldHash/t/10_hash.t
  +++ ext/Hash-Util-FieldHash/t/10_hash.t
  @@ -46,15 +46,29 @@ use constant START     => "a";
   
   # some initial hash data
   fieldhash my %h2;
  -%h2 = map {$_ => 1} 'a'..'cc';
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
  --- hv.c
  +++ hv.c
  @@ -35,7 +35,8 @@ holds the key and hash value.
   #define PERL_HASH_INTERNAL_ACCESS
   #include "perl.h"
   
  -#define HV_MAX_LENGTH_BEFORE_SPLIT 14
  +#define HV_MAX_LENGTH_BEFORE_REHASH 14
  +#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
   
   static const char S_strtab_error[]
       = "Cannot modify shared string table in hv_%s";
  @@ -818,23 +819,8 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!counter) {				/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
   	    hsplit(hv);
  -	} else if(!HvREHASH(hv)) {
  -	    U32 n_links = 1;
  -
  -	    while ((counter = HeNEXT(counter)))
  -		n_links++;
  -
  -	    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {
  -		/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit
  -		   bucket splits on a rehashed hash, as we're not going to
  -		   split it again, and if someone is lucky (evil) enough to
  -		   get all the keys in one list they could exhaust our memory
  -		   as we repeatedly double the number of buckets on every
  -		   entry. Linear search feels a less worse thing to do.  */
  -		hsplit(hv);
  -	    }
   	}
       }
   
  @@ -1180,7 +1166,7 @@ S_hsplit(pTHX_ HV *hv)
   
   
       /* Pick your policy for "hashing isn't working" here:  */
  -    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT /* split worked?  */
  +    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
   	|| HvREHASH(hv)) {
   	return;
       }
  @@ -2506,8 +2492,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!next) {			/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */) {
  -		hsplit(PL_strtab);
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
  +            hsplit(PL_strtab);
   	}
       }
   
  diff --git a/t/op/hash.t b/t/op/hash.t
  index 9bde518..45eb782 100644
  --- t/op/hash.t
  +++ t/op/hash.t
  @@ -39,22 +39,36 @@ use constant THRESHOLD => 14;
   use constant START     => "a";
   
   # some initial hash data
  -my %h2 = map {$_ => 1} 'a'..'cc';
  +my %h2;
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
   
       # the minimum of bits required to mount the attack on a hash
       my $min_bits = log(THRESHOLD)/log(2);
  -
       # if the hash has already been populated with a significant amount
       # of entries the number of mask bits can be higher
       my $keys = scalar keys %$hr;
  -- 
  1.7.4.1
  
  
  END
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -3312,6 +3312,9 @@ EOM
   			;;
   		next*) osname=next ;;
   		nonstop-ux) osname=nonstopux ;;
  +		bitrig) osname=bitrig
  +			osvers="$3"
  +			;;
   		openbsd) osname=openbsd
                   	osvers="$3"
                   	;;
  BOOGLE
  diff --git a/Makefile.SH b/Makefile.SH
  index 17298fa..ecaa8ac 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -77,7 +77,7 @@ true)
   	sunos*)
   		linklibperl="-lperl"
   		;;
  -	netbsd*|freebsd[234]*|openbsd*)
  +	netbsd*|freebsd[234]*|openbsd*|bitrig*)
   		linklibperl="-L. -lperl"
   		;;
   	interix*)
  BITRIGM1
  diff --git a/Makefile.SH b/Makefile.SH
  index 17298fa..ecaa8ac 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -77,7 +77,7 @@ true)
   	sunos*)
   		linklibperl="-lperl"
   		;;
  -	netbsd*|freebsd[234]*|openbsd*|dragonfly*)
  +	netbsd*|freebsd[234]*|openbsd*|dragonfly*|bitrig*)
   		linklibperl="-L. -lperl"
   		;;
   	interix*)
  BITRIGMX
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure	Thu Aug 22 23:20:14 2013
  +++ Configure	Thu Aug 22 23:20:35 2013
  @@ -7855,7 +7855,7 @@
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd)
  +	freebsd|netbsd|openbsd|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf)
  BITRIGC3
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure	Thu Aug 22 22:56:04 2013
  +++ Configure	Thu Aug 22 22:56:25 2013
  @@ -7892,7 +7892,7 @@
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd|interix)
  +	freebsd|netbsd|openbsd|interix|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGC2
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -8328,7 +8331,7 @@ if "$useshrplib"; then
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd|interix|dragonfly)
  +	freebsd|netbsd|openbsd|interix|dragonfly|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGC1
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -8328,7 +8331,7 @@ if "$useshrplib"; then
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|mirbsd|netbsd|openbsd|interix|dragonfly)
  +	freebsd|mirbsd|netbsd|openbsd|interix|dragonfly|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGCX
  diff --git a/Configure b/Configure
  index ff511d3..30ab78a 100755
  --- Configure
  +++ Configure
  @@ -8048,7 +8048,20 @@ EOM
   			      ;;
   			linux|irix*|gnu*)  dflt="-shared $optimize" ;;
   			next)  dflt='none' ;;
  -			solaris) dflt='-G' ;;
  +			solaris) # See [perl #66604].  On Solaris 11, gcc -m64 on amd64
  +				# appears not to understand -G.  gcc versions at
  +				# least as old as 3.4.3 support -shared, so just
  +				# use that with Solaris 11 and later, but keep
  +				# the old behavior for older Solaris versions.
  +				case "$gccversion" in
  +					'') dflt='-G' ;;
  +					*)	case "$osvers" in
  +							2.?|2.10) dflt='-G' ;;
  +							*) dflt='-shared' ;;
  +						esac
  +						;;
  +				esac
  +				;;
   			sunos) dflt='-assert nodefinitions' ;;
   			svr4*|esix*|nonstopux) dflt="-G $ldflags" ;;
   	        *)     dflt='none' ;;
  BUBBLE
  diff --git a/regexec.c b/regexec.c
  index bc38839..b865b46 100644
  --- regexec.c
  +++ regexec.c
  @@ -6662,7 +6662,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
       scan = *startposp;
       if (max == REG_INFTY)
   	max = I32_MAX;
  -    else if (! utf8_target && scan + max < loceol)
  +    else if (! utf8_target && loceol - scan > max)
   	loceol = scan + max;
   
       /* Here, for the case of a non-UTF-8 target we have adjusted <loceol> down
  @@ -6711,7 +6711,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
   	    scan = loceol;
   	break;
       case CANY:  /* Move <scan> forward <max> bytes, unless goes off end */
  -        if (utf8_target && scan + max < loceol) {
  +        if (utf8_target && loceol - scan > max) {
   
               /* <loceol> hadn't been adjusted in the UTF-8 case */
               scan +=  max;
  @@ -6730,7 +6730,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
            * can use UTF8_IS_INVARIANT() even if the pattern isn't UTF-8, as it's
            * true iff it doesn't matter if the argument is in UTF-8 or not */
           if (UTF8_IS_INVARIANT(c) || (! utf8_target && ! is_utf8_pat)) {
  -            if (utf8_target && scan + max < loceol) {
  +            if (utf8_target && loceol - scan > max) {
                   /* We didn't adjust <loceol> because is UTF-8, but ok to do so,
                    * since here, to match at all, 1 char == 1 byte */
                   loceol = scan + max;
  @@ -6910,7 +6910,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
           /* FALLTHROUGH */
   
       case POSIXA:
  -        if (utf8_target && scan + max < loceol) {
  +        if (utf8_target && loceol - scan > max) {
   
               /* We didn't adjust <loceol> at the beginning of this routine
                * because is UTF-8, but it is actually ok to do so, since here, to
  diff --git a/t/re/pat_rt_report.t b/t/re/pat_rt_report.t
  index 2244fdf..9a9b5f5 100644
  --- t/re/pat_rt_report.t
  +++ t/re/pat_rt_report.t
  @@ -22,7 +22,7 @@ BEGIN {
   }
   
   
  -plan tests => 2530;  # Update this when adding/deleting tests.
  +plan tests => 2532;  # Update this when adding/deleting tests.
   
   run_tests() unless caller;
   
  @@ -1158,6 +1158,21 @@ EOP
               '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$\'|,"\n"',
               "c\n", {}, '$\' first mentioned after match');
       }
  +
  +    {
  +	# [perl #118175] threaded perl-5.18.0 fails pat_rt_report_thr.t
  +	# this tests some related failures
  +	#
  +	# The tests in the block *only* fail when run on 32-bit systems
  +	# with a malloc that allocates above the 2GB line.  On the system
  +	# in the report above that only happened in a thread.
  +	my $s = "\x{1ff}" . "f" x 32;
  +	ok($s =~ /\x{1ff}[[:alpha:]]+/gca, "POSIXA pointer wrap");
  +
  +	# this one segfaulted under the conditions above
  +	# of course, CANY is evil, maybe it should crash
  +	ok($s =~ /.\C+/, "CANY pointer wrap");
  +    }
   } # End of sub run_tests
   
   1;
  BOBBLE
  diff --git a/Makefile.SH b/Makefile.SH
  index ac5ade4..8e66603 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -295,6 +295,30 @@ obj = $(obj1) $(obj2) $(obj3) $(ARCHOBJS)
   # EMBEDDING is on by default, and MULTIPLICITY doesn't work.
   #
  
  +.PHONY: all compile translators utilities \
  +       FORCE \
  +       preplibrary \
  +       install install-strip install-all install-verbose install-silent \
  +       no-install install.perl install.man installman install.html installhtml \
  +       check_byacc run_byacc \
  +       regen_headers regen_pods regen_all \
  +       clean _tidy _mopup _cleaner1 _cleaner2 \
  +       realclean _realcleaner clobber _clobber \
  +       distclean veryclean _verycleaner \
  +       lint \
  +       depend \
  +       test check test_prep _test_prep \
  +       test_tty test-tty _test_tty test_notty test-notty _test_notty \
  +       utest ucheck test.utf8 check.utf8 \
  +       test.third check.third utest.third ucheck.third test_notty.third \
  +       test.deparse test_notty.deparse \
  +       minitest \
  +       ok okfile oknack okfilenack nok nokfile noknack nokfilenack \
  +       clist hlist shlist pllist \
  +       distcheck \
  +       elc \
  +       etags ctags tags
  +
   lintflags = -hbvxac
  
   .c$(OBJ_EXT):
  END
  diff --git a/sv.c b/sv.c
  index 06c0b83..ac1d972 100644
  --- sv.c
  +++ sv.c
  @@ -1574,14 +1574,19 @@ Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
           newlen++;
   #endif
   
  +#if defined(PERL_USE_MALLOC_SIZE) && defined(Perl_safesysmalloc_size)
  +#define PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
  +#endif
  +
       if (newlen > SvLEN(sv)) {		/* need more room? */
   	STRLEN minlen = SvCUR(sv);
   	minlen += (minlen >> PERL_STRLEN_EXPAND_SHIFT) + 10;
   	if (newlen < minlen)
   	    newlen = minlen;
  -#ifndef Perl_safesysmalloc_size
  -        if (SvLEN(sv))
  +#ifndef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
  +        if (SvLEN(sv)) {
               newlen = PERL_STRLEN_ROUNDUP(newlen);
  +        }
   #endif
   	if (SvLEN(sv) && s) {
   	    s = (char*)saferealloc(s, newlen);
  @@ -1593,7 +1598,7 @@ Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
   	    }
   	}
   	SvPV_set(sv, s);
  -#ifdef Perl_safesysmalloc_size
  +#ifdef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
   	/* Do this here, do it once, do it right, and then we will never get
   	   called back into sv_grow() unless there really is some growing
   	   needed.  */
  COWSAY
  diff --git a/perl.c b/perl.c
  index 82e5538..b9e02fe 100644
  --- perl.c
  +++ perl.c
  @@ -3758,7 +3758,7 @@ S_open_script(pTHX_ const char *scriptname, bool dosearch, SV *sv,
   #       ifdef VMS
               cpp_discard_flag = "";
   #       else
  -            cpp_discard_flag = "-C";
  +            cpp_discard_flag = "-C -ffreestanding";
   #       endif
   
   #       ifdef OS2
  END
  diff --git a/perl.c b/perl.c
  index 623f9be..014d318 100644
  --- perl.c
  +++ perl.c
  @@ -2631,7 +2631,7 @@ sed %s -e \"/^[^#]/b\" \
    -e '/^#[ 	]*undef[ 	]/b' \
    -e '/^#[ 	]*endif/b' \
    -e 's/^[ 	]*#.*//' \
  - %s | %"SVf" -C %"SVf" %s",
  + %s | %"SVf" -C -ffreestanding %"SVf" %s",
   #  endif
   #ifdef LOC_SED
   	  LOC_SED,
  END
  diff --git a/META.json b/META.json
  index 64caea7..200e324 100644
  --- META.json
  +++ META.json
  @@ -118,7 +118,7 @@
            "TestInit.pm"
         ]
      },
  -   "release_status" : "testing",
  +   "release_status" : "stable",
      "resources" : {
         "bugtracker" : {
            "web" : "http://rt.perl.org/perlbug/"
  DOGSAY
  --- handy.h
  +++ handy.h
  @@ -43,12 +43,10 @@
      this file first, then you will have to manually set -DHAS_BOOL in 
      your command line to avoid a conflict.
   */
  -#ifdef _G_HAVE_BOOL
  -# if _G_HAVE_BOOL
  +#ifdef __GNUG__
   #  ifndef HAS_BOOL
   #   define HAS_BOOL 1
   #  endif
  -# endif
   #endif
   
   /* The NeXT dynamic loader headers will not build with the bool macro
  END
  #! /bin/sh
  case $PERL_CONFIG_SH in
  '')
  	if test -f config.sh; then TOP=.;
  	elif test -f ../config.sh; then TOP=..;
  	elif test -f ../../config.sh; then TOP=../..;
  	elif test -f ../../../config.sh; then TOP=../../..;
  	elif test -f ../../../../config.sh; then TOP=../../../..;
  	else
  		echo "Can't find config.sh."; exit 1
  	fi
  	. $TOP/config.sh
  	;;
  esac
  : This forces SH files to create target in same directory as SH file.
  : This is so that make depend always knows where to find SH derivatives.
  case "$0" in
  */*) cd `expr X$0 : 'X\(.*\)/'` ;;
  esac
  
  echo "Extracting makedepend (with variable substitutions)"
  rm -f makedepend
  $spitshell >makedepend <<!GROK!THIS!
  $startsh
  # makedepend.SH
  #
  MAKE=$make
  trnl='$trnl'
  !GROK!THIS!
  $spitshell >>makedepend <<'!NO!SUBS!'
  
  if test -d .depending; then
  	echo "$0: Already running, exiting."
  	exit 0
  fi
  
  mkdir .depending
  
  # This script should be called with 
  #     sh ./makedepend MAKE=$(MAKE)
  case "$1" in 
  	MAKE=*) eval $1; shift ;;
  esac
  
  export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
  
  case $PERL_CONFIG_SH in
  '')
  	if test -f config.sh; then TOP=.;
  	elif test -f ../config.sh; then TOP=..;
  	elif test -f ../../config.sh; then TOP=../..;
  	elif test -f ../../../config.sh; then TOP=../../..;
  	elif test -f ../../../../config.sh; then TOP=../../../..;
  	else
  		echo "Can't find config.sh."; exit 1
  	fi
  	. $TOP/config.sh
  	;;
  esac
  
  # Avoid localized gcc messages
  case "$ccname" in
      gcc) LC_ALL=C ; export LC_ALL ;;
  esac
  
  # We need .. when we are in the x2p directory if we are using the
  # cppstdin wrapper script.
  # Put .. and . first so that we pick up the present cppstdin, not
  # an older one lying about in /usr/local/bin.
  PATH=".$path_sep..$path_sep$PATH"
  export PATH
  
  case "$osname" in
  amigaos) cat=/bin/cat ;; # must be absolute
  esac
  
  $cat /dev/null >.deptmp
  $rm -f *.c.c c/*.c.c
  if test -f Makefile; then
      rm -f $firstmakefile
      cp Makefile $firstmakefile
      # On QNX, 'cp' preserves timestamp, so $firstmakefile appears
      # to be out of date.  I don't know if OS/2 has touch, so do this:
      case "$osname" in
      os2) ;;
      *) $touch $firstmakefile ;;
      esac
  fi
  mf=$firstmakefile
  if test -f $mf; then
      defrule=`<$mf sed -n		\
  	-e '/^\.c\$(OBJ_EXT):.*;/{'	\
  	-e    's/\$\*\.c//'		\
  	-e    's/^[^;]*;[	 ]*//p'	\
  	-e    q				\
  	-e '}'				\
  	-e '/^\.c\$(OBJ_EXT): *$/{'	\
  	-e    N				\
  	-e    's/\$\*\.c//'		\
  	-e    's/^.*\n[	 ]*//p'		\
  	-e    q				\
  	-e '}'`
  fi
  case "$defrule" in
  '') defrule='$(CC) -c $(CFLAGS)' ;;
  esac
  
  : Create files in UU directory to avoid problems with long filenames
  : on systems with 14 character filename limits so file.c.c and file.c
  : might be identical
  $test -d UU || mkdir UU
  
  $MAKE clist || ($echo "Searching for .c files..."; \
  	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
  for file in `$cat .clist`; do
  # for file in `cat /dev/null`; do
      case "$osname" in
      uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
      os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
      cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
      posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
      vos)      uwinfix="-e s/\#/\\\#/" ;;
      *)        uwinfix="" ;;
      esac
      case "$file" in
      *.c) filebase=`basename $file .c` ;;
      *.y) filebase=`basename $file .y` ;;
      esac
      case "$file" in
      */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
      *)   finc= ;;
      esac
      $echo "Finding dependencies for $filebase$_o."
      # Below, we strip out all but preprocessor directives.
      # We have to take care of situations like
      #       #if defined(FOO) BAR   /* comment line 1
      #                                 more comment lines */
      # If we just delete text starting from the '/*' to the end of line, we will
      # screw up cases like
      #      #if defined(FOO)    /* comment */ \
      #          && defined(BAR) /* comment */ \
      #          && defined(BAZ) /* comment */ \
      #               etc.
      # Also, in lines like
      #      #defined FOO(a,b)    a/**/b
      # the comment may be important and so needs to be retained.
      # This code processes the single-line comments first; it assumes there is
      # at most one straightforward comment per continued preprocessor line,
      # replacing each non-empty comment (and its surrounding white space) by a
      # single space.  (sed only has a greedy '*' quantifier, so this doesn't
      # work right if there are multiple comments per line, and strings can look
      # like comments to it; both are unlikely in a preprocessor statement.) Any
      # continuation line is joined, and the process repeated on the enlarged
      # line as long as there are continuations.  At the end, if there are any
      # comments remaining, they are either completely empty or are like the
      # first situation.  The latter are just deleted by first deleting to the
      # end of line (including preceding white space) things that start with '/*'
      # and the next char isn't a '*'; then things that start with '/**', but the
      # next char isn't a '/'.  (Subsequent lines of the comment are irrelevant
      # and get dropped.)  At the end, we unjoin very long lines to avoid
      # preprocessor limitations
      ( $echo "#line 2 \"$file\"";                               \
        $sed -n <$file                                           \
  	-e "/^${filebase}_init(/q"                             \
          -e ': testcont'                                        \
  	-e '/^[ 	]*#/s|[ 	]*/\*..*\*/[ 	]*| |' \
          -e '/\\$/{'                                            \
              -e 'N'                                             \
              -e 'b testcont'                                    \
          -e '}'                                                 \
  	-e 's/\\\n//g'                                         \
  	-e '/^#line/d'                                         \
  	-e '/^[ 	]*#/{'                                 \
  	    -e 's|[ 	]*/\*[^*].*$||'                        \
  	    -e 's|[ 	]*/\*\*[^/].*$||'                      \
              -e 's/.\{255\}/&\\\n/g'                           \
  	    -e p                                               \
  	-e '}' ) >UU/$file.c
  
      # We're not sure why this was there; the #endif is extraneous on modern z/OS
      #if [ "$osname" = os390 -a "$file" = perly.c ]; then
      #   $echo '#endif' >>UU/$file.c
      #fi
  
      if [ "$osname" = os390 ]; then
          $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
          $sed \
      	    -e '/^#.*<stdin>/d' \
  	    -e '/^#.*"-"/d' \
  	    -e '/^#.*git_version\.h/d' \
  	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  	    -e 's/^[	 ]*#[	 ]*line/#/' \
  	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's|: \./|: |' \
  	    -e 's|\.c\.c|.c|' $uwinfix | \
          $uniq | $sort | $uniq >> .deptmp
      else
          $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
          $sed \
  	    -e '1d' \
  	    -e '/^#.*<stdin>/d' \
              -e '/^#.*<builtin>/d' \
              -e '/^#.*<built-in>/d' \
              -e '/^#.*<command line>/d' \
              -e '/^#.*<command-line>/d' \
  	    -e '/^#.*"-"/d' \
  	    -e '/^#.*"\/.*\/"/d' \
  	    -e '/: file path prefix .* never used$/d' \
  	    -e '/^#.*git_version\.h/d' \
  	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  	    -e 's/^[	 ]*#[	 ]*line/#/' \
  	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's|: \./|: |' \
             -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
          $uniq | $sort | $uniq >> .deptmp
      fi
      echo "$filebase\$(OBJ_EXT): $@" >> .deptmp
  done
  
  $sed <$mf >$mf.new -e '1,/^# AUTOMATICALLY/!d'
  
  if $test -s .deptmp; then
      $echo "Updating $mf..."
      $echo "# If this runs make out of memory, delete /usr/include lines." \
  	>> $mf.new
      if [ "$osname" = vos ]; then
          $sed 's|\.incl\.c|.h|' .deptmp >.deptmp.vos
          mv -f .deptmp.vos .deptmp
      fi
      $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
         >>$mf.new
  else
      $MAKE hlist || ($echo "Searching for .h files..."; \
  	$echo *.h | $tr ' ' $trnl | $egrep -v '\*' >.hlist)
      $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
      $egrep '^#include ' `cat .clist` `cat .hlist`  >.deptmp
      $echo "Updating $mf..."
      <.clist $sed -n							\
  	-e '/\//{'							\
  	-e   's|^\(.*\)/\(.*\)\.c|\2\$(OBJ_EXT): \1/\2.c; '"$defrule \1/\2.c|p"	\
  	-e   d								\
  	-e '}'								\
  	-e 's|^\(.*\)\.c|\1\$(OBJ_EXT): \1.c|p' >> $mf.new
      <.hlist $sed -n 's|\(.*/\)\(.*\)|s= \2= \1\2=|p' >.hsed
      <.deptmp $sed -n 's|c:#include "\(.*\)".*$|o: \1|p' | \
         $sed 's|^[^;]*/||' | \
         $sed -f .hsed >> $mf.new
      <.deptmp $sed -n 's|h:#include "\(.*\)".*$|h: \1|p' | \
         $sed -f .hsed >> $mf.new
  fi
  $rm -f $mf.old
  $cp $mf $mf.old
  $rm -f $mf
  $cp $mf.new $mf
  $rm $mf.new
  $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  $rm -rf .deptmp UU .clist .hlist .hsed .cout .cerr
  rmdir .depending
  
  !NO!SUBS!
  $eunicefix makedepend
  chmod +x makedepend
  END
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3442,7 +3445,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3693,7 +3700,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3980,10 +3988,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -3991,10 +4010,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4031,7 +4046,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4149,9 +4164,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4253,7 +4267,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4308,32 +4322,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5147,7 +5135,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6703,6 +6691,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6771,6 +6763,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7305,7 +7314,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7635,7 +7644,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID messages"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the msg*(2) configured." >&4
  +	echo "But your $osname does not have the msg*(2) configured." >&4
           h_msg=false
   	val="$undef"
   	set msgctl d_msgctl
  @@ -7678,7 +7687,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8136,7 +8145,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID messages"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the sem*(2) configured." >&4
  +	echo "But your $osname does not have the sem*(2) configured." >&4
           h_sem=false
   	val="$undef"
   	set semctl d_semctl
  @@ -8185,6 +8194,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8259,6 +8293,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8305,6 +8340,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8499,7 +8535,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID shared memory"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the shm*(2) configured." >&4
  +	echo "But your $osname does not have the shm*(2) configured." >&4
           h_shm=false
   	val="$undef"
   	set shmctl d_shmctl
  @@ -8652,21 +8688,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9610,6 +9633,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10217,8 +10266,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10250,6 +10301,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10458,7 +10603,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10466,7 +10617,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10830,7 +10983,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11055,10 +11214,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11195,6 +11350,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11774,6 +11930,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11882,6 +12039,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11894,6 +12052,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  @@ -12023,51 +12182,6 @@ esac
   : if this fails, just run all the .SH files by hand
   . ./config.sh
   
  -case "$ebcdic" in
  -$define)
  -    xxx=''
  -    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  -    rm -f y.tab.c y.tab.h
  -    yacc -d perly.y >/dev/null 2>&1
  -    if cmp -s y.tab.c perly.c; then
  -        rm -f y.tab.c
  -    else
  -        echo "perly.y -> perly.c" >&4
  -        mv -f y.tab.c perly.c
  -        chmod u+w perly.c
  -        sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  -            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  -        xxx="$xxx perly.c"
  -    fi
  -    if cmp -s y.tab.h perly.h; then
  -        rm -f y.tab.h
  -    else
  -        echo "perly.y -> perly.h" >&4
  -        mv -f y.tab.h perly.h
  -        xxx="$xxx perly.h"
  -    fi
  -    echo "x2p/a2p.y" >&4
  -    cd x2p
  -    rm -f y.tab.c
  -    yacc a2p.y >/dev/null 2>&1
  -    if cmp -s y.tab.c a2p.c
  -    then
  -        rm -f y.tab.c
  -    else
  -        echo "a2p.y -> a2p.c" >&4
  -        mv -f y.tab.c a2p.c
  -        chmod u+w a2p.c
  -        sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  -            -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  -        xxx="$xxx a2p.c"
  -    fi
  -    cd ..
  -    case "$xxx" in
  -    '') echo "No parser files were regenerated.  That's okay." >&4 ;;
  -    esac
  -    ;;
  -esac
  -
   echo " "
   exec 1>&4
   . ./UU/extract
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__) || defined(sun)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3454,7 +3457,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3705,7 +3712,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3992,10 +4000,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -4003,10 +4022,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4043,7 +4058,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4161,9 +4176,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4265,7 +4279,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4320,32 +4334,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5159,7 +5147,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6715,6 +6703,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6783,6 +6775,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7317,7 +7326,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7643,6 +7652,27 @@ echo " "
   case "$d_msgctl$d_msgget$d_msgsnd$d_msgrcv" in
   *"$undef"*) h_msg=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the msg*(2) configured." >&4
  +        h_msg=false
  +	val="$undef"
  +	set msgctl d_msgctl
  +	eval $setvar
  +	set msgget d_msgget
  +	eval $setvar
  +	set msgsnd d_msgsnd
  +	eval $setvar
  +	set msgrcv d_msgrcv
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_msg && $test `./findhdr sys/msg.h`; then
   	echo "You have the full msg*(2) library." >&4
  @@ -7671,7 +7701,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8125,6 +8155,25 @@ echo " "
   case "$d_semctl$d_semget$d_semop" in
   *"$undef"*) h_sem=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the sem*(2) configured." >&4
  +        h_sem=false
  +	val="$undef"
  +	set semctl d_semctl
  +	eval $setvar
  +	set semget d_semget
  +	eval $setvar
  +	set semop d_semop
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_sem && $test `./findhdr sys/sem.h`; then
   	echo "You have the full sem*(2) library." >&4
  @@ -8161,6 +8210,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8235,6 +8309,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8281,6 +8356,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8471,6 +8547,27 @@ echo " "
   case "$d_shmctl$d_shmget$d_shmat$d_shmdt" in
   *"$undef"*) h_shm=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID shared memory"*"not configured"*)
  +	echo "But your $osname does not have the shm*(2) configured." >&4
  +        h_shm=false
  +	val="$undef"
  +	set shmctl d_shmctl
  +	evat $setvar
  +	set shmget d_shmget
  +	evat $setvar
  +	set shmat d_shmat
  +	evat $setvar
  +	set shmdt d_shmdt
  +	evat $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_shm && $test `./findhdr sys/shm.h`; then
   	echo "You have the full shm*(2) library." >&4
  @@ -8609,21 +8706,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9567,6 +9651,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10174,8 +10284,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10207,6 +10319,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10415,7 +10621,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10423,7 +10635,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10787,7 +11001,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11012,10 +11232,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11152,6 +11368,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11731,6 +11948,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11839,6 +12057,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11851,6 +12070,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__) || defined(sun)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3454,7 +3457,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3705,7 +3712,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3992,10 +4000,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -4003,10 +4022,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4043,7 +4058,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4161,9 +4176,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4265,7 +4279,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4320,32 +4334,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5159,7 +5147,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6715,6 +6703,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6783,6 +6775,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7317,7 +7326,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7643,6 +7652,27 @@ echo " "
   case "$d_msgctl$d_msgget$d_msgsnd$d_msgrcv" in
   *"$undef"*) h_msg=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the msg*(2) configured." >&4
  +        h_msg=false
  +	val="$undef"
  +	set msgctl d_msgctl
  +	eval $setvar
  +	set msgget d_msgget
  +	eval $setvar
  +	set msgsnd d_msgsnd
  +	eval $setvar
  +	set msgrcv d_msgrcv
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_msg && $test `./findhdr sys/msg.h`; then
   	echo "You have the full msg*(2) library." >&4
  @@ -7671,7 +7701,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8125,6 +8155,25 @@ echo " "
   case "$d_semctl$d_semget$d_semop" in
   *"$undef"*) h_sem=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the sem*(2) configured." >&4
  +        h_sem=false
  +	val="$undef"
  +	set semctl d_semctl
  +	eval $setvar
  +	set semget d_semget
  +	eval $setvar
  +	set semop d_semop
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_sem && $test `./findhdr sys/sem.h`; then
   	echo "You have the full sem*(2) library." >&4
  @@ -8161,6 +8210,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8235,6 +8309,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8281,6 +8356,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8471,6 +8547,27 @@ echo " "
   case "$d_shmctl$d_shmget$d_shmat$d_shmdt" in
   *"$undef"*) h_shm=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID shared memory"*"not configured"*)
  +	echo "But your $osname does not have the shm*(2) configured." >&4
  +        h_shm=false
  +	val="$undef"
  +	set shmctl d_shmctl
  +	evat $setvar
  +	set shmget d_shmget
  +	evat $setvar
  +	set shmat d_shmat
  +	evat $setvar
  +	set shmdt d_shmdt
  +	evat $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_shm && $test `./findhdr sys/shm.h`; then
   	echo "You have the full shm*(2) library." >&4
  @@ -8609,21 +8706,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9567,6 +9651,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10174,8 +10284,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10207,6 +10319,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10415,7 +10621,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10423,7 +10635,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10787,7 +11001,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11012,10 +11232,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11152,6 +11368,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11731,6 +11948,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11839,6 +12057,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11851,6 +12070,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index df68dc3..8385048 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -143,16 +143,26 @@ sub write_errno_pm {
   
       # invoke CPP and read the output
   
  +    my $inhibit_linemarkers = '';
  +    if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +        # GCC 5.0 interleaves expanded macros with line numbers breaking
  +        # each line into multiple lines. RT#123784
  +        $inhibit_linemarkers = ' -P';
  +    }
  +
       if ($^O eq 'VMS') {
  -	my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +  my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +    $inhibit_linemarkers . " $Config{cppminus}";
   	$cpp =~ s/sys\$input//i;
   	open(CPPO,"$cpp  errno.c |") or
             die "Cannot exec $Config{cppstdin}";
       } elsif ($^O eq 'MSWin32') {
  -	open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -	    die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +       my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +         $inhibit_linemarkers;
  +       open(CPPO,"$cpp errno.c |") or
  +         die "Cannot run '$cpp errno.c'";
       } else {
  -	my $cpp = default_cpp();
  +	my $cpp = default_cpp() . $inhibit_linemarkers;
   	open(CPPO,"$cpp < errno.c |")
   	    or die "Cannot exec $cpp";
       }
  END
  ZGlmZiAtLWdpdCBhL2V4dC9FcnJuby9FcnJub19wbS5QTCBiL2V4dC9FcnJuby9FcnJub19wbS5Q
  TAppbmRleCBkZjY4ZGMzYmRhLi4yNTFmMmJhNjYzIDEwMDY0NAotLS0gZXh0L0Vycm5vL0Vycm5v
  X3BtLlBMCisrKyBleHQvRXJybm8vRXJybm9fcG0uUEwKQEAgLTIsOSArMiw3IEBAIHVzZSBFeHRV
  dGlsczo6TWFrZU1ha2VyOwogdXNlIENvbmZpZzsKIHVzZSBzdHJpY3Q7CiAKLXVzZSB2YXJzIHF3
  KCRWRVJTSU9OKTsKLQotJFZFUlNJT04gPSAiMS4xMTEiOworb3VyICRWRVJTSU9OID0gIjEuMTEx
  IjsKIAogbXkgJWVyciA9ICgpOwogCkBAIC0yOSw2ICsyNywxMiBAQCBzdWIgcHJvY2Vzc19maWxl
  IHsKICAgICAgICAgICAgIHdhcm4gIkNhbm5vdCBvcGVuICckZmlsZSciOwogICAgICAgICAgICAg
  cmV0dXJuOwogCX0gICAgIAorICAgIH0gZWxzaWYgKCRDb25maWd7Z2NjdmVyc2lvbn0gbmUgJycp
  IHsgCisJIyBXaXRoIHRoZSAtZE0gb3B0aW9uLCBnY2Mgb3V0cHV0cyBldmVyeSAjZGVmaW5lIGl0
  IGZpbmRzCisJdW5sZXNzKG9wZW4oRkgsIiRDb25maWd7Y2N9IC1FIC1kTSAkQ29uZmlne2NwcGZs
  YWdzfSAkZmlsZSB8IikpIHsKKyAgICAgICAgICAgIHdhcm4gIkNhbm5vdCBvcGVuICckZmlsZSci
  OworICAgICAgICAgICAgcmV0dXJuOworCX0gICAgIAogICAgIH0gZWxzZSB7CiAJdW5sZXNzKG9w
  ZW4oRkgsIjwgJGZpbGUiKSkgewogCSAgICAjIFRoaXMgZmlsZSBjb3VsZCBiZSBhIHRlbXBvcmFy
  eSBmaWxlIGNyZWF0ZWQgYnkgY3Bwc3RkaW4KQEAgLTM3LDExICs0MSwxOSBAQCBzdWIgcHJvY2Vz
  c19maWxlIHsKICAgICAgICAgICAgIHJldHVybjsKIAl9CiAgICAgfQotICAgIHdoaWxlKDxGSD4p
  IHsKLQkkZXJyeyQxfSA9IDEKLQkgICAgaWYgL15ccyojXHMqZGVmaW5lXHMrKEVcdyspXHMrLzsK
  LSAgIH0KLSAgIGNsb3NlKEZIKTsKKworICAgIGlmICgkXk8gZXEgJ01hY09TJykgeworCXdoaWxl
  KDxGSD4pIHsKKwkgICAgJGVycnskMX0gPSAkMgorCQlpZiAvXlxzKiNccypkZWZpbmVccysoRVx3
  KylccysoXGQrKS87CisJfQorICAgIH0gZWxzZSB7CisJd2hpbGUoPEZIPikgeworCSAgICAkZXJy
  eyQxfSA9IDEKKwkJaWYgL15ccyojXHMqZGVmaW5lXHMrKEVcdyspXHMrLzsKKwl9CisgICAgfQor
  ICAgIGNsb3NlKEZIKTsKIH0KIAogbXkgJGNwcHN0ZGluOwpAQCAtNzksNiArOTEsMTggQEAgc3Vi
  IGdldF9maWxlcyB7CiAgICAgfSBlbHNpZiAoJF5PIGVxICd2bWVzYScpIHsKIAkjIE9TLzM5MCBD
  IGNvbXBpbGVyIGRvZXNuJ3QgZ2VuZXJhdGUgI2ZpbGUgb3IgI2xpbmUgZGlyZWN0aXZlcwogCSRm
  aWxleycuLi8uLi92bWVzYS9lcnJuby5oJ30gPSAxOworICAgIH0gZWxzaWYgKCRDb25maWd7YXJj
  aG5hbWV9IGVxICdlcG9jJykgeworCSMgV2F0Y2ggb3V0IGZvciBjcm9zcyBjb21waWxpbmcgZm9y
  IEVQT0MgKHVzdWFsbHkgZG9uZSBvbiBsaW51eCkKKwkkZmlsZXsnL3Vzci9sb2NhbC9lcG9jL2lu
  Y2x1ZGUvbGliYy9zeXMvZXJybm8uaCd9ID0gMTsKKyAgICB9IGVsc2lmICgkXk8gZXEgJ2xpbnV4
  JykgeworCSMgU29tZSBMaW51eGVzIGhhdmUgd2VpcmQgZXJybm8uaHMgd2hpY2ggZ2VuZXJhdGUK
  KwkjIG5vICNmaWxlIG9yICNsaW5lIGRpcmVjdGl2ZXMKKwkkZmlsZXsnL3Vzci9pbmNsdWRlL2Vy
  cm5vLmgnfSA9IDE7CisgICAgfSBlbHNpZiAoJF5PIGVxICdNYWNPUycpIHsKKwkjIG5vdGUgdGhh
  dCB3ZSBhcmUgb25seSBnZXR0aW5nIHRoZSBHVVNJIGVycm5vJ3MgaGVyZSAuLi4KKwkjIHdlIG1p
  Z2h0IG1pc3Mgb3V0IG9uIGNvbXBpbGVyLXNwZWNpZmljIG9uZXMKKwkkZmlsZXsiJEVOVntHVVNJ
  fWluY2x1ZGU6c3lzOmVycm5vLmgifSA9IDE7CisKICAgICB9IGVsc2UgewogCW9wZW4oQ1BQSSwi
  PiBlcnJuby5jIikgb3IKIAkgICAgZGllICJDYW5ub3Qgb3BlbiBlcnJuby5jIjsKQEAgLTEwMiw3
  ICsxMjYsNyBAQCBzdWIgZ2V0X2ZpbGVzIHsKIAkgICAgJHBhdCA9ICdeL1wqXHMrKC4rKVxzK1xk
  K1xzKjpccytcKi8nOwogCX0KIAllbHNlIHsKLQkgICAgJHBhdCA9ICdeIyg/OmxpbmUpP1xzKlxk
  K1xzKyIoW14iXSspIic7CisJICAgICRwYXQgPSAnXiNccyooPzpsaW5lKT9ccypcZCtccysiKFte
  Il0rKSInOwogCX0KIAl3aGlsZSg8Q1BQTz4pIHsKIAkgICAgaWYgKCReTyBlcSAnb3MyJyBvciAk
  Xk8gZXEgJ01TV2luMzInKSB7CkBAIC0xNDEsMzEgKzE2NSw0MyBAQCBzdWIgd3JpdGVfZXJybm9f
  cG0gewogCiAgICAgY2xvc2UoQ1BQSSk7CiAKKyAgICB1bmxlc3MgKCReTyBlcSAnTWFjT1MnKSB7
  CSMgdHJ1c3Qgd2hhdCB3ZSBoYXZlCiAgICAgIyBpbnZva2UgQ1BQIGFuZCByZWFkIHRoZSBvdXRw
  dXQKIAotICAgIGlmICgkXk8gZXEgJ1ZNUycpIHsKLQlteSAkY3BwID0gIiRDb25maWd7Y3Bwc3Rk
  aW59ICRDb25maWd7Y3BwZmxhZ3N9ICRDb25maWd7Y3BwbWludXN9IjsKLQkkY3BwID1+IHMvc3lz
  XCRpbnB1dC8vaTsKLQlvcGVuKENQUE8sIiRjcHAgIGVycm5vLmMgfCIpIG9yCi0gICAgICAgICAg
  ZGllICJDYW5ub3QgZXhlYyAkQ29uZmlne2NwcHN0ZGlufSI7Ci0gICAgfSBlbHNpZiAoJF5PIGVx
  ICdNU1dpbjMyJykgewotCW9wZW4oQ1BQTywiJENvbmZpZ3tjcHBydW59ICRDb25maWd7Y3BwZmxh
  Z3N9IGVycm5vLmMgfCIpIG9yCi0JICAgIGRpZSAiQ2Fubm90IHJ1biAnJENvbmZpZ3tjcHBydW59
  ICRDb25maWd7Y3BwZmxhZ3N9IGVycm5vLmMnIjsKLSAgICB9IGVsc2UgewotCW15ICRjcHAgPSBk
  ZWZhdWx0X2NwcCgpOwotCW9wZW4oQ1BQTywiJGNwcCA8IGVycm5vLmMgfCIpCi0JICAgIG9yIGRp
  ZSAiQ2Fubm90IGV4ZWMgJGNwcCI7Ci0gICAgfQorICAgICAgIG15ICRpbmhpYml0X2xpbmVtYXJr
  ZXJzID0gJyc7CisgICAgICAgaWYgKCRDb25maWd7Z2NjdmVyc2lvbn0gPX4gL1xBKFxkKylcLi8g
  YW5kICQxID49IDUpIHsKKyAgICAgICAgICAgIyBHQ0MgNS4wIGludGVybGVhdmVzIGV4cGFuZGVk
  IG1hY3JvcyB3aXRoIGxpbmUgbnVtYmVycyBicmVha2luZworICAgICAgICAgICAjIGVhY2ggbGlu
  ZSBpbnRvIG11bHRpcGxlIGxpbmVzLiBSVCMxMjM3ODQKKyAgICAgICAgICAgJGluaGliaXRfbGlu
  ZW1hcmtlcnMgPSAnIC1QJzsKKyAgICAgICB9CisKKwlpZiAoJF5PIGVxICdWTVMnKSB7CisJICAg
  IG15ICRjcHAgPSAiJENvbmZpZ3tjcHBzdGRpbn0gJENvbmZpZ3tjcHBmbGFnc30iIC4KKyAgICAg
  ICAgJGluaGliaXRfbGluZW1hcmtlcnMgLiAiICRDb25maWd7Y3BwbWludXN9IjsKKwkgICAgJGNw
  cCA9fiBzL3N5c1wkaW5wdXQvL2k7CisJICAgIG9wZW4oQ1BQTywiJGNwcCAgZXJybm8uYyB8Iikg
  b3IKKwkJZGllICJDYW5ub3QgZXhlYyAkQ29uZmlne2NwcHN0ZGlufSI7CisJfSBlbHNpZiAoJF5P
  IGVxICdNU1dpbjMyJykgeworICAgICAgICAgICBteSAkY3BwID0gIiRDb25maWd7Y3BwcnVufSAk
  Q29uZmlne2NwcGZsYWdzfSIgLgorICAgICAgICAgICAgICAgJGluaGliaXRfbGluZW1hcmtlcnM7
  CisgICAgICAgICAgIG9wZW4oQ1BQTywiJGNwcCBlcnJuby5jIHwiKSBvcgorICAgICAgICAgICAg
  ICAgZGllICJDYW5ub3QgcnVuICckY3BwIGVycm5vLmMnIjsKKwl9IGVsc2UgeworCSAgICBteSAk
  Y3BwID0gZGVmYXVsdF9jcHAoKSAuICRpbmhpYml0X2xpbmVtYXJrZXJzOworCSAgICBvcGVuKENQ
  UE8sIiRjcHAgPCBlcnJuby5jIHwiKQorCQlvciBkaWUgIkNhbm5vdCBleGVjICRjcHAiOworCX0K
  IAotICAgICVlcnIgPSAoKTsKKwklZXJyID0gKCk7CiAKLSAgICB3aGlsZSg8Q1BQTz4pIHsKLQlt
  eSgkbmFtZSwkZXhwcik7Ci0JbmV4dCB1bmxlc3MgKCRuYW1lLCAkZXhwcikgPSAvIiguKj8pIlxz
  KlxbXHMqXFtccyooLio/KVxzKlxdXHMqXF0vOwotCW5leHQgaWYgJG5hbWUgZXEgJGV4cHI7Ci0J
  JGVycnskbmFtZX0gPSBldmFsICRleHByOworCXdoaWxlKDxDUFBPPikgeworCSAgICBteSgkbmFt
  ZSwkZXhwcik7CisJICAgIG5leHQgdW5sZXNzICgkbmFtZSwgJGV4cHIpID0gLyIoLio/KSJccypc
  W1xzKlxbXHMqKC4qPylccypcXVxzKlxdLzsKKwkgICAgbmV4dCBpZiAkbmFtZSBlcSAkZXhwcjsK
  KwkgICAgJGVycnskbmFtZX0gPSBldmFsICRleHByOworCX0KKwljbG9zZShDUFBPKTsKICAgICB9
  Ci0gICAgY2xvc2UoQ1BQTyk7CiAKICAgICAjIFdyaXRlIEVycm5vLnBtCiAKQEAgLTE3NSw3ICsy
  MTEsNyBAQCBzdWIgd3JpdGVfZXJybm9fcG0gewogIwogCiBwYWNrYWdlIEVycm5vOwotdXNlIHZh
  cnMgcXcoXEBFWFBPUlRfT0sgXCVFWFBPUlRfVEFHUyBcQElTQSBcJFZFUlNJT04gXCVlcnJubyBc
  JEFVVE9MT0FEKTsKK291ciAoXEBFWFBPUlRfT0ssXCVFWFBPUlRfVEFHUyxcQElTQSxcJFZFUlNJ
  T04sXCVlcnJubyxcJEFVVE9MT0FEKTsKIHVzZSBFeHBvcnRlciAoKTsKIHVzZSBDb25maWc7CiB1
  c2Ugc3RyaWN0Owo=
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3f2f3e0..d8fe44e 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -172,16 +172,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS') {	# trust what we have
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +        $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3f2f3e0..d8fe44e 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -172,16 +172,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS') {	# trust what we have
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +        $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32' || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index d8a0ab3..796e2f1 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -235,16 +235,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS' || $^O eq 'beos') {	# trust what we have / get later
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +      my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +      $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32' || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
  LS0tIGV4dC9FcnJuby9FcnJub19wbS5QTAorKysgZXh0L0Vycm5vL0Vycm5vX3BtLlBMCkBAIC03
  LDEyICs3LDM1IEBAIG91ciAkVkVSU0lPTiA9ICIxLjA5XzAxIjsKIG15ICVlcnIgPSAoKTsKIG15
  ICV3c2EgPSAoKTsKIAorIyBTeW1iaWFuIGNyb3NzLWNvbXBpbGluZyBlbnZpcm9ubWVudC4KK215
  ICRJc1N5bWJpYW4gPSBleGlzdHMgJEVOVntTREt9ICYmIC1kICIkRU5We1NES31cXGVwb2MzMiI7
  CisKK215ICRJc01TV2luMzIgPSAkXk8gZXEgJ01TV2luMzInICYmICEkSXNTeW1iaWFuOworCiB1
  bmxpbmsgIkVycm5vLnBtIiBpZiAtZiAiRXJybm8ucG0iOwogb3BlbiBPVVQsICI+RXJybm8ucG0i
  IG9yIGRpZSAiQ2Fubm90IG9wZW4gRXJybm8ucG06ICQhIjsKIHNlbGVjdCBPVVQ7CiBteSAkZmls
  ZTsKLWZvcmVhY2ggJGZpbGUgKGdldF9maWxlcygpKSB7Ci0gICAgcHJvY2Vzc19maWxlKCRmaWxl
  KTsKK215IEBmaWxlcyA9IGdldF9maWxlcygpOworaWYgKCRDb25maWd7Z2NjdmVyc2lvbn0gbmUg
  JycgJiYgJF5PIGVxICdNU1dpbjMyJykgeworICAgICMgTWluR1cgY29tcGxhaW5zICJ3YXJuaW5n
  OiAjcHJhZ21hIHN5c3RlbV9oZWFkZXIgaWdub3JlZCBvdXRzaWRlIGluY2x1ZGUKKyAgICAjIGZp
  bGUiIGlmIHRoZSBoZWFkZXIgZmlsZXMgYXJlIHByb2Nlc3NlZCBpbmRpdmlkdWFsbHksIHNvIGlu
  Y2x1ZGUgdGhlbQorICAgICMgYWxsIGluIC5jIGZpbGUgYW5kIHByb2Nlc3MgdGhhdCBpbnN0ZWFk
  LgorICAgIG9wZW4gSU5DUywgJz5pbmNsdWRlcy5jJyBvcgorCWRpZSAiQ2Fubm90IG9wZW4gaW5j
  bHVkZXMuYyI7CisgICAgZm9yZWFjaCAkZmlsZSAoQGZpbGVzKSB7CisJbmV4dCBpZiAkZmlsZSBl
  cSAnZXJybm8uYyc7CisJbmV4dCB1bmxlc3MgLWYgJGZpbGU7CisJcHJpbnQgSU5DUyBxcVsjaW5j
  bHVkZSAiJGZpbGUiXG5dOworICAgIH0KKyAgICBjbG9zZSBJTkNTOworICAgIHByb2Nlc3NfZmls
  ZSgnaW5jbHVkZXMuYycpOworICAgIHVubGluayAnaW5jbHVkZXMuYyc7Cit9CitlbHNlIHsKKyAg
  ICBmb3JlYWNoICRmaWxlIChAZmlsZXMpIHsKKwlwcm9jZXNzX2ZpbGUoJGZpbGUpOworICAgIH0K
  IH0KIHdyaXRlX2Vycm5vX3BtKCk7CiB1bmxpbmsgImVycm5vLmMiIGlmIC1mICJlcnJuby5jIjsK
  QEAgLTI3LDcgKzUwLDcgQEAgc3ViIHByb2Nlc3NfZmlsZSB7CiAgICAgfQogCiAgICAgcmV0dXJu
  IHVubGVzcyBkZWZpbmVkICRmaWxlIGFuZCAtZiAkZmlsZTsKLSMgICB3YXJuICJQcm9jZXNzaW5n
  ICRmaWxlXG4iOworIyAgICB3YXJuICJQcm9jZXNzaW5nICRmaWxlXG4iOwogCiAgICAgbG9jYWwg
  KkZIOwogICAgIGlmICgoJF5PIGVxICdWTVMnKSAmJiAoJENvbmZpZ3t2bXNfY2NfdHlwZX0gbmUg
  J2dudWMnKSkgewpAQCAtNTMsNyArNzYsNyBAQCBzdWIgcHJvY2Vzc19maWxlIHsKICAgICAgICAg
  ICAgIHJldHVybjsKIAl9CiAgICAgfQotCisgICAgCiAgICAgaWYgKCReTyBlcSAnTWFjT1MnKSB7
  CiAJd2hpbGUoPEZIPikgewogCSAgICAkZXJyeyQxfSA9ICQyCkBAIC02MywxMiArODYsMTMgQEAg
  c3ViIHByb2Nlc3NfZmlsZSB7CiAJd2hpbGUoPEZIPikgewogCSAgICAkZXJyeyQxfSA9IDEKIAkJ
  aWYgL15ccyojXHMqZGVmaW5lXHMrKEVcdyspXHMrLzsKLSAgICAgICAgICAgIGlmICgkXk8gZXEg
  J01TV2luMzInKSB7CisgICAgICAgICAgICBpZiAoJElzTVNXaW4zMikgewogCSAgICAgICAgJHdz
  YXskMX0gPSAxCiAJICAgIAkgICAgaWYgL15ccyojXHMqZGVmaW5lXHMrV1NBKEVcdyspXHMrLzsK
  ICAgICAgICAgICAgIH0KIAl9CiAgICAgfQorCiAgICAgY2xvc2UoRkgpOwogfQogCkBAIC0xMzAs
  NiArMTU0LDEwIEBAIHN1YiBnZXRfZmlsZXMgewogICAgIH0gZWxzaWYgKCReTyBlcSAndm9zJykg
  ewogCSMgYXZvaWQgcHJvYmxlbSB3aGVyZSBjcHAgcmV0dXJucyBub24tUE9TSVggcGF0aG5hbWVz
  CiAJJGZpbGV7Jy9zeXN0ZW0vaW5jbHVkZV9saWJyYXJ5L2Vycm5vLmgnfSA9IDE7CisgICAgfSBl
  bHNpZiAoJElzU3ltYmlhbikgeworICAgICAgICBteSAkU0RLID0gJEVOVntTREt9OworICAgICAg
  ICAkU0RLID1+IHMhXFwhLyFnOworCSRmaWxleyIkU0RLL2Vwb2MzMi9pbmNsdWRlL2xpYmMvc3lz
  L2Vycm5vLmgifSA9IDE7CiAgICAgfSBlbHNlIHsKIAlvcGVuKENQUEksIj4gZXJybm8uYyIpIG9y
  CiAJICAgIGRpZSAiQ2Fubm90IG9wZW4gZXJybm8uYyI7CkBAIC0xMzgsNyArMTY2LDcgQEAgc3Vi
  IGdldF9maWxlcyB7CiAJICAgIHByaW50IENQUEkgIiNpbmNsdWRlIDxud2Vycm5vLmg+XG4iOwog
  CX0gZWxzZSB7CiAJICAgIHByaW50IENQUEkgIiNpbmNsdWRlIDxlcnJuby5oPlxuIjsKLQkgICAg
  aWYgKCReTyBlcSAnTVNXaW4zMicpIHsKKwkgICAgaWYgKCRJc01TV2luMzIpIHsKIAkJcHJpbnQg
  Q1BQSSAiI2RlZmluZSBfV0lOU09DS0FQSV9cbiI7ICMgZG9uJ3QgZHJhZyBpbiBldmVyeXRoaW5n
  CiAJCXByaW50IENQUEkgIiNpbmNsdWRlIDx3aW5zb2NrLmg+XG4iOwogCSAgICB9CkBAIC0xNDcs
  NyArMTc1LDcgQEAgc3ViIGdldF9maWxlcyB7CiAJY2xvc2UoQ1BQSSk7CiAKIAkjIGludm9rZSBD
  UFAgYW5kIHJlYWQgdGhlIG91dHB1dAotCWlmICgkXk8gZXEgJ01TV2luMzInIHx8ICReTyBlcSAn
  TmV0V2FyZScpIHsKKwlpZiAoJElzTVNXaW4zMiB8fCAkXk8gZXEgJ05ldFdhcmUnKSB7CiAJICAg
  IG9wZW4oQ1BQTywiJENvbmZpZ3tjcHBydW59ICRDb25maWd7Y3BwZmxhZ3N9IGVycm5vLmMgfCIp
  IG9yCiAJCWRpZSAiQ2Fubm90IHJ1biAnJENvbmZpZ3tjcHBydW59ICRDb25maWd7Y3BwZmxhZ3N9
  IGVycm5vLmMnIjsKIAl9IGVsc2UgewpAQCAtMTU3LDE0ICsxODUsMTQgQEAgc3ViIGdldF9maWxl
  cyB7CiAJfQogCiAJbXkgJHBhdDsKLQlpZiAoKCReTyBlcSAnTVNXaW4zMicgfHwgJF5PIGVxICdO
  ZXRXYXJlJykgYW5kICRDb25maWd7Y2N9ID1+IC9eYmNjL2kpIHsKKwlpZiAoKCRJc01TV2luMzIg
  fHwgJF5PIGVxICdOZXRXYXJlJykgYW5kICRDb25maWd7Y2N9ID1+IC9eYmNjL2kpIHsKIAkgICAg
  JHBhdCA9ICdeL1wqXHMrKC4rKVxzK1xkK1xzKjpccytcKi8nOwogCX0KIAllbHNlIHsKIAkgICAg
  JHBhdCA9ICdeI1xzKig/OmxpbmUpP1xzKlxkK1xzKyIoW14iXSspIic7CiAJfQogCXdoaWxlKDxD
  UFBPPikgewotCSAgICBpZiAoJF5PIGVxICdvczInIG9yICReTyBlcSAnTVNXaW4zMicgb3IgJF5P
  IGVxICdOZXRXYXJlJykgeworCSAgICBpZiAoJF5PIGVxICdvczInIG9yICRJc01TV2luMzIgb3Ig
  JF5PIGVxICdOZXRXYXJlJykgewogCQlpZiAoLyRwYXQvbykgewogCQkgICBteSAkZiA9ICQxOwog
  CQkgICAkZiA9fiBzLFxcXFwsLyxnOwpAQCAtMTk4LDcgKzIyNiw3IEBAIHN1YiB3cml0ZV9lcnJu
  b19wbSB7CiAgICAgZWxzZSB7CiAJcHJpbnQgQ1BQSSAiI2luY2x1ZGUgPGVycm5vLmg+XG4iOwog
  ICAgIH0KLSAgICBpZiAoJF5PIGVxICdNU1dpbjMyJykgeworICAgIGlmICgkSXNNU1dpbjMyKSB7
  CiAJcHJpbnQgQ1BQSSAiI2luY2x1ZGUgPHdpbnNvY2suaD5cbiI7CiAJZm9yZWFjaCAkZXJyIChr
  ZXlzICV3c2EpIHsKIAkgICAgcHJpbnQgQ1BQSSAiI2lmbmRlZiAkZXJyXG4iOwpAQCAtMjE3LDE2
  ICsyNDUsMzEgQEAgc3ViIHdyaXRlX2Vycm5vX3BtIHsKICAgICB1bmxlc3MgKCReTyBlcSAnTWFj
  T1MnIHx8ICReTyBlcSAnYmVvcycpIHsJIyB0cnVzdCB3aGF0IHdlIGhhdmUgLyBnZXQgbGF0ZXIK
  ICAgICAjIGludm9rZSBDUFAgYW5kIHJlYWQgdGhlIG91dHB1dAogCisJbXkgJGluaGliaXRfbGlu
  ZW1hcmtlcnMgPSAnJzsKKwlpZiAoJENvbmZpZ3tnY2N2ZXJzaW9ufSA9fiAvXEEoXGQrKVwuLyBh
  bmQgJDEgPj0gNSkgeworCSAgICAjIEdDQyA1LjAgaW50ZXJsZWF2ZXMgZXhwYW5kZWQgbWFjcm9z
  IHdpdGggbGluZSBudW1iZXJzIGJyZWFraW5nCisJICAgICMgZWFjaCBsaW5lIGludG8gbXVsdGlw
  bGUgbGluZXMuIFJUIzEyMzc4NAorCSAgICAkaW5oaWJpdF9saW5lbWFya2VycyA9ICcgLVAnOwor
  CX0KKwogCWlmICgkXk8gZXEgJ1ZNUycpIHsKLQkgICAgbXkgJGNwcCA9ICIkQ29uZmlne2NwcHN0
  ZGlufSAkQ29uZmlne2NwcGZsYWdzfSAkQ29uZmlne2NwcG1pbnVzfSI7CisJICAgIG15ICRjcHAg
  PSAiJENvbmZpZ3tjcHBzdGRpbn0gJENvbmZpZ3tjcHBmbGFnc30iIC4KKwkJJGluaGliaXRfbGlu
  ZW1hcmtlcnMgLiAiICRDb25maWd7Y3BwbWludXN9IjsKIAkgICAgJGNwcCA9fiBzL3N5c1wkaW5w
  dXQvL2k7CiAJICAgIG9wZW4oQ1BQTywiJGNwcCAgZXJybm8uYyB8Iikgb3IKIAkJZGllICJDYW5u
  b3QgZXhlYyAkQ29uZmlne2NwcHN0ZGlufSI7Ci0JfSBlbHNpZiAoJF5PIGVxICdNU1dpbjMyJyB8
  fCAkXk8gZXEgJ05ldFdhcmUnKSB7Ci0JICAgIG9wZW4oQ1BQTywiJENvbmZpZ3tjcHBydW59ICRD
  b25maWd7Y3BwZmxhZ3N9IGVycm5vLmMgfCIpIG9yCi0JCWRpZSAiQ2Fubm90IHJ1biAnJENvbmZp
  Z3tjcHBydW59ICRDb25maWd7Y3BwZmxhZ3N9IGVycm5vLmMnIjsKLQl9IGVsc2UgewotCSAgICBt
  eSAkY3BwID0gZGVmYXVsdF9jcHAoKTsKKwl9IGVsc2lmICgkSXNNU1dpbjMyIHx8ICReTyBlcSAn
  TmV0V2FyZScpIHsKKwkgICAgbXkgJGNwcCA9ICIkQ29uZmlne2NwcHJ1bn0gJENvbmZpZ3tjcHBm
  bGFnc30iIC4KKwkJJGluaGliaXRfbGluZW1hcmtlcnM7CisJICAgIG9wZW4oQ1BQTywiJGNwcCBl
  cnJuby5jIHwiKSBvcgorCQlkaWUgIkNhbm5vdCBydW4gJyRjcHAgZXJybm8uYyciOworCX0gZWxz
  aWYgKCRJc1N5bWJpYW4pIHsKKyAgICAgICAgICAgIG15ICRjcHAgPSAiZ2NjIC1FIC1JJEVOVntT
  REt9XFxlcG9jMzJcXGluY2x1ZGVcXGxpYmMiIC4KKwkJJGluaGliaXRfbGluZW1hcmtlcnMgLiIg
  LSI7CisJICAgIG9wZW4oQ1BQTywiJGNwcCA8IGVycm5vLmMgfCIpCisJCW9yIGRpZSAiQ2Fubm90
  IGV4ZWMgJGNwcCI7CisgICAgICAgIH0gZWxzZSB7CisJICAgIG15ICRjcHAgPSBkZWZhdWx0X2Nw
  cCgpIC4gJGluaGliaXRfbGluZW1hcmtlcnM7CiAJICAgIG9wZW4oQ1BQTywiJGNwcCA8IGVycm5v
  LmMgfCIpCiAJCW9yIGRpZSAiQ2Fubm90IGV4ZWMgJGNwcCI7CiAJfQo=
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3dadfce..c6bfa06 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -215,20 +215,31 @@ sub write_errno_pm {
       {	# BeOS (support now removed) did not enter this block
       # invoke CPP and read the output
   
  +	my $inhibit_linemarkers = '';
  +	if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +	    # GCC 5.0 interleaves expanded macros with line numbers breaking
  +	    # each line into multiple lines. RT#123784
  +	    $inhibit_linemarkers = ' -P';
  +	}
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +		$inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($IsMSWin32 || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +	    my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +		$inhibit_linemarkers;
  +	    open(CPPO,"$cpp errno.c |") or
  +		die "Cannot run '$cpp errno.c'";
   	} elsif ($IsSymbian) {
  -            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc -";
  +            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc" .
  +		$inhibit_linemarkers ." -";
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
           } else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
  diff --git a/dist/Time-HiRes/HiRes.pm b/dist/Time-HiRes/HiRes.pm
  index ad9a65c99d..a3ddd595b7 100644
  --- dist/Time-HiRes/HiRes.pm
  +++ dist/Time-HiRes/HiRes.pm
  @@ -23,12 +23,12 @@ our @EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval
   		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
   		 TIMER_ABSTIME
   		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
  -		 d_nanosleep d_clock_gettime d_clock_getres
  +		 d_nanosleep d_clock_gettime d_clock_getres d_hires_utime
   		 d_clock d_clock_nanosleep
  -		 stat lstat
  +		 stat lstat utime
   		);
   
  -our $VERSION = '1.9733';
  +our $VERSION = '1.9741';
   our $XS_VERSION = $VERSION;
   $VERSION = eval $VERSION;
   
  @@ -60,6 +60,7 @@ sub import {
   	    ($i eq 'clock'           && !&d_clock)           ||
   	    ($i eq 'nanosleep'       && !&d_nanosleep)       ||
   	    ($i eq 'usleep'          && !&d_usleep)          ||
  +	    ($i eq 'utime'           && !&d_hires_utime)     ||
   	    ($i eq 'ualarm'          && !&d_ualarm)) {
   	    require Carp;
   	    Carp::croak("Time::HiRes::$i(): unimplemented in this platform");
  @@ -92,7 +93,7 @@ Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers
   
     use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
   		      clock_gettime clock_getres clock_nanosleep clock
  -                      stat lstat );
  +                      stat lstat utime);
   
     usleep ($microseconds);
     nanosleep ($nanoseconds);
  @@ -137,6 +138,9 @@ Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers
     my @stat = stat(FH);
     my @stat = lstat("file");
   
  +  use Time::HiRes qw( utime );
  +  utime $floating_seconds, $floating_seconds, file...;
  +
   =head1 DESCRIPTION
   
   The C<Time::HiRes> module implements a Perl interface to the
  @@ -446,6 +450,26 @@ if the operations are
   the access time stamp from t2 need not be greater-than the modify
   time stamp from t1: it may be equal or I<less>.
   
  +=item utime LIST
  +
  +As L<perlfunc/utime>
  +but with the ability to set the access/modify file timestamps
  +in subsecond resolution, if the operating system and the filesystem
  +both support such timestamps.  To override the standard utime():
  +
  +    use Time::HiRes qw(utime);
  +
  +Test for the value of &Time::HiRes::d_hires_utime to find out whether
  +the operating system supports setting subsecond file timestamps.
  +
  +As with CORE::utime(), passing undef as both the atime and mtime will
  +call the syscall with a NULL argument.
  +
  +The actual achievable subsecond resolution depends on the combination
  +of the operating system and the filesystem.
  +
  +Returns the number of files successfully changed.
  +
   =back
   
   =head1 EXAMPLES
  @@ -535,7 +559,7 @@ VMS have emulations for it.)
   Here is an example of using C<NVtime> from C:
   
     NV (*myNVtime)(); /* Returns -1 on failure. */
  -  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
  +  SV **svp = hv_fetchs(PL_modglobal, "Time::NVtime", 0);
     if (!svp)         croak("Time::HiRes is required");
     if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
     myNVtime = INT2PTR(NV(*)(), SvIV(*svp));
  @@ -586,9 +610,13 @@ might help in this (in case your system supports CLOCK_MONOTONIC).
   Some systems have APIs but not implementations: for example QNX and Haiku
   have the interval timer APIs but not the functionality.
   
  -In OS X clock_getres(), clock_gettime() and clock_nanosleep() are
  -emulated using the Mach timers; as a side effect of being emulated
  -the CLOCK_REALTIME and CLOCK_MONOTONIC are the same timer.
  +In pre-Sierra macOS (pre-10.12, OS X) clock_getres(), clock_gettime()
  +and clock_nanosleep() are emulated using the Mach timers; as a side
  +effect of being emulated the CLOCK_REALTIME and CLOCK_MONOTONIC are
  +the same timer.
  +
  +gnukfreebsd seems to have non-functional futimens() and utimensat()
  +(at least as of 10.1): therefore the hires utime() does not work.
   
   =head1 SEE ALSO
   
  diff --git a/dist/Time-HiRes/HiRes.xs b/dist/Time-HiRes/HiRes.xs
  index 38ca0dc320..6b0dba8e68 100644
  --- dist/Time-HiRes/HiRes.xs
  +++ dist/Time-HiRes/HiRes.xs
  @@ -87,6 +87,10 @@ extern "C" {
   #   undef ITIMER_REALPROF
   #endif
   
  +#ifndef TIME_HIRES_CLOCKID_T
  +typedef int clockid_t;
  +#endif
  +
   #if defined(TIME_HIRES_CLOCK_GETTIME) && defined(_STRUCT_ITIMERSPEC)
   
   /* HP-UX has CLOCK_XXX values but as enums, not as defines.
  @@ -747,21 +751,33 @@ hrstatns(UV *atime_nsec, UV *mtime_nsec, UV *ctime_nsec)
   #endif /* !TIME_HIRES_STAT */
   }
   
  -/* Until Apple implements clock_gettime() (ditto clock_getres())
  - * we will emulate it using Mach interfaces. */
  -#if defined(PERL_DARWIN) && !defined(CLOCK_REALTIME)
  -
  -#  include <mach/mach_time.h>
  +/* Until Apple implements clock_gettime()
  + * (ditto clock_getres() and clock_nanosleep())
  + * we will emulate them using the Mach kernel interfaces. */
  +#if defined(PERL_DARWIN) && \
  +  (defined(TIME_HIRES_CLOCK_GETTIME_EMULATION)   || \
  +   defined(TIME_HIRES_CLOCK_GETRES_EMULATION)    || \
  +   defined(TIME_HIRES_CLOCK_NANOSLEEP_EMULATION))
   
  +#ifndef CLOCK_REALTIME
   #  define CLOCK_REALTIME  0x01
   #  define CLOCK_MONOTONIC 0x02
  +#endif
   
  +#ifndef TIMER_ABSTIME
   #  define TIMER_ABSTIME   0x01
  +#endif
   
   #ifdef USE_ITHREADS
  +#  define PERL_DARWIN_MUTEX
  +#endif
  +
  +#ifdef PERL_DARWIN_MUTEX
   STATIC perl_mutex darwin_time_mutex;
   #endif
   
  +#include <mach/mach_time.h>
  +
   static uint64_t absolute_time_init;
   static mach_timebase_info_data_t timebase_info;
   static struct timespec timespec_init;
  @@ -769,7 +785,7 @@ static struct timespec timespec_init;
   static int darwin_time_init() {
     struct timeval tv;
     int success = 1;
  -#ifdef USE_ITHREADS
  +#ifdef PERL_DARWIN_MUTEX
     MUTEX_LOCK(&darwin_time_mutex);
   #endif
     if (absolute_time_init == 0) {
  @@ -784,13 +800,14 @@ static int darwin_time_init() {
         }
       }
     }
  -#ifdef USE_ITHREADS
  +#ifdef PERL_DARWIN_MUTEX
     MUTEX_UNLOCK(&darwin_time_mutex);
   #endif
     return success;
   }
   
  -static int clock_gettime(int clock_id, struct timespec *ts) {
  +#ifdef TIME_HIRES_CLOCK_GETTIME_EMULATION
  +static int th_clock_gettime(clockid_t clock_id, struct timespec *ts) {
     if (darwin_time_init() && timebase_info.denom) {
       switch (clock_id) {
         case CLOCK_REALTIME:
  @@ -822,7 +839,12 @@ static int clock_gettime(int clock_id, struct timespec *ts) {
     return -1;
   }
   
  -static int clock_getres(int clock_id, struct timespec *ts) {
  +#define clock_gettime(clock_id, ts) th_clock_gettime((clock_id), (ts))
  +
  +#endif /* TIME_HIRES_CLOCK_GETTIME_EMULATION */
  +
  +#ifdef TIME_HIRES_CLOCK_GETRES_EMULATION
  +static int th_clock_getres(clockid_t clock_id, struct timespec *ts) {
     if (darwin_time_init() && timebase_info.denom) {
       switch (clock_id) {
         case CLOCK_REALTIME:
  @@ -842,7 +864,11 @@ static int clock_getres(int clock_id, struct timespec *ts) {
     return -1;
   }
   
  -static int clock_nanosleep(int clock_id, int flags,
  +#define clock_getres(clock_id, ts) th_clock_getres((clock_id), (ts))
  +#endif /* TIME_HIRES_CLOCK_GETRES_EMULATION */
  +
  +#ifdef TIME_HIRES_CLOCK_NANOSLEEP_EMULATION
  +static int th_clock_nanosleep(clockid_t clock_id, int flags,
   			   const struct timespec *rqtp,
   			   struct timespec *rmtp) {
     if (darwin_time_init()) {
  @@ -880,6 +906,11 @@ static int clock_nanosleep(int clock_id, int flags,
     return -1;
   }
   
  +#define clock_nanosleep(clock_id, flags, rqtp, rmtp) \
  +  th_clock_nanosleep((clock_id), (flags), (rqtp), (rmtp))
  +
  +#endif /* TIME_HIRES_CLOCK_NANOSLEEP_EMULATION */
  +
   #endif /* PERL_DARWIN */
   
   #include "const-c.inc"
  @@ -921,6 +952,22 @@ nsec_without_unslept(struct timespec *sleepfor,
   
   #endif
   
  +/* In case Perl and/or Devel::PPPort are too old, minimally emulate
  + * IS_SAFE_PATHNAME() (which looks for zero bytes in the pathname). */
  +#ifndef IS_SAFE_PATHNAME
  +#if PERL_VERSION >= 12 /* Perl_ck_warner is 5.10.0 -> */
  +#ifdef WARN_SYSCALLS
  +#define WARNEMUCAT WARN_SYSCALLS /* 5.22.0 -> */
  +#else
  +#define WARNEMUCAT WARN_MISC
  +#endif
  +#define WARNEMU(opname) Perl_ck_warner(aTHX_ packWARN(WARNEMUCAT), "Invalid \\0 character in pathname for %s",opname)
  +#else
  +#define WARNEMU(opname) Perl_warn(aTHX_ "Invalid \\0 character in pathname for %s",opname)
  +#endif
  +#define IS_SAFE_PATHNAME(pv, len, opname) (((len)>1)&&memchr((pv), 0, (len)-1)?(SETERRNO(ENOENT, LIB_INVARG),WARNEMU(opname),FALSE):(TRUE))
  +#endif
  +
   MODULE = Time::HiRes            PACKAGE = Time::HiRes
   
   PROTOTYPES: ENABLE
  @@ -941,7 +988,7 @@ BOOT:
   #   endif
   #endif
   #if defined(PERL_DARWIN)
  -#  ifdef USE_ITHREADS
  +#  if defined(USE_ITHREADS) && defined(PERL_DARWIN_MUTEX)
     MUTEX_INIT(&darwin_time_mutex);
   #  endif
   #endif
  @@ -978,7 +1025,8 @@ usleep(useconds)
   		    useconds -= NV_1E6 * seconds;
   		}
   	    } else if (useconds < 0.0)
  -	        croak("Time::HiRes::usleep(%"NVgf"): negative time not invented yet", useconds);
  +	        croak("Time::HiRes::usleep(%" NVgf
  +                      "): negative time not invented yet", useconds);
   	    usleep((U32)useconds);
   	} else
   	    PerlProc_pause();
  @@ -1000,7 +1048,8 @@ nanosleep(nsec)
   	struct timespec sleepfor, unslept;
   	CODE:
   	if (nsec < 0.0)
  -	    croak("Time::HiRes::nanosleep(%"NVgf"): negative time not invented yet", nsec);
  +	    croak("Time::HiRes::nanosleep(%" NVgf
  +                  "): negative time not invented yet", nsec);
           nanosleep_init(nsec, &sleepfor, &unslept);
   	if (nanosleep(&sleepfor, &unslept) == 0) {
   	    RETVAL = nsec;
  @@ -1045,11 +1094,15 @@ sleep(...)
   		   useconds = -(IV)useconds;
   #endif /* #if defined(__sparc64__) && defined(__GNUC__) */
   		   if ((IV)useconds < 0)
  -		     croak("Time::HiRes::sleep(%"NVgf"): internal error: useconds < 0 (unsigned %"UVuf" signed %"IVdf")", seconds, useconds, (IV)useconds);
  +		     croak("Time::HiRes::sleep(%" NVgf
  +                           "): internal error: useconds < 0 (unsigned %" UVuf
  +                           " signed %" IVdf ")",
  +                           seconds, useconds, (IV)useconds);
   		 }
   		 usleep(useconds);
   	    } else
  -	        croak("Time::HiRes::sleep(%"NVgf"): negative time not invented yet", seconds);
  +	        croak("Time::HiRes::sleep(%" NVgf
  +                      "): negative time not invented yet", seconds);
   	} else
   	    PerlProc_pause();
   	gettimeofday(&Tb, NULL);
  @@ -1097,7 +1150,9 @@ ualarm(useconds,uinterval=0)
   	  }
   #else
   	if (useconds >= IV_1E6 || uinterval >= IV_1E6) 
  -		croak("Time::HiRes::ualarm(%d, %d): useconds or uinterval equal to or more than %"IVdf, useconds, uinterval, IV_1E6);
  +		croak("Time::HiRes::ualarm(%d, %d): useconds or uinterval"
  +                      " equal to or more than %" IVdf,
  +                      useconds, uinterval, IV_1E6);
   	RETVAL = ualarm(useconds, uinterval);
   #endif
   
  @@ -1110,7 +1165,8 @@ alarm(seconds,interval=0)
   	NV interval
   	CODE:
   	if (seconds < 0.0 || interval < 0.0)
  -	    croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): negative time not invented yet", seconds, interval);
  +	    croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                  "): negative time not invented yet", seconds, interval);
   	{
   	  IV iseconds = (IV)seconds;
   	  IV iinterval = (IV)interval;
  @@ -1118,7 +1174,9 @@ alarm(seconds,interval=0)
   	  NV finterval = interval - iinterval;
   	  IV useconds, uinterval;
   	  if (fseconds >= 1.0 || finterval >= 1.0)
  -		croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): seconds or interval too large to split correctly", seconds, interval);
  +		croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                      "): seconds or interval too large to split correctly",
  +                      seconds, interval);
   	  useconds = IV_1E6 * fseconds;
   	  uinterval = IV_1E6 * finterval;
   #if defined(HAS_SETITIMER) && defined(ITIMER_REAL)
  @@ -1138,7 +1196,9 @@ alarm(seconds,interval=0)
   	  }
   #else
   	  if (iseconds || iinterval)
  -		croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): seconds or interval equal to or more than 1.0 ", seconds, interval);
  +		croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                      "): seconds or interval equal to or more than 1.0 ",
  +                      seconds, interval);
   	    RETVAL = (NV)ualarm( useconds, uinterval ) / NV_1E6;
   #endif
   	}
  @@ -1266,7 +1326,9 @@ setitimer(which, seconds, interval = 0)
   	struct itimerval oldit;
       PPCODE:
   	if (seconds < 0.0 || interval < 0.0)
  -	    croak("Time::HiRes::setitimer(%"IVdf", %"NVgf", %"NVgf"): negative time not invented yet", (IV)which, seconds, interval);
  +	    croak("Time::HiRes::setitimer(%" IVdf ", %" NVgf ", %" NVgf
  +                  "): negative time not invented yet",
  +                  (IV)which, seconds, interval);
   	newit.it_value.tv_sec  = (IV)seconds;
   	newit.it_value.tv_usec =
   	  (IV)((seconds  - (NV)newit.it_value.tv_sec)    * NV_1E6);
  @@ -1317,11 +1379,89 @@ getitimer(which)
   
   #endif /* #if defined(HAS_GETITIMER) && defined(HAS_SETITIMER) */
   
  +#if defined(TIME_HIRES_UTIME)
  +
  +I32
  +utime(accessed, modified, ...)
  +PROTOTYPE: $$@
  +    PREINIT:
  +	SV* accessed;
  +	SV* modified;
  +	SV* file;
  +
  +	struct timespec utbuf[2];
  +	struct timespec *utbufp = utbuf;
  +	int tot;
  +
  +    CODE:
  +	accessed = ST(0);
  +	modified = ST(1);
  +	items -= 2;
  +	tot = 0;
  +
  +	if ( accessed == &PL_sv_undef && modified == &PL_sv_undef )
  +		utbufp = NULL;
  +	else {
  +		if (SvNV(accessed) < 0.0 || SvNV(modified) < 0.0)
  +                    croak("Time::HiRes::utime(%" NVgf ", %" NVgf
  +                          "): negative time not invented yet",
  +                              SvNV(accessed), SvNV(modified));
  +		Zero(&utbuf, sizeof utbuf, char);
  +		utbuf[0].tv_sec = (Time_t)SvNV(accessed);  /* time accessed */
  +		utbuf[0].tv_nsec = (long)( ( SvNV(accessed) - utbuf[0].tv_sec ) * 1e9 );
  +		utbuf[1].tv_sec = (Time_t)SvNV(modified);  /* time modified */
  +		utbuf[1].tv_nsec = (long)( ( SvNV(modified) - utbuf[1].tv_sec ) * 1e9 );
  +	}
  +
  +	while (items > 0) {
  +		file = POPs; items--;
  +
  +		if (SvROK(file) && GvIO(SvRV(file)) && IoIFP(sv_2io(SvRV(file)))) {
  +			int fd =  PerlIO_fileno(IoIFP(sv_2io(file)));
  +			if (fd < 0)
  +				SETERRNO(EBADF,RMS_IFI);
  +			else 
  +#ifdef HAS_FUTIMENS
  +			if (futimens(fd, utbufp) == 0)
  +				tot++;
  +#else  /* HAS_FUTIMES */
  +				croak("futimens unimplemented in this platform");
  +#endif /* HAS_FUTIMES */
  +		}
  +		else {
  +#ifdef HAS_UTIMENSAT
  +			STRLEN len;
  +			char * name = SvPV(file, len);
  +			if (IS_SAFE_PATHNAME(name, len, "utime") &&
  +			    utimensat(AT_FDCWD, name, utbufp, 0) == 0)
  +				tot++;
  +#else  /* HAS_UTIMENSAT */
  +			croak("utimensat unimplemented in this platform");
  +#endif /* HAS_UTIMENSAT */
  +		}
  +	} /* while items */
  +	RETVAL = tot;
  +
  +    OUTPUT:
  +	RETVAL
  +
  +#else  /* #if defined(TIME_HIRES_UTIME) */
  +
  +I32
  +utime(accessed, modified, ...)
  +    CODE:
  +        croak("Time::HiRes::utime(): unimplemented in this platform");
  +        RETVAL = 0;
  +    OUTPUT:
  +	RETVAL
  +
  +#endif /* #if defined(TIME_HIRES_UTIME) */
  +
   #if defined(TIME_HIRES_CLOCK_GETTIME)
   
   NV
   clock_gettime(clock_id = CLOCK_REALTIME)
  -	int clock_id
  +	clockid_t clock_id
       PREINIT:
   	struct timespec ts;
   	int status = -1;
  @@ -1340,7 +1480,7 @@ clock_gettime(clock_id = CLOCK_REALTIME)
   
   NV
   clock_gettime(clock_id = 0)
  -	int clock_id
  +	clockid_t clock_id
       CODE:
   	PERL_UNUSED_ARG(clock_id);
           croak("Time::HiRes::clock_gettime(): unimplemented in this platform");
  @@ -1354,7 +1494,7 @@ clock_gettime(clock_id = 0)
   
   NV
   clock_getres(clock_id = CLOCK_REALTIME)
  -	int clock_id
  +	clockid_t clock_id
       PREINIT:
   	int status = -1;
   	struct timespec ts;
  @@ -1373,7 +1513,7 @@ clock_getres(clock_id = CLOCK_REALTIME)
   
   NV
   clock_getres(clock_id = 0)
  -	int clock_id
  +	clockid_t clock_id
       CODE:
   	PERL_UNUSED_ARG(clock_id);
           croak("Time::HiRes::clock_getres(): unimplemented in this platform");
  @@ -1387,14 +1527,15 @@ clock_getres(clock_id = 0)
   
   NV
   clock_nanosleep(clock_id, nsec, flags = 0)
  -	int clock_id
  +	clockid_t clock_id
   	NV  nsec
   	int flags
       PREINIT:
   	struct timespec sleepfor, unslept;
       CODE:
   	if (nsec < 0.0)
  -	    croak("Time::HiRes::clock_nanosleep(..., %"NVgf"): negative time not invented yet", nsec);
  +	    croak("Time::HiRes::clock_nanosleep(..., %" NVgf
  +                  "): negative time not invented yet", nsec);
           nanosleep_init(nsec, &sleepfor, &unslept);
   	if (clock_nanosleep(clock_id, flags, &sleepfor, &unslept) == 0) {
   	    RETVAL = nsec;
  @@ -1408,7 +1549,7 @@ clock_nanosleep(clock_id, nsec, flags = 0)
   
   NV
   clock_nanosleep(clock_id, nsec, flags = 0)
  -	int clock_id
  +	clockid_t clock_id
   	NV  nsec
   	int flags
       CODE:
  diff --git a/dist/Time-HiRes/Makefile.PL b/dist/Time-HiRes/Makefile.PL
  index 087ab79871..ccad6a3e6f 100644
  --- dist/Time-HiRes/Makefile.PL
  +++ dist/Time-HiRes/Makefile.PL
  @@ -88,7 +88,7 @@ sub try_compile_and_link {
       my $obj_ext = $Config{obj_ext} || ".o";
       unlink("$tmp.c", "$tmp$obj_ext");
   
  -    if (open(TMPC, ">$tmp.c")) {
  +    if (open(TMPC, '>', "$tmp.c")) {
   	print TMPC $c;
   	close(TMPC);
   
  @@ -132,7 +132,7 @@ __EOD__
   	    unless defined $cccmd;
   
          if ($^O eq 'VMS') {
  -	    open( CMDFILE, ">$tmp.com" );
  +	    open( CMDFILE, '>', "$tmp.com" );
   	    print CMDFILE "\$ SET MESSAGE/NOFACILITY/NOSEVERITY/NOIDENT/NOTEXT\n";
   	    print CMDFILE "\$ $cccmd\n";
   	    print CMDFILE "\$ IF \$SEVERITY .NE. 1 THEN EXIT 44\n"; # escalate
  @@ -290,6 +290,7 @@ sub has_clock_xxx_syscall {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   #include <$SYSCALL_H>
   int main(int argc, char** argv)
   {
  @@ -309,6 +310,7 @@ sub has_clock_xxx {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   int main(int argc, char** argv)
   {
       struct timespec ts;
  @@ -325,6 +327,7 @@ sub has_clock {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   int main(int argc, char** argv)
   {
       clock_t tictoc;
  @@ -348,12 +351,63 @@ int main(int argc, char** argv)
       struct timespec ts2;
       ts1.tv_sec  = 0;
       ts1.tv_nsec = 750000000;;
  -    ret = clock_nanosleep(CLOCK_MONOTONIC, 0, &ts1, &ts2);
  +    /* All implementations are supposed to support CLOCK_REALTIME. */
  +    ret = clock_nanosleep(CLOCK_REALTIME, 0, &ts1, &ts2);
       ret == 0 ? exit(0) : exit(errno ? errno : -1);
   }
   EOM
   }
   
  +sub has_futimens {
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <sys/stat.h>
  +int main(int argc, char** argv)
  +{
  +    int ret;
  +    struct timespec ts[2];
  +    ret = futimens(0, ts);
  +    ret == 0 ? exit(0) : exit(errno ? errno : -1);
  +}
  +EOM
  +}
  +
  +sub has_utimensat{
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <sys/stat.h>
  +#include <fcntl.h>
  +int main(int argc, char** argv)
  +{
  +    int ret;
  +    struct timespec ts[2];
  +    ret = utimensat(AT_FDCWD, 0, ts, 0);
  +    ret == 0 ? exit(0) : exit(errno ? errno : -1);
  +}
  +EOM
  +}
  +
  +sub has_clockid_t{
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <time.h>
  +int main(int argc, char** argv)
  +{
  +    clockid_t id = CLOCK_REALTIME;
  +    exit(id == CLOCK_REALTIME ? 1 : 0);
  +}
  +EOM
  +}
  +
   sub DEFINE {
       my ($def, $val) = @_;
       my $define = defined $val ? "$def=$val" : $def ;
  @@ -534,6 +588,16 @@ EOD
           print "(It would not be portable anyway.)\n";
       }
   
  +    print "Looking for clockid_t... ";
  +    my $has_clockid_t;
  +    if (has_clockid_t()) {
  +	print "found.\n";
  +        $has_clockid_t++;
  +	$DEFINE .= ' -DTIME_HIRES_CLOCKID_T';
  +    } else {
  +	print "NOT found, will use int.\n";
  +    }
  +
       print "Looking for clock_gettime()... ";
       my $has_clock_gettime;
       my $has_clock_gettime_emulation;
  @@ -548,7 +612,7 @@ EOD
       } elsif ($^O eq 'darwin') {
          $has_clock_gettime_emulation++;
          $has_clock_gettime++;
  -       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETTIME';
  +       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETTIME -DTIME_HIRES_CLOCK_GETTIME_EMULATION';
       }
   
       if ($has_clock_gettime) {
  @@ -577,7 +641,7 @@ EOD
       } elsif ($^O eq 'darwin') {
          $has_clock_getres_emulation++;
          $has_clock_getres++;
  -       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETRES';
  +       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETRES -DTIME_HIRES_CLOCK_GETRES_EMULATION';
       }
   
       if ($has_clock_getres) {
  @@ -603,7 +667,7 @@ EOD
       } elsif ($^O eq 'darwin') {
           $has_clock_nanosleep++;
           $has_clock_nanosleep_emulation++;
  -	$DEFINE .= ' -DTIME_HIRES_CLOCK_NANOSLEEP';
  +	$DEFINE .= ' -DTIME_HIRES_CLOCK_NANOSLEEP -DTIME_HIRES_CLOCK_NANOSLEEP_EMULATION';
       }
   
       if ($has_clock_nanosleep) {
  @@ -631,6 +695,36 @@ EOD
   	print "NOT found.\n";
       }
   
  +    print "Looking for futimens()... ";
  +    my $has_futimens;
  +    if (has_futimens()) {
  +        $has_futimens++;
  +	$DEFINE .= ' -DHAS_FUTIMENS';
  +    }
  +
  +    if ($has_futimens) {
  +        print "found.\n";
  +    } else {
  +	print "NOT found.\n";
  +    }
  +
  +    print "Looking for utimensat()... ";
  +    my $has_utimensat;
  +    if (has_utimensat()) {
  +        $has_utimensat++;
  +	$DEFINE .= ' -DHAS_UTIMENSAT';
  +    }
  +
  +    if ($has_utimensat) {
  +        print "found.\n";
  +    } else {
  +	print "NOT found.\n";
  +    }
  +
  +    if ($has_futimens or $has_utimensat) {
  +	$DEFINE .= ' -DTIME_HIRES_UTIME';
  +    }
  +
       print "Looking for stat() subsecond timestamps...\n";
   
       print "Trying struct stat st_atimespec.tv_nsec...";
  @@ -644,7 +738,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtimespec++;
  -      DEFINE('TIME_HIRES_STAT', 1);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIMESPEC');  # 1
       }
   
       if ($has_stat_st_xtimespec) {
  @@ -664,7 +758,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtimensec++;
  -      DEFINE('TIME_HIRES_STAT', 2);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIMENSEC');  # 2
       }
   
       if ($has_stat_st_xtimensec) {
  @@ -684,7 +778,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtime_n++;
  -      DEFINE('TIME_HIRES_STAT', 3);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIME_N');  # 3
       }
   
       if ($has_stat_st_xtime_n) {
  @@ -704,7 +798,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtim++;
  -      DEFINE('TIME_HIRES_STAT', 4);
  +      DEFINE('TIME_HIRES_STAT_XTIM');  # 4
       }
   
       if ($has_stat_st_xtim) {
  @@ -724,7 +818,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_uxtime++;
  -      DEFINE('TIME_HIRES_STAT', 5);
  +      DEFINE('TIME_HIRES_STAT_ST_UXTIME');  # 5
       }
   
       if ($has_stat_st_uxtime) {
  @@ -733,6 +827,19 @@ EOM
   	print "NOT found.\n";
       }
   
  +    # See HiRes.xs hrstatns()
  +    if ($has_stat_st_xtimespec) {
  +        DEFINE('TIME_HIRES_STAT', 1);
  +    } elsif ($has_stat_st_xtimensec) {
  +        DEFINE('TIME_HIRES_STAT', 2);
  +    } elsif ($has_stat_st_xtime_n) {
  +        DEFINE('TIME_HIRES_STAT', 3);
  +    } elsif ($has_stat_st_xtim) {
  +        DEFINE('TIME_HIRES_STAT', 4);
  +    } elsif ($has_stat_st_uxtime) {
  +        DEFINE('TIME_HIRES_STAT', 5);
  +    }    
  +
      if ($DEFINE =~ /-DTIME_HIRES_STAT=\d+/) {
       print "You seem to have stat() subsecond timestamps.\n";
       print "(Your struct stat has them, but the filesystems must help.)\n";
  @@ -757,7 +864,7 @@ EOM
   
       if ($DEFINE) {
           $DEFINE =~ s/^\s+//;
  -        if (open(XDEFINE, ">xdefine")) {
  +        if (open(XDEFINE, '>', 'xdefine')) {
   	    print XDEFINE $DEFINE, "\n";
   	    close(XDEFINE);
           }
  @@ -791,7 +898,7 @@ sub doMakefile {
   	    'DynaLoader' => 0,
   	    'Exporter' => 0,
   	    'ExtUtils::MakeMaker' => 0,
  -	    'Test::More' => "0.82",
  +	    'Test::More' => 0,
   	    'strict' => 0,
   	},
   	'dist'      => {
  @@ -869,7 +976,8 @@ sub doConstants {
                         );
   	foreach (qw (d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
   		     d_nanosleep d_clock_gettime d_clock_getres
  -		     d_clock d_clock_nanosleep d_hires_stat)) {
  +		     d_clock d_clock_nanosleep d_hires_stat
  +                     d_futimens d_utimensat d_hires_utime)) {
   	    my $macro = $_;
   	    if ($macro =~ /^(d_nanosleep|d_clock)$/) {
   		$macro =~ s/^d_(.+)/TIME_HIRES_\U$1/;
  @@ -879,6 +987,13 @@ sub doConstants {
   		push @names, {name => $_, macro => "TIME_HIRES_STAT", value => $d_hires_stat,
   			      default => ["IV", "0"]};
   		next;
  +	    } elsif ($macro =~ /^(d_hires_utime)$/) {
  +		my $d_hires_utime =
  +                    ($DEFINE =~ /-DHAS_FUTIMENS/ ||
  +                     $DEFINE =~ /-DHAS_UTIMENSAT/) ? 1 : 0;
  +		push @names, {name => $_, macro => "TIME_HIRES_UTIME", value => $d_hires_utime,
  +			      default => ["IV", "0"]};
  +		next;
   	    } elsif ($macro =~ /^(d_clock_gettime|d_clock_getres|d_clock_nanosleep)$/) {
   		$macro =~ s/^d_(.+)/TIME_HIRES_\U$1/;
   		my $val = ($DEFINE =~ /-D$macro\b/) ? 1 : 0;
  @@ -900,8 +1015,8 @@ sub doConstants {
   	foreach $file ('const-c.inc', 'const-xs.inc') {
   	    my $fallback = File::Spec->catfile('fallback', $file);
   	    local $/;
  -	    open IN, "<$fallback" or die "Can't open $fallback: $!";
  -	    open OUT, ">$file" or die "Can't open $file: $!";
  +	    open IN, '<', $fallback or die "Can't open $fallback: $!";
  +	    open OUT, '>', $file or die "Can't open $file: $!";
   	    print OUT <IN> or die $!;
   	    close OUT or die "Can't close $file: $!";
   	    close IN or die "Can't close $fallback: $!";
  @@ -920,7 +1035,7 @@ sub main {
   	    DEFINE('SELECT_IS_BROKEN');
   	    $LIBS = [];
   	    print "System is $^O, skipping full configure...\n";
  -	    open(XDEFINE, ">xdefine") or die "$0: Cannot create xdefine: $!\n";
  +	    open(XDEFINE, '>', 'xdefine') or die "$0: Cannot create xdefine: $!\n";
   	    close(XDEFINE);
   	} else {
   	    init();
  diff --git a/dist/Time-HiRes/fallback/const-c.inc b/dist/Time-HiRes/fallback/const-c.inc
  index a8626172af..524db169a9 100644
  --- dist/Time-HiRes/fallback/const-c.inc
  +++ dist/Time-HiRes/fallback/const-c.inc
  @@ -19,6 +19,7 @@ typedef double NV; /* 5.6 and later define NVTYPE, and typedef NV to it.  */
   #ifndef pTHX_
   #define pTHX_ /* 5.6 or later define this for threading support.  */
   #endif
  +
   static int
   constant_11 (pTHX_ const char *name, IV *iv_return) {
     /* When generated this function returned values for the list of names given
  @@ -86,6 +87,51 @@ constant_11 (pTHX_ const char *name, IV *iv_return) {
     return PERL_constant_NOTFOUND;
   }
   
  +static int
  +constant_13 (pTHX_ const char *name, IV *iv_return) {
  +  /* When generated this function returned values for the list of names given
  +     here.  However, subsequent manual editing may have added or removed some.
  +     CLOCK_HIGHRES TIMER_ABSTIME d_hires_utime */
  +  /* Offset 1 gives the best switch position.  */
  +  switch (name[1]) {
  +  case 'I':
  +    if (memEQ(name, "TIMER_ABSTIME", 13)) {
  +    /*                ^                  */
  +#ifdef TIMER_ABSTIME
  +      *iv_return = TIMER_ABSTIME;
  +      return PERL_constant_ISIV;
  +#else
  +      return PERL_constant_NOTDEF;
  +#endif
  +    }
  +    break;
  +  case 'L':
  +    if (memEQ(name, "CLOCK_HIGHRES", 13)) {
  +    /*                ^                  */
  +#ifdef CLOCK_HIGHRES
  +      *iv_return = CLOCK_HIGHRES;
  +      return PERL_constant_ISIV;
  +#else
  +      return PERL_constant_NOTDEF;
  +#endif
  +    }
  +    break;
  +  case '_':
  +    if (memEQ(name, "d_hires_utime", 13)) {
  +    /*                ^                  */
  +#ifdef TIME_HIRES_UTIME
  +      *iv_return = 1;
  +      return PERL_constant_ISIV;
  +#else
  +      *iv_return = 0;
  +      return PERL_constant_ISIV;
  +#endif
  +    }
  +    break;
  +  }
  +  return PERL_constant_NOTFOUND;
  +}
  +
   static int
   constant_14 (pTHX_ const char *name, IV *iv_return) {
     /* When generated this function returned values for the list of names given
  @@ -250,16 +296,17 @@ my @names = (qw(CLOCKS_PER_SEC CLOCK_HIGHRES CLOCK_MONOTONIC
               {name=>"d_getitimer", type=>"IV", macro=>"HAS_GETITIMER", value=>"1", default=>["IV", "0"]},
               {name=>"d_gettimeofday", type=>"IV", macro=>"HAS_GETTIMEOFDAY", value=>"1", default=>["IV", "0"]},
               {name=>"d_hires_stat", type=>"IV", macro=>"TIME_HIRES_STAT", value=>"1", default=>["IV", "0"]},
  +            {name=>"d_hires_utime", type=>"IV", macro=>"TIME_HIRES_UTIME", value=>"1", default=>["IV", "0"]},
               {name=>"d_nanosleep", type=>"IV", macro=>"TIME_HIRES_NANOSLEEP", value=>"1", default=>["IV", "0"]},
               {name=>"d_setitimer", type=>"IV", macro=>"HAS_SETITIMER", value=>"1", default=>["IV", "0"]},
               {name=>"d_ualarm", type=>"IV", macro=>"HAS_UALARM", value=>"1", default=>["IV", "0"]},
               {name=>"d_usleep", type=>"IV", macro=>"HAS_USLEEP", value=>"1", default=>["IV", "0"]});
   
  -print constant_types(); # macro defs
  +print constant_types(), "\n"; # macro defs
   foreach (C_constant ("Time::HiRes", 'constant', 'IV', $types, undef, 3, @names) ) {
       print $_, "\n"; # C constant subs
   }
  -print "#### XS Section:\n";
  +print "\n#### XS Section:\n";
   print XS_constant ("Time::HiRes", $types);
   __END__
      */
  @@ -322,33 +369,7 @@ __END__
       }
       break;
     case 13:
  -    /* Names all of length 13.  */
  -    /* CLOCK_HIGHRES TIMER_ABSTIME */
  -    /* Offset 2 gives the best switch position.  */
  -    switch (name[2]) {
  -    case 'M':
  -      if (memEQ(name, "TIMER_ABSTIME", 13)) {
  -      /*                 ^                 */
  -#ifdef TIMER_ABSTIME
  -        *iv_return = TIMER_ABSTIME;
  -        return PERL_constant_ISIV;
  -#else
  -        return PERL_constant_NOTDEF;
  -#endif
  -      }
  -      break;
  -    case 'O':
  -      if (memEQ(name, "CLOCK_HIGHRES", 13)) {
  -      /*                 ^                 */
  -#ifdef CLOCK_HIGHRES
  -        *iv_return = CLOCK_HIGHRES;
  -        return PERL_constant_ISIV;
  -#else
  -        return PERL_constant_NOTDEF;
  -#endif
  -      }
  -      break;
  -    }
  +    return constant_13 (aTHX_ name, iv_return);
       break;
     case 14:
       return constant_14 (aTHX_ name, iv_return);
  diff --git a/dist/Time-HiRes/t/Watchdog.pm b/dist/Time-HiRes/t/Watchdog.pm
  index 83e854396f..44ec8081de 100644
  --- dist/Time-HiRes/t/Watchdog.pm
  +++ dist/Time-HiRes/t/Watchdog.pm
  @@ -10,44 +10,44 @@ my $watchdog_pid;
   my $TheEnd;
   
   if ($Config{d_fork}) {
  -    note "I am the main process $$, starting the watchdog process...";
  +    print("# I am the main process $$, starting the watchdog process...\n");
       $watchdog_pid = fork();
       if (defined $watchdog_pid) {
   	if ($watchdog_pid == 0) { # We are the kid, set up the watchdog.
   	    my $ppid = getppid();
  -	    note "I am the watchdog process $$, sleeping for $waitfor seconds...";
  +	    print("# I am the watchdog process $$, sleeping for $waitfor seconds...\n");
   	    sleep($waitfor - 2);    # Workaround for perlbug #49073
   	    sleep(2);               # Wait for parent to exit
   	    if (kill(0, $ppid)) {   # Check if parent still exists
   		warn "\n$0: overall time allowed for tests (${waitfor}s) exceeded!\n";
  -		note "Terminating main process $ppid...";
  +		print("Terminating main process $ppid...\n");
   		kill('KILL', $ppid);
  -		note "This is the watchdog process $$, over and out.";
  +		print("# This is the watchdog process $$, over and out.\n");
   	    }
   	    exit(0);
   	} else {
  -	    note "The watchdog process $watchdog_pid launched, continuing testing...";
  +	    print("# The watchdog process $watchdog_pid launched, continuing testing...\n");
   	    $TheEnd = time() + $waitfor;
   	}
       } else {
   	warn "$0: fork failed: $!\n";
       }
   } else {
  -    note "No watchdog process (need fork)";
  +    print("# No watchdog process (need fork)\n");
   }
   
   END {
       if ($watchdog_pid) { # Only in the main process.
   	my $left = $TheEnd - time();
  -	note sprintf "I am the main process $$, terminating the watchdog process $watchdog_pid before it terminates me in %d seconds (testing took %d seconds).", $left, $waitfor - $left;
  +	printf("# I am the main process $$, terminating the watchdog process $watchdog_pid before it terminates me in %d seconds (testing took %d seconds).\n", $left, $waitfor - $left);
   	if (kill(0, $watchdog_pid)) {
   	    local $? = 0;
   	    my $kill = kill('KILL', $watchdog_pid); # We are done, the watchdog can go.
   	    wait();
  -	    note sprintf "kill KILL $watchdog_pid = %d", $kill;
  +	    printf("# kill KILL $watchdog_pid = %d\n", $kill);
   	}
   	unlink("ktrace.out"); # Used in BSD system call tracing.
  -	note "All done.";
  +	print("# All done.\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/t/alarm.t b/dist/Time-HiRes/t/alarm.t
  index 841694f67c..4935410d36 100644
  --- dist/Time-HiRes/t/alarm.t
  +++ dist/Time-HiRes/t/alarm.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 10;
  +use Test::More tests => 10;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -10,7 +10,7 @@ use Config;
   my $limit = 0.25; # 25% is acceptable slosh for testing timers
   
   my $xdefine = ''; 
  -if (open(XDEFINE, "xdefine")) {
  +if (open(XDEFINE, "<", "xdefine")) {
       chomp($xdefine = <XDEFINE> || "");
       close(XDEFINE);
   }
  @@ -29,12 +29,14 @@ SKIP: {
   
       my ($r, $i, $not, $ok);
   
  +    $not = "";
  +
       $r = [Time::HiRes::gettimeofday()];
       $i = 5;
       my $oldaction;
       if ($use_sigaction) {
   	$oldaction = new POSIX::SigAction;
  -	note sprintf "sigaction tick, ALRM = %d", &POSIX::SIGALRM;
  +	printf("# sigaction tick, ALRM = %d\n", &POSIX::SIGALRM);
   
   	# Perl's deferred signals may be too wimpy to break through
   	# a restartable select(), so use POSIX::sigaction if available.
  @@ -44,7 +46,7 @@ SKIP: {
   			 $oldaction)
   	    or die "Error setting SIGALRM handler with sigaction: $!\n";
       } else {
  -	note "SIG tick";
  +	print("# SIG tick\n");
   	$SIG{ALRM} = "tick";
       }
   
  @@ -56,8 +58,8 @@ SKIP: {
   	    Time::HiRes::alarm(0.3);
   	    select (undef, undef, undef, 3);
   	    my $ival = Time::HiRes::tv_interval ($r);
  -	    note "Select returned! $i $ival";
  -	    note abs($ival/3 - 1);
  +	    print("# Select returned! $i $ival\n");
  +	    printf("# %s\n", abs($ival/3 - 1));
   	    # Whether select() gets restarted after signals is
   	    # implementation dependent.  If it is restarted, we
   	    # will get about 3.3 seconds: 3 from the select, 0.3
  @@ -86,7 +88,7 @@ SKIP: {
       sub tick {
   	$i--;
   	my $ival = Time::HiRes::tv_interval ($r);
  -	note "Tick! $i $ival";
  +	print("# Tick! $i $ival\n");
   	my $exp = 0.3 * (5 - $i);
   	if ($exp == 0) {
   	    $not = "tick: divisor became zero";
  @@ -106,8 +108,8 @@ SKIP: {
   	Time::HiRes::alarm(0); # can't cancel usig %SIG
       }
   
  +    print("# $not\n");
       ok !$not;
  -    note $not || $ok;
   }
   
   SKIP: {
  @@ -126,7 +128,7 @@ SKIP: {
       # http://groups.google.com/group/perl.perl5.porters/browse_thread/thread/adaffaaf939b042e/20dafc298df737f0%2320dafc298df737f0?sa=X&oi=groupsr&start=0&num=3
       # Perl changes [18765] and [18770], perl bug [perl #20920]
   
  -    note "Finding delay loop...";
  +    print("# Finding delay loop...\n");
   
       my $T = 0.01;
       my $DelayN = 1024;
  @@ -137,7 +139,7 @@ SKIP: {
   	 for ($i = 0; $i < $DelayN; $i++) { }
   	 my $t1 = Time::HiRes::time();
   	 my $dt = $t1 - $t0;
  -	 note "N = $DelayN, t1 = $t1, t0 = $t0, dt = $dt";
  +	 print("# N = $DelayN, t1 = $t1, t0 = $t0, dt = $dt\n");
   	 last N if $dt > $T;
   	 $DelayN *= 2;
        } while (1);
  @@ -169,7 +171,7 @@ SKIP: {
   
       $SIG{ALRM} = sub {
   	$a++;
  -	note "Alarm $a - ", Time::HiRes::time();
  +	printf("# Alarm $a - %s\n", Time::HiRes::time());
   	Time::HiRes::alarm(0) if $a >= $A; # Disarm the alarm.
   	$Delay->(2); # Try burning CPU at least for 2T seconds.
       }; 
  @@ -204,18 +206,18 @@ SKIP: {
   	my $alrm = 0;
   	$SIG{ALRM} = sub { $alrm++ };
   	my $got = Time::HiRes::alarm(2.7);
  -	ok $got == 0 or note $got;
  +	ok $got == 0 or print("# $got\n");
   
   	my $t0 = Time::HiRes::time();
   	1 while Time::HiRes::time() - $t0 <= 1;
   
   	$got = Time::HiRes::alarm(0);
  -	ok $got > 0 && $got < 1.8 or note $got;
  +	ok $got > 0 && $got < 1.8 or print("# $got\n");
   
  -	ok $alrm == 0 or note $alrm;
  +	ok $alrm == 0 or print("# $alrm\n");
   
   	$got = Time::HiRes::alarm(0);
  -	ok $got == 0 or note $got;
  +	ok $got == 0 or print("# $got\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/t/clock.t b/dist/Time-HiRes/t/clock.t
  index 6d11dd2ca0..346ca57fbf 100644
  --- dist/Time-HiRes/t/clock.t
  +++ dist/Time-HiRes/t/clock.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 5;
  +use Test::More tests => 5;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -13,10 +13,10 @@ sub has_symbol {
       return $@ eq '';
   }
   
  -note sprintf "have_clock_gettime   = %d", &Time::HiRes::d_clock_gettime;
  -note sprintf "have_clock_getres    = %d", &Time::HiRes::d_clock_getres;
  -note sprintf "have_clock_nanosleep = %d", &Time::HiRes::d_clock_nanosleep;
  -note sprintf "have_clock           = %d", &Time::HiRes::d_clock;
  +printf("# have_clock_gettime   = %d\n", &Time::HiRes::d_clock_gettime);
  +printf("# have_clock_getres    = %d\n", &Time::HiRes::d_clock_getres);
  +printf("# have_clock_nanosleep = %d\n", &Time::HiRes::d_clock_nanosleep);
  +printf("# have_clock           = %d\n", &Time::HiRes::d_clock);
   
   # Ideally, we'd like to test that the timers are rather precise.
   # However, if the system is busy, there are no guarantees on how
  @@ -36,25 +36,25 @@ SKIP: {
       my $ok = 0;
    TRY: {
   	for my $try (1..3) {
  -	    note "CLOCK_REALTIME: try = $try";
  +	    print("# CLOCK_REALTIME: try = $try\n");
   	    my $t0 = Time::HiRes::clock_gettime(&CLOCK_REALTIME);
   	    my $T = 1.5;
   	    Time::HiRes::sleep($T);
   	    my $t1 = Time::HiRes::clock_gettime(&CLOCK_REALTIME);
   	    if ($t0 > 0 && $t1 > $t0) {
  -		note "t1 = $t1, t0 = $t0";
  +		print("# t1 = $t1, t0 = $t0\n");
   		my $dt = $t1 - $t0;
   		my $rt = abs(1 - $dt / $T);
  -		note "dt = $dt, rt = $rt";
  +		print("# dt = $dt, rt = $rt\n");
   		if ($rt <= 2 * $limit) {
   		    $ok = 1;
   		    last TRY;
   		}
   	    } else {
  -		note "Error: t0 = $t0, t1 = $t1";
  +		print("# Error: t0 = $t0, t1 = $t1\n");
   	    }
   	    my $r = rand() + rand();
  -	    note sprintf "Sleeping for %.6f seconds...\n", $r;
  +	    printf("# Sleeping for %.6f seconds...\n", $r);
   	    Time::HiRes::sleep($r);
   	}
       }
  @@ -64,7 +64,7 @@ SKIP: {
   SKIP: {
       skip "no clock_getres", 1 unless &Time::HiRes::d_clock_getres;
       my $tr = Time::HiRes::clock_getres();
  -    ok $tr > 0 or note "tr = $tr";
  +    ok $tr > 0 or print("# tr = $tr\n");
   }
   
   SKIP: {
  @@ -73,17 +73,17 @@ SKIP: {
       my $s = 1.5e9;
       my $t = Time::HiRes::clock_nanosleep(&CLOCK_REALTIME, $s);
       my $r = abs(1 - $t / $s);
  -    ok $r < 2 * $limit or note "t = $t, r = $r";
  +    ok $r < 2 * $limit or print("# t = $t, r = $r\n");
   }
   
   SKIP: {
       skip "no clock", 1 unless &Time::HiRes::d_clock;
       my @clock = Time::HiRes::clock();
  -    note "clock = @clock";
  +    print("# clock = @clock\n");
       for my $i (1..3) {
   	for (my $j = 0; $j < 1e6; $j++) { }
   	push @clock, Time::HiRes::clock();
  -	note "clock = @clock";
  +	print("# clock = @clock\n");
       }
       ok $clock[0] >= 0 &&
   	$clock[1] > $clock[0] &&
  diff --git a/dist/Time-HiRes/t/gettimeofday.t b/dist/Time-HiRes/t/gettimeofday.t
  index 8f7c5f3039..69defe8672 100644
  --- dist/Time-HiRes/t/gettimeofday.t
  +++ dist/Time-HiRes/t/gettimeofday.t
  @@ -8,26 +8,26 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 6;
  +use Test::More tests => 6;
   use t::Watchdog;
   
   my @one = Time::HiRes::gettimeofday();
  -note 'gettimeofday returned ', 0+@one, ' args';
  +printf("# gettimeofday returned %d args\n", 0+@one);
   ok @one == 2;
  -ok $one[0] > 850_000_000 or note "@one too small";
  +ok $one[0] > 850_000_000 or print("# @one too small\n");
   
   sleep 1;
   
   my @two = Time::HiRes::gettimeofday();
   ok $two[0] > $one[0] || ($two[0] == $one[0] && $two[1] > $one[1])
  -	or note "@two is not greater than @one";
  +	or print("# @two is not greater than @one\n");
   
   my $f = Time::HiRes::time();
  -ok $f > 850_000_000 or note "$f too small";
  -ok $f - $two[0] < 2 or note "$f - $two[0] >= 2";
  +ok $f > 850_000_000 or print("# $f too small\n");
  +ok $f - $two[0] < 2 or print("# $f - $two[0] >= 2\n");
   
   my $r = [Time::HiRes::gettimeofday()];
   my $g = Time::HiRes::tv_interval $r;
  -ok $g < 2 or note $g;
  +ok $g < 2 or print("# $g\n");
   
   1;
  diff --git a/dist/Time-HiRes/t/itimer.t b/dist/Time-HiRes/t/itimer.t
  index 9eb2b93f6f..31cdd674ae 100644
  --- dist/Time-HiRes/t/itimer.t
  +++ dist/Time-HiRes/t/itimer.t
  @@ -25,7 +25,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   use t::Watchdog;
   
   my $limit = 0.25; # 25% is acceptable slosh for testing timers
  @@ -35,11 +35,11 @@ my $r = [Time::HiRes::gettimeofday()];
   
   $SIG{VTALRM} = sub {
       $i ? $i-- : Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0);
  -    note "Tick! $i ", Time::HiRes::tv_interval($r);
  +    printf("# Tick! $i %s\n", Time::HiRes::tv_interval($r));
   };	
   
  -note "setitimer: ", join(" ",
  -    Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0.5, 0.4));
  +printf("# setitimer: %s\n", join(" ",
  +       Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0.5, 0.4)));
   
   # Assume interval timer granularity of $limit * 0.5 seconds.  Too bold?
   my $virt = Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL);
  @@ -47,19 +47,19 @@ ok(defined $virt && abs($virt / 0.5) - 1 < $limit,
      "ITIMER_VIRTUAL defined with sufficient granularity")
      or diag "virt=" . (defined $virt ? $virt : 'undef');
   
  -note "getitimer: ", join(" ",
  -    Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL));
  +printf("# getitimer: %s\n", join(" ",
  +       Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)));
   
   while (Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)) {
       my $j;
       for (1..1000) { $j++ } # Can't be unbreakable, must test getitimer().
   }
   
  -note "getitimer: ", join(" ",
  -    Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL));
  +printf("# getitimer: %s\n", join(" ",
  +       Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)));
   
   $virt = Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL);
  -note "at end, i=$i";
  +print("# at end, i=$i\n");
   is($virt, 0, "time left should be zero");
   
   $SIG{VTALRM} = 'DEFAULT';
  diff --git a/dist/Time-HiRes/t/nanosleep.t b/dist/Time-HiRes/t/nanosleep.t
  index aef9db6163..c17a7e4790 100644
  --- dist/Time-HiRes/t/nanosleep.t
  +++ dist/Time-HiRes/t/nanosleep.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 3;
  +use Test::More tests => 3;
   use t::Watchdog;
   
   eval { Time::HiRes::nanosleep(-5) };
  @@ -21,7 +21,7 @@ my $two = CORE::time;
   Time::HiRes::nanosleep(10_000_000);
   my $three = CORE::time;
   ok $one == $two || $two == $three
  -    or note "slept too long, $one $two $three";
  +    or print("# slept too long, $one $two $three\n");
   
   SKIP: {
       skip "no gettimeofday", 1 unless &Time::HiRes::d_gettimeofday;
  @@ -29,7 +29,7 @@ SKIP: {
       Time::HiRes::nanosleep(500_000_000);
       my $f2 = Time::HiRes::time();
       my $d = $f2 - $f;
  -    ok $d > 0.4 && $d < 0.9 or note "slept $d secs $f to $f2";
  +    ok $d > 0.4 && $d < 0.9 or print("# slept $d secs $f to $f2\n");
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/sleep.t b/dist/Time-HiRes/t/sleep.t
  index e7cc6271a8..b84b4c6725 100644
  --- dist/Time-HiRes/t/sleep.t
  +++ dist/Time-HiRes/t/sleep.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 4;
  +use Test::More tests => 4;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -8,7 +8,7 @@ BEGIN { require_ok "Time::HiRes"; }
   use Config;
   
   my $xdefine = ''; 
  -if (open(XDEFINE, "xdefine")) {
  +if (open(XDEFINE, "<", "xdefine")) {
       chomp($xdefine = <XDEFINE> || "");
       close(XDEFINE);
   }
  @@ -26,12 +26,12 @@ like $@, qr/::sleep\(-1\): negative time not invented yet/,
   SKIP: {
       skip "no subsecond alarm", 2 unless $can_subsecond_alarm;
       my $f = Time::HiRes::time; 
  -    note "time...$f";
  +    print("# time...$f\n");
       ok 1;
   
       my $r = [Time::HiRes::gettimeofday()];
       Time::HiRes::sleep (0.5);
  -    note "sleep...", Time::HiRes::tv_interval($r);
  +    printf("# sleep...%s\n", Time::HiRes::tv_interval($r));
       ok 1;
   }
   
  diff --git a/dist/Time-HiRes/t/stat.t b/dist/Time-HiRes/t/stat.t
  index 68a6fb6bbd..a59a342e20 100644
  --- dist/Time-HiRes/t/stat.t
  +++ dist/Time-HiRes/t/stat.t
  @@ -13,14 +13,14 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 43;
  +use Test::More tests => 43;
   use t::Watchdog;
   
   my @atime;
   my @mtime;
   for (1..5) {
       Time::HiRes::sleep(rand(0.1) + 0.1);
  -    open(X, ">$$");
  +    open(X, '>', $$);
       print X $$;
       close(X);
       my($a, $stat, $b) = ("a", [Time::HiRes::stat($$)], "b");
  @@ -33,7 +33,7 @@ for (1..5) {
       is $b, "b";
       is_deeply $lstat, $stat;
       Time::HiRes::sleep(rand(0.1) + 0.1);
  -    open(X, "<$$");
  +    open(X, '<', $$);
       <X>;
       close(X);
       $stat = [Time::HiRes::stat($$)];
  @@ -42,8 +42,8 @@ for (1..5) {
       is_deeply $lstat, $stat;
   }
   1 while unlink $$;
  -note "mtime = @mtime";
  -note "atime = @atime";
  +print("# mtime = @mtime\n");
  +print("# atime = @atime\n");
   my $ai = 0;
   my $mi = 0;
   my $ss = 0;
  @@ -63,7 +63,7 @@ for (my $i = 1; $i < @mtime; $i++) {
   	$ss++;
       }
   }
  -note "ai = $ai, mi = $mi, ss = $ss";
  +print("# ai = $ai, mi = $mi, ss = $ss\n");
   # Need at least 75% of monotonical increase and
   # 20% of subsecond results. Yes, this is guessing.
   SKIP: {
  @@ -75,7 +75,7 @@ SKIP: {
   my $targetname = "tgt$$";
   my $linkname = "link$$";
   SKIP: {
  -    open(X, ">$targetname");
  +    open(X, '>', $targetname);
       print X $$;
       close(X);
       eval { symlink $targetname, $linkname or die "can't symlink: $!"; };
  diff --git a/dist/Time-HiRes/t/time.t b/dist/Time-HiRes/t/time.t
  index feec4799d9..6f219f9e0c 100644
  --- dist/Time-HiRes/t/time.t
  +++ dist/Time-HiRes/t/time.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -16,8 +16,8 @@ SKIP: {
       # (CORE::time() may be rounding down, up, or closest),
       # but allow 10% of slop.
       ok abs($s) / $n <= 1.10
  -	or note "Time::HiRes::time() not close to CORE::time()";
  -    note "s = $s, n = $n, s/n = ", abs($s)/$n;
  +	or print("# Time::HiRes::time() not close to CORE::time()\n");
  +    printf("# s = $s, n = $n, s/n = %s\n", abs($s)/$n);
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/tv_interval.t b/dist/Time-HiRes/t/tv_interval.t
  index bffcf39ec1..8ac876daf3 100644
  --- dist/Time-HiRes/t/tv_interval.t
  +++ dist/Time-HiRes/t/tv_interval.t
  @@ -1,10 +1,10 @@
   use strict;
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   
   BEGIN { require_ok "Time::HiRes"; }
   
   my $f = Time::HiRes::tv_interval [5, 100_000], [10, 500_000];
  -ok abs($f - 5.4) < 0.001 or note $f;
  +ok abs($f - 5.4) < 0.001 or print("# $f\n");
   
   1;
  diff --git a/dist/Time-HiRes/t/ualarm.t b/dist/Time-HiRes/t/ualarm.t
  index 12ef4b52cc..b50a175f44 100644
  --- dist/Time-HiRes/t/ualarm.t
  +++ dist/Time-HiRes/t/ualarm.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 12;
  +use Test::More tests => 12;
   use t::Watchdog;
   
   use Config;
  @@ -24,13 +24,13 @@ SKIP: {
       $tick = 0; Time::HiRes::ualarm(10_000); while ($tick == 0) { }
       my $three = CORE::time;
       ok $one == $two || $two == $three
  -	or note "slept too long, $one $two $three";
  -    note "tick = $tick, one = $one, two = $two, three = $three";
  +	or print("# slept too long, $one $two $three\n");
  +    print("# tick = $tick, one = $one, two = $two, three = $three\n");
   
       $tick = 0; Time::HiRes::ualarm(10_000, 10_000); while ($tick < 3) { }
       ok 1;
       Time::HiRes::ualarm(0);
  -    note "tick = $tick, one = $one, two = $two, three = $three";
  +    print("# tick = $tick, one = $one, two = $two, three = $three\n");
   }
   
   eval { Time::HiRes::ualarm(-4) };
  @@ -59,24 +59,24 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
   	my $alarmed = 0;
   	local $SIG{ ALRM } = sub { $alarmed++ };
   	my $t0 = Time::HiRes::time();
  -	note "t0 = $t0";
  -	note "ualarm($n)";
  +	print("# t0 = $t0\n");
  +	print("# ualarm($n)\n");
   	Time::HiRes::ualarm($n); 1 while $alarmed == 0;
   	my $t1 = Time::HiRes::time();
  -	note "t1 = $t1";
  +	print("# t1 = $t1\n");
   	my $dt = $t1 - $t0;
  -	note "dt = $dt";
  +	print("# dt = $dt\n");
   	my $r = $dt / ($n/1e6);
  -	note "r = $r";
  +	print("# r = $r\n");
   	$ok =
   	    ($n < 1_000_000 || # Too much noise.
   	     ($r >= 0.8 && $r <= 1.6));
   	last if $ok;
   	my $nap = bellish(3, 15);
  -	note sprintf "Retrying in %.1f seconds...\n", $nap;
  +	printf("# Retrying in %.1f seconds...\n", $nap);
   	Time::HiRes::sleep($nap);
       }
  -    ok $ok or note "ualarm($n) close enough";
  +    ok $ok or print("# ualarm($n) close enough\n");
   }
   
   {
  @@ -93,12 +93,12 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
       } while $t1 - $t0 <= 0.3;
       my $got1 = Time::HiRes::ualarm(0);
   
  -    note "t0 = $t0";
  -    note "got0 = $got0";
  -    note "t1 = $t1";
  -    note "t1 - t0 = ", ($t1 - $t0);
  -    note "got1 = $got1";
  -    ok $got0 == 0 or note $got0;
  +    print("# t0 = $t0\n");
  +    print("# got0 = $got0\n");
  +    print("# t1 = $t1\n");
  +    printf("# t1 - t0 = %s\n", ($t1 - $t0));
  +    print("# got1 = $got1\n");
  +    ok $got0 == 0 or print("# $got0\n");
       SKIP: {
   	skip "alarm interval exceeded", 2 if $t1 - $t0 >= 0.5;
   	ok $got1 > 0;
  @@ -106,7 +106,7 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
       }
       ok $got1 < 300_000;
       my $got2 = Time::HiRes::ualarm(0);
  -    ok $got2 == 0 or note $got2;
  +    ok $got2 == 0 or print("# $got2\n");
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/usleep.t b/dist/Time-HiRes/t/usleep.t
  index 0d6bacfac3..bdf372bd16 100644
  --- dist/Time-HiRes/t/usleep.t
  +++ dist/Time-HiRes/t/usleep.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 6;
  +use Test::More tests => 6;
   use t::Watchdog;
   
   eval { Time::HiRes::usleep(-2) };
  @@ -23,7 +23,7 @@ my $two = CORE::time;
   Time::HiRes::usleep(10_000);
   my $three = CORE::time;
   ok $one == $two || $two == $three
  -or note "slept too long, $one $two $three";
  +or print("# slept too long, $one $two $three\n");
   
   SKIP: {
       skip "no gettimeofday", 1 unless &Time::HiRes::d_gettimeofday;
  @@ -31,7 +31,7 @@ SKIP: {
       Time::HiRes::usleep(500_000);
       my $f2 = Time::HiRes::time();
       my $d = $f2 - $f;
  -    ok $d > 0.4 && $d < 0.9 or note "slept $d secs $f to $f2";
  +    ok $d > 0.4 && $d < 0.9 or print("# slept $d secs $f to $f2\n");
   }
   
   SKIP: {
  @@ -39,7 +39,7 @@ SKIP: {
       my $r = [ Time::HiRes::gettimeofday() ];
       Time::HiRes::sleep( 0.5 );
       my $f = Time::HiRes::tv_interval $r;
  -    ok $f > 0.4 && $f < 0.9 or note "slept $f instead of 0.5 secs.";
  +    ok $f > 0.4 && $f < 0.9 or print("# slept $f instead of 0.5 secs.\n");
   }
   
   SKIP: {
  @@ -59,7 +59,7 @@ SKIP: {
   
       SKIP: {
   	skip $msg, 1 unless $td < $sleep * (1 + $limit);
  -	ok $a < $limit or note $msg;
  +	ok $a < $limit or print("# $msg\n");
       }
   
       $t0 = Time::HiRes::gettimeofday();
  @@ -71,7 +71,7 @@ SKIP: {
   
       SKIP: {
   	skip $msg, 1 unless $td < $sleep * (1 + $limit);
  -	ok $a < $limit or note $msg;
  +	ok $a < $limit or print("# $msg\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/typemap b/dist/Time-HiRes/typemap
  index 1124eb6483..3fa91f3a0b 100644
  --- dist/Time-HiRes/typemap
  +++ dist/Time-HiRes/typemap
  @@ -28,6 +28,8 @@ AV *			T_AVREF
   HV *			T_HVREF
   CV *			T_CVREF
   
  +clockid_t               T_IV
  +
   IV			T_IV
   UV			T_UV
   NV                      T_NV
  END
  --- perl.h.orig
  +++ perl.h
  @@ -1585,6 +1585,26 @@ EXTERN_C char *crypt(const char *, const char *);
   #endif
   #endif
   
  +/* We have somehow managed not to define the denormal/subnormal
  + * detection.
  + *
  + * This may happen if the compiler doesn't expose the C99 math like
  + * the fpclassify() without some special switches.  Perl tries to
  + * stay C89, so for example -std=c99 is not an option.
  + *
  + * The Perl_isinf() and Perl_isnan() should have been defined even if
  + * the C99 isinf() and isnan() are unavailable, and the NV_MIN becomes
  + * from the C89 DBL_MIN or moral equivalent. */
  +#if !defined(Perl_fp_class_denorm) && defined(Perl_isinf) && defined(Perl_isnan) && defined(NV_MIN)
  +#  define Perl_fp_class_denorm(x) ((x) != 0.0 && !Perl_isinf(x) && !Perl_isnan(x) && PERL_ABS(x) < NV_MIN)
  +#endif
  +
  +/* This is not a great fallback: subnormals tests will fail,
  + * but at least Perl will link and 99.999% of tests will work. */
  +#if !defined(Perl_fp_class_denorm)
  +#  define Perl_fp_class_denorm(x) FALSE
  +#endif
  +
   /* There is no quadmath_vsnprintf, and therefore my_vsnprintf()
    * dies if called under USE_QUADMATH. */
   #if defined(HAS_VSNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
  END
  --- perl.h.orig
  +++ perl.h
  @@ -6867,6 +6867,26 @@ extern void moncontrol(int);
   #  endif
   #endif
   
  +/* We have somehow managed not to define the denormal/subnormal
  + * detection.
  + *
  + * This may happen if the compiler doesn't expose the C99 math like
  + * the fpclassify() without some special switches.  Perl tries to
  + * stay C89, so for example -std=c99 is not an option.
  + *
  + * The Perl_isinf() and Perl_isnan() should have been defined even if
  + * the C99 isinf() and isnan() are unavailable, and the NV_MIN becomes
  + * from the C89 DBL_MIN or moral equivalent. */
  +#if !defined(Perl_fp_class_denorm) && defined(Perl_isinf) && defined(Perl_isnan) && defined(NV_MIN)
  +#  define Perl_fp_class_denorm(x) ((x) != 0.0 && !Perl_isinf(x) && !Perl_isnan(x) && PERL_ABS(x) < NV_MIN)
  +#endif
  +
  +/* This is not a great fallback: subnormals tests will fail,
  + * but at least Perl will link and 99.999% of tests will work. */
  +#if !defined(Perl_fp_class_denorm)
  +#  define Perl_fp_class_denorm(x) FALSE
  +#endif
  +
   #ifdef DOUBLE_IS_IEEE_FORMAT
   #  define DOUBLE_HAS_INF
   #  define DOUBLE_HAS_NAN
  END
  diff --git a/Configure b/Configure
  index e12c8bb..1a8088f 100755
  --- Configure
  +++ Configure
  @@ -25151,6 +25151,8 @@ zcat='\$zcat'
   zip='\$zip'
   EOT
   
  +echo "BuiltWithPatchPerl='$dpv'" >>config.sh
  +
   : add special variables
   \$test -f \$src/patchlevel.h && \
   awk '/^#define[ 	]+PERL_/ {printf "\%s=\%s\\n",\$2,\$3}' \$src/patchlevel.h >>config.sh
  END
  diff --git a/Configure b/Configure
  index 15b3da1769..791889a2ab 100755
  --- Configure
  +++ Configure
  @@ -4643,6 +4643,22 @@ case "$gccversion" in
       $rm -f try try.*
   esac
   
  +# gcc 4.9 by default does some optimizations that break perl.
  +# see ticket 121505.
  +#
  +# The -fwrapv disables those optimizations (and probably others,) so
  +# for gcc 4.9 (and later, since the optimizations probably won't go
  +# away), add -fwrapv unless the user requests -fno-wrapv, which
  +# disables -fwrapv, or if the user requests -fsanitize=undefined,
  +# which turns the overflows -fwrapv ignores into runtime errors.
  +case "$gccversion" in
  +4.[3-9].*|4.[1-9][0-9]*|[5-9].*|[1-9][0-9]*)
  +    case "$ccflags" in
  +    *-fno-wrapv*|*-fsanitize=undefined*|*-fwrapv*) ;;
  +    *) ccflags="$ccflags -fwrapv" ;;
  +    esac
  +esac
  +
   : What should the include directory be ?
   : Use sysroot if set, so findhdr looks in the right place.
   echo " "
  FWRAPV
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTM2LDEzICszNiwyMSBAQCAk
  Q29uZmlne3N0YXJ0cGVybH0KIAogcHJpbnQgT1VUIDw8JyFOTyFTVUJTISc7CiAKK3VzZSBzdHJp
  Y3Q7CisKIHVzZSBDb25maWc7CiB1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGgpOwogdXNlIEdldG9w
  dDo6U3RkOwogCi1nZXRvcHRzKCdEZDpybGhhUScpOworIyBNYWtlIHN1cmUgcmVhZCBwZXJtaXNz
  aW9ucyBmb3IgYWxsIGFyZSBzZXQ6CitpZiAoZGVmaW5lZCB1bWFzayAmJiAodW1hc2soKSAmIDA0
  NDQpKSB7CisgICAgdW1hc2sgKHVtYXNrKCkgJiB+MDQ0NCk7Cit9CisKK2dldG9wdHMoJ0RkOnJs
  aGFRZScpOwordXNlIHZhcnMgcXcoJG9wdF9EICRvcHRfZCAkb3B0X3IgJG9wdF9sICRvcHRfaCAk
  b3B0X2EgJG9wdF9RICRvcHRfZSk7CiBkaWUgIi1yIGFuZCAtYSBvcHRpb25zIGFyZSBtdXR1YWxs
  eSBleGNsdXNpdmVcbiIgaWYgKCRvcHRfciBhbmQgJG9wdF9hKTsKLUBpbmNfZGlycyA9IGluY19k
  aXJzKCkgaWYgJG9wdF9hOworbXkgQGluY19kaXJzID0gaW5jX2RpcnMoKSBpZiAkb3B0X2E7CiAK
  IG15ICRFeGl0ID0gMDsKIApAQCAtNTAsNyArNTgsNyBAQCBteSAkRGVzdF9kaXIgPSAkb3B0X2Qg
  fHwgJENvbmZpZ3tpbnN0YWxsc2l0ZWFyY2h9OwogZGllICJEZXN0aW5hdGlvbiBkaXJlY3Rvcnkg
  JERlc3RfZGlyIGRvZXNuJ3QgZXhpc3Qgb3IgaXNuJ3QgYSBkaXJlY3RvcnlcbiIKICAgICB1bmxl
  c3MgLWQgJERlc3RfZGlyOwogCi1AaXNhdHlwZSA9IHNwbGl0KCcgJyw8PEVORCk7CitteSBAaXNh
  dHlwZSA9IHNwbGl0KCcgJyw8PEVORCk7CiAJY2hhcgl1Y2hhcgl1X2NoYXIKIAlzaG9ydAl1c2hv
  cnQJdV9zaG9ydAogCWludAl1aW50CXVfaW50CkBAIC01OCwxNCArNjYsMjYgQEAgZGllICJEZXN0
  aW5hdGlvbiBkaXJlY3RvcnkgJERlc3RfZGlyIGRvZXNuJ3QgZXhpc3Qgb3IgaXNuJ3QgYSBkaXJl
  Y3RvcnlcbiIKIAlGSUxFCWtleV90CWNhZGRyX3QKIEVORAogCitteSAlaXNhdHlwZTsKIEBpc2F0
  eXBle0Bpc2F0eXBlfSA9ICgxKSB4IEBpc2F0eXBlOwotJGluaWYgPSAwOworbXkgJGluaWYgPSAw
  OworbXkgJUlzX2NvbnZlcnRlZDsKK215ICViYWRfZmlsZSA9ICgpOwogCiBAQVJHViA9ICgnLScp
  IHVubGVzcyBAQVJHVjsKIAogYnVpbGRfcHJlYW1ibGVfaWZfbmVjZXNzYXJ5KCk7CiAKLXdoaWxl
  IChkZWZpbmVkICgkZmlsZSA9IG5leHRfZmlsZSgpKSkgeworc3ViIHJlaW5kZW50KCQpIHsKKyAg
  ICBteSgkdGV4dCkgPSBzaGlmdDsKKyAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOworICAgICR0
  ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKKyAgICAkdGV4dDsKK30KKworbXkgKCR0LCAkdGFiLCAl
  Y3VyYXJncywgJG5ldywgJGV2YWxfaW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91dGZpbGUp
  OworbXkgKCRpbmNsLCAkaW5jbF90eXBlLCAkaW5jbF9xdW90ZSwgJG5leHQpOword2hpbGUgKGRl
  ZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAgICAgaWYgKC1sICRmaWxlIGFuZCAt
  ZCAkZmlsZSkgewogICAgICAgICBsaW5rX2lmX3Bvc3NpYmxlKCRmaWxlKSBpZiAoJG9wdF9sKTsK
  ICAgICAgICAgbmV4dDsKQEAgLTEwMCwzNiArMTIwLDIzIEBAIHdoaWxlIChkZWZpbmVkICgkZmls
  ZSA9IG5leHRfZmlsZSgpKSkgewogCW9wZW4oT1VULCI+JERlc3RfZGlyLyRvdXRmaWxlIikgfHwg
  ZGllICJDYW4ndCBjcmVhdGUgJG91dGZpbGU6ICQhXG4iOwogICAgIH0KIAotICAgIHByaW50IE9V
  VCAicmVxdWlyZSAnX2gycGhfcHJlLnBoJztcblxuIjsKLSAgICB3aGlsZSAoPElOPikgewotCWNo
  b3A7Ci0Jd2hpbGUgKC9cXCQvKSB7Ci0JICAgIGNob3A7Ci0JICAgICRfIC49IDxJTj47Ci0JICAg
  IGNob3A7Ci0JfQotCXByaW50IE9VVCAiIyAkX1xuIiBpZiAkb3B0X0Q7Ci0KLQlpZiAoczovXCo6
  XDIwMDpnKSB7Ci0JICAgIHM6XCovOlwyMDE6ZzsKLQkgICAgcy9cMjAwW15cMjAxXSpcMjAxLy9n
  OwkjIGRlbGV0ZSBzaW5nbGUgbGluZSBjb21tZW50cwotCSAgICBpZiAocy9cMjAwLiovLykgewkJ
  IyBiZWdpbiBtdWx0aS1saW5lIGNvbW1lbnQ/Ci0JCSRfIC49ICcvKic7Ci0JCSRfIC49IDxJTj47
  Ci0JCXJlZG87Ci0JICAgIH0KLQl9CisgICAgcHJpbnQgT1VUCisgICAgICAgICJyZXF1aXJlICdf
  aDJwaF9wcmUucGgnO1xuXG4iLAorICAgICAgICAibm8gd2FybmluZ3MgJ3JlZGVmaW5lJztcblxu
  IjsKKworICAgIHdoaWxlIChkZWZpbmVkIChsb2NhbCAkXyA9IG5leHRfbGluZSgkZmlsZSkpKSB7
  CiAJaWYgKHMvXlxzKlwjXHMqLy8pIHsKIAkgICAgaWYgKHMvXmRlZmluZVxzKyhcdyspLy8pIHsK
  IAkJJG5hbWUgPSAkMTsKIAkJJG5ldyA9ICcnOwogCQlzL1xzKyQvLzsKKwkJcy9cKFx3K1xzKlwo
  XCpcKVxzKlwoXHcqXClcKVxzKigtP1xkKykvJDEvOyAjIChpbnQgKCopKGZvb190KSkwCiAJCWlm
  IChzL15cKChbXHcsXHNdKilcKS8vKSB7CiAJCSAgICAkYXJncyA9ICQxOwogICAgIAkgICAgCSAg
  ICBteSAkcHJvdG8gPSAnKCkgJzsKIAkJICAgIGlmICgkYXJncyBuZSAnJykgewogICAgIAkgICAg
  CSAgICAJJHByb3RvID0gJyc7Ci0JCQlmb3JlYWNoICRhcmcgKHNwbGl0KC8sXHMqLywkYXJncykp
  IHsKKwkJCWZvcmVhY2ggbXkgJGFyZyAoc3BsaXQoLyxccyovLCRhcmdzKSkgewogCQkJICAgICRh
  cmcgPX4gcy9eXHMqKFteXHNdLipbXlxzXSlccyokLyQxLzsKIAkJCSAgICAkY3VyYXJnc3skYXJn
  fSA9IDE7CiAJCQl9CkBAIC0xNzcsMjIgKzE4NCwzMiBAQCB3aGlsZSAoZGVmaW5lZCAoJGZpbGUg
  PSBuZXh0X2ZpbGUoKSkpIHsKICAgICAgICAgICAgICAgICAgICAgICBwcmludCBPVVQgJHQsInVu
  bGVzcyhkZWZpbmVkKFwmJG5hbWUpKSB7XG4gICAgc3ViICRuYW1lICgpIHtcdCIsJG5ldywiO31c
  bn1cbiI7CiAJCSAgICB9CiAJCX0KLQkgICAgfSBlbHNpZiAoL14oaW5jbHVkZXxpbXBvcnQpXHMq
  WzwiXSguKilbPiJdLykgewotCQkoJGluY2wgPSAkMikgPX4gcy9cLmgkLy5waC87Ci0JCXByaW50
  IE9VVCAkdCwicmVxdWlyZSAnJGluY2wnO1xuIjsKLQkgICAgfSBlbHNpZigvXmluY2x1ZGVfbmV4
  dFxzKls8Il0oLiopWz4iXS8pIHsKLQkJKCRpbmNsID0gJDEpID1+IHMvXC5oJC8ucGgvOworCSAg
  ICB9IGVsc2lmICgvXihpbmNsdWRlfGltcG9ydHxpbmNsdWRlX25leHQpXHMqKFs8XCJdKSguKilb
  PlwiXS8pIHsKKyAgICAgICAgICAgICAgICAkaW5jbF90eXBlID0gJDE7CisgICAgICAgICAgICAg
  ICAgJGluY2xfcXVvdGUgPSAkMjsKKyAgICAgICAgICAgICAgICAkaW5jbCA9ICQzOworICAgICAg
  ICAgICAgICAgIGlmICgoJGluY2xfdHlwZSBlcSAnaW5jbHVkZV9uZXh0JykgfHwKKyAgICAgICAg
  ICAgICAgICAgICAgKCRvcHRfZSAmJiBleGlzdHMoJGJhZF9maWxleyRpbmNsfSkpKSB7CisgICAg
  ICAgICAgICAgICAgICAgICRpbmNsID1+IHMvXC5oJC8ucGgvOwogCQlwcmludCBPVVQgKCR0LAog
  CQkJICAgImV2YWwge1xuIik7CiAgICAgICAgICAgICAgICAgJHRhYiArPSA0OwogICAgICAgICAg
  ICAgICAgICR0ID0gIlx0IiB4ICgkdGFiIC8gOCkgLiAnICcgeCAoJHRhYiAlIDgpOworICAgICAg
  ICAgICAgICAgICAgICBwcmludCBPVVQgKCR0LCAibXkoXEBSRU0pO1xuIik7CisgICAgICAgICAg
  ICAgICAgICAgIGlmICgkaW5jbF90eXBlIGVxICdpbmNsdWRlX25leHQnKSB7CiAJCXByaW50IE9V
  VCAoJHQsCiAJCQkgICAibXkoXCVJTkNEKSA9IG1hcCB7IFwkSU5De1wkX30gPT4gMSB9ICIsCi0J
  CQkgICAiKGdyZXAgeyBcJF8gZXEgXCIkaW5jbFwiIH0ga2V5cyhcJUlOQykpO1xuIik7CisJCQkg
  ICAgICAgICAgICIoZ3JlcCB7IFwkXyBlcSBcIiRpbmNsXCIgfSAiLAorICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAia2V5cyhcJUlOQykpO1xuIik7CiAJCXByaW50IE9VVCAoJHQs
  Ci0JCQkgICAibXkoXEBSRU0pID0gbWFwIHsgXCJcJF8vJGluY2xcIiB9ICIsCisJCQkgICAgICAg
  ICAgICJcQFJFTSA9IG1hcCB7IFwiXCRfLyRpbmNsXCIgfSAiLAogCQkJICAgIihncmVwIHsgbm90
  IGV4aXN0cyhcJElOQ0R7XCJcJF8vJGluY2xcIn0pIiwKLQkJCSAgICJhbmQgLWYgXCJcJF8vJGlu
  Y2xcIiB9IFxASU5DKTtcbiIpOworCQkJICAgICAgICAgICAiIGFuZCAtZiBcIlwkXy8kaW5jbFwi
  IH0gXEBJTkMpO1xuIik7CisgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CisgICAgICAgICAg
  ICAgICAgICAgICAgICBwcmludCBPVVQgKCR0LAorICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAiXEBSRU0gPSBtYXAgeyBcIlwkXy8kaW5jbFwiIH0gIiwKKyAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgIihncmVwIHstciBcIlwkXy8kaW5jbFwiIH0gXEBJTkMpO1xu
  Iik7CisgICAgICAgICAgICAgICAgICAgIH0KIAkJcHJpbnQgT1VUICgkdCwKIAkJCSAgICJyZXF1
  aXJlIFwiXCRSRU1bMF1cIiBpZiBcQFJFTTtcbiIpOwogICAgICAgICAgICAgICAgICR0YWIgLT0g
  NDsKQEAgLTIwMSw2ICsyMTgsMTQgQEAgd2hpbGUgKGRlZmluZWQgKCRmaWxlID0gbmV4dF9maWxl
  KCkpKSB7CiAJCQkgICAifTtcbiIpOwogCQlwcmludCBPVVQgKCR0LAogCQkJICAgIndhcm4oXCRc
  QCkgaWYgXCRcQDtcbiIpOworICAgICAgICAgICAgICAgIH0gZWxzZSB7CisgICAgICAgICAgICAg
  ICAgICAgICRpbmNsID1+IHMvXC5oJC8ucGgvOworICAgICAgICAgICAgICAgICAgICAjIGNvcHkg
  dGhlIHByZWZpeCBpbiB0aGUgcXVvdGUgc3ludGF4ICgjaW5jbHVkZSAieC5oIikgY2FzZQorICAg
  ICAgICAgICAgICAgICAgICBpZiAoJGluY2wgIX4gbXwvfCAmJiAkaW5jbF9xdW90ZSBlcSBxeyJ9
  ICYmICRmaWxlID1+IG18XiguKikvfCkgeworICAgICAgICAgICAgICAgICAgICAgICAgJGluY2wg
  PSAiJDEvJGluY2wiOworICAgICAgICAgICAgICAgICAgICB9CisJCSAgICBwcmludCBPVVQgJHQs
  InJlcXVpcmUgJyRpbmNsJztcbiI7CisgICAgICAgICAgICAgICAgfQogCSAgICB9IGVsc2lmICgv
  XmlmZGVmXHMrKFx3KykvKSB7CiAJCXByaW50IE9VVCAkdCwiaWYoZGVmaW5lZCgmJDEpKSB7XG4i
  OwogCQkkdGFiICs9IDQ7CkBAIC0yNDgsMjAgKzI3MywyNCBAQCB3aGlsZSAoZGVmaW5lZCAoJGZp
  bGUgPSBuZXh0X2ZpbGUoKSkpIHsKIAkgICAgfSBlbHNpZigvXmlkZW50XHMrKC4qKS8pIHsKIAkJ
  cHJpbnQgT1VUICR0LCAiIyAkMVxuIjsKIAkgICAgfQotIAl9IGVsc2lmKC9eXHMqKHR5cGVkZWZc
  cyopP2VudW1ccyooXHMrW2EtekEtWl9dXHcqXHMqKT9cey8pIHsKLQkgICAgdW50aWwoL1x9Lio/
  Oy8pIHsKLQkJY2hvbXAoJG5leHQgPSA8SU4+KTsKKwl9IGVsc2lmKC9eXHMqKHR5cGVkZWZccyop
  P2VudW1ccyooXHMrW2EtekEtWl9dXHcqXHMqKT8vKSB7CisJICAgIHVudGlsKC9ce1tefV0qXH0u
  KjsvIHx8IC87LykgeworCQlsYXN0IHVubGVzcyBkZWZpbmVkICgkbmV4dCA9IG5leHRfbGluZSgk
  ZmlsZSkpOworCQljaG9tcCAkbmV4dDsKKwkJIyBkcm9wICIjZGVmaW5lIEZPTyBGT08iIGluIGVu
  dW1zCisJCSRuZXh0ID1+IHMvXlxzKiNccypkZWZpbmVccysoXHcrKVxzK1wxXHMqJC8vOwogCQkk
  XyAuPSAkbmV4dDsKIAkJcHJpbnQgT1VUICIjICRuZXh0XG4iIGlmICRvcHRfRDsKIAkgICAgfQor
  CSAgICBzLyNccyppZi4qPyNccyplbmRpZi8vZzsgIyBkcm9wICNpZmRlZnMKIAkgICAgc0AvXCou
  Kj9cKi9AQGc7CiAJICAgIHMvXHMrLyAvZzsKLQkgICAgL15ccz8odHlwZWRlZlxzPyk/ZW51bVxz
  PyhbYS16QS1aX11cdyopP1xzP1x7KC4qKVx9XHM/KFthLXpBLVpfXVx3Kik/XHM/Oy87Ci0JICAg
  ICgkZW51bV9zdWJzID0gJDMpID1+IHMvXHMvL2c7Ci0JICAgIEBlbnVtX3N1YnMgPSBzcGxpdCgv
  LC8sICRlbnVtX3N1YnMpOwotCSAgICAkZW51bV92YWwgPSAtMTsKLQkgICAgZm9yICRlbnVtIChA
  ZW51bV9zdWJzKSB7Ci0JCSgkZW51bV9uYW1lLCAkZW51bV92YWx1ZSkgPSAkZW51bSA9fiAvXihb
  YS16QS1aX11cdyopKD0uKyk/JC87CisJICAgIG5leHQgdW5sZXNzIC9eXHM/KHR5cGVkZWZccz8p
  P2VudW1ccz8oW2EtekEtWl9dXHcqKT9ccz9ceyguKilcfVxzPyhbYS16QS1aX11cdyopP1xzPzsv
  OworCSAgICAobXkgJGVudW1fc3VicyA9ICQzKSA9fiBzL1xzLy9nOworCSAgICBteSBAZW51bV9z
  dWJzID0gc3BsaXQoLywvLCAkZW51bV9zdWJzKTsKKwkgICAgbXkgJGVudW1fdmFsID0gLTE7CisJ
  ICAgIGZvcmVhY2ggbXkgJGVudW0gKEBlbnVtX3N1YnMpIHsKKwkJbXkgKCRlbnVtX25hbWUsICRl
  bnVtX3ZhbHVlKSA9ICRlbnVtID1+IC9eKFthLXpBLVpfXVx3KikoPS4rKT8kLzsKIAkJJGVudW1f
  dmFsdWUgPX4gcy9ePS8vOwogCQkkZW51bV92YWwgPSAobGVuZ3RoKCRlbnVtX3ZhbHVlKSA/ICRl
  bnVtX3ZhbHVlIDogJGVudW1fdmFsICsgMSk7CiAJCWlmICgkb3B0X2gpIHsKQEAgLTI3OCwzMSAr
  MzA3LDQ3IEBAIHdoaWxlIChkZWZpbmVkICgkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCSAgICB9
  CiAJfQogICAgIH0KLSAgICBwcmludCBPVVQgIjE7XG4iOwotCi0gICAgJGlzX2NvbnZlcnRlZHsk
  ZmlsZX0gPSAxOworICAgICRJc19jb252ZXJ0ZWR7JGZpbGV9ID0gMTsKKyAgICBpZiAoJG9wdF9l
  ICYmIGV4aXN0cygkYmFkX2ZpbGV7JGZpbGV9KSkgeworICAgICAgICB1bmxpbmsoJERlc3RfZGly
  IC4gJy8nIC4gJG91dGZpbGUpOworICAgICAgICAkbmV4dCA9ICcnOworICAgIH0gZWxzZSB7Cisg
  ICAgICAgIHByaW50IE9VVCAiMTtcbiI7CiAgICAgcXVldWVfaW5jbHVkZXNfZnJvbSgkZmlsZSkg
  aWYgKCRvcHRfYSk7CisgICAgfQogfQogCi1leGl0ICRFeGl0OwotCi1zdWIgcmVpbmRlbnQoJCkg
  ewotICAgIG15KCR0ZXh0KSA9IHNoaWZ0OwotICAgICR0ZXh0ID1+IHMvXG4vXG4gICAgL2c7Ci0g
  ICAgJHRleHQgPX4gcy8gICAgICAgIC9cdC9nOwotICAgICR0ZXh0OworaWYgKCRvcHRfZSAmJiAo
  c2NhbGFyKGtleXMgJWJhZF9maWxlKSA+IDApKSB7CisgICAgd2FybiAiV2FzIHVuYWJsZSB0byBj
  b252ZXJ0IHRoZSBmb2xsb3dpbmcgZmlsZXM6XG4iOworICAgIHdhcm4gIlx0IiAuIGpvaW4oIlxu
  XHQiLHNvcnQoa2V5cyAlYmFkX2ZpbGUpKSAuICJcbiI7CiB9CiAKK2V4aXQgJEV4aXQ7CisKIHN1
  YiBleHByIHsKKyAgICBteSAkam9pbmVkX2FyZ3M7CiAgICAgaWYoa2V5cyglY3VyYXJncykpIHsK
  LQlteSgkam9pbmVkX2FyZ3MpID0gam9pbignfCcsIGtleXMoJWN1cmFyZ3MpKTsKKwkkam9pbmVk
  X2FyZ3MgPSBqb2luKCd8Jywga2V5cyglY3VyYXJncykpOwogICAgIH0KICAgICB3aGlsZSAoJF8g
  bmUgJycpIHsKIAlzL15cJlwmLy8gJiYgZG8geyAkbmV3IC49ICIgJiYiOyBuZXh0O307ICMgaGFu
  ZGxlICYmIG9wZXJhdG9yCiAJcy9eXCYoW1woYS16XCldKykvJDEvaTsJIyBoYWNrIGZvciB0aGlu
  Z3MgdGhhdCB0YWtlIHRoZSBhZGRyZXNzIG9mCiAJcy9eKFxzKykvLwkJJiYgZG8geyRuZXcgLj0g
  JyAnOyBuZXh0O307Ci0Jcy9eKDBYWzAtOUEtRl0rKVtVTF0qLy9pCSYmIGRvIHskbmV3IC49IGxj
  KCQxKTsgbmV4dDt9OwotCXMvXigtP1xkK1wuXGQrRVstK11cZCspRj8vL2kJJiYgZG8geyRuZXcg
  Lj0gJDE7IG5leHQ7fTsKKwlzL14wWChbMC05QS1GXSspW1VMXSovL2kgCisJICAgICYmIGRvIHtt
  eSAkaGV4ID0gJDE7CisJCSAgICRoZXggPX4gcy9eMCsvLzsKKwkJICAgaWYgKGxlbmd0aCAkaGV4
  ID4gOCAmJiAhJENvbmZpZ3t1c2U2NGJpdGludH0pIHsKKwkJICAgICAgICMgQ3JvYWsgaWYgbnZf
  cHJlc2VydmVzX3V2X2JpdHMgPCA2NCA/CisJCSAgICAgICAkbmV3IC49ICAgICAgICAgaGV4KHN1
  YnN0cigkaGV4LCAtOCkpICsKKwkJCSAgICAgICAyKiozMiAqIGhleChzdWJzdHIoJGhleCwgIDAs
  IC04KSk7CisJCSAgICAgICAjIFRoZSBhYm92ZSB3aWxsIHByb2R1Y2UgImVycm9ybmV1cyIgY29k
  ZQorCQkgICAgICAgIyBpZiB0aGUgaGV4IGNvbnN0YW50IHdhcyBlLmcuIGluc2lkZSBVSU5UNjRf
  QworCQkgICAgICAgIyBtYWNybywgYnV0IHRoZW4gYWdhaW4sIGgycGggaXMgYW4gYXBwcm94aW1h
  dGlvbi4KKwkJICAgfSBlbHNlIHsKKwkJICAgICAgICRuZXcgLj0gbGMoIjB4JGhleCIpOworCQkg
  ICB9CisJCSAgIG5leHQ7fTsKKwlzL14oLT9cZCtcLlxkK0VbLStdP1xkKylbRkxdPy8vaQkmJiBk
  byB7JG5ldyAuPSAkMTsgbmV4dDt9OwogCXMvXihcZCspXHMqW0xVXSovL2kJJiYgZG8geyRuZXcg
  Lj0gJDE7IG5leHQ7fTsKIAlzL14oIihcXCJ8W14iXSkqIikvLwkmJiBkbyB7JG5ldyAuPSAkMTsg
  bmV4dDt9OwogCXMvXicoKFxcInxbXiJdKSopJy8vCSYmIGRvIHsKQEAgLTM0MSwxMyArMzg2LDEz
  IEBAIHN1YiBleHByIHsKIAkjIEVsaW1pbmF0ZSB0eXBlZGVmcwogCS9cKChbXHdcc10rKVtcKlxz
  XSpcKVxzKltcd1woXS8gJiYgZG8gewogCSAgICBmb3JlYWNoIChzcGxpdCAvXHMrLywgJDEpIHsg
  ICMgTWFrZSBzdXJlIGFsbCB0aGUgd29yZHMgYXJlIHR5cGVzLAotCQlsYXN0IHVubGVzcyAoJGlz
  YXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnKTsKKwkJbGFzdCB1bmxlc3MgKCRpc2F0eXBleyRf
  fSBvciAkXyBlcSAnc3RydWN0JyBvciAkXyBlcSAndW5pb24nKTsKIAkgICAgfQogCSAgICBzL1wo
  W1x3XHNdK1tcKlxzXSpcKS8vICYmIG5leHQ7ICAgICAgIyB0aGVuIGVsaW1pbmF0ZSB0aGVtLgog
  CX07CiAJIyBzdHJ1Y3QvdW5pb24gbWVtYmVyLCBpbmNsdWRpbmcgYXJyYXlzOgogCXMvXihbX0Et
  Wl1cdyooXFtbXlxdXStcXSk/KChcLnwtPilbX0EtWl1cdyooXFtbXlxdXStcXSk/KSspLy9pICYm
  IGRvIHsKLQkgICAgJGlkID0gJDE7CisJICAgIG15ICRpZCA9ICQxOwogCSAgICAkaWQgPX4gcy8o
  XC58KC0+KSkoW15cLlwtXSopLy0+XHskM1x9L2c7CiAJICAgICRpZCA9fiBzL1xiKFteXCRdKSgk
  am9pbmVkX2FyZ3MpLyQxXCQkMi9nIGlmIGxlbmd0aCgkam9pbmVkX2FyZ3MpOwogCSAgICB3aGls
  ZSgkaWQgPX4gL1xbXHMqKFteXCRcJlxkXF1dKylcXS8pIHsKQEAgLTM2Myw4ICs0MDgsOCBAQCBz
  dWIgZXhwciB7CiAJICAgICRuZXcgLj0gIiAoXCQkaWQpIjsKIAl9OwogCXMvXihbX2EtekEtWl1c
  dyopLy8JJiYgZG8gewotCSAgICAkaWQgPSAkMTsKLQkgICAgaWYgKCRpZCBlcSAnc3RydWN0Jykg
  eworCSAgICBteSAkaWQgPSAkMTsKKwkgICAgaWYgKCRpZCBlcSAnc3RydWN0JyB8fCAkaWQgZXEg
  J3VuaW9uJykgewogCQlzL15ccysoXHcrKS8vOwogCQkkaWQgLj0gJyAnIC4gJDE7CiAJCSRpc2F0
  eXBleyRpZH0gPSAxOwpAQCAtMzc3LDggKzQyMiw4IEBAIHN1YiBleHByIHsKIAkJJG5ldyAuPSAn
  LT4nIGlmIC9eW1xbXHtdLzsKIAkgICAgfSBlbHNpZiAoJGlkIGVxICdkZWZpbmVkJykgewogCQkk
  bmV3IC49ICdkZWZpbmVkJzsKLQkgICAgfSBlbHNpZiAoL15cKC8pIHsKLQkJcy9eXCgoXHcpLC8o
  IiQxIiwvIGlmICRpZCA9fiAvXl9JT1tXUl0qJC9pOwkjIGNoZWF0CisJICAgIH0gZWxzaWYgKC9e
  XHMqXCgvKSB7CisJCXMvXlxzKlwoKFx3KSwvKCIkMSIsLyBpZiAkaWQgPX4gL15fSU9bV1JdKiQv
  aTsJIyBjaGVhdAogCQkkbmV3IC49ICIgJiRpZCI7CiAJICAgIH0gZWxzaWYgKCRpc2F0eXBleyRp
  ZH0pIHsKIAkJaWYgKCRuZXcgPX4gL3tccyokLykgewpAQCAtMzkxLDcgKzQzNiw3IEBAIHN1YiBl
  eHByIHsKIAkJfQogCSAgICB9IGVsc2UgewogCQlpZiAoJGluaWYgJiYgJG5ldyAhfiAvZGVmaW5l
  ZFxzKlwoJC8pIHsKLQkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAmJyAu
  ICRpZCAuICcgOiAwKSc7CisJCSAgICAkbmV3IC49ICcoZGVmaW5lZCgmJyAuICRpZCAuICcpID8g
  JicgLiAkaWQgLiAnIDogdW5kZWYpJzsKIAkJfSBlbHNpZiAoL15cWy8pIHsKIAkJICAgICRuZXcg
  Lj0gIiBcJCRpZCI7CiAJCX0gZWxzZSB7CkBAIC00MDUsNiArNDUwLDEwMSBAQCBzdWIgZXhwciB7
  CiB9CiAKIAorc3ViIG5leHRfbGluZQoreworICAgIG15ICRmaWxlID0gc2hpZnQ7CisgICAgbXkg
  KCRpbiwgJG91dCk7CisgICAgbXkgJHByZV9zdWJfdHJpX2dyYXBocyA9IDE7CisKKyAgICBSRUFE
  OiB3aGlsZSAobm90IGVvZiBJTikgeworICAgICAgICAkaW4gIC49IDxJTj47CisgICAgICAgIGNo
  b21wICRpbjsKKyAgICAgICAgbmV4dCB1bmxlc3MgbGVuZ3RoICRpbjsKKworICAgICAgICB3aGls
  ZSAobGVuZ3RoICRpbikgeworICAgICAgICAgICAgaWYgKCRwcmVfc3ViX3RyaV9ncmFwaHMpIHsK
  KyAgICAgICAgICAgICAgICAjIFByZXByb2Nlc3MgYWxsIHRyaS1ncmFwaHMgCisgICAgICAgICAg
  ICAgICAgIyBpbmNsdWRpbmcgdGhpbmdzIHN0dWNrIGluIHF1b3RlZCBzdHJpbmcgY29uc3RhbnRz
  LgorICAgICAgICAgICAgICAgICRpbiA9fiBzL1w/XD89LyMvZzsgICAgICAgICAgICAgICAgICAg
  ICAgICAgIyB8ID8/PXwgICN8CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1whL3wvZzsg
  ICAgICAgICAgICAgICAgICAgICAgICAjIHwgPz8hfCAgfHwKKyAgICAgICAgICAgICAgICAkaW4g
  PX4gcy9cP1w/Jy9eL2c7ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pyd8ICBefAorICAg
  ICAgICAgICAgICAgICRpbiA9fiBzL1w/XD9cKC9bL2c7ICAgICAgICAgICAgICAgICAgICAgICAg
  IyB8ID8/KHwgIFt8CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1wpL10vZzsgICAgICAg
  ICAgICAgICAgICAgICAgICAjIHwgPz8pfCAgXXwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9c
  P1w/XC0vfi9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Py18ICB+fAorICAgICAgICAg
  ICAgICAgICRpbiA9fiBzL1w/XD9cLy9cXC9nOyAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/
  L3wgIFx8CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cPzwvey9nOyAgICAgICAgICAgICAg
  ICAgICAgICAgICAjIHwgPz88fCAge3wKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/Pi99
  L2c7ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pz58ICB9fAorICAgICAgICAgICAgfQor
  CSAgICBpZiAoJGluID1+IC9eXCNpZmRlZiBfX0xBTkdVQUdFX1BBU0NBTF9fLykgeworICAgICAg
  ICAgICAgICAgICMgVHJ1NjQgZGlzYXNzZW1ibGVyLmggZXZpbG5lc3M6IG1peGVkIEMgYW5kIFBh
  c2NhbC4KKwkJd2hpbGUgKDxJTj4pIHsKKwkJICAgIGxhc3QgaWYgL15cI2VuZGlmLzsgCisJCX0K
  KwkJbmV4dCBSRUFEOworCSAgICB9CisJICAgIGlmICgkaW4gPX4gL15leHRlcm4gaW5saW5lIC8g
  JiYgIyBJbmxpbmVkIGFzc2VtYmxlci4KKwkJJF5PIGVxICdsaW51eCcgJiYgJGZpbGUgPX4gbSEo
  PzpefC8pYXNtL1teL10rXC5oJCEpIHsKKyAJCXdoaWxlICg8SU4+KSB7CisJCSAgICBsYXN0IGlm
  IC9efS87IAorCQl9CisJCW5leHQgUkVBRDsKKwkgICAgfQorICAgICAgICAgICAgaWYgKCRpbiA9
  fiBzL1xcJC8vKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBcLW5ld2xpbmUKKyAgICAg
  ICAgICAgICAgICAkb3V0ICAgIC49ICcgJzsKKyAgICAgICAgICAgICAgICBuZXh0IFJFQUQ7Cisg
  ICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFteIidcXFwvXSspLy8pIHsgICAgICAgICAg
  ICAjIFBhc3N0aHJvdWdoCisgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsKKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oXFwuKS8vKSB7ICAgICAgICAgICAgICAgICAgICMgXC4u
  LgorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgk
  aW4gPX4gL14nLykgeyAgICAgICAgICAgICAgICAgICAgICAgICAjICcuLi4KKyAgICAgICAgICAg
  ICAgICBpZiAoJGluID1+IHMvXignKFxcLnxbXidcXF0pKicpLy8pIHsKKyAgICAgICAgICAgICAg
  ICAgICAgJG91dCAgICAuPSAkMTsKKyAgICAgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAg
  ICAgICAgICAgICBuZXh0IFJFQUQ7CisgICAgICAgICAgICAgICAgfQorICAgICAgICAgICAgfSBl
  bHNpZiAoJGluID1+IC9eIi8pIHsgICAgICAgICAgICAgICAgICAgICAgICAgIyAiLi4uCisgICAg
  ICAgICAgICAgICAgaWYgKCRpbiA9fiBzL14oIihcXC58W14iXFxdKSoiKS8vKSB7CisgICAgICAg
  ICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsKKyAg
  ICAgICAgICAgICAgICAgICAgbmV4dCBSRUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiBzL15cL1wvLiovLykgeyAgICAgICAgICAgICAgICAgICMgLy8u
  Li4KKyAgICAgICAgICAgICAgICAjIGZhbGwgdGhyb3VnaAorICAgICAgICAgICAgfSBlbHNpZiAo
  JGluID1+IG0vXlwvXCovKSB7ICAgICAgICAgICAgICAgICAgICAgIyAvKi4uLgorICAgICAgICAg
  ICAgICAgICMgQyBjb21tZW50IHJlbW92YWwgYWRhcHRlZCBmcm9tIHBlcmxmYXE2OgorICAgICAg
  ICAgICAgICAgIGlmICgkaW4gPX4gcy9eXC9cKlteKl0qXCorKFteXC8qXVteKl0qXCorKSpcLy8v
  KSB7CisgICAgICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAnOworICAgICAgICAgICAgICAg
  IH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBJbmNvbXBsZXRl
  IC8qICovCisgICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgICAgICB9
  CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFwvKS8vKSB7ICAgICAgICAgICAgICAg
  ICAgICAjIC8uLi4KKyAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAg
  fSBlbHNpZiAoJGluID1+IHMvXihbXlwnXCJcXFwvXSspLy8pIHsKKyAgICAgICAgICAgICAgICAk
  b3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAoJF5PIGVxICdsaW51eCcgJiYKKyAg
  ICAgICAgICAgICAgICAgICAgICRmaWxlID1+IG0hKD86XnwvKWxpbnV4L2J5dGVvcmRlci9wZHBf
  ZW5kaWFuXC5oJCEgJiYKKyAgICAgICAgICAgICAgICAgICAgICRpbiAgID1+IHMhXCdUIEtOT1ch
  ISkgeworICAgICAgICAgICAgICAgICRvdXQgICAgPX4gcyFJIERPTiQhSV9ET19OT1RfS05PVyE7
  CisgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgIGlmICgkb3B0X2UpIHsKKyAg
  ICAgICAgICAgICAgICAgICAgd2FybiAiQ2Fubm90IHBhcnNlICRmaWxlOlxuJGluXG4iOworICAg
  ICAgICAgICAgICAgICAgICAkYmFkX2ZpbGV7JGZpbGV9ID0gMTsKKyAgICAgICAgICAgICAgICAg
  ICAgJGluID0gJyc7CisgICAgICAgICAgICAgICAgICAgICRvdXQgPSB1bmRlZjsKKyAgICAgICAg
  ICAgICAgICAgICAgbGFzdCBSRUFEOworICAgICAgICAgICAgICAgIH0gZWxzZSB7CisJCWRpZSAi
  Q2Fubm90IHBhcnNlOlxuJGluXG4iOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAgICAgIH0K
  KyAgICAgICAgfQorCisgICAgICAgIGxhc3QgUkVBRCBpZiAkb3V0ID1+IC9cUy87CisgICAgfQor
  CisgICAgcmV0dXJuICRvdXQ7Cit9CisKKwogIyBIYW5kbGUgcmVjdXJzaXZlIHN1YmRpcmVjdG9y
  aWVzIHdpdGhvdXQgZ2V0dGluZyBhIGdyb3Rlc3F1ZWx5IGJpZyBzdGFjay4KICMgQ291bGQgdGhp
  cyBiZSBpbXBsZW1lbnRlZCB1c2luZyBGaWxlOjpGaW5kPwogc3ViIG5leHRfZmlsZQpAQCAtNTA0
  LDggKzY0NCwxMyBAQCBzdWIgcXVldWVfaW5jbHVkZXNfZnJvbQogICAgICAgICAgICAgICAgICRs
  aW5lIC49IDxIRUFERVI+OwogICAgICAgICAgICAgfQogCi0gICAgICAgICAgICBpZiAoJGxpbmUg
  PX4gL14jXHMqaW5jbHVkZVxzKzwoLio/KT4vKSB7Ci0gICAgICAgICAgICAgICAgcHVzaChAQVJH
  ViwgJDEpIHVubGVzcyAkaXNfY29udmVydGVkeyQxfTsKKyAgICAgICAgICAgIGlmICgkbGluZSA9
  fiAvXiNccyppbmNsdWRlXHMrKFs8Il0pKC4qPylbPiJdLykgeworICAgICAgICAgICAgICAgIG15
  ICgkZGVsaW1pdGVyLCAkbmV3X2ZpbGUpID0gKCQxLCAkMik7CisgICAgICAgICAgICAgICAgIyBj
  b3B5IHRoZSBwcmVmaXggaW4gdGhlIHF1b3RlIHN5bnRheCAoI2luY2x1ZGUgInguaCIpIGNhc2UK
  KyAgICAgICAgICAgICAgICBpZiAoJGRlbGltaXRlciBlcSBxeyJ9ICYmICRmaWxlID1+IG18Xigu
  KikvfCkgeworICAgICAgICAgICAgICAgICAgICAkbmV3X2ZpbGUgPSAiJDEvJG5ld19maWxlIjsK
  KyAgICAgICAgICAgICAgICB9CisgICAgICAgICAgICAgICAgcHVzaChAQVJHViwgJG5ld19maWxl
  KSB1bmxlc3MgJElzX2NvbnZlcnRlZHskbmV3X2ZpbGV9OwogICAgICAgICAgICAgfQogICAgICAg
  ICB9CiAgICAgY2xvc2UgSEVBREVSOwpAQCAtNTQ2LDI1ICs2OTEsNTAgQEAgc3ViIGJ1aWxkX3By
  ZWFtYmxlX2lmX25lY2Vzc2FyeQogICAgIG15ICglZGVmaW5lKSA9IF9leHRyYWN0X2NjX2RlZmlu
  ZXMoKTsKIAogICAgIG9wZW4gIFBSRUFNQkxFLCAiPiRwcmVhbWJsZSIgb3IgZGllICJDYW5ub3Qg
  b3BlbiAkcHJlYW1ibGU6ICAkISI7Ci0gICAgICAgIHByaW50IFBSRUFNQkxFICIjIFRoaXMgZmls
  ZSB3YXMgY3JlYXRlZCBieSBoMnBoIHZlcnNpb24gJFZFUlNJT05cbiI7Ci0KLSAgICAgICAgZm9y
  ZWFjaCAoc29ydCBrZXlzICVkZWZpbmUpIHsKLSAgICAgICAgICAgIGlmICgkb3B0X0QpIHsKLSAg
  ICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKLSAgICAg
  ICAgICAgIH0KLQotICAgICAgICAgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eXGQrJC8pIHsKLSAg
  ICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNz
  IChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICRkZWZpbmV7JF99IH0gfVxuXG4iOwotICAgICAg
  ICAgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL15cdyskLykgewotICAgICAgICAgICAgICAg
  IHByaW50IFBSRUFNQkxFCi0gICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRf
  KSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNl
  IHsKKwlwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJz
  aW9uICRWRVJTSU9OXG4iOworICAgICAgICAjIFByZXZlbnQgbm9uLXBvcnRhYmxlIGhleCBjb25z
  dGFudHMgZnJvbSB3YXJuaW5nLgorICAgICAgICAjCisgICAgICAgICMgV2Ugc3RpbGwgcHJvZHVj
  ZSBhbiBvdmVyZmxvdyB3YXJuaW5nIGlmIHdlIGNhbid0IHJlcHJlc2VudAorICAgICAgICAjIGEg
  aGV4IGNvbnN0YW50IGFzIGFuIGludGVnZXIuCisgICAgICAgIHByaW50IFBSRUFNQkxFICJubyB3
  YXJuaW5ncyBxdyhwb3J0YWJsZSk7XG4iOworCisJZm9yZWFjaCAoc29ydCBrZXlzICVkZWZpbmUp
  IHsKKwkgICAgaWYgKCRvcHRfRCkgeworCQlwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRf
  fVxuIjsKKwkgICAgfQorCSAgICBpZiAoJGRlZmluZXskX30gPX4gL15cKCguKilcKSQvKSB7CisJ
  CSMgcGFyZW50aGVzaXplZCB2YWx1ZTogIGQ9KHYpCisJCSRkZWZpbmV7JF99ID0gJDE7CisJICAg
  IH0KKwkgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/KFxkKyk/XC5cZCsoW2VFXVsrLV0/
  XGQrKT8pW0ZMXT8kLykgeworCQkjIGZsb2F0OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVu
  bGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNp
  ZiAoJGRlZmluZXskX30gPX4gL14oWystXT9cZCspVT9MezAsMn0kL2kpIHsKKwkJIyBpbnRlZ2Vy
  OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRf
  KCkgeyAkMSB9IH1cblxuIjsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9e
  KFsrLV0/MHhbXGRhLWZdKylVP0x7MCwyfSQvaSkgeworICAgICAgICAgICAgICAgICMgaGV4IGlu
  dGVnZXIKKyAgICAgICAgICAgICAgICAjIFNwZWNpYWwgY2FzZWQsIHNpbmNlIHBlcmwgd2FybnMg
  b24gaGV4IGludGVnZXJzCisgICAgICAgICAgICAgICAgIyB0aGF0IGNhbid0IGJlIHJlcHJlc2Vu
  dGVkIGluIGEgVVYuCisgICAgICAgICAgICAgICAgIworICAgICAgICAgICAgICAgICMgVGhpcyB3
  YXkgd2UgZ2V0IHRoZSB3YXJuaW5nIGF0IHRpbWUgb2YgdXNlLCBzbyB0aGUgdXNlcgorICAgICAg
  ICAgICAgICAgICMgb25seSBnZXRzIHRoZSB3YXJuaW5nIGlmIHRoZXkgaGFwcGVuIHRvIHVzZSB0
  aGlzCisgICAgICAgICAgICAgICAgIyBwbGF0Zm9ybS1zcGVjaWZpYyBkZWZpbml0aW9uLgorICAg
  ICAgICAgICAgICAgIG15ICRjb2RlID0gJDE7CisgICAgICAgICAgICAgICAgJGNvZGUgPSAiaGV4
  KCckY29kZScpIiBpZiBsZW5ndGggJGNvZGUgPiAxMDsKICAgICAgICAgICAgICAgICBwcmludCBQ
  UkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIg
  JF8oKSB7IFwiIiwKLSAgICAgICAgICAgICAgICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7JF99KSwg
  IlwiIH0gfVxuXG4iOwotICAgICAgICAgICAgfQotICAgICAgICB9CisgICAgICAgICAgICAgICAg
  ICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJGNvZGUgfSB9XG5cbiI7CisJ
  ICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9eXHcrJC8pIHsKKwkJcHJpbnQgUFJFQU1CTEUK
  KwkJICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0g
  fVxuXG4iOworCSAgICB9IGVsc2UgeworCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAo
  ZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyBcIiIsCisJCSAgICBxdW90ZW1ldGEoJGRlZmluZXsk
  X30pLCAiXCIgfSB9XG5cbiI7CisJICAgIH0KKwl9CiAgICAgY2xvc2UgUFJFQU1CTEUgICAgICAg
  ICAgICAgICBvciBkaWUgIkNhbm5vdCBjbG9zZSAkcHJlYW1ibGU6ICAkISI7CiB9CiAKQEAgLTU3
  NSwxNSArNzQ1LDE1IEBAIHN1YiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkKIHN1YiBfZXh0
  cmFjdF9jY19kZWZpbmVzCiB7CiAgICAgbXkgJWRlZmluZTsKLSAgICBteSAkYWxsc3ltYm9scyA9
  IGpvaW4gIiAiLCBAQ29uZmlne2Njc3ltYm9scywgY3Bwc3ltYm9scywgY3BwY2NzeW1ib2xzfTsK
  KyAgICBteSAkYWxsc3ltYm9scyAgPSBqb2luICIgIiwKKwlAQ29uZmlneydjY3N5bWJvbHMnLCAn
  Y3Bwc3ltYm9scycsICdjcHBjY3N5bWJvbHMnfTsKIAogICAgICMgU3BsaXQgY29tcGlsZXIgcHJl
  LWRlZmluaXRpb25zIGludG8gYGtleT12YWx1ZScgcGFpcnM6Ci0gICAgZm9yZWFjaCAoc3BsaXQg
  L1xzKy8sICRhbGxzeW1ib2xzKSB7Ci0gICAgICAgIC8oLis/KT0oLispLyBhbmQgJGRlZmluZXsk
  MX0gPSAkMjsKLQotICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICBwcmludCBTVERF
  UlIgIiRfOiAgJDEgLT4gJDJcbiI7Ci0gICAgICAgIH0KKyAgICB3aGlsZSAoJGFsbHN5bWJvbHMg
  PX4gLyhbXlxzXSspPSgoXFxcc3xbXlxzXSkrKS9nKSB7CisJJGRlZmluZXskMX0gPSAkMjsKKwlp
  ZiAoJG9wdF9EKSB7CisJICAgIHByaW50IFNUREVSUiAiJF86ICAkMSAtPiAkMlxuIjsKKwl9CiAg
  ICAgfQogCiAgICAgcmV0dXJuICVkZWZpbmU7CkBAIC02MTIsNiArNzgyLDEwIEBAIEl0IGlzIG1v
  c3QgZWFzaWx5IHJ1biB3aGlsZSBpbiAvdXNyL2luY2x1ZGU6CiAKIAljZCAvdXNyL2luY2x1ZGU7
  IGgycGggKiBzeXMvKgogCitvcgorCisJY2QgL3Vzci9pbmNsdWRlOyBoMnBoICogc3lzLyogYXJw
  YS8qIG5ldGluZXQvKgorCiBvcgogCiAJY2QgL3Vzci9pbmNsdWRlOyBoMnBoIC1yIC1sIC4KQEAg
  LTYyOSw3ICs4MDMsNyBAQCBJZiBydW4gd2l0aCBubyBhcmd1bWVudHMsIGZpbHRlcnMgc3RhbmRh
  cmQgaW5wdXQgdG8gc3RhbmRhcmQgb3V0cHV0LgogPWl0ZW0gLWQgZGVzdGluYXRpb25fZGlyCiAK
  IFB1dCB0aGUgcmVzdWx0aW5nIEI8LnBoPiBmaWxlcyBiZW5lYXRoIEI8ZGVzdGluYXRpb25fZGly
  PiwgaW5zdGVhZCBvZgotYmVuZWF0aCB0aGUgZGVmYXVsdCBQZXJsIGxpYnJhcnkgbG9jYXRpb24g
  KEM8JENvbmZpZ3snaW5zdGFsbHNpdHNlYXJjaCd9PikuCitiZW5lYXRoIHRoZSBkZWZhdWx0IFBl
  cmwgbGlicmFyeSBsb2NhdGlvbiAoQzwkQ29uZmlneydpbnN0YWxsc2l0ZWFyY2gnfT4pLgogCiA9
  aXRlbSAtcgogCkBAIC03MDgsMTggKzg4MiwxNiBAQCB0aGF0IGl0IGNhbiB0cmFuc2xhdGUuCiBJ
  dCdzIG9ubHkgaW50ZW5kZWQgYXMgYSByb3VnaCB0b29sLgogWW91IG1heSBuZWVkIHRvIGRpY2tl
  ciB3aXRoIHRoZSBmaWxlcyBwcm9kdWNlZC4KIAotRG9lc24ndCBydW4gd2l0aCBDPHVzZSBzdHJp
  Y3Q+Ci0KIFlvdSBoYXZlIHRvIHJ1biB0aGlzIHByb2dyYW0gYnkgaGFuZDsgaXQncyBub3QgcnVu
  IGFzIHBhcnQgb2YgdGhlIFBlcmwKIGluc3RhbGxhdGlvbi4KIAogRG9lc24ndCBoYW5kbGUgY29t
  cGxpY2F0ZWQgZXhwcmVzc2lvbnMgYnVpbHQgcGllY2VtZWFsLCBhIGxhOgogCiAgICAgZW51bSB7
  Ci0gICAgICAgIEZJUlNUX1ZBTFVFLAotICAgICAgICBTRUNPTkRfVkFMVUUsCisJRklSU1RfVkFM
  VUUsCisJU0VDT05EX1ZBTFVFLAogICAgICNpZmRlZiBBQkMKLSAgICAgICAgVEhJUkRfVkFMVUUK
  KwlUSElSRF9WQUxVRQogICAgICNlbmRpZgogICAgIH07CiAK
  UH2PH560
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTQyLDggKzQyLDEzIEBAIHVz
  ZSBDb25maWc7CiB1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGgpOwogdXNlIEdldG9wdDo6U3RkOwog
  Ci1nZXRvcHRzKCdEZDpybGhhUScpOwotdXNlIHZhcnMgcXcoJG9wdF9EICRvcHRfZCAkb3B0X3Ig
  JG9wdF9sICRvcHRfaCAkb3B0X2EgJG9wdF9RKTsKKyMgTWFrZSBzdXJlIHJlYWQgcGVybWlzc2lv
  bnMgZm9yIGFsbCBhcmUgc2V0OgoraWYgKGRlZmluZWQgdW1hc2sgJiYgKHVtYXNrKCkgJiAwNDQ0
  KSkgeworICAgIHVtYXNrICh1bWFzaygpICYgfjA0NDQpOworfQorCitnZXRvcHRzKCdEZDpybGhh
  UWUnKTsKK3VzZSB2YXJzIHF3KCRvcHRfRCAkb3B0X2QgJG9wdF9yICRvcHRfbCAkb3B0X2ggJG9w
  dF9hICRvcHRfUSAkb3B0X2UpOwogZGllICItciBhbmQgLWEgb3B0aW9ucyBhcmUgbXV0dWFsbHkg
  ZXhjbHVzaXZlXG4iIGlmICgkb3B0X3IgYW5kICRvcHRfYSk7CiBteSBAaW5jX2RpcnMgPSBpbmNf
  ZGlycygpIGlmICRvcHRfYTsKIApAQCAtNjUsMTMgKzcwLDIxIEBAIG15ICVpc2F0eXBlOwogQGlz
  YXR5cGV7QGlzYXR5cGV9ID0gKDEpIHggQGlzYXR5cGU7CiBteSAkaW5pZiA9IDA7CiBteSAlSXNf
  Y29udmVydGVkOworbXkgJWJhZF9maWxlID0gKCk7CiAKIEBBUkdWID0gKCctJykgdW5sZXNzIEBB
  UkdWOwogCiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkoKTsKIAorc3ViIHJlaW5kZW50KCQp
  IHsKKyAgICBteSgkdGV4dCkgPSBzaGlmdDsKKyAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOwor
  ICAgICR0ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKKyAgICAkdGV4dDsKK30KKwogbXkgKCR0LCAk
  dGFiLCAlY3VyYXJncywgJG5ldywgJGV2YWxfaW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91
  dGZpbGUpOwotbXkgKCRpbmNsLCAkbmV4dCk7CitteSAoJGluY2wsICRpbmNsX3R5cGUsICRpbmNs
  X3F1b3RlLCAkbmV4dCk7CiB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkp
  IHsKICAgICBpZiAoLWwgJGZpbGUgYW5kIC1kICRmaWxlKSB7CiAgICAgICAgIGxpbmtfaWZfcG9z
  c2libGUoJGZpbGUpIGlmICgkb3B0X2wpOwpAQCAtMTA3LDMwICsxMjAsMTcgQEAgd2hpbGUgKGRl
  ZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJb3BlbihPVVQsIj4kRGVzdF9kaXIv
  JG91dGZpbGUiKSB8fCBkaWUgIkNhbid0IGNyZWF0ZSAkb3V0ZmlsZTogJCFcbiI7CiAgICAgfQog
  Ci0gICAgcHJpbnQgT1VUICJyZXF1aXJlICdfaDJwaF9wcmUucGgnO1xuXG4iOwotICAgIHdoaWxl
  ICg8SU4+KSB7Ci0JY2hvcDsKLQl3aGlsZSAoL1xcJC8pIHsKLQkgICAgY2hvcDsKLQkgICAgJF8g
  Lj0gPElOPjsKLQkgICAgY2hvcDsKLQl9Ci0JcHJpbnQgT1VUICIjICRfXG4iIGlmICRvcHRfRDsK
  LQotCWlmIChzOi9cKjpcMjAwOmcpIHsKLQkgICAgczpcKi86XDIwMTpnOwotCSAgICBzL1wyMDBb
  XlwyMDFdKlwyMDEvL2c7CSMgZGVsZXRlIHNpbmdsZSBsaW5lIGNvbW1lbnRzCi0JICAgIGlmIChz
  L1wyMDAuKi8vKSB7CQkjIGJlZ2luIG11bHRpLWxpbmUgY29tbWVudD8KLQkJJF8gLj0gJy8qJzsK
  LQkJJF8gLj0gPElOPjsKLQkJcmVkbzsKLQkgICAgfQotCX0KKyAgICBwcmludCBPVVQKKyAgICAg
  ICAgInJlcXVpcmUgJ19oMnBoX3ByZS5waCc7XG5cbiIsCisgICAgICAgICJubyB3YXJuaW5ncyAn
  cmVkZWZpbmUnO1xuXG4iOworCisgICAgd2hpbGUgKGRlZmluZWQgKGxvY2FsICRfID0gbmV4dF9s
  aW5lKCRmaWxlKSkpIHsKIAlpZiAocy9eXHMqXCNccyovLykgewogCSAgICBpZiAocy9eZGVmaW5l
  XHMrKFx3KykvLykgewogCQkkbmFtZSA9ICQxOwogCQkkbmV3ID0gJyc7CiAJCXMvXHMrJC8vOwor
  CQlzL1woXHcrXHMqXChcKlwpXHMqXChcdypcKVwpXHMqKC0/XGQrKS8kMS87ICMgKGludCAoKiko
  Zm9vX3QpKTAKIAkJaWYgKHMvXlwoKFtcdyxcc10qKVwpLy8pIHsKIAkJICAgICRhcmdzID0gJDE7
  CiAgICAgCSAgICAJICAgIG15ICRwcm90byA9ICcoKSAnOwpAQCAtMTg0LDIyICsxODQsMzIgQEAg
  d2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAgICAgICAgICAgICAg
  ICAgICAgICAgcHJpbnQgT1VUICR0LCJ1bmxlc3MoZGVmaW5lZChcJiRuYW1lKSkge1xuICAgIHN1
  YiAkbmFtZSAoKSB7XHQiLCRuZXcsIjt9XG59XG4iOwogCQkgICAgfQogCQl9Ci0JICAgIH0gZWxz
  aWYgKC9eKGluY2x1ZGV8aW1wb3J0KVxzKls8Il0oLiopWz4iXS8pIHsKLQkJKCRpbmNsID0gJDIp
  ID1+IHMvXC5oJC8ucGgvOwotCQlwcmludCBPVVQgJHQsInJlcXVpcmUgJyRpbmNsJztcbiI7Ci0J
  ICAgIH0gZWxzaWYoL15pbmNsdWRlX25leHRccypbPCJdKC4qKVs+Il0vKSB7Ci0JCSgkaW5jbCA9
  ICQxKSA9fiBzL1wuaCQvLnBoLzsKKwkgICAgfSBlbHNpZiAoL14oaW5jbHVkZXxpbXBvcnR8aW5j
  bHVkZV9uZXh0KVxzKihbPFwiXSkoLiopWz5cIl0vKSB7CisgICAgICAgICAgICAgICAgJGluY2xf
  dHlwZSA9ICQxOworICAgICAgICAgICAgICAgICRpbmNsX3F1b3RlID0gJDI7CisgICAgICAgICAg
  ICAgICAgJGluY2wgPSAkMzsKKyAgICAgICAgICAgICAgICBpZiAoKCRpbmNsX3R5cGUgZXEgJ2lu
  Y2x1ZGVfbmV4dCcpIHx8CisgICAgICAgICAgICAgICAgICAgICgkb3B0X2UgJiYgZXhpc3RzKCRi
  YWRfZmlsZXskaW5jbH0pKSkgeworICAgICAgICAgICAgICAgICAgICAkaW5jbCA9fiBzL1wuaCQv
  LnBoLzsKIAkJcHJpbnQgT1VUICgkdCwKIAkJCSAgICJldmFsIHtcbiIpOwogICAgICAgICAgICAg
  ICAgICR0YWIgKz0gNDsKICAgICAgICAgICAgICAgICAkdCA9ICJcdCIgeCAoJHRhYiAvIDgpIC4g
  JyAnIHggKCR0YWIgJSA4KTsKKyAgICAgICAgICAgICAgICAgICAgcHJpbnQgT1VUICgkdCwgIm15
  KFxAUkVNKTtcbiIpOworICAgICAgICAgICAgICAgICAgICBpZiAoJGluY2xfdHlwZSBlcSAnaW5j
  bHVkZV9uZXh0JykgewogCQlwcmludCBPVVQgKCR0LAogCQkJICAgIm15KFwlSU5DRCkgPSBtYXAg
  eyBcJElOQ3tcJF99ID0+IDEgfSAiLAotCQkJICAgIihncmVwIHsgXCRfIGVxIFwiJGluY2xcIiB9
  IGtleXMoXCVJTkMpKTtcbiIpOworCQkJICAgICAgICAgICAiKGdyZXAgeyBcJF8gZXEgXCIkaW5j
  bFwiIH0gIiwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImtleXMoXCVJTkMp
  KTtcbiIpOwogCQlwcmludCBPVVQgKCR0LAotCQkJICAgIm15KFxAUkVNKSA9IG1hcCB7IFwiXCRf
  LyRpbmNsXCIgfSAiLAorCQkJICAgICAgICAgICAiXEBSRU0gPSBtYXAgeyBcIlwkXy8kaW5jbFwi
  IH0gIiwKIAkJCSAgICIoZ3JlcCB7IG5vdCBleGlzdHMoXCRJTkNEe1wiXCRfLyRpbmNsXCJ9KSIs
  Ci0JCQkgICAiYW5kIC1mIFwiXCRfLyRpbmNsXCIgfSBcQElOQyk7XG4iKTsKKwkJCSAgICAgICAg
  ICAgIiBhbmQgLWYgXCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworICAgICAgICAgICAgICAg
  ICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgT1VUICgkdCwKKyAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlxAUkVNID0gbWFwIHsgXCJcJF8vJGlu
  Y2xcIiB9ICIsCisgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIoZ3JlcCB7LXIg
  XCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworICAgICAgICAgICAgICAgICAgICB9CiAJCXBy
  aW50IE9VVCAoJHQsCiAJCQkgICAicmVxdWlyZSBcIlwkUkVNWzBdXCIgaWYgXEBSRU07XG4iKTsK
  ICAgICAgICAgICAgICAgICAkdGFiIC09IDQ7CkBAIC0yMDgsNiArMjE4LDE0IEBAIHdoaWxlIChk
  ZWZpbmVkIChteSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCQkJICAgIn07XG4iKTsKIAkJcHJp
  bnQgT1VUICgkdCwKIAkJCSAgICJ3YXJuKFwkXEApIGlmIFwkXEA7XG4iKTsKKyAgICAgICAgICAg
  ICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICAkaW5jbCA9fiBzL1wuaCQvLnBoLzsK
  KyAgICAgICAgICAgICAgICAgICAgIyBjb3B5IHRoZSBwcmVmaXggaW4gdGhlIHF1b3RlIHN5bnRh
  eCAoI2luY2x1ZGUgInguaCIpIGNhc2UKKyAgICAgICAgICAgICAgICAgICAgaWYgKCRpbmNsICF+
  IG18L3wgJiYgJGluY2xfcXVvdGUgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4oLiopL3wpIHsKKyAg
  ICAgICAgICAgICAgICAgICAgICAgICRpbmNsID0gIiQxLyRpbmNsIjsKKyAgICAgICAgICAgICAg
  ICAgICAgfQorCQkgICAgcHJpbnQgT1VUICR0LCJyZXF1aXJlICckaW5jbCc7XG4iOworICAgICAg
  ICAgICAgICAgIH0KIAkgICAgfSBlbHNpZiAoL15pZmRlZlxzKyhcdyspLykgewogCQlwcmludCBP
  VVQgJHQsImlmKGRlZmluZWQoJiQxKSkge1xuIjsKIAkJJHRhYiArPSA0OwpAQCAtMjU1LDE1ICsy
  NzMsMTkgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJICAg
  IH0gZWxzaWYoL15pZGVudFxzKyguKikvKSB7CiAJCXByaW50IE9VVCAkdCwgIiMgJDFcbiI7CiAJ
  ICAgIH0KLSAJfSBlbHNpZigvXlxzKih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3
  KlxzKik/XHsvKSB7Ci0JICAgIHVudGlsKC9cfS4qPzsvKSB7Ci0JCWNob21wKCRuZXh0ID0gPElO
  Pik7CisJfSBlbHNpZigvXlxzKih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3Klxz
  Kik/LykgeworCSAgICB1bnRpbCgvXHtbXn1dKlx9Lio7LyB8fCAvOy8pIHsKKwkJbGFzdCB1bmxl
  c3MgZGVmaW5lZCAoJG5leHQgPSBuZXh0X2xpbmUoJGZpbGUpKTsKKwkJY2hvbXAgJG5leHQ7CisJ
  CSMgZHJvcCAiI2RlZmluZSBGT08gRk9PIiBpbiBlbnVtcworCQkkbmV4dCA9fiBzL15ccyojXHMq
  ZGVmaW5lXHMrKFx3KylccytcMVxzKiQvLzsKIAkJJF8gLj0gJG5leHQ7CiAJCXByaW50IE9VVCAi
  IyAkbmV4dFxuIiBpZiAkb3B0X0Q7CiAJICAgIH0KKwkgICAgcy8jXHMqaWYuKj8jXHMqZW5kaWYv
  L2c7ICMgZHJvcCAjaWZkZWZzCiAJICAgIHNAL1wqLio/XCovQEBnOwogCSAgICBzL1xzKy8gL2c7
  Ci0JICAgIC9eXHM/KHR5cGVkZWZccz8pP2VudW1ccz8oW2EtekEtWl9dXHcqKT9ccz9ceyguKilc
  fVxzPyhbYS16QS1aX11cdyopP1xzPzsvOworCSAgICBuZXh0IHVubGVzcyAvXlxzPyh0eXBlZGVm
  XHM/KT9lbnVtXHM/KFthLXpBLVpfXVx3Kik/XHM/XHsoLiopXH1ccz8oW2EtekEtWl9dXHcqKT9c
  cz87LzsKIAkgICAgKG15ICRlbnVtX3N1YnMgPSAkMykgPX4gcy9ccy8vZzsKIAkgICAgbXkgQGVu
  dW1fc3VicyA9IHNwbGl0KC8sLywgJGVudW1fc3Vicyk7CiAJICAgIG15ICRlbnVtX3ZhbCA9IC0x
  OwpAQCAtMjg1LDIyICszMDcsMjIgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9m
  aWxlKCkpKSB7CiAJICAgIH0KIAl9CiAgICAgfQotICAgIHByaW50IE9VVCAiMTtcbiI7Ci0KICAg
  ICAkSXNfY29udmVydGVkeyRmaWxlfSA9IDE7CisgICAgaWYgKCRvcHRfZSAmJiBleGlzdHMoJGJh
  ZF9maWxleyRmaWxlfSkpIHsKKyAgICAgICAgdW5saW5rKCREZXN0X2RpciAuICcvJyAuICRvdXRm
  aWxlKTsKKyAgICAgICAgJG5leHQgPSAnJzsKKyAgICB9IGVsc2UgeworICAgICAgICBwcmludCBP
  VVQgIjE7XG4iOwogICAgIHF1ZXVlX2luY2x1ZGVzX2Zyb20oJGZpbGUpIGlmICgkb3B0X2EpOwor
  ICAgIH0KIH0KIAotZXhpdCAkRXhpdDsKLQotCi1zdWIgcmVpbmRlbnQoJCkgewotICAgIG15KCR0
  ZXh0KSA9IHNoaWZ0OwotICAgICR0ZXh0ID1+IHMvXG4vXG4gICAgL2c7Ci0gICAgJHRleHQgPX4g
  cy8gICAgICAgIC9cdC9nOwotICAgICR0ZXh0OworaWYgKCRvcHRfZSAmJiAoc2NhbGFyKGtleXMg
  JWJhZF9maWxlKSA+IDApKSB7CisgICAgd2FybiAiV2FzIHVuYWJsZSB0byBjb252ZXJ0IHRoZSBm
  b2xsb3dpbmcgZmlsZXM6XG4iOworICAgIHdhcm4gIlx0IiAuIGpvaW4oIlxuXHQiLHNvcnQoa2V5
  cyAlYmFkX2ZpbGUpKSAuICJcbiI7CiB9CiAKK2V4aXQgJEV4aXQ7CiAKIHN1YiBleHByIHsKICAg
  ICBteSAkam9pbmVkX2FyZ3M7CkBAIC0zMTEsOCArMzMzLDIxIEBAIHN1YiBleHByIHsKIAlzL15c
  JlwmLy8gJiYgZG8geyAkbmV3IC49ICIgJiYiOyBuZXh0O307ICMgaGFuZGxlICYmIG9wZXJhdG9y
  CiAJcy9eXCYoW1woYS16XCldKykvJDEvaTsJIyBoYWNrIGZvciB0aGluZ3MgdGhhdCB0YWtlIHRo
  ZSBhZGRyZXNzIG9mCiAJcy9eKFxzKykvLwkJJiYgZG8geyRuZXcgLj0gJyAnOyBuZXh0O307Ci0J
  cy9eKDBYWzAtOUEtRl0rKVtVTF0qLy9pCSYmIGRvIHskbmV3IC49IGxjKCQxKTsgbmV4dDt9Owot
  CXMvXigtP1xkK1wuXGQrRVstK11cZCspRj8vL2kJJiYgZG8geyRuZXcgLj0gJDE7IG5leHQ7fTsK
  KwlzL14wWChbMC05QS1GXSspW1VMXSovL2kgCisJICAgICYmIGRvIHtteSAkaGV4ID0gJDE7CisJ
  CSAgICRoZXggPX4gcy9eMCsvLzsKKwkJICAgaWYgKGxlbmd0aCAkaGV4ID4gOCAmJiAhJENvbmZp
  Z3t1c2U2NGJpdGludH0pIHsKKwkJICAgICAgICMgQ3JvYWsgaWYgbnZfcHJlc2VydmVzX3V2X2Jp
  dHMgPCA2NCA/CisJCSAgICAgICAkbmV3IC49ICAgICAgICAgaGV4KHN1YnN0cigkaGV4LCAtOCkp
  ICsKKwkJCSAgICAgICAyKiozMiAqIGhleChzdWJzdHIoJGhleCwgIDAsIC04KSk7CisJCSAgICAg
  ICAjIFRoZSBhYm92ZSB3aWxsIHByb2R1Y2UgImVycm9ybmV1cyIgY29kZQorCQkgICAgICAgIyBp
  ZiB0aGUgaGV4IGNvbnN0YW50IHdhcyBlLmcuIGluc2lkZSBVSU5UNjRfQworCQkgICAgICAgIyBt
  YWNybywgYnV0IHRoZW4gYWdhaW4sIGgycGggaXMgYW4gYXBwcm94aW1hdGlvbi4KKwkJICAgfSBl
  bHNlIHsKKwkJICAgICAgICRuZXcgLj0gbGMoIjB4JGhleCIpOworCQkgICB9CisJCSAgIG5leHQ7
  fTsKKwlzL14oLT9cZCtcLlxkK0VbLStdP1xkKylbRkxdPy8vaQkmJiBkbyB7JG5ldyAuPSAkMTsg
  bmV4dDt9OwogCXMvXihcZCspXHMqW0xVXSovL2kJJiYgZG8geyRuZXcgLj0gJDE7IG5leHQ7fTsK
  IAlzL14oIihcXCJ8W14iXSkqIikvLwkmJiBkbyB7JG5ldyAuPSAkMTsgbmV4dDt9OwogCXMvXico
  KFxcInxbXiJdKSopJy8vCSYmIGRvIHsKQEAgLTM1MSw3ICszODYsNyBAQCBzdWIgZXhwciB7CiAJ
  IyBFbGltaW5hdGUgdHlwZWRlZnMKIAkvXCgoW1x3XHNdKylbXCpcc10qXClccypbXHdcKF0vICYm
  IGRvIHsKIAkgICAgZm9yZWFjaCAoc3BsaXQgL1xzKy8sICQxKSB7ICAjIE1ha2Ugc3VyZSBhbGwg
  dGhlIHdvcmRzIGFyZSB0eXBlcywKLQkJbGFzdCB1bmxlc3MgKCRpc2F0eXBleyRffSBvciAkXyBl
  cSAnc3RydWN0Jyk7CisJCWxhc3QgdW5sZXNzICgkaXNhdHlwZXskX30gb3IgJF8gZXEgJ3N0cnVj
  dCcgb3IgJF8gZXEgJ3VuaW9uJyk7CiAJICAgIH0KIAkgICAgcy9cKFtcd1xzXStbXCpcc10qXCkv
  LyAmJiBuZXh0OyAgICAgICMgdGhlbiBlbGltaW5hdGUgdGhlbS4KIAl9OwpAQCAtMzc0LDcgKzQw
  OSw3IEBAIHN1YiBleHByIHsKIAl9OwogCXMvXihbX2EtekEtWl1cdyopLy8JJiYgZG8gewogCSAg
  ICBteSAkaWQgPSAkMTsKLQkgICAgaWYgKCRpZCBlcSAnc3RydWN0JykgeworCSAgICBpZiAoJGlk
  IGVxICdzdHJ1Y3QnIHx8ICRpZCBlcSAndW5pb24nKSB7CiAJCXMvXlxzKyhcdyspLy87CiAJCSRp
  ZCAuPSAnICcgLiAkMTsKIAkJJGlzYXR5cGV7JGlkfSA9IDE7CkBAIC0zODcsOCArNDIyLDggQEAg
  c3ViIGV4cHIgewogCQkkbmV3IC49ICctPicgaWYgL15bXFtce10vOwogCSAgICB9IGVsc2lmICgk
  aWQgZXEgJ2RlZmluZWQnKSB7CiAJCSRuZXcgLj0gJ2RlZmluZWQnOwotCSAgICB9IGVsc2lmICgv
  XlwoLykgewotCQlzL15cKChcdyksLygiJDEiLC8gaWYgJGlkID1+IC9eX0lPW1dSXSokL2k7CSMg
  Y2hlYXQKKwkgICAgfSBlbHNpZiAoL15ccypcKC8pIHsKKwkJcy9eXHMqXCgoXHcpLC8oIiQxIiwv
  IGlmICRpZCA9fiAvXl9JT1tXUl0qJC9pOwkjIGNoZWF0CiAJCSRuZXcgLj0gIiAmJGlkIjsKIAkg
  ICAgfSBlbHNpZiAoJGlzYXR5cGV7JGlkfSkgewogCQlpZiAoJG5ldyA9fiAve1xzKiQvKSB7CkBA
  IC00MDEsNyArNDM2LDcgQEAgc3ViIGV4cHIgewogCQl9CiAJICAgIH0gZWxzZSB7CiAJCWlmICgk
  aW5pZiAmJiAkbmV3ICF+IC9kZWZpbmVkXHMqXCgkLykgewotCQkgICAgJG5ldyAuPSAnKGRlZmlu
  ZWQoJicgLiAkaWQgLiAnKSA/ICYnIC4gJGlkIC4gJyA6IDApJzsKKwkJICAgICRuZXcgLj0gJyhk
  ZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAmJyAuICRpZCAuICcgOiB1bmRlZiknOwogCQl9IGVsc2lm
  ICgvXlxbLykgewogCQkgICAgJG5ldyAuPSAiIFwkJGlkIjsKIAkJfSBlbHNlIHsKQEAgLTQxNSw2
  ICs0NTAsMTAxIEBAIHN1YiBleHByIHsKIH0KIAogCitzdWIgbmV4dF9saW5lCit7CisgICAgbXkg
  JGZpbGUgPSBzaGlmdDsKKyAgICBteSAoJGluLCAkb3V0KTsKKyAgICBteSAkcHJlX3N1Yl90cmlf
  Z3JhcGhzID0gMTsKKworICAgIFJFQUQ6IHdoaWxlIChub3QgZW9mIElOKSB7CisgICAgICAgICRp
  biAgLj0gPElOPjsKKyAgICAgICAgY2hvbXAgJGluOworICAgICAgICBuZXh0IHVubGVzcyBsZW5n
  dGggJGluOworCisgICAgICAgIHdoaWxlIChsZW5ndGggJGluKSB7CisgICAgICAgICAgICBpZiAo
  JHByZV9zdWJfdHJpX2dyYXBocykgeworICAgICAgICAgICAgICAgICMgUHJlcHJvY2VzcyBhbGwg
  dHJpLWdyYXBocyAKKyAgICAgICAgICAgICAgICAjIGluY2x1ZGluZyB0aGluZ3Mgc3R1Y2sgaW4g
  cXVvdGVkIHN0cmluZyBjb25zdGFudHMuCisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cPz0v
  Iy9nOyAgICAgICAgICAgICAgICAgICAgICAgICAjIHwgPz89fCAgI3wKKyAgICAgICAgICAgICAg
  ICAkaW4gPX4gcy9cP1w/XCEvfC9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/PyF8ICB8
  fAorICAgICAgICAgICAgICAgICRpbiA9fiBzL1w/XD8nL14vZzsgICAgICAgICAgICAgICAgICAg
  ICAgICAgIyB8ID8/J3wgIF58CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1woL1svZzsg
  ICAgICAgICAgICAgICAgICAgICAgICAjIHwgPz8ofCAgW3wKKyAgICAgICAgICAgICAgICAkaW4g
  PX4gcy9cP1w/XCkvXS9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pyl8ICBdfAorICAg
  ICAgICAgICAgICAgICRpbiA9fiBzL1w/XD9cLS9+L2c7ICAgICAgICAgICAgICAgICAgICAgICAg
  IyB8ID8/LXwgIH58CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1wvL1xcL2c7ICAgICAg
  ICAgICAgICAgICAgICAgICAjIHwgPz8vfCAgXHwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9c
  P1w/PC97L2c7ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pzx8ICB7fAorICAgICAgICAg
  ICAgICAgICRpbiA9fiBzL1w/XD8+L30vZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/
  PnwgIH18CisgICAgICAgICAgICB9CisJICAgIGlmICgkaW4gPX4gL15cI2lmZGVmIF9fTEFOR1VB
  R0VfUEFTQ0FMX18vKSB7CisgICAgICAgICAgICAgICAgIyBUcnU2NCBkaXNhc3NlbWJsZXIuaCBl
  dmlsbmVzczogbWl4ZWQgQyBhbmQgUGFzY2FsLgorCQl3aGlsZSAoPElOPikgeworCQkgICAgbGFz
  dCBpZiAvXlwjZW5kaWYvOyAKKwkJfQorCQluZXh0IFJFQUQ7CisJICAgIH0KKwkgICAgaWYgKCRp
  biA9fiAvXmV4dGVybiBpbmxpbmUgLyAmJiAjIElubGluZWQgYXNzZW1ibGVyLgorCQkkXk8gZXEg
  J2xpbnV4JyAmJiAkZmlsZSA9fiBtISg/Ol58Lylhc20vW14vXStcLmgkISkgeworIAkJd2hpbGUg
  KDxJTj4pIHsKKwkJICAgIGxhc3QgaWYgL159LzsgCisJCX0KKwkJbmV4dCBSRUFEOworCSAgICB9
  CisgICAgICAgICAgICBpZiAoJGluID1+IHMvXFwkLy8pIHsgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAjIFwtbmV3bGluZQorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAnOworICAgICAg
  ICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oW14i
  J1xcXC9dKykvLykgeyAgICAgICAgICAgICMgUGFzc3Rocm91Z2gKKyAgICAgICAgICAgICAgICAk
  b3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXihcXC4pLy8pIHsg
  ICAgICAgICAgICAgICAgICAgIyBcLi4uCisgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsK
  KyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiAvXicvKSB7ICAgICAgICAgICAgICAgICAgICAg
  ICAgICMgJy4uLgorICAgICAgICAgICAgICAgIGlmICgkaW4gPX4gcy9eKCcoXFwufFteJ1xcXSkq
  JykvLykgeworICAgICAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAg
  ICAgIH0gZWxzZSB7CisgICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAg
  ICAgICB9CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gL14iLykgeyAgICAgICAgICAgICAg
  ICAgICAgICAgICAjICIuLi4KKyAgICAgICAgICAgICAgICBpZiAoJGluID1+IHMvXigiKFxcLnxb
  XiJcXF0pKiIpLy8pIHsKKyAgICAgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsKKyAgICAg
  ICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICBuZXh0IFJFQUQ7CisgICAg
  ICAgICAgICAgICAgfQorICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXlwvXC8uKi8vKSB7
  ICAgICAgICAgICAgICAgICAgIyAvLy4uLgorICAgICAgICAgICAgICAgICMgZmFsbCB0aHJvdWdo
  CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gbS9eXC9cKi8pIHsgICAgICAgICAgICAgICAg
  ICAgICAjIC8qLi4uCisgICAgICAgICAgICAgICAgIyBDIGNvbW1lbnQgcmVtb3ZhbCBhZGFwdGVk
  IGZyb20gcGVybGZhcTY6CisgICAgICAgICAgICAgICAgaWYgKCRpbiA9fiBzL15cL1wqW14qXSpc
  KisoW15cLypdW14qXSpcKispKlwvLy8pIHsKKyAgICAgICAgICAgICAgICAgICAgJG91dCAgICAu
  PSAnICc7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAjIEluY29tcGxldGUgLyogKi8KKyAgICAgICAgICAgICAgICAgICAgbmV4dCBS
  RUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14o
  XC8pLy8pIHsgICAgICAgICAgICAgICAgICAgICMgLy4uLgorICAgICAgICAgICAgICAgICRvdXQg
  ICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFteXCdcIlxcXC9dKykv
  LykgeworICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lm
  ICgkXk8gZXEgJ2xpbnV4JyAmJgorICAgICAgICAgICAgICAgICAgICAgJGZpbGUgPX4gbSEoPzpe
  fC8pbGludXgvYnl0ZW9yZGVyL3BkcF9lbmRpYW5cLmgkISAmJgorICAgICAgICAgICAgICAgICAg
  ICAgJGluICAgPX4gcyFcJ1QgS05PVyEhKSB7CisgICAgICAgICAgICAgICAgJG91dCAgICA9fiBz
  IUkgRE9OJCFJX0RPX05PVF9LTk9XITsKKyAgICAgICAgICAgIH0gZWxzZSB7CisgICAgICAgICAg
  ICAgICAgaWYgKCRvcHRfZSkgeworICAgICAgICAgICAgICAgICAgICB3YXJuICJDYW5ub3QgcGFy
  c2UgJGZpbGU6XG4kaW5cbiI7CisgICAgICAgICAgICAgICAgICAgICRiYWRfZmlsZXskZmlsZX0g
  PSAxOworICAgICAgICAgICAgICAgICAgICAkaW4gPSAnJzsKKyAgICAgICAgICAgICAgICAgICAg
  JG91dCA9IHVuZGVmOworICAgICAgICAgICAgICAgICAgICBsYXN0IFJFQUQ7CisgICAgICAgICAg
  ICAgICAgfSBlbHNlIHsKKwkJZGllICJDYW5ub3QgcGFyc2U6XG4kaW5cbiI7CisgICAgICAgICAg
  ICAgICAgfQorICAgICAgICAgICAgfQorICAgICAgICB9CisKKyAgICAgICAgbGFzdCBSRUFEIGlm
  ICRvdXQgPX4gL1xTLzsKKyAgICB9CisKKyAgICByZXR1cm4gJG91dDsKK30KKworCiAjIEhhbmRs
  ZSByZWN1cnNpdmUgc3ViZGlyZWN0b3JpZXMgd2l0aG91dCBnZXR0aW5nIGEgZ3JvdGVzcXVlbHkg
  YmlnIHN0YWNrLgogIyBDb3VsZCB0aGlzIGJlIGltcGxlbWVudGVkIHVzaW5nIEZpbGU6OkZpbmQ/
  CiBzdWIgbmV4dF9maWxlCkBAIC01MTQsOCArNjQ0LDEzIEBAIHN1YiBxdWV1ZV9pbmNsdWRlc19m
  cm9tCiAgICAgICAgICAgICAgICAgJGxpbmUgLj0gPEhFQURFUj47CiAgICAgICAgICAgICB9CiAK
  LSAgICAgICAgICAgIGlmICgkbGluZSA9fiAvXiNccyppbmNsdWRlXHMrPCguKj8pPi8pIHsKLSAg
  ICAgICAgICAgICAgICBwdXNoKEBBUkdWLCAkMSkgdW5sZXNzICRJc19jb252ZXJ0ZWR7JDF9Owor
  ICAgICAgICAgICAgaWYgKCRsaW5lID1+IC9eI1xzKmluY2x1ZGVccysoWzwiXSkoLio/KVs+Il0v
  KSB7CisgICAgICAgICAgICAgICAgbXkgKCRkZWxpbWl0ZXIsICRuZXdfZmlsZSkgPSAoJDEsICQy
  KTsKKyAgICAgICAgICAgICAgICAjIGNvcHkgdGhlIHByZWZpeCBpbiB0aGUgcXVvdGUgc3ludGF4
  ICgjaW5jbHVkZSAieC5oIikgY2FzZQorICAgICAgICAgICAgICAgIGlmICgkZGVsaW1pdGVyIGVx
  IHF7In0gJiYgJGZpbGUgPX4gbXxeKC4qKS98KSB7CisgICAgICAgICAgICAgICAgICAgICRuZXdf
  ZmlsZSA9ICIkMS8kbmV3X2ZpbGUiOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAgICAgICAg
  ICBwdXNoKEBBUkdWLCAkbmV3X2ZpbGUpIHVubGVzcyAkSXNfY29udmVydGVkeyRuZXdfZmlsZX07
  CiAgICAgICAgICAgICB9CiAgICAgICAgIH0KICAgICBjbG9zZSBIRUFERVI7CkBAIC01NTYsMjUg
  KzY5MSw1MCBAQCBzdWIgYnVpbGRfcHJlYW1ibGVfaWZfbmVjZXNzYXJ5CiAgICAgbXkgKCVkZWZp
  bmUpID0gX2V4dHJhY3RfY2NfZGVmaW5lcygpOwogCiAgICAgb3BlbiAgUFJFQU1CTEUsICI+JHBy
  ZWFtYmxlIiBvciBkaWUgIkNhbm5vdCBvcGVuICRwcmVhbWJsZTogICQhIjsKLSAgICAgICAgcHJp
  bnQgUFJFQU1CTEUgIiMgVGhpcyBmaWxlIHdhcyBjcmVhdGVkIGJ5IGgycGggdmVyc2lvbiAkVkVS
  U0lPTlxuIjsKLQotICAgICAgICBmb3JlYWNoIChzb3J0IGtleXMgJWRlZmluZSkgewotICAgICAg
  ICAgICAgaWYgKCRvcHRfRCkgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFICIjICRf
  PSRkZWZpbmV7JF99XG4iOwotICAgICAgICAgICAgfQotCi0gICAgICAgICAgICBpZiAoJGRlZmlu
  ZXskX30gPX4gL15cZCskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAg
  ICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJGRlZmlu
  ZXskX30gfSB9XG5cbiI7Ci0gICAgICAgICAgICB9IGVsc2lmICgkZGVmaW5leyRffSA9fiAvXlx3
  KyQvKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJFQU1CTEUKLSAgICAgICAgICAgICAgICAg
  ICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAmJGRlZmluZXskX30gfSB9XG5c
  biI7Ci0gICAgICAgICAgICB9IGVsc2UgeworCXByaW50IFBSRUFNQkxFICIjIFRoaXMgZmlsZSB3
  YXMgY3JlYXRlZCBieSBoMnBoIHZlcnNpb24gJFZFUlNJT05cbiI7CisgICAgICAgICMgUHJldmVu
  dCBub24tcG9ydGFibGUgaGV4IGNvbnN0YW50cyBmcm9tIHdhcm5pbmcuCisgICAgICAgICMKKyAg
  ICAgICAgIyBXZSBzdGlsbCBwcm9kdWNlIGFuIG92ZXJmbG93IHdhcm5pbmcgaWYgd2UgY2FuJ3Qg
  cmVwcmVzZW50CisgICAgICAgICMgYSBoZXggY29uc3RhbnQgYXMgYW4gaW50ZWdlci4KKyAgICAg
  ICAgcHJpbnQgUFJFQU1CTEUgIm5vIHdhcm5pbmdzIHF3KHBvcnRhYmxlKTtcbiI7CisKKwlmb3Jl
  YWNoIChzb3J0IGtleXMgJWRlZmluZSkgeworCSAgICBpZiAoJG9wdF9EKSB7CisJCXByaW50IFBS
  RUFNQkxFICIjICRfPSRkZWZpbmV7JF99XG4iOworCSAgICB9CisJICAgIGlmICgkZGVmaW5leyRf
  fSA9fiAvXlwoKC4qKVwpJC8pIHsKKwkJIyBwYXJlbnRoZXNpemVkIHZhbHVlOiAgZD0odikKKwkJ
  JGRlZmluZXskX30gPSAkMTsKKwkgICAgfQorCSAgICBpZiAoJGRlZmluZXskX30gPX4gL14oWyst
  XT8oXGQrKT9cLlxkKyhbZUVdWystXT9cZCspPylbRkxdPyQvKSB7CisJCSMgZmxvYXQ6CisJCXBy
  aW50IFBSRUFNQkxFCisJCSAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICQx
  IH0gfVxuXG4iOworCSAgICB9IGVsc2lmICgkZGVmaW5leyRffSA9fiAvXihbKy1dP1xkKylVP0x7
  MCwyfSQvaSkgeworCQkjIGludGVnZXI6CisJCXByaW50IFBSRUFNQkxFCisJCSAgICAidW5sZXNz
  IChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOworICAgICAgICAgICAgfSBl
  bHNpZiAoJGRlZmluZXskX30gPX4gL14oWystXT8weFtcZGEtZl0rKVU/THswLDJ9JC9pKSB7Cisg
  ICAgICAgICAgICAgICAgIyBoZXggaW50ZWdlcgorICAgICAgICAgICAgICAgICMgU3BlY2lhbCBj
  YXNlZCwgc2luY2UgcGVybCB3YXJucyBvbiBoZXggaW50ZWdlcnMKKyAgICAgICAgICAgICAgICAj
  IHRoYXQgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgaW4gYSBVVi4KKyAgICAgICAgICAgICAgICAjCisg
  ICAgICAgICAgICAgICAgIyBUaGlzIHdheSB3ZSBnZXQgdGhlIHdhcm5pbmcgYXQgdGltZSBvZiB1
  c2UsIHNvIHRoZSB1c2VyCisgICAgICAgICAgICAgICAgIyBvbmx5IGdldHMgdGhlIHdhcm5pbmcg
  aWYgdGhleSBoYXBwZW4gdG8gdXNlIHRoaXMKKyAgICAgICAgICAgICAgICAjIHBsYXRmb3JtLXNw
  ZWNpZmljIGRlZmluaXRpb24uCisgICAgICAgICAgICAgICAgbXkgJGNvZGUgPSAkMTsKKyAgICAg
  ICAgICAgICAgICAkY29kZSA9ICJoZXgoJyRjb2RlJykiIGlmIGxlbmd0aCAkY29kZSA+IDEwOwog
  ICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAgICAgICAgICAgICAgICAgICJ1bmxl
  c3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgXCIiLAotICAgICAgICAgICAgICAgICAgICBx
  dW90ZW1ldGEoJGRlZmluZXskX30pLCAiXCIgfSB9XG5cbiI7Ci0gICAgICAgICAgICB9Ci0gICAg
  ICAgIH0KKyAgICAgICAgICAgICAgICAgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRf
  KCkgeyAkY29kZSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL15cdysk
  LykgeworCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3Vi
  ICRfKCkgeyAmJGRlZmluZXskX30gfSB9XG5cbiI7CisJICAgIH0gZWxzZSB7CisJCXByaW50IFBS
  RUFNQkxFCisJCSAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7IFwiIiwKKwkJ
  ICAgIHF1b3RlbWV0YSgkZGVmaW5leyRffSksICJcIiB9IH1cblxuIjsKKwkgICAgfQorCX0KICAg
  ICBjbG9zZSBQUkVBTUJMRSAgICAgICAgICAgICAgIG9yIGRpZSAiQ2Fubm90IGNsb3NlICRwcmVh
  bWJsZTogICQhIjsKIH0KIApAQCAtNTg2LDE1ICs3NDYsMTQgQEAgc3ViIF9leHRyYWN0X2NjX2Rl
  ZmluZXMKIHsKICAgICBteSAlZGVmaW5lOwogICAgIG15ICRhbGxzeW1ib2xzICA9IGpvaW4gIiAi
  LAotICAgICAgICBAQ29uZmlneydjY3N5bWJvbHMnLCAnY3Bwc3ltYm9scycsICdjcHBjY3N5bWJv
  bHMnfTsKKwlAQ29uZmlneydjY3N5bWJvbHMnLCAnY3Bwc3ltYm9scycsICdjcHBjY3N5bWJvbHMn
  fTsKIAogICAgICMgU3BsaXQgY29tcGlsZXIgcHJlLWRlZmluaXRpb25zIGludG8gYGtleT12YWx1
  ZScgcGFpcnM6Ci0gICAgZm9yZWFjaCAoc3BsaXQgL1xzKy8sICRhbGxzeW1ib2xzKSB7Ci0gICAg
  ICAgIC8oLis/KT0oLispLyBhbmQgJGRlZmluZXskMX0gPSAkMjsKLQotICAgICAgICBpZiAoJG9w
  dF9EKSB7Ci0gICAgICAgICAgICBwcmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7Ci0gICAg
  ICAgIH0KKyAgICB3aGlsZSAoJGFsbHN5bWJvbHMgPX4gLyhbXlxzXSspPSgoXFxcc3xbXlxzXSkr
  KS9nKSB7CisJJGRlZmluZXskMX0gPSAkMjsKKwlpZiAoJG9wdF9EKSB7CisJICAgIHByaW50IFNU
  REVSUiAiJF86ICAkMSAtPiAkMlxuIjsKKwl9CiAgICAgfQogCiAgICAgcmV0dXJuICVkZWZpbmU7
  CkBAIC02MjMsNiArNzgyLDEwIEBAIEl0IGlzIG1vc3QgZWFzaWx5IHJ1biB3aGlsZSBpbiAvdXNy
  L2luY2x1ZGU6CiAKIAljZCAvdXNyL2luY2x1ZGU7IGgycGggKiBzeXMvKgogCitvcgorCisJY2Qg
  L3Vzci9pbmNsdWRlOyBoMnBoICogc3lzLyogYXJwYS8qIG5ldGluZXQvKgorCiBvcgogCiAJY2Qg
  L3Vzci9pbmNsdWRlOyBoMnBoIC1yIC1sIC4KQEAgLTY0MCw3ICs4MDMsNyBAQCBJZiBydW4gd2l0
  aCBubyBhcmd1bWVudHMsIGZpbHRlcnMgc3RhbmRhcmQgaW5wdXQgdG8gc3RhbmRhcmQgb3V0cHV0
  LgogPWl0ZW0gLWQgZGVzdGluYXRpb25fZGlyCiAKIFB1dCB0aGUgcmVzdWx0aW5nIEI8LnBoPiBm
  aWxlcyBiZW5lYXRoIEI8ZGVzdGluYXRpb25fZGlyPiwgaW5zdGVhZCBvZgotYmVuZWF0aCB0aGUg
  ZGVmYXVsdCBQZXJsIGxpYnJhcnkgbG9jYXRpb24gKEM8JENvbmZpZ3snaW5zdGFsbHNpdHNlYXJj
  aCd9PikuCitiZW5lYXRoIHRoZSBkZWZhdWx0IFBlcmwgbGlicmFyeSBsb2NhdGlvbiAoQzwkQ29u
  ZmlneydpbnN0YWxsc2l0ZWFyY2gnfT4pLgogCiA9aXRlbSAtcgogCkBAIC03MjUsMTAgKzg4OCwx
  MCBAQCBpbnN0YWxsYXRpb24uCiBEb2Vzbid0IGhhbmRsZSBjb21wbGljYXRlZCBleHByZXNzaW9u
  cyBidWlsdCBwaWVjZW1lYWwsIGEgbGE6CiAKICAgICBlbnVtIHsKLSAgICAgICAgRklSU1RfVkFM
  VUUsCi0gICAgICAgIFNFQ09ORF9WQUxVRSwKKwlGSVJTVF9WQUxVRSwKKwlTRUNPTkRfVkFMVUUs
  CiAgICAgI2lmZGVmIEFCQwotICAgICAgICBUSElSRF9WQUxVRQorCVRISVJEX1ZBTFVFCiAgICAg
  I2VuZGlmCiAgICAgfTsKIAo=
  UH2PH562
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTM2LDEzICszNiwxNiBAQAog
  CiBwcmludCBPVVQgPDwnIU5PIVNVQlMhJzsKIAordXNlIHN0cmljdDsKKwogdXNlIENvbmZpZzsK
  IHVzZSBGaWxlOjpQYXRoIHF3KG1rcGF0aCk7CiB1c2UgR2V0b3B0OjpTdGQ7CiAKIGdldG9wdHMo
  J0RkOnJsaGFRJyk7Cit1c2UgdmFycyBxdygkb3B0X0QgJG9wdF9kICRvcHRfciAkb3B0X2wgJG9w
  dF9oICRvcHRfYSAkb3B0X1EpOwogZGllICItciBhbmQgLWEgb3B0aW9ucyBhcmUgbXV0dWFsbHkg
  ZXhjbHVzaXZlXG4iIGlmICgkb3B0X3IgYW5kICRvcHRfYSk7Ci1AaW5jX2RpcnMgPSBpbmNfZGly
  cygpIGlmICRvcHRfYTsKK215IEBpbmNfZGlycyA9IGluY19kaXJzKCkgaWYgJG9wdF9hOwogCiBt
  eSAkRXhpdCA9IDA7CiAKQEAgLTUwLDcgKzUzLDcgQEAKIGRpZSAiRGVzdGluYXRpb24gZGlyZWN0
  b3J5ICREZXN0X2RpciBkb2Vzbid0IGV4aXN0IG9yIGlzbid0IGEgZGlyZWN0b3J5XG4iCiAgICAg
  dW5sZXNzIC1kICREZXN0X2RpcjsKIAotQGlzYXR5cGUgPSBzcGxpdCgnICcsPDxFTkQpOworbXkg
  QGlzYXR5cGUgPSBzcGxpdCgnICcsPDxFTkQpOwogCWNoYXIJdWNoYXIJdV9jaGFyCiAJc2hvcnQJ
  dXNob3J0CXVfc2hvcnQKIAlpbnQJdWludAl1X2ludApAQCAtNTgsMTQgKzYxLDE4IEBACiAJRklM
  RQlrZXlfdAljYWRkcl90CiBFTkQKIAorbXkgJWlzYXR5cGU7CiBAaXNhdHlwZXtAaXNhdHlwZX0g
  PSAoMSkgeCBAaXNhdHlwZTsKLSRpbmlmID0gMDsKK215ICRpbmlmID0gMDsKK215ICVJc19jb252
  ZXJ0ZWQ7CiAKIEBBUkdWID0gKCctJykgdW5sZXNzIEBBUkdWOwogCiBidWlsZF9wcmVhbWJsZV9p
  Zl9uZWNlc3NhcnkoKTsKIAotd2hpbGUgKGRlZmluZWQgKCRmaWxlID0gbmV4dF9maWxlKCkpKSB7
  CitteSAoJHQsICR0YWIsICVjdXJhcmdzLCAkbmV3LCAkZXZhbF9pbmRleCwgJGRpciwgJG5hbWUs
  ICRhcmdzLCAkb3V0ZmlsZSk7CitteSAoJGluY2wsICRuZXh0KTsKK3doaWxlIChkZWZpbmVkICht
  eSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogICAgIGlmICgtbCAkZmlsZSBhbmQgLWQgJGZpbGUp
  IHsKICAgICAgICAgbGlua19pZl9wb3NzaWJsZSgkZmlsZSkgaWYgKCRvcHRfbCk7CiAgICAgICAg
  IG5leHQ7CkBAIC0xMDEsMjQgKzEwOCw3IEBACiAgICAgfQogCiAgICAgcHJpbnQgT1VUICJyZXF1
  aXJlICdfaDJwaF9wcmUucGgnO1xuXG4iOwotICAgIHdoaWxlICg8SU4+KSB7Ci0JY2hvcDsKLQl3
  aGlsZSAoL1xcJC8pIHsKLQkgICAgY2hvcDsKLQkgICAgJF8gLj0gPElOPjsKLQkgICAgY2hvcDsK
  LQl9Ci0JcHJpbnQgT1VUICIjICRfXG4iIGlmICRvcHRfRDsKLQotCWlmIChzOi9cKjpcMjAwOmcp
  IHsKLQkgICAgczpcKi86XDIwMTpnOwotCSAgICBzL1wyMDBbXlwyMDFdKlwyMDEvL2c7CSMgZGVs
  ZXRlIHNpbmdsZSBsaW5lIGNvbW1lbnRzCi0JICAgIGlmIChzL1wyMDAuKi8vKSB7CQkjIGJlZ2lu
  IG11bHRpLWxpbmUgY29tbWVudD8KLQkJJF8gLj0gJy8qJzsKLQkJJF8gLj0gPElOPjsKLQkJcmVk
  bzsKLQkgICAgfQotCX0KKyAgICB3aGlsZSAoZGVmaW5lZCAobG9jYWwgJF8gPSBuZXh0X2xpbmUo
  KSkpIHsKIAlpZiAocy9eXHMqXCNccyovLykgewogCSAgICBpZiAocy9eZGVmaW5lXHMrKFx3Kykv
  LykgewogCQkkbmFtZSA9ICQxOwpAQCAtMTI5LDcgKzExOSw3IEBACiAgICAgCSAgICAJICAgIG15
  ICRwcm90byA9ICcoKSAnOwogCQkgICAgaWYgKCRhcmdzIG5lICcnKSB7CiAgICAgCSAgICAJICAg
  IAkkcHJvdG8gPSAnJzsKLQkJCWZvcmVhY2ggJGFyZyAoc3BsaXQoLyxccyovLCRhcmdzKSkgewor
  CQkJZm9yZWFjaCBteSAkYXJnIChzcGxpdCgvLFxzKi8sJGFyZ3MpKSB7CiAJCQkgICAgJGFyZyA9
  fiBzL15ccyooW15cc10uKlteXHNdKVxzKiQvJDEvOwogCQkJICAgICRjdXJhcmdzeyRhcmd9ID0g
  MTsKIAkJCX0KQEAgLTI0OCwyMCArMjM4LDI0IEBACiAJICAgIH0gZWxzaWYoL15pZGVudFxzKygu
  KikvKSB7CiAJCXByaW50IE9VVCAkdCwgIiMgJDFcbiI7CiAJICAgIH0KLSAJfSBlbHNpZigvXlxz
  Kih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3KlxzKik/XHsvKSB7Ci0JICAgIHVu
  dGlsKC9cfS4qPzsvKSB7Ci0JCWNob21wKCRuZXh0ID0gPElOPik7CisJfSBlbHNpZigvXlxzKih0
  eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3KlxzKik/LykgeworCSAgICB1bnRpbCgv
  XHtbXn1dKlx9Lio7LyB8fCAvOy8pIHsKKwkJbGFzdCB1bmxlc3MgZGVmaW5lZCAoJG5leHQgPSBu
  ZXh0X2xpbmUoKSk7CisJCWNob21wICRuZXh0OworCQkjIGRyb3AgIiNkZWZpbmUgRk9PIEZPTyIg
  aW4gZW51bXMKKwkJJG5leHQgPX4gcy9eXHMqI1xzKmRlZmluZVxzKyhcdyspXHMrXDFccyokLy87
  CiAJCSRfIC49ICRuZXh0OwogCQlwcmludCBPVVQgIiMgJG5leHRcbiIgaWYgJG9wdF9EOwogCSAg
  ICB9CisJICAgIHMvI1xzKmlmLio/I1xzKmVuZGlmLy9nOyAjIGRyb3AgI2lmZGVmcwogCSAgICBz
  QC9cKi4qP1wqL0BAZzsKIAkgICAgcy9ccysvIC9nOwotCSAgICAvXlxzPyh0eXBlZGVmXHM/KT9l
  bnVtXHM/KFthLXpBLVpfXVx3Kik/XHM/XHsoLiopXH1ccz8oW2EtekEtWl9dXHcqKT9ccz87LzsK
  LQkgICAgKCRlbnVtX3N1YnMgPSAkMykgPX4gcy9ccy8vZzsKLQkgICAgQGVudW1fc3VicyA9IHNw
  bGl0KC8sLywgJGVudW1fc3Vicyk7Ci0JICAgICRlbnVtX3ZhbCA9IC0xOwotCSAgICBmb3IgJGVu
  dW0gKEBlbnVtX3N1YnMpIHsKLQkJKCRlbnVtX25hbWUsICRlbnVtX3ZhbHVlKSA9ICRlbnVtID1+
  IC9eKFthLXpBLVpfXVx3KikoPS4rKT8kLzsKKwkgICAgbmV4dCB1bmxlc3MgL15ccz8odHlwZWRl
  ZlxzPyk/ZW51bVxzPyhbYS16QS1aX11cdyopP1xzP1x7KC4qKVx9XHM/KFthLXpBLVpfXVx3Kik/
  XHM/Oy87CisJICAgIChteSAkZW51bV9zdWJzID0gJDMpID1+IHMvXHMvL2c7CisJICAgIG15IEBl
  bnVtX3N1YnMgPSBzcGxpdCgvLC8sICRlbnVtX3N1YnMpOworCSAgICBteSAkZW51bV92YWwgPSAt
  MTsKKwkgICAgZm9yZWFjaCBteSAkZW51bSAoQGVudW1fc3VicykgeworCQlteSAoJGVudW1fbmFt
  ZSwgJGVudW1fdmFsdWUpID0gJGVudW0gPX4gL14oW2EtekEtWl9dXHcqKSg9LispPyQvOwogCQkk
  ZW51bV92YWx1ZSA9fiBzL149Ly87CiAJCSRlbnVtX3ZhbCA9IChsZW5ndGgoJGVudW1fdmFsdWUp
  ID8gJGVudW1fdmFsdWUgOiAkZW51bV92YWwgKyAxKTsKIAkJaWYgKCRvcHRfaCkgewpAQCAtMjgw
  LDEyICsyNzQsMTMgQEAKICAgICB9CiAgICAgcHJpbnQgT1VUICIxO1xuIjsKIAotICAgICRpc19j
  b252ZXJ0ZWR7JGZpbGV9ID0gMTsKKyAgICAkSXNfY29udmVydGVkeyRmaWxlfSA9IDE7CiAgICAg
  cXVldWVfaW5jbHVkZXNfZnJvbSgkZmlsZSkgaWYgKCRvcHRfYSk7CiB9CiAKIGV4aXQgJEV4aXQ7
  CiAKKwogc3ViIHJlaW5kZW50KCQpIHsKICAgICBteSgkdGV4dCkgPSBzaGlmdDsKICAgICAkdGV4
  dCA9fiBzL1xuL1xuICAgIC9nOwpAQCAtMjkzLDkgKzI4OCwxMSBAQAogICAgICR0ZXh0OwogfQog
  CisKIHN1YiBleHByIHsKKyAgICBteSAkam9pbmVkX2FyZ3M7CiAgICAgaWYoa2V5cyglY3VyYXJn
  cykpIHsKLQlteSgkam9pbmVkX2FyZ3MpID0gam9pbignfCcsIGtleXMoJWN1cmFyZ3MpKTsKKwkk
  am9pbmVkX2FyZ3MgPSBqb2luKCd8Jywga2V5cyglY3VyYXJncykpOwogICAgIH0KICAgICB3aGls
  ZSAoJF8gbmUgJycpIHsKIAlzL15cJlwmLy8gJiYgZG8geyAkbmV3IC49ICIgJiYiOyBuZXh0O307
  ICMgaGFuZGxlICYmIG9wZXJhdG9yCkBAIC0zNDEsMTMgKzMzOCwxMyBAQAogCSMgRWxpbWluYXRl
  IHR5cGVkZWZzCiAJL1woKFtcd1xzXSspW1wqXHNdKlwpXHMqW1x3XChdLyAmJiBkbyB7CiAJICAg
  IGZvcmVhY2ggKHNwbGl0IC9ccysvLCAkMSkgeyAgIyBNYWtlIHN1cmUgYWxsIHRoZSB3b3JkcyBh
  cmUgdHlwZXMsCi0JCWxhc3QgdW5sZXNzICgkaXNhdHlwZXskX30gb3IgJF8gZXEgJ3N0cnVjdCcp
  OworCQlsYXN0IHVubGVzcyAoJGlzYXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnIG9yICRfIGVx
  ICd1bmlvbicpOwogCSAgICB9CiAJICAgIHMvXChbXHdcc10rW1wqXHNdKlwpLy8gJiYgbmV4dDsg
  ICAgICAjIHRoZW4gZWxpbWluYXRlIHRoZW0uCiAJfTsKIAkjIHN0cnVjdC91bmlvbiBtZW1iZXIs
  IGluY2x1ZGluZyBhcnJheXM6CiAJcy9eKFtfQS1aXVx3KihcW1teXF1dK1xdKT8oKFwufC0+KVtf
  QS1aXVx3KihcW1teXF1dK1xdKT8pKykvL2kgJiYgZG8gewotCSAgICAkaWQgPSAkMTsKKwkgICAg
  bXkgJGlkID0gJDE7CiAJICAgICRpZCA9fiBzLyhcLnwoLT4pKShbXlwuXC1dKikvLT5ceyQzXH0v
  ZzsKIAkgICAgJGlkID1+IHMvXGIoW15cJF0pKCRqb2luZWRfYXJncykvJDFcJCQyL2cgaWYgbGVu
  Z3RoKCRqb2luZWRfYXJncyk7CiAJICAgIHdoaWxlKCRpZCA9fiAvXFtccyooW15cJFwmXGRcXV0r
  KVxdLykgewpAQCAtMzYzLDggKzM2MCw4IEBACiAJICAgICRuZXcgLj0gIiAoXCQkaWQpIjsKIAl9
  OwogCXMvXihbX2EtekEtWl1cdyopLy8JJiYgZG8gewotCSAgICAkaWQgPSAkMTsKLQkgICAgaWYg
  KCRpZCBlcSAnc3RydWN0JykgeworCSAgICBteSAkaWQgPSAkMTsKKwkgICAgaWYgKCRpZCBlcSAn
  c3RydWN0JyB8fCAkaWQgZXEgJ3VuaW9uJykgewogCQlzL15ccysoXHcrKS8vOwogCQkkaWQgLj0g
  JyAnIC4gJDE7CiAJCSRpc2F0eXBleyRpZH0gPSAxOwpAQCAtMzc3LDggKzM3NCw4IEBACiAJCSRu
  ZXcgLj0gJy0+JyBpZiAvXltcW1x7XS87CiAJICAgIH0gZWxzaWYgKCRpZCBlcSAnZGVmaW5lZCcp
  IHsKIAkJJG5ldyAuPSAnZGVmaW5lZCc7Ci0JICAgIH0gZWxzaWYgKC9eXCgvKSB7Ci0JCXMvXlwo
  KFx3KSwvKCIkMSIsLyBpZiAkaWQgPX4gL15fSU9bV1JdKiQvaTsJIyBjaGVhdAorCSAgICB9IGVs
  c2lmICgvXlxzKlwoLykgeworCQlzL15ccypcKChcdyksLygiJDEiLC8gaWYgJGlkID1+IC9eX0lP
  W1dSXSokL2k7CSMgY2hlYXQKIAkJJG5ldyAuPSAiICYkaWQiOwogCSAgICB9IGVsc2lmICgkaXNh
  dHlwZXskaWR9KSB7CiAJCWlmICgkbmV3ID1+IC97XHMqJC8pIHsKQEAgLTQwNSw2ICs0MDIsNjYg
  QEAKIH0KIAogCitzdWIgbmV4dF9saW5lCit7CisgICAgbXkgKCRpbiwgJG91dCk7CisgICAgbXkg
  JHByZV9zdWJfdHJpX2dyYXBocyA9IDE7CisKKyAgICBSRUFEOiB3aGlsZSAobm90IGVvZiBJTikg
  eworICAgICAgICAkaW4gIC49IDxJTj47CisgICAgICAgIGNob21wICRpbjsKKyAgICAgICAgbmV4
  dCB1bmxlc3MgbGVuZ3RoICRpbjsKKworICAgICAgICB3aGlsZSAobGVuZ3RoICRpbikgeworICAg
  ICAgICAgICAgaWYgKCRwcmVfc3ViX3RyaV9ncmFwaHMpIHsKKyAgICAgICAgICAgICAgICAjIFBy
  ZXByb2Nlc3MgYWxsIHRyaS1ncmFwaHMgCisgICAgICAgICAgICAgICAgIyBpbmNsdWRpbmcgdGhp
  bmdzIHN0dWNrIGluIHF1b3RlZCBzdHJpbmcgY29uc3RhbnRzLgorICAgICAgICAgICAgICAgICRp
  biA9fiBzL1w/XD89LyMvZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/PXwgICN8Cisg
  ICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1whL3wvZzsgICAgICAgICAgICAgICAgICAgICAg
  ICAjIHwgPz8hfCAgfHwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/Jy9eL2c7ICAgICAg
  ICAgICAgICAgICAgICAgICAgICMgfCA/Pyd8ICBefAorICAgICAgICAgICAgICAgICRpbiA9fiBz
  L1w/XD9cKC9bL2c7ICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/KHwgIFt8CisgICAgICAg
  ICAgICAgICAgJGluID1+IHMvXD9cP1wpL10vZzsgICAgICAgICAgICAgICAgICAgICAgICAjIHwg
  Pz8pfCAgXXwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/XC0vfi9nOyAgICAgICAgICAg
  ICAgICAgICAgICAgICMgfCA/Py18ICB+fAorICAgICAgICAgICAgICAgICRpbiA9fiBzL1w/XD9c
  Ly9cXC9nOyAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/L3wgIFx8CisgICAgICAgICAgICAg
  ICAgJGluID1+IHMvXD9cPzwvey9nOyAgICAgICAgICAgICAgICAgICAgICAgICAjIHwgPz88fCAg
  e3wKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/Pi99L2c7ICAgICAgICAgICAgICAgICAg
  ICAgICAgICMgfCA/Pz58ICB9fAorICAgICAgICAgICAgfQorICAgICAgICAgICAgaWYgKCRpbiA9
  fiBzL1xcJC8vKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBcLW5ld2xpbmUKKyAgICAg
  ICAgICAgICAgICAkb3V0ICAgIC49ICcgJzsKKyAgICAgICAgICAgICAgICBuZXh0IFJFQUQ7Cisg
  ICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFteIidcXFwvXSspLy8pIHsgICAgICAgICAg
  ICAjIFBhc3N0aHJvdWdoCisgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsKKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oXFwuKS8vKSB7ICAgICAgICAgICAgICAgICAgICMgXC4u
  LgorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgk
  aW4gPX4gcy9eKCcoXFwufFteJ1xcXSkqJykvLykgeyAgICAgICAjICcuLi4KKyAgICAgICAgICAg
  ICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXigiKFxc
  LnxbXiJcXF0pKiIpLy8pIHsgICAgICAgIyAiLi4uCisgICAgICAgICAgICAgICAgJG91dCAgICAu
  PSAkMTsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL15cL1wvLiovLykgeyAgICAgICAg
  ICAgICAgICAgICMgLy8uLi4KKyAgICAgICAgICAgICAgICAjIGZhbGwgdGhyb3VnaAorICAgICAg
  ICAgICAgfSBlbHNpZiAoJGluID1+IG0vXlwvXCovKSB7ICAgICAgICAgICAgICAgICAgICAgIyAv
  Ki4uLgorICAgICAgICAgICAgICAgICMgQyBjb21tZW50IHJlbW92YWwgYWRhcHRlZCBmcm9tIHBl
  cmxmYXE2OgorICAgICAgICAgICAgICAgIGlmICgkaW4gPX4gcy9eXC9cKlteKl0qXCorKFteXC8q
  XVteKl0qXCorKSpcLy8vKSB7CisgICAgICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAnOwor
  ICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgIyBJbmNvbXBsZXRlIC8qICovCisgICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAg
  ICAgICAgICAgICAgICB9CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFwvKS8vKSB7
  ICAgICAgICAgICAgICAgICAgICAjIC8uLi4KKyAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQx
  OworICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXihbXlwnXCJcXFwvXSspLy8pIHsKKyAg
  ICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNlIHsKKyAgICAg
  ICAgICAgICAgICBkaWUgIkNhbm5vdCBwYXJzZTpcbiRpblxuIjsKKyAgICAgICAgICAgIH0KKyAg
  ICAgICAgfQorCisgICAgICAgIGxhc3QgUkVBRCBpZiAkb3V0ID1+IC9cUy87CisgICAgfQorCisg
  ICAgcmV0dXJuICRvdXQ7Cit9CisKKwogIyBIYW5kbGUgcmVjdXJzaXZlIHN1YmRpcmVjdG9yaWVz
  IHdpdGhvdXQgZ2V0dGluZyBhIGdyb3Rlc3F1ZWx5IGJpZyBzdGFjay4KICMgQ291bGQgdGhpcyBi
  ZSBpbXBsZW1lbnRlZCB1c2luZyBGaWxlOjpGaW5kPwogc3ViIG5leHRfZmlsZQpAQCAtNTA1LDcg
  KzU2Miw3IEBACiAgICAgICAgICAgICB9CiAKICAgICAgICAgICAgIGlmICgkbGluZSA9fiAvXiNc
  cyppbmNsdWRlXHMrPCguKj8pPi8pIHsKLSAgICAgICAgICAgICAgICBwdXNoKEBBUkdWLCAkMSkg
  dW5sZXNzICRpc19jb252ZXJ0ZWR7JDF9OworICAgICAgICAgICAgICAgIHB1c2goQEFSR1YsICQx
  KSB1bmxlc3MgJElzX2NvbnZlcnRlZHskMX07CiAgICAgICAgICAgICB9CiAgICAgICAgIH0KICAg
  ICBjbG9zZSBIRUFERVI7CkBAIC01NTMsOSArNjEwLDkgQEAKICAgICAgICAgICAgICAgICBwcmlu
  dCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKICAgICAgICAgICAgIH0KIAotICAgICAg
  ICAgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eXGQrJC8pIHsKKyAgICAgICAgICAgIGlmICgkZGVm
  aW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKICAgICAgICAgICAgICAgICBwcmludCBQ
  UkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIg
  JF8oKSB7ICRkZWZpbmV7JF99IH0gfVxuXG4iOworICAgICAgICAgICAgICAgICAgICAidW5sZXNz
  IChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwogICAgICAgICAgICAgfSBl
  bHNpZiAoJGRlZmluZXskX30gPX4gL15cdyskLykgewogICAgICAgICAgICAgICAgIHByaW50IFBS
  RUFNQkxFCiAgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAk
  XygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOwpAQCAtNTc1LDcgKzYzMiw4IEBACiBzdWIgX2V4
  dHJhY3RfY2NfZGVmaW5lcwogewogICAgIG15ICVkZWZpbmU7Ci0gICAgbXkgJGFsbHN5bWJvbHMg
  PSBqb2luICIgIiwgQENvbmZpZ3tjY3N5bWJvbHMsIGNwcHN5bWJvbHMsIGNwcGNjc3ltYm9sc307
  CisgICAgbXkgJGFsbHN5bWJvbHMgID0gam9pbiAiICIsCisgICAgICAgIEBDb25maWd7J2Njc3lt
  Ym9scycsICdjcHBzeW1ib2xzJywgJ2NwcGNjc3ltYm9scyd9OwogCiAgICAgIyBTcGxpdCBjb21w
  aWxlciBwcmUtZGVmaW5pdGlvbnMgaW50byBga2V5PXZhbHVlJyBwYWlyczoKICAgICBmb3JlYWNo
  IChzcGxpdCAvXHMrLywgJGFsbHN5bWJvbHMpIHsKQEAgLTcwOCw4ICs3NjYsNiBAQAogSXQncyBv
  bmx5IGludGVuZGVkIGFzIGEgcm91Z2ggdG9vbC4KIFlvdSBtYXkgbmVlZCB0byBkaWNrZXIgd2l0
  aCB0aGUgZmlsZXMgcHJvZHVjZWQuCiAKLURvZXNuJ3QgcnVuIHdpdGggQzx1c2Ugc3RyaWN0Pgot
  CiBZb3UgaGF2ZSB0byBydW4gdGhpcyBwcm9ncmFtIGJ5IGhhbmQ7IGl0J3Mgbm90IHJ1biBhcyBw
  YXJ0IG9mIHRoZSBQZXJsCiBpbnN0YWxsYXRpb24uCiAK
  UH2PH570
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTEwOCwyNCArMTA4LDcgQEAK
  ICAgICB9CiAKICAgICBwcmludCBPVVQgInJlcXVpcmUgJ19oMnBoX3ByZS5waCc7XG5cbiI7Ci0g
  ICAgd2hpbGUgKDxJTj4pIHsKLQljaG9wOwotCXdoaWxlICgvXFwkLykgewotCSAgICBjaG9wOwot
  CSAgICAkXyAuPSA8SU4+OwotCSAgICBjaG9wOwotCX0KLQlwcmludCBPVVQgIiMgJF9cbiIgaWYg
  JG9wdF9EOwotCi0JaWYgKHM6L1wqOlwyMDA6ZykgewotCSAgICBzOlwqLzpcMjAxOmc7Ci0JICAg
  IHMvXDIwMFteXDIwMV0qXDIwMS8vZzsJIyBkZWxldGUgc2luZ2xlIGxpbmUgY29tbWVudHMKLQkg
  ICAgaWYgKHMvXDIwMC4qLy8pIHsJCSMgYmVnaW4gbXVsdGktbGluZSBjb21tZW50PwotCQkkXyAu
  PSAnLyonOwotCQkkXyAuPSA8SU4+OwotCQlyZWRvOwotCSAgICB9Ci0JfQorICAgIHdoaWxlIChk
  ZWZpbmVkIChsb2NhbCAkXyA9IG5leHRfbGluZSgpKSkgewogCWlmIChzL15ccypcI1xzKi8vKSB7
  CiAJICAgIGlmIChzL15kZWZpbmVccysoXHcrKS8vKSB7CiAJCSRuYW1lID0gJDE7CkBAIC0yNTUs
  MTUgKzIzOCwxOSBAQAogCSAgICB9IGVsc2lmKC9eaWRlbnRccysoLiopLykgewogCQlwcmludCBP
  VVQgJHQsICIjICQxXG4iOwogCSAgICB9Ci0gCX0gZWxzaWYoL15ccyoodHlwZWRlZlxzKik/ZW51
  bVxzKihccytbYS16QS1aX11cdypccyopP1x7LykgewotCSAgICB1bnRpbCgvXH0uKj87Lykgewot
  CQljaG9tcCgkbmV4dCA9IDxJTj4pOworCX0gZWxzaWYoL15ccyoodHlwZWRlZlxzKik/ZW51bVxz
  KihccytbYS16QS1aX11cdypccyopPy8pIHsKKwkgICAgdW50aWwoL1x7W159XSpcfS4qOy8gfHwg
  LzsvKSB7CisJCWxhc3QgdW5sZXNzIGRlZmluZWQgKCRuZXh0ID0gbmV4dF9saW5lKCkpOworCQlj
  aG9tcCAkbmV4dDsKKwkJIyBkcm9wICIjZGVmaW5lIEZPTyBGT08iIGluIGVudW1zCisJCSRuZXh0
  ID1+IHMvXlxzKiNccypkZWZpbmVccysoXHcrKVxzK1wxXHMqJC8vOwogCQkkXyAuPSAkbmV4dDsK
  IAkJcHJpbnQgT1VUICIjICRuZXh0XG4iIGlmICRvcHRfRDsKIAkgICAgfQorCSAgICBzLyNccypp
  Zi4qPyNccyplbmRpZi8vZzsgIyBkcm9wICNpZmRlZnMKIAkgICAgc0AvXCouKj9cKi9AQGc7CiAJ
  ICAgIHMvXHMrLyAvZzsKLQkgICAgL15ccz8odHlwZWRlZlxzPyk/ZW51bVxzPyhbYS16QS1aX11c
  dyopP1xzP1x7KC4qKVx9XHM/KFthLXpBLVpfXVx3Kik/XHM/Oy87CisJICAgIG5leHQgdW5sZXNz
  IC9eXHM/KHR5cGVkZWZccz8pP2VudW1ccz8oW2EtekEtWl9dXHcqKT9ccz9ceyguKilcfVxzPyhb
  YS16QS1aX11cdyopP1xzPzsvOwogCSAgICAobXkgJGVudW1fc3VicyA9ICQzKSA9fiBzL1xzLy9n
  OwogCSAgICBteSBAZW51bV9zdWJzID0gc3BsaXQoLywvLCAkZW51bV9zdWJzKTsKIAkgICAgbXkg
  JGVudW1fdmFsID0gLTE7CkBAIC0zNTEsNyArMzM4LDcgQEAKIAkjIEVsaW1pbmF0ZSB0eXBlZGVm
  cwogCS9cKChbXHdcc10rKVtcKlxzXSpcKVxzKltcd1woXS8gJiYgZG8gewogCSAgICBmb3JlYWNo
  IChzcGxpdCAvXHMrLywgJDEpIHsgICMgTWFrZSBzdXJlIGFsbCB0aGUgd29yZHMgYXJlIHR5cGVz
  LAotCQlsYXN0IHVubGVzcyAoJGlzYXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnKTsKKwkJbGFz
  dCB1bmxlc3MgKCRpc2F0eXBleyRffSBvciAkXyBlcSAnc3RydWN0JyBvciAkXyBlcSAndW5pb24n
  KTsKIAkgICAgfQogCSAgICBzL1woW1x3XHNdK1tcKlxzXSpcKS8vICYmIG5leHQ7ICAgICAgIyB0
  aGVuIGVsaW1pbmF0ZSB0aGVtLgogCX07CkBAIC0zNzQsNyArMzYxLDcgQEAKIAl9OwogCXMvXihb
  X2EtekEtWl1cdyopLy8JJiYgZG8gewogCSAgICBteSAkaWQgPSAkMTsKLQkgICAgaWYgKCRpZCBl
  cSAnc3RydWN0JykgeworCSAgICBpZiAoJGlkIGVxICdzdHJ1Y3QnIHx8ICRpZCBlcSAndW5pb24n
  KSB7CiAJCXMvXlxzKyhcdyspLy87CiAJCSRpZCAuPSAnICcgLiAkMTsKIAkJJGlzYXR5cGV7JGlk
  fSA9IDE7CkBAIC0zODcsOCArMzc0LDggQEAKIAkJJG5ldyAuPSAnLT4nIGlmIC9eW1xbXHtdLzsK
  IAkgICAgfSBlbHNpZiAoJGlkIGVxICdkZWZpbmVkJykgewogCQkkbmV3IC49ICdkZWZpbmVkJzsK
  LQkgICAgfSBlbHNpZiAoL15cKC8pIHsKLQkJcy9eXCgoXHcpLC8oIiQxIiwvIGlmICRpZCA9fiAv
  Xl9JT1tXUl0qJC9pOwkjIGNoZWF0CisJICAgIH0gZWxzaWYgKC9eXHMqXCgvKSB7CisJCXMvXlxz
  KlwoKFx3KSwvKCIkMSIsLyBpZiAkaWQgPX4gL15fSU9bV1JdKiQvaTsJIyBjaGVhdAogCQkkbmV3
  IC49ICIgJiRpZCI7CiAJICAgIH0gZWxzaWYgKCRpc2F0eXBleyRpZH0pIHsKIAkJaWYgKCRuZXcg
  PX4gL3tccyokLykgewpAQCAtNDE1LDYgKzQwMiw2NiBAQAogfQogCiAKK3N1YiBuZXh0X2xpbmUK
  K3sKKyAgICBteSAoJGluLCAkb3V0KTsKKyAgICBteSAkcHJlX3N1Yl90cmlfZ3JhcGhzID0gMTsK
  KworICAgIFJFQUQ6IHdoaWxlIChub3QgZW9mIElOKSB7CisgICAgICAgICRpbiAgLj0gPElOPjsK
  KyAgICAgICAgY2hvbXAgJGluOworICAgICAgICBuZXh0IHVubGVzcyBsZW5ndGggJGluOworCisg
  ICAgICAgIHdoaWxlIChsZW5ndGggJGluKSB7CisgICAgICAgICAgICBpZiAoJHByZV9zdWJfdHJp
  X2dyYXBocykgeworICAgICAgICAgICAgICAgICMgUHJlcHJvY2VzcyBhbGwgdHJpLWdyYXBocyAK
  KyAgICAgICAgICAgICAgICAjIGluY2x1ZGluZyB0aGluZ3Mgc3R1Y2sgaW4gcXVvdGVkIHN0cmlu
  ZyBjb25zdGFudHMuCisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cPz0vIy9nOyAgICAgICAg
  ICAgICAgICAgICAgICAgICAjIHwgPz89fCAgI3wKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9c
  P1w/XCEvfC9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/PyF8ICB8fAorICAgICAgICAg
  ICAgICAgICRpbiA9fiBzL1w/XD8nL14vZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/
  J3wgIF58CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1woL1svZzsgICAgICAgICAgICAg
  ICAgICAgICAgICAjIHwgPz8ofCAgW3wKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/XCkv
  XS9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pyl8ICBdfAorICAgICAgICAgICAgICAg
  ICRpbiA9fiBzL1w/XD9cLS9+L2c7ICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/LXwgIH58
  CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1wvL1xcL2c7ICAgICAgICAgICAgICAgICAg
  ICAgICAjIHwgPz8vfCAgXHwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/PC97L2c7ICAg
  ICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pzx8ICB7fAorICAgICAgICAgICAgICAgICRpbiA9
  fiBzL1w/XD8+L30vZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/PnwgIH18CisgICAg
  ICAgICAgICB9CisgICAgICAgICAgICBpZiAoJGluID1+IHMvXFwkLy8pIHsgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAjIFwtbmV3bGluZQorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAn
  OworICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9
  fiBzL14oW14iJ1xcXC9dKykvLykgeyAgICAgICAgICAgICMgUGFzc3Rocm91Z2gKKyAgICAgICAg
  ICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXihc
  XC4pLy8pIHsgICAgICAgICAgICAgICAgICAgIyBcLi4uCisgICAgICAgICAgICAgICAgJG91dCAg
  ICAuPSAkMTsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxdKSon
  KS8vKSB7ICAgICAgICMgJy4uLgorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAg
  ICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgeyAgICAgICAj
  ICIuLi4KKyAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNp
  ZiAoJGluID1+IHMvXlwvXC8uKi8vKSB7ICAgICAgICAgICAgICAgICAgIyAvLy4uLgorICAgICAg
  ICAgICAgICAgICMgZmFsbCB0aHJvdWdoCisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gbS9e
  XC9cKi8pIHsgICAgICAgICAgICAgICAgICAgICAjIC8qLi4uCisgICAgICAgICAgICAgICAgIyBD
  IGNvbW1lbnQgcmVtb3ZhbCBhZGFwdGVkIGZyb20gcGVybGZhcTY6CisgICAgICAgICAgICAgICAg
  aWYgKCRpbiA9fiBzL15cL1wqW14qXSpcKisoW15cLypdW14qXSpcKispKlwvLy8pIHsKKyAgICAg
  ICAgICAgICAgICAgICAgJG91dCAgICAuPSAnICc7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIEluY29tcGxldGUgLyogKi8KKyAg
  ICAgICAgICAgICAgICAgICAgbmV4dCBSRUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oXC8pLy8pIHsgICAgICAgICAgICAgICAgICAgICMgLy4u
  LgorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgk
  aW4gPX4gcy9eKFteXCdcIlxcXC9dKykvLykgeworICAgICAgICAgICAgICAgICRvdXQgICAgLj0g
  JDE7CisgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgIGRpZSAiQ2Fubm90IHBh
  cnNlOlxuJGluXG4iOworICAgICAgICAgICAgfQorICAgICAgICB9CisKKyAgICAgICAgbGFzdCBS
  RUFEIGlmICRvdXQgPX4gL1xTLzsKKyAgICB9CisKKyAgICByZXR1cm4gJG91dDsKK30KKworCiAj
  IEhhbmRsZSByZWN1cnNpdmUgc3ViZGlyZWN0b3JpZXMgd2l0aG91dCBnZXR0aW5nIGEgZ3JvdGVz
  cXVlbHkgYmlnIHN0YWNrLgogIyBDb3VsZCB0aGlzIGJlIGltcGxlbWVudGVkIHVzaW5nIEZpbGU6
  OkZpbmQ/CiBzdWIgbmV4dF9maWxlCkBAIC01NjMsOSArNjEwLDkgQEAKICAgICAgICAgICAgICAg
  ICBwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKICAgICAgICAgICAgIH0KIAot
  ICAgICAgICAgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eXGQrJC8pIHsKKyAgICAgICAgICAgIGlm
  ICgkZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKICAgICAgICAgICAgICAgICBw
  cmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7ICRkZWZpbmV7JF99IH0gfVxuXG4iOworICAgICAgICAgICAgICAgICAgICAi
  dW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwogICAgICAgICAg
  ICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL15cdyskLykgewogICAgICAgICAgICAgICAgIHBy
  aW50IFBSRUFNQkxFCiAgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7
  IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOwo=
  UH2PH571
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTIzOCwxNSArMjM4LDE5IEBA
  CiAJICAgIH0gZWxzaWYoL15pZGVudFxzKyguKikvKSB7CiAJCXByaW50IE9VVCAkdCwgIiMgJDFc
  biI7CiAJICAgIH0KLSAJfSBlbHNpZigvXlxzKih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpB
  LVpfXVx3KlxzKik/XHsvKSB7Ci0JICAgIHVudGlsKC9cfS4qPzsvKSB7Ci0JCWNob21wKCRuZXh0
  ID0gPElOPik7CisJfSBlbHNpZigvXlxzKih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpf
  XVx3KlxzKik/LykgeworCSAgICB1bnRpbCgvXHtbXn1dKlx9Lio7LyB8fCAvOy8pIHsKKwkJbGFz
  dCB1bmxlc3MgZGVmaW5lZCAoJG5leHQgPSBuZXh0X2xpbmUoKSk7CisJCWNob21wICRuZXh0Owor
  CQkjIGRyb3AgIiNkZWZpbmUgRk9PIEZPTyIgaW4gZW51bXMKKwkJJG5leHQgPX4gcy9eXHMqI1xz
  KmRlZmluZVxzKyhcdyspXHMrXDFccyokLy87CiAJCSRfIC49ICRuZXh0OwogCQlwcmludCBPVVQg
  IiMgJG5leHRcbiIgaWYgJG9wdF9EOwogCSAgICB9CisJICAgIHMvI1xzKmlmLio/I1xzKmVuZGlm
  Ly9nOyAjIGRyb3AgI2lmZGVmcwogCSAgICBzQC9cKi4qP1wqL0BAZzsKIAkgICAgcy9ccysvIC9n
  OwotCSAgICAvXlxzPyh0eXBlZGVmXHM/KT9lbnVtXHM/KFthLXpBLVpfXVx3Kik/XHM/XHsoLiop
  XH1ccz8oW2EtekEtWl9dXHcqKT9ccz87LzsKKwkgICAgbmV4dCB1bmxlc3MgL15ccz8odHlwZWRl
  ZlxzPyk/ZW51bVxzPyhbYS16QS1aX11cdyopP1xzP1x7KC4qKVx9XHM/KFthLXpBLVpfXVx3Kik/
  XHM/Oy87CiAJICAgIChteSAkZW51bV9zdWJzID0gJDMpID1+IHMvXHMvL2c7CiAJICAgIG15IEBl
  bnVtX3N1YnMgPSBzcGxpdCgvLC8sICRlbnVtX3N1YnMpOwogCSAgICBteSAkZW51bV92YWwgPSAt
  MTsKQEAgLTMzNCw3ICszMzgsNyBAQAogCSMgRWxpbWluYXRlIHR5cGVkZWZzCiAJL1woKFtcd1xz
  XSspW1wqXHNdKlwpXHMqW1x3XChdLyAmJiBkbyB7CiAJICAgIGZvcmVhY2ggKHNwbGl0IC9ccysv
  LCAkMSkgeyAgIyBNYWtlIHN1cmUgYWxsIHRoZSB3b3JkcyBhcmUgdHlwZXMsCi0JCWxhc3QgdW5s
  ZXNzICgkaXNhdHlwZXskX30gb3IgJF8gZXEgJ3N0cnVjdCcpOworCQlsYXN0IHVubGVzcyAoJGlz
  YXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnIG9yICRfIGVxICd1bmlvbicpOwogCSAgICB9CiAJ
  ICAgIHMvXChbXHdcc10rW1wqXHNdKlwpLy8gJiYgbmV4dDsgICAgICAjIHRoZW4gZWxpbWluYXRl
  IHRoZW0uCiAJfTsKQEAgLTM1Nyw3ICszNjEsNyBAQAogCX07CiAJcy9eKFtfYS16QS1aXVx3Kikv
  LwkmJiBkbyB7CiAJICAgIG15ICRpZCA9ICQxOwotCSAgICBpZiAoJGlkIGVxICdzdHJ1Y3QnKSB7
  CisJICAgIGlmICgkaWQgZXEgJ3N0cnVjdCcgfHwgJGlkIGVxICd1bmlvbicpIHsKIAkJcy9eXHMr
  KFx3KykvLzsKIAkJJGlkIC49ICcgJyAuICQxOwogCQkkaXNhdHlwZXskaWR9ID0gMTsKQEAgLTQz
  NCw3ICs0MzgsNyBAQAogICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXigiKFxcLnxbXiJc
  XF0pKiIpLy8pIHsgICAgICAgIyAiLi4uCiAgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsK
  ICAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL15cL1wvLiovLykgeyAgICAgICAgICAgICAg
  ICAgICMgLy8uLi4KLSAgICAgICAgICAgICAgICBsYXN0IFJFQUQ7CisgICAgICAgICAgICAgICAg
  IyBmYWxsIHRocm91Z2gKICAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBtL15cL1wqLykgeyAg
  ICAgICAgICAgICAgICAgICAgICMgLyouLi4KICAgICAgICAgICAgICAgICAjIEMgY29tbWVudCBy
  ZW1vdmFsIGFkYXB0ZWQgZnJvbSBwZXJsZmFxNjoKICAgICAgICAgICAgICAgICBpZiAoJGluID1+
  IHMvXlwvXCpbXipdKlwqKyhbXlwvKl1bXipdKlwqKykqXC8vLykgewpAQCAtNDUxLDcgKzQ1NSw3
  IEBACiAgICAgICAgICAgICB9CiAgICAgICAgIH0KIAotICAgICAgICBsYXN0IFJFQUQ7CisgICAg
  ICAgIGxhc3QgUkVBRCBpZiAkb3V0ID1+IC9cUy87CiAgICAgfQogCiAgICAgcmV0dXJuICRvdXQ7
  CkBAIC02MDYsOSArNjEwLDkgQEAKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRSAiIyAk
  Xz0kZGVmaW5leyRffVxuIjsKICAgICAgICAgICAgIH0KIAotICAgICAgICAgICAgaWYgKCRkZWZp
  bmV7JF99ID1+IC9eXGQrJC8pIHsKKyAgICAgICAgICAgIGlmICgkZGVmaW5leyRffSA9fiAvXihc
  ZCspVT9MezAsMn0kL2kpIHsKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAg
  ICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICRkZWZpbmV7
  JF99IH0gfVxuXG4iOworICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwogICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmluZXsk
  X30gPX4gL15cdyskLykgewogICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCiAgICAgICAg
  ICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7
  JF99IH0gfVxuXG4iOwo=
  UH2PH572
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTQyLDggKzQyLDEzIEBAIHVz
  ZSBDb25maWc7CiB1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGgpOwogdXNlIEdldG9wdDo6U3RkOwog
  Ci1nZXRvcHRzKCdEZDpybGhhUScpOwotdXNlIHZhcnMgcXcoJG9wdF9EICRvcHRfZCAkb3B0X3Ig
  JG9wdF9sICRvcHRfaCAkb3B0X2EgJG9wdF9RKTsKKyMgTWFrZSBzdXJlIHJlYWQgcGVybWlzc2lv
  bnMgZm9yIGFsbCBhcmUgc2V0OgoraWYgKGRlZmluZWQgdW1hc2sgJiYgKHVtYXNrKCkgJiAwNDQ0
  KSkgeworICAgIHVtYXNrICh1bWFzaygpICYgfjA0NDQpOworfQorCitnZXRvcHRzKCdEZDpybGhh
  UWUnKTsKK3VzZSB2YXJzIHF3KCRvcHRfRCAkb3B0X2QgJG9wdF9yICRvcHRfbCAkb3B0X2ggJG9w
  dF9hICRvcHRfUSAkb3B0X2UpOwogZGllICItciBhbmQgLWEgb3B0aW9ucyBhcmUgbXV0dWFsbHkg
  ZXhjbHVzaXZlXG4iIGlmICgkb3B0X3IgYW5kICRvcHRfYSk7CiBteSBAaW5jX2RpcnMgPSBpbmNf
  ZGlycygpIGlmICRvcHRfYTsKIApAQCAtNjUsMTMgKzcwLDIxIEBAIG15ICVpc2F0eXBlOwogQGlz
  YXR5cGV7QGlzYXR5cGV9ID0gKDEpIHggQGlzYXR5cGU7CiBteSAkaW5pZiA9IDA7CiBteSAlSXNf
  Y29udmVydGVkOworbXkgJWJhZF9maWxlID0gKCk7CiAKIEBBUkdWID0gKCctJykgdW5sZXNzIEBB
  UkdWOwogCiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkoKTsKIAorc3ViIHJlaW5kZW50KCQp
  IHsKKyAgICBteSgkdGV4dCkgPSBzaGlmdDsKKyAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOwor
  ICAgICR0ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKKyAgICAkdGV4dDsKK30KKwogbXkgKCR0LCAk
  dGFiLCAlY3VyYXJncywgJG5ldywgJGV2YWxfaW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91
  dGZpbGUpOwotbXkgKCRpbmNsLCAkbmV4dCk7CitteSAoJGluY2wsICRpbmNsX3R5cGUsICRpbmNs
  X3F1b3RlLCAkbmV4dCk7CiB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkp
  IHsKICAgICBpZiAoLWwgJGZpbGUgYW5kIC1kICRmaWxlKSB7CiAgICAgICAgIGxpbmtfaWZfcG9z
  c2libGUoJGZpbGUpIGlmICgkb3B0X2wpOwpAQCAtMTA3LDEzICsxMjAsMTcgQEAgd2hpbGUgKGRl
  ZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJb3BlbihPVVQsIj4kRGVzdF9kaXIv
  JG91dGZpbGUiKSB8fCBkaWUgIkNhbid0IGNyZWF0ZSAkb3V0ZmlsZTogJCFcbiI7CiAgICAgfQog
  Ci0gICAgcHJpbnQgT1VUICJyZXF1aXJlICdfaDJwaF9wcmUucGgnO1xuXG4iOwotICAgIHdoaWxl
  IChkZWZpbmVkIChsb2NhbCAkXyA9IG5leHRfbGluZSgpKSkgeworICAgIHByaW50IE9VVAorICAg
  ICAgICAicmVxdWlyZSAnX2gycGhfcHJlLnBoJztcblxuIiwKKyAgICAgICAgIm5vIHdhcm5pbmdz
  ICdyZWRlZmluZSc7XG5cbiI7CisKKyAgICB3aGlsZSAoZGVmaW5lZCAobG9jYWwgJF8gPSBuZXh0
  X2xpbmUoJGZpbGUpKSkgewogCWlmIChzL15ccypcI1xzKi8vKSB7CiAJICAgIGlmIChzL15kZWZp
  bmVccysoXHcrKS8vKSB7CiAJCSRuYW1lID0gJDE7CiAJCSRuZXcgPSAnJzsKIAkJcy9ccyskLy87
  CisJCXMvXChcdytccypcKFwqXClccypcKFx3KlwpXClccyooLT9cZCspLyQxLzsgIyAoaW50ICgq
  KShmb29fdCkpMAogCQlpZiAocy9eXCgoW1x3LFxzXSopXCkvLykgewogCQkgICAgJGFyZ3MgPSAk
  MTsKICAgICAJICAgIAkgICAgbXkgJHByb3RvID0gJygpICc7CkBAIC0xNjcsMjIgKzE4NCwzMiBA
  QCB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkpIHsKICAgICAgICAgICAg
  ICAgICAgICAgICBwcmludCBPVVQgJHQsInVubGVzcyhkZWZpbmVkKFwmJG5hbWUpKSB7XG4gICAg
  c3ViICRuYW1lICgpIHtcdCIsJG5ldywiO31cbn1cbiI7CiAJCSAgICB9CiAJCX0KLQkgICAgfSBl
  bHNpZiAoL14oaW5jbHVkZXxpbXBvcnQpXHMqWzwiXSguKilbPiJdLykgewotCQkoJGluY2wgPSAk
  MikgPX4gcy9cLmgkLy5waC87Ci0JCXByaW50IE9VVCAkdCwicmVxdWlyZSAnJGluY2wnO1xuIjsK
  LQkgICAgfSBlbHNpZigvXmluY2x1ZGVfbmV4dFxzKls8Il0oLiopWz4iXS8pIHsKLQkJKCRpbmNs
  ID0gJDEpID1+IHMvXC5oJC8ucGgvOworCSAgICB9IGVsc2lmICgvXihpbmNsdWRlfGltcG9ydHxp
  bmNsdWRlX25leHQpXHMqKFs8XCJdKSguKilbPlwiXS8pIHsKKyAgICAgICAgICAgICAgICAkaW5j
  bF90eXBlID0gJDE7CisgICAgICAgICAgICAgICAgJGluY2xfcXVvdGUgPSAkMjsKKyAgICAgICAg
  ICAgICAgICAkaW5jbCA9ICQzOworICAgICAgICAgICAgICAgIGlmICgoJGluY2xfdHlwZSBlcSAn
  aW5jbHVkZV9uZXh0JykgfHwKKyAgICAgICAgICAgICAgICAgICAgKCRvcHRfZSAmJiBleGlzdHMo
  JGJhZF9maWxleyRpbmNsfSkpKSB7CisgICAgICAgICAgICAgICAgICAgICRpbmNsID1+IHMvXC5o
  JC8ucGgvOwogCQlwcmludCBPVVQgKCR0LAogCQkJICAgImV2YWwge1xuIik7CiAgICAgICAgICAg
  ICAgICAgJHRhYiArPSA0OwogICAgICAgICAgICAgICAgICR0ID0gIlx0IiB4ICgkdGFiIC8gOCkg
  LiAnICcgeCAoJHRhYiAlIDgpOworICAgICAgICAgICAgICAgICAgICBwcmludCBPVVQgKCR0LCAi
  bXkoXEBSRU0pO1xuIik7CisgICAgICAgICAgICAgICAgICAgIGlmICgkaW5jbF90eXBlIGVxICdp
  bmNsdWRlX25leHQnKSB7CiAJCXByaW50IE9VVCAoJHQsCiAJCQkgICAibXkoXCVJTkNEKSA9IG1h
  cCB7IFwkSU5De1wkX30gPT4gMSB9ICIsCi0JCQkgICAiKGdyZXAgeyBcJF8gZXEgXCIkaW5jbFwi
  IH0ga2V5cyhcJUlOQykpO1xuIik7CisJCQkgICAgICAgICAgICIoZ3JlcCB7IFwkXyBlcSBcIiRp
  bmNsXCIgfSAiLAorICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAia2V5cyhcJUlO
  QykpO1xuIik7CiAJCXByaW50IE9VVCAoJHQsCi0JCQkgICAibXkoXEBSRU0pID0gbWFwIHsgXCJc
  JF8vJGluY2xcIiB9ICIsCisJCQkgICAgICAgICAgICJcQFJFTSA9IG1hcCB7IFwiXCRfLyRpbmNs
  XCIgfSAiLAogCQkJICAgIihncmVwIHsgbm90IGV4aXN0cyhcJElOQ0R7XCJcJF8vJGluY2xcIn0p
  IiwKLQkJCSAgICJhbmQgLWYgXCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworCQkJICAgICAg
  ICAgICAiIGFuZCAtZiBcIlwkXy8kaW5jbFwiIH0gXEBJTkMpO1xuIik7CisgICAgICAgICAgICAg
  ICAgICAgIH0gZWxzZSB7CisgICAgICAgICAgICAgICAgICAgICAgICBwcmludCBPVVQgKCR0LAor
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiXEBSRU0gPSBtYXAgeyBcIlwkXy8k
  aW5jbFwiIH0gIiwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIihncmVwIHst
  ciBcIlwkXy8kaW5jbFwiIH0gXEBJTkMpO1xuIik7CisgICAgICAgICAgICAgICAgICAgIH0KIAkJ
  cHJpbnQgT1VUICgkdCwKIAkJCSAgICJyZXF1aXJlIFwiXCRSRU1bMF1cIiBpZiBcQFJFTTtcbiIp
  OwogICAgICAgICAgICAgICAgICR0YWIgLT0gNDsKQEAgLTE5MSw2ICsyMTgsMTQgQEAgd2hpbGUg
  KGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJCQkgICAifTtcbiIpOwogCQlw
  cmludCBPVVQgKCR0LAogCQkJICAgIndhcm4oXCRcQCkgaWYgXCRcQDtcbiIpOworICAgICAgICAg
  ICAgICAgIH0gZWxzZSB7CisgICAgICAgICAgICAgICAgICAgICRpbmNsID1+IHMvXC5oJC8ucGgv
  OworICAgICAgICAgICAgICAgICAgICAjIGNvcHkgdGhlIHByZWZpeCBpbiB0aGUgcXVvdGUgc3lu
  dGF4ICgjaW5jbHVkZSAieC5oIikgY2FzZQorICAgICAgICAgICAgICAgICAgICBpZiAoJGluY2wg
  IX4gbXwvfCAmJiAkaW5jbF9xdW90ZSBlcSBxeyJ9ICYmICRmaWxlID1+IG18XiguKikvfCkgewor
  ICAgICAgICAgICAgICAgICAgICAgICAgJGluY2wgPSAiJDEvJGluY2wiOworICAgICAgICAgICAg
  ICAgICAgICB9CisJCSAgICBwcmludCBPVVQgJHQsInJlcXVpcmUgJyRpbmNsJztcbiI7CisgICAg
  ICAgICAgICAgICAgfQogCSAgICB9IGVsc2lmICgvXmlmZGVmXHMrKFx3KykvKSB7CiAJCXByaW50
  IE9VVCAkdCwiaWYoZGVmaW5lZCgmJDEpKSB7XG4iOwogCQkkdGFiICs9IDQ7CkBAIC0yNDAsNyAr
  Mjc1LDcgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJICAg
  IH0KIAl9IGVsc2lmKC9eXHMqKHR5cGVkZWZccyopP2VudW1ccyooXHMrW2EtekEtWl9dXHcqXHMq
  KT8vKSB7CiAJICAgIHVudGlsKC9ce1tefV0qXH0uKjsvIHx8IC87LykgewotCQlsYXN0IHVubGVz
  cyBkZWZpbmVkICgkbmV4dCA9IG5leHRfbGluZSgpKTsKKwkJbGFzdCB1bmxlc3MgZGVmaW5lZCAo
  JG5leHQgPSBuZXh0X2xpbmUoJGZpbGUpKTsKIAkJY2hvbXAgJG5leHQ7CiAJCSMgZHJvcCAiI2Rl
  ZmluZSBGT08gRk9PIiBpbiBlbnVtcwogCQkkbmV4dCA9fiBzL15ccyojXHMqZGVmaW5lXHMrKFx3
  KylccytcMVxzKiQvLzsKQEAgLTI3MiwyMiArMzA3LDIyIEBAIHdoaWxlIChkZWZpbmVkIChteSAk
  ZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCSAgICB9CiAJfQogICAgIH0KLSAgICBwcmludCBPVVQg
  IjE7XG4iOwotCiAgICAgJElzX2NvbnZlcnRlZHskZmlsZX0gPSAxOworICAgIGlmICgkb3B0X2Ug
  JiYgZXhpc3RzKCRiYWRfZmlsZXskZmlsZX0pKSB7CisgICAgICAgIHVubGluaygkRGVzdF9kaXIg
  LiAnLycgLiAkb3V0ZmlsZSk7CisgICAgICAgICRuZXh0ID0gJyc7CisgICAgfSBlbHNlIHsKKyAg
  ICAgICAgcHJpbnQgT1VUICIxO1xuIjsKICAgICBxdWV1ZV9pbmNsdWRlc19mcm9tKCRmaWxlKSBp
  ZiAoJG9wdF9hKTsKKyAgICB9CiB9CiAKLWV4aXQgJEV4aXQ7Ci0KLQotc3ViIHJlaW5kZW50KCQp
  IHsKLSAgICBteSgkdGV4dCkgPSBzaGlmdDsKLSAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOwot
  ICAgICR0ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKLSAgICAkdGV4dDsKK2lmICgkb3B0X2UgJiYg
  KHNjYWxhcihrZXlzICViYWRfZmlsZSkgPiAwKSkgeworICAgIHdhcm4gIldhcyB1bmFibGUgdG8g
  Y29udmVydCB0aGUgZm9sbG93aW5nIGZpbGVzOlxuIjsKKyAgICB3YXJuICJcdCIgLiBqb2luKCJc
  blx0Iixzb3J0KGtleXMgJWJhZF9maWxlKSkgLiAiXG4iOwogfQogCitleGl0ICRFeGl0OwogCiBz
  dWIgZXhwciB7CiAgICAgbXkgJGpvaW5lZF9hcmdzOwpAQCAtMjk4LDggKzMzMywyMSBAQCBzdWIg
  ZXhwciB7CiAJcy9eXCZcJi8vICYmIGRvIHsgJG5ldyAuPSAiICYmIjsgbmV4dDt9OyAjIGhhbmRs
  ZSAmJiBvcGVyYXRvcgogCXMvXlwmKFtcKGEtelwpXSspLyQxL2k7CSMgaGFjayBmb3IgdGhpbmdz
  IHRoYXQgdGFrZSB0aGUgYWRkcmVzcyBvZgogCXMvXihccyspLy8JCSYmIGRvIHskbmV3IC49ICcg
  JzsgbmV4dDt9OwotCXMvXigwWFswLTlBLUZdKylbVUxdKi8vaQkmJiBkbyB7JG5ldyAuPSBsYygk
  MSk7IG5leHQ7fTsKLQlzL14oLT9cZCtcLlxkK0VbLStdXGQrKUY/Ly9pCSYmIGRvIHskbmV3IC49
  ICQxOyBuZXh0O307CisJcy9eMFgoWzAtOUEtRl0rKVtVTF0qLy9pIAorCSAgICAmJiBkbyB7bXkg
  JGhleCA9ICQxOworCQkgICAkaGV4ID1+IHMvXjArLy87CisJCSAgIGlmIChsZW5ndGggJGhleCA+
  IDggJiYgISRDb25maWd7dXNlNjRiaXRpbnR9KSB7CisJCSAgICAgICAjIENyb2FrIGlmIG52X3By
  ZXNlcnZlc191dl9iaXRzIDwgNjQgPworCQkgICAgICAgJG5ldyAuPSAgICAgICAgIGhleChzdWJz
  dHIoJGhleCwgLTgpKSArCisJCQkgICAgICAgMioqMzIgKiBoZXgoc3Vic3RyKCRoZXgsICAwLCAt
  OCkpOworCQkgICAgICAgIyBUaGUgYWJvdmUgd2lsbCBwcm9kdWNlICJlcnJvcm5ldXMiIGNvZGUK
  KwkJICAgICAgICMgaWYgdGhlIGhleCBjb25zdGFudCB3YXMgZS5nLiBpbnNpZGUgVUlOVDY0X0MK
  KwkJICAgICAgICMgbWFjcm8sIGJ1dCB0aGVuIGFnYWluLCBoMnBoIGlzIGFuIGFwcHJveGltYXRp
  b24uCisJCSAgIH0gZWxzZSB7CisJCSAgICAgICAkbmV3IC49IGxjKCIweCRoZXgiKTsKKwkJICAg
  fQorCQkgICBuZXh0O307CisJcy9eKC0/XGQrXC5cZCtFWy0rXT9cZCspW0ZMXT8vL2kJJiYgZG8g
  eyRuZXcgLj0gJDE7IG5leHQ7fTsKIAlzL14oXGQrKVxzKltMVV0qLy9pCSYmIGRvIHskbmV3IC49
  ICQxOyBuZXh0O307CiAJcy9eKCIoXFwifFteIl0pKiIpLy8JJiYgZG8geyRuZXcgLj0gJDE7IG5l
  eHQ7fTsKIAlzL14nKChcXCJ8W14iXSkqKScvLwkmJiBkbyB7CkBAIC0zODgsNyArNDM2LDcgQEAg
  c3ViIGV4cHIgewogCQl9CiAJICAgIH0gZWxzZSB7CiAJCWlmICgkaW5pZiAmJiAkbmV3ICF+IC9k
  ZWZpbmVkXHMqXCgkLykgewotCQkgICAgJG5ldyAuPSAnKGRlZmluZWQoJicgLiAkaWQgLiAnKSA/
  ICYnIC4gJGlkIC4gJyA6IDApJzsKKwkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4g
  JykgPyAmJyAuICRpZCAuICcgOiB1bmRlZiknOwogCQl9IGVsc2lmICgvXlxbLykgewogCQkgICAg
  JG5ldyAuPSAiIFwkJGlkIjsKIAkJfSBlbHNlIHsKQEAgLTQwNCw2ICs0NTIsNyBAQCBzdWIgZXhw
  ciB7CiAKIHN1YiBuZXh0X2xpbmUKIHsKKyAgICBteSAkZmlsZSA9IHNoaWZ0OwogICAgIG15ICgk
  aW4sICRvdXQpOwogICAgIG15ICRwcmVfc3ViX3RyaV9ncmFwaHMgPSAxOwogCkBAIC00MjYsNiAr
  NDc1LDIwIEBAIHN1YiBuZXh0X2xpbmUKICAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/PC97
  L2c7ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pzx8ICB7fAogICAgICAgICAgICAgICAg
  ICRpbiA9fiBzL1w/XD8+L30vZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/PnwgIH18
  CiAgICAgICAgICAgICB9CisJICAgIGlmICgkaW4gPX4gL15cI2lmZGVmIF9fTEFOR1VBR0VfUEFT
  Q0FMX18vKSB7CisgICAgICAgICAgICAgICAgIyBUcnU2NCBkaXNhc3NlbWJsZXIuaCBldmlsbmVz
  czogbWl4ZWQgQyBhbmQgUGFzY2FsLgorCQl3aGlsZSAoPElOPikgeworCQkgICAgbGFzdCBpZiAv
  XlwjZW5kaWYvOyAKKwkJfQorCQluZXh0IFJFQUQ7CisJICAgIH0KKwkgICAgaWYgKCRpbiA9fiAv
  XmV4dGVybiBpbmxpbmUgLyAmJiAjIElubGluZWQgYXNzZW1ibGVyLgorCQkkXk8gZXEgJ2xpbnV4
  JyAmJiAkZmlsZSA9fiBtISg/Ol58Lylhc20vW14vXStcLmgkISkgeworIAkJd2hpbGUgKDxJTj4p
  IHsKKwkJICAgIGxhc3QgaWYgL159LzsgCisJCX0KKwkJbmV4dCBSRUFEOworCSAgICB9CiAgICAg
  ICAgICAgICBpZiAoJGluID1+IHMvXFwkLy8pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAj
  IFwtbmV3bGluZQogICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAnOwogICAgICAgICAgICAg
  ICAgIG5leHQgUkVBRDsKQEAgLTQzMywxMCArNDk2LDE4IEBAIHN1YiBuZXh0X2xpbmUKICAgICAg
  ICAgICAgICAgICAkb3V0ICAgIC49ICQxOwogICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMv
  XihcXC4pLy8pIHsgICAgICAgICAgICAgICAgICAgIyBcLi4uCiAgICAgICAgICAgICAgICAgJG91
  dCAgICAuPSAkMTsKLSAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxd
  KSonKS8vKSB7ICAgICAgICMgJy4uLgotICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7Ci0g
  ICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgeyAgICAg
  ICAjICIuLi4KLSAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBl
  bHNpZiAoJGluID1+IC9eJy8pIHsgICAgICAgICAgICAgICAgICAgICAgICAgIyAnLi4uCisgICAg
  ICAgICAgICAgICAgaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxdKSonKS8vKSB7CisgICAgICAg
  ICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsKKyAg
  ICAgICAgICAgICAgICAgICAgbmV4dCBSRUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiAvXiIvKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICMgIi4u
  LgorICAgICAgICAgICAgICAgIGlmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgewor
  ICAgICAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgICAgIH0gZWxz
  ZSB7CisgICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgICAgICB9CiAg
  ICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eXC9cLy4qLy8pIHsgICAgICAgICAgICAgICAg
  ICAjIC8vLi4uCiAgICAgICAgICAgICAgICAgIyBmYWxsIHRocm91Z2gKICAgICAgICAgICAgIH0g
  ZWxzaWYgKCRpbiA9fiBtL15cL1wqLykgeyAgICAgICAgICAgICAgICAgICAgICMgLyouLi4KQEAg
  LTQ1MCw4ICs1MjEsMjAgQEAgc3ViIG5leHRfbGluZQogICAgICAgICAgICAgICAgICRvdXQgICAg
  Lj0gJDE7CiAgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFteXCdcIlxcXC9dKykvLykg
  ewogICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgk
  Xk8gZXEgJ2xpbnV4JyAmJgorICAgICAgICAgICAgICAgICAgICAgJGZpbGUgPX4gbSEoPzpefC8p
  bGludXgvYnl0ZW9yZGVyL3BkcF9lbmRpYW5cLmgkISAmJgorICAgICAgICAgICAgICAgICAgICAg
  JGluICAgPX4gcyFcJ1QgS05PVyEhKSB7CisgICAgICAgICAgICAgICAgJG91dCAgICA9fiBzIUkg
  RE9OJCFJX0RPX05PVF9LTk9XITsKICAgICAgICAgICAgIH0gZWxzZSB7Ci0gICAgICAgICAgICAg
  ICAgZGllICJDYW5ub3QgcGFyc2U6XG4kaW5cbiI7CisgICAgICAgICAgICAgICAgaWYgKCRvcHRf
  ZSkgeworICAgICAgICAgICAgICAgICAgICB3YXJuICJDYW5ub3QgcGFyc2UgJGZpbGU6XG4kaW5c
  biI7CisgICAgICAgICAgICAgICAgICAgICRiYWRfZmlsZXskZmlsZX0gPSAxOworICAgICAgICAg
  ICAgICAgICAgICAkaW4gPSAnJzsKKyAgICAgICAgICAgICAgICAgICAgJG91dCA9IHVuZGVmOwor
  ICAgICAgICAgICAgICAgICAgICBsYXN0IFJFQUQ7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsK
  KwkJZGllICJDYW5ub3QgcGFyc2U6XG4kaW5cbiI7CisgICAgICAgICAgICAgICAgfQogICAgICAg
  ICAgICAgfQogICAgICAgICB9CiAKQEAgLTU2MSw4ICs2NDQsMTMgQEAgc3ViIHF1ZXVlX2luY2x1
  ZGVzX2Zyb20KICAgICAgICAgICAgICAgICAkbGluZSAuPSA8SEVBREVSPjsKICAgICAgICAgICAg
  IH0KIAotICAgICAgICAgICAgaWYgKCRsaW5lID1+IC9eI1xzKmluY2x1ZGVccys8KC4qPyk+Lykg
  ewotICAgICAgICAgICAgICAgIHB1c2goQEFSR1YsICQxKSB1bmxlc3MgJElzX2NvbnZlcnRlZHsk
  MX07CisgICAgICAgICAgICBpZiAoJGxpbmUgPX4gL14jXHMqaW5jbHVkZVxzKyhbPCJdKSguKj8p
  Wz4iXS8pIHsKKyAgICAgICAgICAgICAgICBteSAoJGRlbGltaXRlciwgJG5ld19maWxlKSA9ICgk
  MSwgJDIpOworICAgICAgICAgICAgICAgICMgY29weSB0aGUgcHJlZml4IGluIHRoZSBxdW90ZSBz
  eW50YXggKCNpbmNsdWRlICJ4LmgiKSBjYXNlCisgICAgICAgICAgICAgICAgaWYgKCRkZWxpbWl0
  ZXIgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4oLiopL3wpIHsKKyAgICAgICAgICAgICAgICAgICAg
  JG5ld19maWxlID0gIiQxLyRuZXdfZmlsZSI7CisgICAgICAgICAgICAgICAgfQorICAgICAgICAg
  ICAgICAgIHB1c2goQEFSR1YsICRuZXdfZmlsZSkgdW5sZXNzICRJc19jb252ZXJ0ZWR7JG5ld19m
  aWxlfTsKICAgICAgICAgICAgIH0KICAgICAgICAgfQogICAgIGNsb3NlIEhFQURFUjsKQEAgLTYw
  MywyNSArNjkxLDUwIEBAIHN1YiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkKICAgICBteSAo
  JWRlZmluZSkgPSBfZXh0cmFjdF9jY19kZWZpbmVzKCk7CiAKICAgICBvcGVuICBQUkVBTUJMRSwg
  Ij4kcHJlYW1ibGUiIG9yIGRpZSAiQ2Fubm90IG9wZW4gJHByZWFtYmxlOiAgJCEiOwotICAgICAg
  ICBwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJzaW9u
  ICRWRVJTSU9OXG4iOwotCi0gICAgICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlZGVmaW5lKSB7Ci0g
  ICAgICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJFQU1CTEUg
  IiMgJF89JGRlZmluZXskX31cbiI7Ci0gICAgICAgICAgICB9Ci0KLSAgICAgICAgICAgIGlmICgk
  ZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKLSAgICAgICAgICAgICAgICBwcmlu
  dCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBz
  dWIgJF8oKSB7ICQxIH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmluZXskX30g
  PX4gL15cdyskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAgICAgICAg
  ICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99
  IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNlIHsKKwlwcmludCBQUkVBTUJMRSAiIyBUaGlz
  IGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJzaW9uICRWRVJTSU9OXG4iOworICAgICAgICAj
  IFByZXZlbnQgbm9uLXBvcnRhYmxlIGhleCBjb25zdGFudHMgZnJvbSB3YXJuaW5nLgorICAgICAg
  ICAjCisgICAgICAgICMgV2Ugc3RpbGwgcHJvZHVjZSBhbiBvdmVyZmxvdyB3YXJuaW5nIGlmIHdl
  IGNhbid0IHJlcHJlc2VudAorICAgICAgICAjIGEgaGV4IGNvbnN0YW50IGFzIGFuIGludGVnZXIu
  CisgICAgICAgIHByaW50IFBSRUFNQkxFICJubyB3YXJuaW5ncyBxdyhwb3J0YWJsZSk7XG4iOwor
  CisJZm9yZWFjaCAoc29ydCBrZXlzICVkZWZpbmUpIHsKKwkgICAgaWYgKCRvcHRfRCkgeworCQlw
  cmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKKwkgICAgfQorCSAgICBpZiAoJGRl
  ZmluZXskX30gPX4gL15cKCguKilcKSQvKSB7CisJCSMgcGFyZW50aGVzaXplZCB2YWx1ZTogIGQ9
  KHYpCisJCSRkZWZpbmV7JF99ID0gJDE7CisJICAgIH0KKwkgICAgaWYgKCRkZWZpbmV7JF99ID1+
  IC9eKFsrLV0/KFxkKyk/XC5cZCsoW2VFXVsrLV0/XGQrKT8pW0ZMXT8kLykgeworCQkjIGZsb2F0
  OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRf
  KCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL14oWystXT9c
  ZCspVT9MezAsMn0kL2kpIHsKKwkJIyBpbnRlZ2VyOgorCQlwcmludCBQUkVBTUJMRQorCQkgICAg
  InVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/MHhbXGRhLWZdKylVP0x7MCwyfSQv
  aSkgeworICAgICAgICAgICAgICAgICMgaGV4IGludGVnZXIKKyAgICAgICAgICAgICAgICAjIFNw
  ZWNpYWwgY2FzZWQsIHNpbmNlIHBlcmwgd2FybnMgb24gaGV4IGludGVnZXJzCisgICAgICAgICAg
  ICAgICAgIyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGluIGEgVVYuCisgICAgICAgICAgICAg
  ICAgIworICAgICAgICAgICAgICAgICMgVGhpcyB3YXkgd2UgZ2V0IHRoZSB3YXJuaW5nIGF0IHRp
  bWUgb2YgdXNlLCBzbyB0aGUgdXNlcgorICAgICAgICAgICAgICAgICMgb25seSBnZXRzIHRoZSB3
  YXJuaW5nIGlmIHRoZXkgaGFwcGVuIHRvIHVzZSB0aGlzCisgICAgICAgICAgICAgICAgIyBwbGF0
  Zm9ybS1zcGVjaWZpYyBkZWZpbml0aW9uLgorICAgICAgICAgICAgICAgIG15ICRjb2RlID0gJDE7
  CisgICAgICAgICAgICAgICAgJGNvZGUgPSAiaGV4KCckY29kZScpIiBpZiBsZW5ndGggJGNvZGUg
  PiAxMDsKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAg
  ICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7IFwiIiwKLSAgICAgICAgICAgICAg
  ICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7JF99KSwgIlwiIH0gfVxuXG4iOwotICAgICAgICAgICAg
  fQotICAgICAgICB9CisgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7
  IHN1YiAkXygpIHsgJGNvZGUgfSB9XG5cbiI7CisJICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+
  IC9eXHcrJC8pIHsKKwkJcHJpbnQgUFJFQU1CTEUKKwkJICAgICJ1bmxlc3MgKGRlZmluZWQgJiRf
  KSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOworCSAgICB9IGVsc2UgeworCQlw
  cmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyBc
  IiIsCisJCSAgICBxdW90ZW1ldGEoJGRlZmluZXskX30pLCAiXCIgfSB9XG5cbiI7CisJICAgIH0K
  Kwl9CiAgICAgY2xvc2UgUFJFQU1CTEUgICAgICAgICAgICAgICBvciBkaWUgIkNhbm5vdCBjbG9z
  ZSAkcHJlYW1ibGU6ICAkISI7CiB9CiAKQEAgLTYzMywxNSArNzQ2LDE0IEBAIHN1YiBfZXh0cmFj
  dF9jY19kZWZpbmVzCiB7CiAgICAgbXkgJWRlZmluZTsKICAgICBteSAkYWxsc3ltYm9scyAgPSBq
  b2luICIgIiwKLSAgICAgICAgQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAnY3Bw
  Y2NzeW1ib2xzJ307CisJQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAnY3BwY2Nz
  eW1ib2xzJ307CiAKICAgICAjIFNwbGl0IGNvbXBpbGVyIHByZS1kZWZpbml0aW9ucyBpbnRvIGBr
  ZXk9dmFsdWUnIHBhaXJzOgotICAgIGZvcmVhY2ggKHNwbGl0IC9ccysvLCAkYWxsc3ltYm9scykg
  ewotICAgICAgICAvKC4rPyk9KC4rKS8gYW5kICRkZWZpbmV7JDF9ID0gJDI7Ci0KLSAgICAgICAg
  aWYgKCRvcHRfRCkgewotICAgICAgICAgICAgcHJpbnQgU1RERVJSICIkXzogICQxIC0+ICQyXG4i
  OwotICAgICAgICB9CisgICAgd2hpbGUgKCRhbGxzeW1ib2xzID1+IC8oW15cc10rKT0oKFxcXHN8
  W15cc10pKykvZykgeworCSRkZWZpbmV7JDF9ID0gJDI7CisJaWYgKCRvcHRfRCkgeworCSAgICBw
  cmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7CisJfQogICAgIH0KIAogICAgIHJldHVybiAl
  ZGVmaW5lOwpAQCAtNjcwLDYgKzc4MiwxMCBAQCBJdCBpcyBtb3N0IGVhc2lseSBydW4gd2hpbGUg
  aW4gL3Vzci9pbmNsdWRlOgogCiAJY2QgL3Vzci9pbmNsdWRlOyBoMnBoICogc3lzLyoKIAorb3IK
  KworCWNkIC91c3IvaW5jbHVkZTsgaDJwaCAqIHN5cy8qIGFycGEvKiBuZXRpbmV0LyoKKwogb3IK
  IAogCWNkIC91c3IvaW5jbHVkZTsgaDJwaCAtciAtbCAuCkBAIC02ODcsNyArODAzLDcgQEAgSWYg
  cnVuIHdpdGggbm8gYXJndW1lbnRzLCBmaWx0ZXJzIHN0YW5kYXJkIGlucHV0IHRvIHN0YW5kYXJk
  IG91dHB1dC4KID1pdGVtIC1kIGRlc3RpbmF0aW9uX2RpcgogCiBQdXQgdGhlIHJlc3VsdGluZyBC
  PC5waD4gZmlsZXMgYmVuZWF0aCBCPGRlc3RpbmF0aW9uX2Rpcj4sIGluc3RlYWQgb2YKLWJlbmVh
  dGggdGhlIGRlZmF1bHQgUGVybCBsaWJyYXJ5IGxvY2F0aW9uIChDPCRDb25maWd7J2luc3RhbGxz
  aXRzZWFyY2gnfT4pLgorYmVuZWF0aCB0aGUgZGVmYXVsdCBQZXJsIGxpYnJhcnkgbG9jYXRpb24g
  KEM8JENvbmZpZ3snaW5zdGFsbHNpdGVhcmNoJ30+KS4KIAogPWl0ZW0gLXIKIApAQCAtNzcyLDEw
  ICs4ODgsMTAgQEAgaW5zdGFsbGF0aW9uLgogRG9lc24ndCBoYW5kbGUgY29tcGxpY2F0ZWQgZXhw
  cmVzc2lvbnMgYnVpbHQgcGllY2VtZWFsLCBhIGxhOgogCiAgICAgZW51bSB7Ci0gICAgICAgIEZJ
  UlNUX1ZBTFVFLAotICAgICAgICBTRUNPTkRfVkFMVUUsCisJRklSU1RfVkFMVUUsCisJU0VDT05E
  X1ZBTFVFLAogICAgICNpZmRlZiBBQkMKLSAgICAgICAgVEhJUkRfVkFMVUUKKwlUSElSRF9WQUxV
  RQogICAgICNlbmRpZgogICAgIH07CiAK
  UH2PH573
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTQyLDggKzQyLDEzIEBAIHVz
  ZSBDb25maWc7CiB1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGgpOwogdXNlIEdldG9wdDo6U3RkOwog
  Ci1nZXRvcHRzKCdEZDpybGhhUScpOwotdXNlIHZhcnMgcXcoJG9wdF9EICRvcHRfZCAkb3B0X3Ig
  JG9wdF9sICRvcHRfaCAkb3B0X2EgJG9wdF9RKTsKKyMgTWFrZSBzdXJlIHJlYWQgcGVybWlzc2lv
  bnMgZm9yIGFsbCBhcmUgc2V0OgoraWYgKGRlZmluZWQgdW1hc2sgJiYgKHVtYXNrKCkgJiAwNDQ0
  KSkgeworICAgIHVtYXNrICh1bWFzaygpICYgfjA0NDQpOworfQorCitnZXRvcHRzKCdEZDpybGhh
  UWUnKTsKK3VzZSB2YXJzIHF3KCRvcHRfRCAkb3B0X2QgJG9wdF9yICRvcHRfbCAkb3B0X2ggJG9w
  dF9hICRvcHRfUSAkb3B0X2UpOwogZGllICItciBhbmQgLWEgb3B0aW9ucyBhcmUgbXV0dWFsbHkg
  ZXhjbHVzaXZlXG4iIGlmICgkb3B0X3IgYW5kICRvcHRfYSk7CiBteSBAaW5jX2RpcnMgPSBpbmNf
  ZGlycygpIGlmICRvcHRfYTsKIApAQCAtNjUsMTMgKzcwLDIxIEBAIG15ICVpc2F0eXBlOwogQGlz
  YXR5cGV7QGlzYXR5cGV9ID0gKDEpIHggQGlzYXR5cGU7CiBteSAkaW5pZiA9IDA7CiBteSAlSXNf
  Y29udmVydGVkOworbXkgJWJhZF9maWxlID0gKCk7CiAKIEBBUkdWID0gKCctJykgdW5sZXNzIEBB
  UkdWOwogCiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkoKTsKIAorc3ViIHJlaW5kZW50KCQp
  IHsKKyAgICBteSgkdGV4dCkgPSBzaGlmdDsKKyAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOwor
  ICAgICR0ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKKyAgICAkdGV4dDsKK30KKwogbXkgKCR0LCAk
  dGFiLCAlY3VyYXJncywgJG5ldywgJGV2YWxfaW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91
  dGZpbGUpOwotbXkgKCRpbmNsLCAkbmV4dCk7CitteSAoJGluY2wsICRpbmNsX3R5cGUsICRpbmNs
  X3F1b3RlLCAkbmV4dCk7CiB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkp
  IHsKICAgICBpZiAoLWwgJGZpbGUgYW5kIC1kICRmaWxlKSB7CiAgICAgICAgIGxpbmtfaWZfcG9z
  c2libGUoJGZpbGUpIGlmICgkb3B0X2wpOwpAQCAtMTA3LDcgKzEyMCw5IEBAIHdoaWxlIChkZWZp
  bmVkIChteSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCW9wZW4oT1VULCI+JERlc3RfZGlyLyRv
  dXRmaWxlIikgfHwgZGllICJDYW4ndCBjcmVhdGUgJG91dGZpbGU6ICQhXG4iOwogICAgIH0KIAot
  ICAgIHByaW50IE9VVCAicmVxdWlyZSAnX2gycGhfcHJlLnBoJztcblxuIjsKKyAgICBwcmludCBP
  VVQKKyAgICAgICAgInJlcXVpcmUgJ19oMnBoX3ByZS5waCc7XG5cbiIsCisgICAgICAgICJubyB3
  YXJuaW5ncyAncmVkZWZpbmUnO1xuXG4iOwogCiAgICAgd2hpbGUgKGRlZmluZWQgKGxvY2FsICRf
  ID0gbmV4dF9saW5lKCRmaWxlKSkpIHsKIAlpZiAocy9eXHMqXCNccyovLykgewpAQCAtMTY5LDIy
  ICsxODQsMzIgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAg
  ICAgICAgICAgICAgICAgICAgICAgcHJpbnQgT1VUICR0LCJ1bmxlc3MoZGVmaW5lZChcJiRuYW1l
  KSkge1xuICAgIHN1YiAkbmFtZSAoKSB7XHQiLCRuZXcsIjt9XG59XG4iOwogCQkgICAgfQogCQl9
  Ci0JICAgIH0gZWxzaWYgKC9eKGluY2x1ZGV8aW1wb3J0KVxzKls8Il0oLiopWz4iXS8pIHsKLQkJ
  KCRpbmNsID0gJDIpID1+IHMvXC5oJC8ucGgvOwotCQlwcmludCBPVVQgJHQsInJlcXVpcmUgJyRp
  bmNsJztcbiI7Ci0JICAgIH0gZWxzaWYoL15pbmNsdWRlX25leHRccypbPCJdKC4qKVs+Il0vKSB7
  Ci0JCSgkaW5jbCA9ICQxKSA9fiBzL1wuaCQvLnBoLzsKKwkgICAgfSBlbHNpZiAoL14oaW5jbHVk
  ZXxpbXBvcnR8aW5jbHVkZV9uZXh0KVxzKihbPFwiXSkoLiopWz5cIl0vKSB7CisgICAgICAgICAg
  ICAgICAgJGluY2xfdHlwZSA9ICQxOworICAgICAgICAgICAgICAgICRpbmNsX3F1b3RlID0gJDI7
  CisgICAgICAgICAgICAgICAgJGluY2wgPSAkMzsKKyAgICAgICAgICAgICAgICBpZiAoKCRpbmNs
  X3R5cGUgZXEgJ2luY2x1ZGVfbmV4dCcpIHx8CisgICAgICAgICAgICAgICAgICAgICgkb3B0X2Ug
  JiYgZXhpc3RzKCRiYWRfZmlsZXskaW5jbH0pKSkgeworICAgICAgICAgICAgICAgICAgICAkaW5j
  bCA9fiBzL1wuaCQvLnBoLzsKIAkJcHJpbnQgT1VUICgkdCwKIAkJCSAgICJldmFsIHtcbiIpOwog
  ICAgICAgICAgICAgICAgICR0YWIgKz0gNDsKICAgICAgICAgICAgICAgICAkdCA9ICJcdCIgeCAo
  JHRhYiAvIDgpIC4gJyAnIHggKCR0YWIgJSA4KTsKKyAgICAgICAgICAgICAgICAgICAgcHJpbnQg
  T1VUICgkdCwgIm15KFxAUkVNKTtcbiIpOworICAgICAgICAgICAgICAgICAgICBpZiAoJGluY2xf
  dHlwZSBlcSAnaW5jbHVkZV9uZXh0JykgewogCQlwcmludCBPVVQgKCR0LAogCQkJICAgIm15KFwl
  SU5DRCkgPSBtYXAgeyBcJElOQ3tcJF99ID0+IDEgfSAiLAotCQkJICAgIihncmVwIHsgXCRfIGVx
  IFwiJGluY2xcIiB9IGtleXMoXCVJTkMpKTtcbiIpOworCQkJICAgICAgICAgICAiKGdyZXAgeyBc
  JF8gZXEgXCIkaW5jbFwiIH0gIiwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ImtleXMoXCVJTkMpKTtcbiIpOwogCQlwcmludCBPVVQgKCR0LAotCQkJICAgIm15KFxAUkVNKSA9
  IG1hcCB7IFwiXCRfLyRpbmNsXCIgfSAiLAorCQkJICAgICAgICAgICAiXEBSRU0gPSBtYXAgeyBc
  IlwkXy8kaW5jbFwiIH0gIiwKIAkJCSAgICIoZ3JlcCB7IG5vdCBleGlzdHMoXCRJTkNEe1wiXCRf
  LyRpbmNsXCJ9KSIsCi0JCQkgICAiYW5kIC1mIFwiXCRfLyRpbmNsXCIgfSBcQElOQyk7XG4iKTsK
  KwkJCSAgICAgICAgICAgIiBhbmQgLWYgXCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworICAg
  ICAgICAgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQg
  T1VUICgkdCwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlxAUkVNID0gbWFw
  IHsgXCJcJF8vJGluY2xcIiB9ICIsCisgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICIoZ3JlcCB7LXIgXCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworICAgICAgICAgICAgICAg
  ICAgICB9CiAJCXByaW50IE9VVCAoJHQsCiAJCQkgICAicmVxdWlyZSBcIlwkUkVNWzBdXCIgaWYg
  XEBSRU07XG4iKTsKICAgICAgICAgICAgICAgICAkdGFiIC09IDQ7CkBAIC0xOTMsNiArMjE4LDE0
  IEBAIHdoaWxlIChkZWZpbmVkIChteSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCQkJICAgIn07
  XG4iKTsKIAkJcHJpbnQgT1VUICgkdCwKIAkJCSAgICJ3YXJuKFwkXEApIGlmIFwkXEA7XG4iKTsK
  KyAgICAgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICAkaW5jbCA9fiBz
  L1wuaCQvLnBoLzsKKyAgICAgICAgICAgICAgICAgICAgIyBjb3B5IHRoZSBwcmVmaXggaW4gdGhl
  IHF1b3RlIHN5bnRheCAoI2luY2x1ZGUgInguaCIpIGNhc2UKKyAgICAgICAgICAgICAgICAgICAg
  aWYgKCRpbmNsICF+IG18L3wgJiYgJGluY2xfcXVvdGUgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4o
  LiopL3wpIHsKKyAgICAgICAgICAgICAgICAgICAgICAgICRpbmNsID0gIiQxLyRpbmNsIjsKKyAg
  ICAgICAgICAgICAgICAgICAgfQorCQkgICAgcHJpbnQgT1VUICR0LCJyZXF1aXJlICckaW5jbCc7
  XG4iOworICAgICAgICAgICAgICAgIH0KIAkgICAgfSBlbHNpZiAoL15pZmRlZlxzKyhcdyspLykg
  ewogCQlwcmludCBPVVQgJHQsImlmKGRlZmluZWQoJiQxKSkge1xuIjsKIAkJJHRhYiArPSA0OwpA
  QCAtMjc0LDIyICszMDcsMjIgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxl
  KCkpKSB7CiAJICAgIH0KIAl9CiAgICAgfQotICAgIHByaW50IE9VVCAiMTtcbiI7Ci0KICAgICAk
  SXNfY29udmVydGVkeyRmaWxlfSA9IDE7CisgICAgaWYgKCRvcHRfZSAmJiBleGlzdHMoJGJhZF9m
  aWxleyRmaWxlfSkpIHsKKyAgICAgICAgdW5saW5rKCREZXN0X2RpciAuICcvJyAuICRvdXRmaWxl
  KTsKKyAgICAgICAgJG5leHQgPSAnJzsKKyAgICB9IGVsc2UgeworICAgICAgICBwcmludCBPVVQg
  IjE7XG4iOwogICAgIHF1ZXVlX2luY2x1ZGVzX2Zyb20oJGZpbGUpIGlmICgkb3B0X2EpOworICAg
  IH0KIH0KIAotZXhpdCAkRXhpdDsKLQotCi1zdWIgcmVpbmRlbnQoJCkgewotICAgIG15KCR0ZXh0
  KSA9IHNoaWZ0OwotICAgICR0ZXh0ID1+IHMvXG4vXG4gICAgL2c7Ci0gICAgJHRleHQgPX4gcy8g
  ICAgICAgIC9cdC9nOwotICAgICR0ZXh0OworaWYgKCRvcHRfZSAmJiAoc2NhbGFyKGtleXMgJWJh
  ZF9maWxlKSA+IDApKSB7CisgICAgd2FybiAiV2FzIHVuYWJsZSB0byBjb252ZXJ0IHRoZSBmb2xs
  b3dpbmcgZmlsZXM6XG4iOworICAgIHdhcm4gIlx0IiAuIGpvaW4oIlxuXHQiLHNvcnQoa2V5cyAl
  YmFkX2ZpbGUpKSAuICJcbiI7CiB9CiAKK2V4aXQgJEV4aXQ7CiAKIHN1YiBleHByIHsKICAgICBt
  eSAkam9pbmVkX2FyZ3M7CkBAIC00MDMsNyArNDM2LDcgQEAgc3ViIGV4cHIgewogCQl9CiAJICAg
  IH0gZWxzZSB7CiAJCWlmICgkaW5pZiAmJiAkbmV3ICF+IC9kZWZpbmVkXHMqXCgkLykgewotCQkg
  ICAgJG5ldyAuPSAnKGRlZmluZWQoJicgLiAkaWQgLiAnKSA/ICYnIC4gJGlkIC4gJyA6IDApJzsK
  KwkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAmJyAuICRpZCAuICcgOiB1
  bmRlZiknOwogCQl9IGVsc2lmICgvXlxbLykgewogCQkgICAgJG5ldyAuPSAiIFwkJGlkIjsKIAkJ
  fSBlbHNlIHsKQEAgLTQ2MywxMCArNDk2LDE4IEBAIHN1YiBuZXh0X2xpbmUKICAgICAgICAgICAg
  ICAgICAkb3V0ICAgIC49ICQxOwogICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXihcXC4p
  Ly8pIHsgICAgICAgICAgICAgICAgICAgIyBcLi4uCiAgICAgICAgICAgICAgICAgJG91dCAgICAu
  PSAkMTsKLSAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxdKSonKS8v
  KSB7ICAgICAgICMgJy4uLgotICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7Ci0gICAgICAg
  ICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgeyAgICAgICAjICIu
  Li4KLSAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAo
  JGluID1+IC9eJy8pIHsgICAgICAgICAgICAgICAgICAgICAgICAgIyAnLi4uCisgICAgICAgICAg
  ICAgICAgaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxdKSonKS8vKSB7CisgICAgICAgICAgICAg
  ICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsKKyAgICAgICAg
  ICAgICAgICAgICAgbmV4dCBSRUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAgICAgIH0g
  ZWxzaWYgKCRpbiA9fiAvXiIvKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICMgIi4uLgorICAg
  ICAgICAgICAgICAgIGlmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgeworICAgICAg
  ICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgICAgIH0gZWxzZSB7Cisg
  ICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgICAgICB9CiAgICAgICAg
  ICAgICB9IGVsc2lmICgkaW4gPX4gcy9eXC9cLy4qLy8pIHsgICAgICAgICAgICAgICAgICAjIC8v
  Li4uCiAgICAgICAgICAgICAgICAgIyBmYWxsIHRocm91Z2gKICAgICAgICAgICAgIH0gZWxzaWYg
  KCRpbiA9fiBtL15cL1wqLykgeyAgICAgICAgICAgICAgICAgICAgICMgLyouLi4KQEAgLTQ4NSw3
  ICs1MjYsMTUgQEAgc3ViIG5leHRfbGluZQogICAgICAgICAgICAgICAgICAgICAgJGluICAgPX4g
  cyFcJ1QgS05PVyEhKSB7CiAgICAgICAgICAgICAgICAgJG91dCAgICA9fiBzIUkgRE9OJCFJX0RP
  X05PVF9LTk9XITsKICAgICAgICAgICAgIH0gZWxzZSB7CisgICAgICAgICAgICAgICAgaWYgKCRv
  cHRfZSkgeworICAgICAgICAgICAgICAgICAgICB3YXJuICJDYW5ub3QgcGFyc2UgJGZpbGU6XG4k
  aW5cbiI7CisgICAgICAgICAgICAgICAgICAgICRiYWRfZmlsZXskZmlsZX0gPSAxOworICAgICAg
  ICAgICAgICAgICAgICAkaW4gPSAnJzsKKyAgICAgICAgICAgICAgICAgICAgJG91dCA9IHVuZGVm
  OworICAgICAgICAgICAgICAgICAgICBsYXN0IFJFQUQ7CisgICAgICAgICAgICAgICAgfSBlbHNl
  IHsKIAkJZGllICJDYW5ub3QgcGFyc2U6XG4kaW5cbiI7CisgICAgICAgICAgICAgICAgfQogICAg
  ICAgICAgICAgfQogICAgICAgICB9CiAKQEAgLTU5NSw4ICs2NDQsMTMgQEAgc3ViIHF1ZXVlX2lu
  Y2x1ZGVzX2Zyb20KICAgICAgICAgICAgICAgICAkbGluZSAuPSA8SEVBREVSPjsKICAgICAgICAg
  ICAgIH0KIAotICAgICAgICAgICAgaWYgKCRsaW5lID1+IC9eI1xzKmluY2x1ZGVccys8KC4qPyk+
  LykgewotICAgICAgICAgICAgICAgIHB1c2goQEFSR1YsICQxKSB1bmxlc3MgJElzX2NvbnZlcnRl
  ZHskMX07CisgICAgICAgICAgICBpZiAoJGxpbmUgPX4gL14jXHMqaW5jbHVkZVxzKyhbPCJdKSgu
  Kj8pWz4iXS8pIHsKKyAgICAgICAgICAgICAgICBteSAoJGRlbGltaXRlciwgJG5ld19maWxlKSA9
  ICgkMSwgJDIpOworICAgICAgICAgICAgICAgICMgY29weSB0aGUgcHJlZml4IGluIHRoZSBxdW90
  ZSBzeW50YXggKCNpbmNsdWRlICJ4LmgiKSBjYXNlCisgICAgICAgICAgICAgICAgaWYgKCRkZWxp
  bWl0ZXIgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4oLiopL3wpIHsKKyAgICAgICAgICAgICAgICAg
  ICAgJG5ld19maWxlID0gIiQxLyRuZXdfZmlsZSI7CisgICAgICAgICAgICAgICAgfQorICAgICAg
  ICAgICAgICAgIHB1c2goQEFSR1YsICRuZXdfZmlsZSkgdW5sZXNzICRJc19jb252ZXJ0ZWR7JG5l
  d19maWxlfTsKICAgICAgICAgICAgIH0KICAgICAgICAgfQogICAgIGNsb3NlIEhFQURFUjsKQEAg
  LTYzNywyNSArNjkxLDUwIEBAIHN1YiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkKICAgICBt
  eSAoJWRlZmluZSkgPSBfZXh0cmFjdF9jY19kZWZpbmVzKCk7CiAKICAgICBvcGVuICBQUkVBTUJM
  RSwgIj4kcHJlYW1ibGUiIG9yIGRpZSAiQ2Fubm90IG9wZW4gJHByZWFtYmxlOiAgJCEiOwotICAg
  ICAgICBwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJz
  aW9uICRWRVJTSU9OXG4iOwotCi0gICAgICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlZGVmaW5lKSB7
  Ci0gICAgICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJFQU1C
  TEUgIiMgJF89JGRlZmluZXskX31cbiI7Ci0gICAgICAgICAgICB9Ci0KLSAgICAgICAgICAgIGlm
  ICgkZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKLSAgICAgICAgICAgICAgICBw
  cmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmluZXsk
  X30gPX4gL15cdyskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAgICAg
  ICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7
  JF99IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNlIHsKKwlwcmludCBQUkVBTUJMRSAiIyBU
  aGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJzaW9uICRWRVJTSU9OXG4iOworICAgICAg
  ICAjIFByZXZlbnQgbm9uLXBvcnRhYmxlIGhleCBjb25zdGFudHMgZnJvbSB3YXJuaW5nLgorICAg
  ICAgICAjCisgICAgICAgICMgV2Ugc3RpbGwgcHJvZHVjZSBhbiBvdmVyZmxvdyB3YXJuaW5nIGlm
  IHdlIGNhbid0IHJlcHJlc2VudAorICAgICAgICAjIGEgaGV4IGNvbnN0YW50IGFzIGFuIGludGVn
  ZXIuCisgICAgICAgIHByaW50IFBSRUFNQkxFICJubyB3YXJuaW5ncyBxdyhwb3J0YWJsZSk7XG4i
  OworCisJZm9yZWFjaCAoc29ydCBrZXlzICVkZWZpbmUpIHsKKwkgICAgaWYgKCRvcHRfRCkgewor
  CQlwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKKwkgICAgfQorCSAgICBpZiAo
  JGRlZmluZXskX30gPX4gL15cKCguKilcKSQvKSB7CisJCSMgcGFyZW50aGVzaXplZCB2YWx1ZTog
  IGQ9KHYpCisJCSRkZWZpbmV7JF99ID0gJDE7CisJICAgIH0KKwkgICAgaWYgKCRkZWZpbmV7JF99
  ID1+IC9eKFsrLV0/KFxkKyk/XC5cZCsoW2VFXVsrLV0/XGQrKT8pW0ZMXT8kLykgeworCQkjIGZs
  b2F0OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3Vi
  ICRfKCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL14oWyst
  XT9cZCspVT9MezAsMn0kL2kpIHsKKwkJIyBpbnRlZ2VyOgorCQlwcmludCBQUkVBTUJMRQorCQkg
  ICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKyAgICAg
  ICAgICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/MHhbXGRhLWZdKylVP0x7MCwy
  fSQvaSkgeworICAgICAgICAgICAgICAgICMgaGV4IGludGVnZXIKKyAgICAgICAgICAgICAgICAj
  IFNwZWNpYWwgY2FzZWQsIHNpbmNlIHBlcmwgd2FybnMgb24gaGV4IGludGVnZXJzCisgICAgICAg
  ICAgICAgICAgIyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGluIGEgVVYuCisgICAgICAgICAg
  ICAgICAgIworICAgICAgICAgICAgICAgICMgVGhpcyB3YXkgd2UgZ2V0IHRoZSB3YXJuaW5nIGF0
  IHRpbWUgb2YgdXNlLCBzbyB0aGUgdXNlcgorICAgICAgICAgICAgICAgICMgb25seSBnZXRzIHRo
  ZSB3YXJuaW5nIGlmIHRoZXkgaGFwcGVuIHRvIHVzZSB0aGlzCisgICAgICAgICAgICAgICAgIyBw
  bGF0Zm9ybS1zcGVjaWZpYyBkZWZpbml0aW9uLgorICAgICAgICAgICAgICAgIG15ICRjb2RlID0g
  JDE7CisgICAgICAgICAgICAgICAgJGNvZGUgPSAiaGV4KCckY29kZScpIiBpZiBsZW5ndGggJGNv
  ZGUgPiAxMDsKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAg
  ICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7IFwiIiwKLSAgICAgICAgICAg
  ICAgICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7JF99KSwgIlwiIH0gfVxuXG4iOwotICAgICAgICAg
  ICAgfQotICAgICAgICB9CisgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRf
  KSB7IHN1YiAkXygpIHsgJGNvZGUgfSB9XG5cbiI7CisJICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99
  ID1+IC9eXHcrJC8pIHsKKwkJcHJpbnQgUFJFQU1CTEUKKwkJICAgICJ1bmxlc3MgKGRlZmluZWQg
  JiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOworCSAgICB9IGVsc2Ugewor
  CQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkg
  eyBcIiIsCisJCSAgICBxdW90ZW1ldGEoJGRlZmluZXskX30pLCAiXCIgfSB9XG5cbiI7CisJICAg
  IH0KKwl9CiAgICAgY2xvc2UgUFJFQU1CTEUgICAgICAgICAgICAgICBvciBkaWUgIkNhbm5vdCBj
  bG9zZSAkcHJlYW1ibGU6ICAkISI7CiB9CiAKQEAgLTY2NywxNSArNzQ2LDE0IEBAIHN1YiBfZXh0
  cmFjdF9jY19kZWZpbmVzCiB7CiAgICAgbXkgJWRlZmluZTsKICAgICBteSAkYWxsc3ltYm9scyAg
  PSBqb2luICIgIiwKLSAgICAgICAgQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAn
  Y3BwY2NzeW1ib2xzJ307CisJQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAnY3Bw
  Y2NzeW1ib2xzJ307CiAKICAgICAjIFNwbGl0IGNvbXBpbGVyIHByZS1kZWZpbml0aW9ucyBpbnRv
  IGBrZXk9dmFsdWUnIHBhaXJzOgotICAgIGZvcmVhY2ggKHNwbGl0IC9ccysvLCAkYWxsc3ltYm9s
  cykgewotICAgICAgICAvKC4rPyk9KC4rKS8gYW5kICRkZWZpbmV7JDF9ID0gJDI7Ci0KLSAgICAg
  ICAgaWYgKCRvcHRfRCkgewotICAgICAgICAgICAgcHJpbnQgU1RERVJSICIkXzogICQxIC0+ICQy
  XG4iOwotICAgICAgICB9CisgICAgd2hpbGUgKCRhbGxzeW1ib2xzID1+IC8oW15cc10rKT0oKFxc
  XHN8W15cc10pKykvZykgeworCSRkZWZpbmV7JDF9ID0gJDI7CisJaWYgKCRvcHRfRCkgeworCSAg
  ICBwcmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7CisJfQogICAgIH0KIAogICAgIHJldHVy
  biAlZGVmaW5lOwpAQCAtNzI1LDcgKzgwMyw3IEBAIElmIHJ1biB3aXRoIG5vIGFyZ3VtZW50cywg
  ZmlsdGVycyBzdGFuZGFyZCBpbnB1dCB0byBzdGFuZGFyZCBvdXRwdXQuCiA9aXRlbSAtZCBkZXN0
  aW5hdGlvbl9kaXIKIAogUHV0IHRoZSByZXN1bHRpbmcgQjwucGg+IGZpbGVzIGJlbmVhdGggQjxk
  ZXN0aW5hdGlvbl9kaXI+LCBpbnN0ZWFkIG9mCi1iZW5lYXRoIHRoZSBkZWZhdWx0IFBlcmwgbGli
  cmFyeSBsb2NhdGlvbiAoQzwkQ29uZmlneydpbnN0YWxsc2l0c2VhcmNoJ30+KS4KK2JlbmVhdGgg
  dGhlIGRlZmF1bHQgUGVybCBsaWJyYXJ5IGxvY2F0aW9uIChDPCRDb25maWd7J2luc3RhbGxzaXRl
  YXJjaCd9PikuCiAKID1pdGVtIC1yCiAKQEAgLTgxMCwxMCArODg4LDEwIEBAIGluc3RhbGxhdGlv
  bi4KIERvZXNuJ3QgaGFuZGxlIGNvbXBsaWNhdGVkIGV4cHJlc3Npb25zIGJ1aWx0IHBpZWNlbWVh
  bCwgYSBsYToKIAogICAgIGVudW0gewotICAgICAgICBGSVJTVF9WQUxVRSwKLSAgICAgICAgU0VD
  T05EX1ZBTFVFLAorCUZJUlNUX1ZBTFVFLAorCVNFQ09ORF9WQUxVRSwKICAgICAjaWZkZWYgQUJD
  Ci0gICAgICAgIFRISVJEX1ZBTFVFCisJVEhJUkRfVkFMVUUKICAgICAjZW5kaWYKICAgICB9Owog
  Cg==
  UH2PH580
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTg0LDcgKzg0LDcgQEAgc3Vi
  IHJlaW5kZW50KCQpIHsKIH0KIAogbXkgKCR0LCAkdGFiLCAlY3VyYXJncywgJG5ldywgJGV2YWxf
  aW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91dGZpbGUpOwotbXkgKCRpbmNsLCAkaW5jbF90
  eXBlLCAkbmV4dCk7CitteSAoJGluY2wsICRpbmNsX3R5cGUsICRpbmNsX3F1b3RlLCAkbmV4dCk7
  CiB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkpIHsKICAgICBpZiAoLWwg
  JGZpbGUgYW5kIC1kICRmaWxlKSB7CiAgICAgICAgIGxpbmtfaWZfcG9zc2libGUoJGZpbGUpIGlm
  ICgkb3B0X2wpOwpAQCAtMTg0LDkgKzE4NCwxMCBAQCB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUg
  PSBuZXh0X2ZpbGUoKSkpIHsKICAgICAgICAgICAgICAgICAgICAgICBwcmludCBPVVQgJHQsInVu
  bGVzcyhkZWZpbmVkKFwmJG5hbWUpKSB7XG4gICAgc3ViICRuYW1lICgpIHtcdCIsJG5ldywiO31c
  bn1cbiI7CiAJCSAgICB9CiAJCX0KLQkgICAgfSBlbHNpZiAoL14oaW5jbHVkZXxpbXBvcnR8aW5j
  bHVkZV9uZXh0KVxzKls8XCJdKC4qKVs+XCJdLykgeworCSAgICB9IGVsc2lmICgvXihpbmNsdWRl
  fGltcG9ydHxpbmNsdWRlX25leHQpXHMqKFs8XCJdKSguKilbPlwiXS8pIHsKICAgICAgICAgICAg
  ICAgICAkaW5jbF90eXBlID0gJDE7Ci0gICAgICAgICAgICAgICAgJGluY2wgPSAkMjsKKyAgICAg
  ICAgICAgICAgICAkaW5jbF9xdW90ZSA9ICQyOworICAgICAgICAgICAgICAgICRpbmNsID0gJDM7
  CiAgICAgICAgICAgICAgICAgaWYgKCgkaW5jbF90eXBlIGVxICdpbmNsdWRlX25leHQnKSB8fAog
  ICAgICAgICAgICAgICAgICAgICAoJG9wdF9lICYmIGV4aXN0cygkYmFkX2ZpbGV7JGluY2x9KSkp
  IHsKICAgICAgICAgICAgICAgICAgICAgJGluY2wgPX4gcy9cLmgkLy5waC87CkBAIC0yMTksNiAr
  MjIwLDEwIEBAIHdoaWxlIChkZWZpbmVkIChteSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCQkJ
  ICAgIndhcm4oXCRcQCkgaWYgXCRcQDtcbiIpOwogICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAg
  ICAgICAgICAgICAgICAgICAgICRpbmNsID1+IHMvXC5oJC8ucGgvOworICAgICAgICAgICAgICAg
  ICAgICAjIGNvcHkgdGhlIHByZWZpeCBpbiB0aGUgcXVvdGUgc3ludGF4ICgjaW5jbHVkZSAieC5o
  IikgY2FzZQorICAgICAgICAgICAgICAgICAgICBpZiAoJGluY2wgIX4gbXwvfCAmJiAkaW5jbF9x
  dW90ZSBlcSBxeyJ9ICYmICRmaWxlID1+IG18XiguKikvfCkgeworICAgICAgICAgICAgICAgICAg
  ICAgICAgJGluY2wgPSAiJDEvJGluY2wiOworICAgICAgICAgICAgICAgICAgICB9CiAJCSAgICBw
  cmludCBPVVQgJHQsInJlcXVpcmUgJyRpbmNsJztcbiI7CiAgICAgICAgICAgICAgICAgfQogCSAg
  ICB9IGVsc2lmICgvXmlmZGVmXHMrKFx3KykvKSB7CkBAIC00MzEsNyArNDM2LDcgQEAgc3ViIGV4
  cHIgewogCQl9CiAJICAgIH0gZWxzZSB7CiAJCWlmICgkaW5pZiAmJiAkbmV3ICF+IC9kZWZpbmVk
  XHMqXCgkLykgewotCQkgICAgJG5ldyAuPSAnKGRlZmluZWQoJicgLiAkaWQgLiAnKSA/ICYnIC4g
  JGlkIC4gJyA6IDApJzsKKwkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAm
  JyAuICRpZCAuICcgOiB1bmRlZiknOwogCQl9IGVsc2lmICgvXlxbLykgewogCQkgICAgJG5ldyAu
  PSAiIFwkJGlkIjsKIAkJfSBlbHNlIHsKQEAgLTYzOSw4ICs2NDQsMTMgQEAgc3ViIHF1ZXVlX2lu
  Y2x1ZGVzX2Zyb20KICAgICAgICAgICAgICAgICAkbGluZSAuPSA8SEVBREVSPjsKICAgICAgICAg
  ICAgIH0KIAotICAgICAgICAgICAgaWYgKCRsaW5lID1+IC9eI1xzKmluY2x1ZGVccys8KC4qPyk+
  LykgewotICAgICAgICAgICAgICAgIHB1c2goQEFSR1YsICQxKSB1bmxlc3MgJElzX2NvbnZlcnRl
  ZHskMX07CisgICAgICAgICAgICBpZiAoJGxpbmUgPX4gL14jXHMqaW5jbHVkZVxzKyhbPCJdKSgu
  Kj8pWz4iXS8pIHsKKyAgICAgICAgICAgICAgICBteSAoJGRlbGltaXRlciwgJG5ld19maWxlKSA9
  ICgkMSwgJDIpOworICAgICAgICAgICAgICAgICMgY29weSB0aGUgcHJlZml4IGluIHRoZSBxdW90
  ZSBzeW50YXggKCNpbmNsdWRlICJ4LmgiKSBjYXNlCisgICAgICAgICAgICAgICAgaWYgKCRkZWxp
  bWl0ZXIgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4oLiopL3wpIHsKKyAgICAgICAgICAgICAgICAg
  ICAgJG5ld19maWxlID0gIiQxLyRuZXdfZmlsZSI7CisgICAgICAgICAgICAgICAgfQorICAgICAg
  ICAgICAgICAgIHB1c2goQEFSR1YsICRuZXdfZmlsZSkgdW5sZXNzICRJc19jb252ZXJ0ZWR7JG5l
  d19maWxlfTsKICAgICAgICAgICAgIH0KICAgICAgICAgfQogICAgIGNsb3NlIEhFQURFUjsKQEAg
  LTY4MSwyNSArNjkxLDUwIEBAIHN1YiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkKICAgICBt
  eSAoJWRlZmluZSkgPSBfZXh0cmFjdF9jY19kZWZpbmVzKCk7CiAKICAgICBvcGVuICBQUkVBTUJM
  RSwgIj4kcHJlYW1ibGUiIG9yIGRpZSAiQ2Fubm90IG9wZW4gJHByZWFtYmxlOiAgJCEiOwotICAg
  ICAgICBwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJz
  aW9uICRWRVJTSU9OXG4iOwotCi0gICAgICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlZGVmaW5lKSB7
  Ci0gICAgICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJFQU1C
  TEUgIiMgJF89JGRlZmluZXskX31cbiI7Ci0gICAgICAgICAgICB9Ci0KLSAgICAgICAgICAgIGlm
  ICgkZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKLSAgICAgICAgICAgICAgICBw
  cmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmluZXsk
  X30gPX4gL15cdyskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAgICAg
  ICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7
  JF99IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNlIHsKKwlwcmludCBQUkVBTUJMRSAiIyBU
  aGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJzaW9uICRWRVJTSU9OXG4iOworICAgICAg
  ICAjIFByZXZlbnQgbm9uLXBvcnRhYmxlIGhleCBjb25zdGFudHMgZnJvbSB3YXJuaW5nLgorICAg
  ICAgICAjCisgICAgICAgICMgV2Ugc3RpbGwgcHJvZHVjZSBhbiBvdmVyZmxvdyB3YXJuaW5nIGlm
  IHdlIGNhbid0IHJlcHJlc2VudAorICAgICAgICAjIGEgaGV4IGNvbnN0YW50IGFzIGFuIGludGVn
  ZXIuCisgICAgICAgIHByaW50IFBSRUFNQkxFICJubyB3YXJuaW5ncyBxdyhwb3J0YWJsZSk7XG4i
  OworCisJZm9yZWFjaCAoc29ydCBrZXlzICVkZWZpbmUpIHsKKwkgICAgaWYgKCRvcHRfRCkgewor
  CQlwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKKwkgICAgfQorCSAgICBpZiAo
  JGRlZmluZXskX30gPX4gL15cKCguKilcKSQvKSB7CisJCSMgcGFyZW50aGVzaXplZCB2YWx1ZTog
  IGQ9KHYpCisJCSRkZWZpbmV7JF99ID0gJDE7CisJICAgIH0KKwkgICAgaWYgKCRkZWZpbmV7JF99
  ID1+IC9eKFsrLV0/KFxkKyk/XC5cZCsoW2VFXVsrLV0/XGQrKT8pW0ZMXT8kLykgeworCQkjIGZs
  b2F0OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3Vi
  ICRfKCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL14oWyst
  XT9cZCspVT9MezAsMn0kL2kpIHsKKwkJIyBpbnRlZ2VyOgorCQlwcmludCBQUkVBTUJMRQorCQkg
  ICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKyAgICAg
  ICAgICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/MHhbXGRhLWZdKylVP0x7MCwy
  fSQvaSkgeworICAgICAgICAgICAgICAgICMgaGV4IGludGVnZXIKKyAgICAgICAgICAgICAgICAj
  IFNwZWNpYWwgY2FzZWQsIHNpbmNlIHBlcmwgd2FybnMgb24gaGV4IGludGVnZXJzCisgICAgICAg
  ICAgICAgICAgIyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGluIGEgVVYuCisgICAgICAgICAg
  ICAgICAgIworICAgICAgICAgICAgICAgICMgVGhpcyB3YXkgd2UgZ2V0IHRoZSB3YXJuaW5nIGF0
  IHRpbWUgb2YgdXNlLCBzbyB0aGUgdXNlcgorICAgICAgICAgICAgICAgICMgb25seSBnZXRzIHRo
  ZSB3YXJuaW5nIGlmIHRoZXkgaGFwcGVuIHRvIHVzZSB0aGlzCisgICAgICAgICAgICAgICAgIyBw
  bGF0Zm9ybS1zcGVjaWZpYyBkZWZpbml0aW9uLgorICAgICAgICAgICAgICAgIG15ICRjb2RlID0g
  JDE7CisgICAgICAgICAgICAgICAgJGNvZGUgPSAiaGV4KCckY29kZScpIiBpZiBsZW5ndGggJGNv
  ZGUgPiAxMDsKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAg
  ICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7IFwiIiwKLSAgICAgICAgICAg
  ICAgICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7JF99KSwgIlwiIH0gfVxuXG4iOwotICAgICAgICAg
  ICAgfQotICAgICAgICB9CisgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRf
  KSB7IHN1YiAkXygpIHsgJGNvZGUgfSB9XG5cbiI7CisJICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99
  ID1+IC9eXHcrJC8pIHsKKwkJcHJpbnQgUFJFQU1CTEUKKwkJICAgICJ1bmxlc3MgKGRlZmluZWQg
  JiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOworCSAgICB9IGVsc2Ugewor
  CQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkg
  eyBcIiIsCisJCSAgICBxdW90ZW1ldGEoJGRlZmluZXskX30pLCAiXCIgfSB9XG5cbiI7CisJICAg
  IH0KKwl9CiAgICAgY2xvc2UgUFJFQU1CTEUgICAgICAgICAgICAgICBvciBkaWUgIkNhbm5vdCBj
  bG9zZSAkcHJlYW1ibGU6ICAkISI7CiB9CiAKQEAgLTcxMSwxNSArNzQ2LDE0IEBAIHN1YiBfZXh0
  cmFjdF9jY19kZWZpbmVzCiB7CiAgICAgbXkgJWRlZmluZTsKICAgICBteSAkYWxsc3ltYm9scyAg
  PSBqb2luICIgIiwKLSAgICAgICAgQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAn
  Y3BwY2NzeW1ib2xzJ307CisJQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAnY3Bw
  Y2NzeW1ib2xzJ307CiAKICAgICAjIFNwbGl0IGNvbXBpbGVyIHByZS1kZWZpbml0aW9ucyBpbnRv
  IGBrZXk9dmFsdWUnIHBhaXJzOgotICAgIGZvcmVhY2ggKHNwbGl0IC9ccysvLCAkYWxsc3ltYm9s
  cykgewotICAgICAgICAvKC4rPyk9KC4rKS8gYW5kICRkZWZpbmV7JDF9ID0gJDI7Ci0KLSAgICAg
  ICAgaWYgKCRvcHRfRCkgewotICAgICAgICAgICAgcHJpbnQgU1RERVJSICIkXzogICQxIC0+ICQy
  XG4iOwotICAgICAgICB9CisgICAgd2hpbGUgKCRhbGxzeW1ib2xzID1+IC8oW15cc10rKT0oKFxc
  XHN8W15cc10pKykvZykgeworCSRkZWZpbmV7JDF9ID0gJDI7CisJaWYgKCRvcHRfRCkgeworCSAg
  ICBwcmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7CisJfQogICAgIH0KIAogICAgIHJldHVy
  biAlZGVmaW5lOwpAQCAtNzY5LDcgKzgwMyw3IEBAIElmIHJ1biB3aXRoIG5vIGFyZ3VtZW50cywg
  ZmlsdGVycyBzdGFuZGFyZCBpbnB1dCB0byBzdGFuZGFyZCBvdXRwdXQuCiA9aXRlbSAtZCBkZXN0
  aW5hdGlvbl9kaXIKIAogUHV0IHRoZSByZXN1bHRpbmcgQjwucGg+IGZpbGVzIGJlbmVhdGggQjxk
  ZXN0aW5hdGlvbl9kaXI+LCBpbnN0ZWFkIG9mCi1iZW5lYXRoIHRoZSBkZWZhdWx0IFBlcmwgbGli
  cmFyeSBsb2NhdGlvbiAoQzwkQ29uZmlneydpbnN0YWxsc2l0c2VhcmNoJ30+KS4KK2JlbmVhdGgg
  dGhlIGRlZmF1bHQgUGVybCBsaWJyYXJ5IGxvY2F0aW9uIChDPCRDb25maWd7J2luc3RhbGxzaXRl
  YXJjaCd9PikuCiAKID1pdGVtIC1yCiAKQEAgLTg1NCwxMCArODg4LDEwIEBAIGluc3RhbGxhdGlv
  bi4KIERvZXNuJ3QgaGFuZGxlIGNvbXBsaWNhdGVkIGV4cHJlc3Npb25zIGJ1aWx0IHBpZWNlbWVh
  bCwgYSBsYToKIAogICAgIGVudW0gewotICAgICAgICBGSVJTVF9WQUxVRSwKLSAgICAgICAgU0VD
  T05EX1ZBTFVFLAorCUZJUlNUX1ZBTFVFLAorCVNFQ09ORF9WQUxVRSwKICAgICAjaWZkZWYgQUJD
  Ci0gICAgICAgIFRISVJEX1ZBTFVFCisJVEhJUkRfVkFMVUUKICAgICAjZW5kaWYKICAgICB9Owog
  Cg==
  UH2PH588
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTU4LDEzICs1OCwxNCBAQAog
  ZGllICJEZXN0aW5hdGlvbiBkaXJlY3RvcnkgJERlc3RfZGlyIGRvZXNuJ3QgZXhpc3Qgb3IgaXNu
  J3QgYSBkaXJlY3RvcnlcbiIKICAgICB1bmxlc3MgLWQgJERlc3RfZGlyOwogCi1teSBAaXNhdHlw
  ZSA9IHNwbGl0KCcgJyw8PEVORCk7CitteSBAaXNhdHlwZSA9IHF3KAogCWNoYXIJdWNoYXIJdV9j
  aGFyCiAJc2hvcnQJdXNob3J0CXVfc2hvcnQKIAlpbnQJdWludAl1X2ludAogCWxvbmcJdWxvbmcJ
  dV9sb25nCiAJRklMRQlrZXlfdAljYWRkcl90Ci1FTkQKKwlmbG9hdAlkb3VibGUJc2l6ZV90Cisp
  OwogCiBteSAlaXNhdHlwZTsKIEBpc2F0eXBle0Bpc2F0eXBlfSA9ICgxKSB4IEBpc2F0eXBlOwpA
  QCAtMTMzLDE5ICsxMzQsMjAgQEAKIAkJcy9cKFx3K1xzKlwoXCpcKVxzKlwoXHcqXClcKVxzKigt
  P1xkKykvJDEvOyAjIChpbnQgKCopKGZvb190KSkwCiAJCWlmIChzL15cKChbXHcsXHNdKilcKS8v
  KSB7CiAJCSAgICAkYXJncyA9ICQxOwotICAgIAkgICAgCSAgICBteSAkcHJvdG8gPSAnKCkgJzsK
  KwkJICAgIG15ICRwcm90byA9ICcoKSAnOwogCQkgICAgaWYgKCRhcmdzIG5lICcnKSB7Ci0gICAg
  CSAgICAJICAgIAkkcHJvdG8gPSAnJzsKKwkJCSRwcm90byA9ICcnOwogCQkJZm9yZWFjaCBteSAk
  YXJnIChzcGxpdCgvLFxzKi8sJGFyZ3MpKSB7CiAJCQkgICAgJGFyZyA9fiBzL15ccyooW15cc10u
  KlteXHNdKVxzKiQvJDEvOwogCQkJICAgICRjdXJhcmdzeyRhcmd9ID0gMTsKIAkJCX0KIAkJCSRh
  cmdzID1+IHMvXGIoXHcpL1wkJDEvZzsKLQkJCSRhcmdzID0gImxvY2FsKCRhcmdzKSA9IFxAXztc
  biR0ICAgICI7CisJCQkkYXJncyA9ICJteSgkYXJncykgPSBcQF87XG4kdCAgICAiOwogCQkgICAg
  fQogCQkgICAgcy9eXHMrLy87CiAJCSAgICBleHByKCk7CiAJCSAgICAkbmV3ID1+IHMvKFsiXFxd
  KS9cXCQxL2c7ICAgICAgICMiXSk7CisJCSAgRU1JVDoKIAkJICAgICRuZXcgPSByZWluZGVudCgk
  bmV3KTsKIAkJICAgICRhcmdzID0gcmVpbmRlbnQoJGFyZ3MpOwogCQkgICAgaWYgKCR0IG5lICcn
  KSB7CkBAIC0yNjgsMTIgKzI3MCwxNCBAQAogCSAgICB9IGVsc2lmKC9eaWRlbnRccysoLiopLykg
  ewogCQlwcmludCBPVVQgJHQsICIjICQxXG4iOwogCSAgICB9Ci0JfSBlbHNpZigvXlxzKih0eXBl
  ZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3KlxzKik/LykgeworCX0gZWxzaWYgKC9eXHMq
  KHR5cGVkZWZccyopP2VudW1ccyooXHMrW2EtekEtWl9dXHcqXHMqKT8vKSB7ICMgeyBmb3IgdmkK
  IAkgICAgdW50aWwoL1x7W159XSpcfS4qOy8gfHwgLzsvKSB7CiAJCWxhc3QgdW5sZXNzIGRlZmlu
  ZWQgKCRuZXh0ID0gbmV4dF9saW5lKCRmaWxlKSk7CiAJCWNob21wICRuZXh0OwogCQkjIGRyb3Ag
  IiNkZWZpbmUgRk9PIEZPTyIgaW4gZW51bXMKIAkJJG5leHQgPX4gcy9eXHMqI1xzKmRlZmluZVxz
  KyhcdyspXHMrXDFccyokLy87CisJCSMgI2RlZmluZXMgaW4gZW51bXMgKGFsaWFzZXMpCisJCSRu
  ZXh0ID1+IHMvXlxzKiNccypkZWZpbmVccysoXHcrKVxzKyhcdyspXHMqJC8kMSA9ICQyLC87CiAJ
  CSRfIC49ICRuZXh0OwogCQlwcmludCBPVVQgIiMgJG5leHRcbiIgaWYgJG9wdF9EOwogCSAgICB9
  CkBAIC0yODYsNiArMjkwLDcgQEAKIAkgICAgbXkgJGVudW1fdmFsID0gLTE7CiAJICAgIGZvcmVh
  Y2ggbXkgJGVudW0gKEBlbnVtX3N1YnMpIHsKIAkJbXkgKCRlbnVtX25hbWUsICRlbnVtX3ZhbHVl
  KSA9ICRlbnVtID1+IC9eKFthLXpBLVpfXVx3KikoPS4rKT8kLzsKKwkJJGVudW1fbmFtZSBvciBu
  ZXh0OwogCQkkZW51bV92YWx1ZSA9fiBzL149Ly87CiAJCSRlbnVtX3ZhbCA9IChsZW5ndGgoJGVu
  dW1fdmFsdWUpID8gJGVudW1fdmFsdWUgOiAkZW51bV92YWwgKyAxKTsKIAkJaWYgKCRvcHRfaCkg
  ewpAQCAtMzAwLDYgKzMwNSw3NSBAQAogCQkJICAgICAgICJ1bmxlc3MgZGVmaW5lZChcJiRlbnVt
  X25hbWUpO1xuIik7CiAJCX0KIAkgICAgfQorCX0gZWxzaWYgKC9eKD86X19leHRlbnNpb25fX1xz
  Kyk/KD86ZXh0ZXJufHN0YXRpYylccysoPzpfXyk/aW5saW5lKD86X18pP1xzKy8KKwkgICAgYW5k
  ICEvO1xzKiQvIGFuZCAhL3tccyp9XHMqJC8pCisJeyAjIHsgZm9yIHZpCisJICAgICMgVGhpcyBp
  cyBhIGhhY2sgdG8gcGFyc2UgdGhlIGlubGluZSBmdW5jdGlvbnMgaW4gdGhlIGdsaWJjIGhlYWRl
  cnMuCisJICAgICMgV2FybmluZzogbWFzc2l2ZSBrbHVkZ2UgYWhlYWQuIFdlIHN1cHBvc2UgaW5s
  aW5lIGZ1bmN0aW9ucworCSAgICAjIGFyZSBtYWlubHkgY29uc3RydWN0ZWQgbGlrZSBtYWNyb3Mu
  CisJICAgIHdoaWxlICgxKSB7CisJCWxhc3QgdW5sZXNzIGRlZmluZWQgKCRuZXh0ID0gbmV4dF9s
  aW5lKCRmaWxlKSk7CisJCWNob21wICRuZXh0OworCQl1bmRlZiAkXywgbGFzdCBpZiAkbmV4dCA9
  fiAvX19USFJPV1xzKjsvCisJCQkgICAgICAgb3IgJG5leHQgPX4gL14oX19leHRlbnNpb25fX3xl
  eHRlcm58c3RhdGljKVxiLzsKKwkJJF8gLj0gIiAkbmV4dCI7CisJCXByaW50IE9VVCAiIyAkbmV4
  dFxuIiBpZiAkb3B0X0Q7CisJCWxhc3QgaWYgJG5leHQgPX4gL159fF57Lip9XHMqJC87CisJICAg
  IH0KKwkgICAgbmV4dCBpZiBub3QgZGVmaW5lZDsgIyBiZWNhdXNlIGl0J3Mgb25seSBhIHByb3Rv
  dHlwZQorCSAgICBzL1xiKF9fZXh0ZW5zaW9uX198ZXh0ZXJufHN0YXRpY3woPzpfXyk/aW5saW5l
  KD86X18pPylcYi8vZzsKKwkgICAgIyB2aW9sZW50bHkgZHJvcCAjaWZkZWZzCisJICAgIHMvI1xz
  KmlmLio/I1xzKmVuZGlmLy9nCisJCWFuZCBwcmludCBPVVQgIiMgc29tZSAjaWZkZWYgd2VyZSBk
  cm9wcGVkIGhlcmUgLS0gZmlsbCBpbiB0aGUgYmxhbmtzXG4iOworCSAgICBpZiAocy9eKD86XHd8
  XHN8XCopKlxzKFx3KylccyovLykgeworCQkkbmFtZSA9ICQxOworCSAgICB9IGVsc2UgeworCQl3
  YXJuICJuYW1lIG5vdCBmb3VuZCI7IG5leHQ7ICMgc2hvdWxkbid0IG9jY3VyLi4uCisJICAgIH0K
  KwkgICAgbXkgQGFyZ3M7CisJICAgIGlmIChzL15cKChbXigpXSopXClccyooXHcrXHMqKSovLykg
  eworCQlmb3IgbXkgJGFyZyAoc3BsaXQgLywvLCAkMSkgeworCQkgICAgaWYgKCRhcmcgPX4gLyhc
  dyspXHMqJC8pIHsKKwkJCSRjdXJhcmdzeyQxfSA9IDE7CisJCQlwdXNoIEBhcmdzLCAkMTsKKwkJ
  ICAgIH0KKwkJfQorCSAgICB9CisJICAgICRhcmdzID0gKAorCQlAYXJncworCQk/ICJteSgiIC4g
  KGpvaW4gJywnLCBtYXAgIlwkJF8iLCBAYXJncykgLiAiKSA9IFxAXztcbiR0ICAgICIKKwkJOiAi
  IgorCSAgICApOworCSAgICBteSAkcHJvdG8gPSBAYXJncyA/ICcnIDogJygpICc7CisJICAgICRu
  ZXcgPSAnJzsKKwkgICAgcy9cYnJldHVyblxiLy9nOyAjICJyZXR1cm4iIGRvZXNuJ3Qgb2NjdXIg
  aW4gbWFjcm9zIHVzdWFsbHkuLi4KKwkgICAgZXhwcigpOworCSAgICAjIHRyeSB0byBmaW5kIGFu
  ZCBwZXJsaWZ5IGxvY2FsIEMgdmFyaWFibGVzCisJICAgIG91ciBAbG9jYWxfdmFyaWFibGVzID0g
  KCk7ICMgbmVlZHMgdG8gYmUgYSBvdXIoKTogKD97Li4ufSkgYnVnIHdvcmthcm91bmQKKwkgICAg
  eworCQl1c2UgcmUgImV2YWwiOworCQlteSAkdHlwZWxpc3QgPSBqb2luICd8Jywga2V5cyAlaXNh
  dHlwZTsKKwkJJG5ldyA9fiBzWycKKwkJICAoPzooPzp1bik/c2lnbmVkXHMrKT8KKwkJICAoPzps
  b25nXHMrKT8KKwkJICAoPzokdHlwZWxpc3QpXHMrCisJCSAgKFx3KykKKwkJICAoP3sgcHVzaCBA
  bG9jYWxfdmFyaWFibGVzLCAkMSB9KQorCQkgICddCisJCSBbbXkgXCQkMV1neDsKKwkJJG5ldyA9
  fiBzWycKKwkJICAoPzooPzp1bik/c2lnbmVkXHMrKT8KKwkJICAoPzpsb25nXHMrKT8KKwkJICAo
  PzokdHlwZWxpc3QpXHMrCisJCSAgJyBccysgJihcdyspIFxzKiA7CisJCSAgKD97IHB1c2ggQGxv
  Y2FsX3ZhcmlhYmxlcywgJDEgfSkKKwkJICBdCisJCSBbbXkgXCQkMTtdZ3g7CisJICAgICB9CisJ
  ICAgICRuZXcgPX4gcy8mJF9cYi9cJCRfL2cgZm9yIEBsb2NhbF92YXJpYWJsZXM7CisJICAgICRu
  ZXcgPX4gcy8oWyJcXF0pL1xcJDEvZzsgICAgICAgIyJdKTsKKwkgICAgIyBub3cgdGhhdCdzIGFs
  bW9zdCBsaWtlIGEgbWFjcm8gKHdlIGhvcGUpCisJICAgIGdvdG8gRU1JVDsKIAl9CiAgICAgfQog
  ICAgICRJc19jb252ZXJ0ZWR7JGZpbGV9ID0gMTsKQEAgLTMwOCw3ICszODIsNyBAQAogICAgICAg
  ICAkbmV4dCA9ICcnOwogICAgIH0gZWxzZSB7CiAgICAgICAgIHByaW50IE9VVCAiMTtcbiI7Ci0g
  ICAgcXVldWVfaW5jbHVkZXNfZnJvbSgkZmlsZSkgaWYgKCRvcHRfYSk7CisJcXVldWVfaW5jbHVk
  ZXNfZnJvbSgkZmlsZSkgaWYgJG9wdF9hOwogICAgIH0KIH0KIApAQCAtMzIwLDYgKzM5NCw3IEBA
  CiBleGl0ICRFeGl0OwogCiBzdWIgZXhwciB7CisgICAgJG5ldyA9ICciKGFzc2VtYmx5IGNvZGUp
  IicgYW5kIHJldHVybiBpZiAvXGJfX2FzbV9fXGIvOyAjIGZyZWFrIG91dC4KICAgICBteSAkam9p
  bmVkX2FyZ3M7CiAgICAgaWYoa2V5cyglY3VyYXJncykpIHsKIAkkam9pbmVkX2FyZ3MgPSBqb2lu
  KCd8Jywga2V5cyglY3VyYXJncykpOwpAQCAtMzI4LDcgKzQwMyw3IEBACiAJcy9eXCZcJi8vICYm
  IGRvIHsgJG5ldyAuPSAiICYmIjsgbmV4dDt9OyAjIGhhbmRsZSAmJiBvcGVyYXRvcgogCXMvXlwm
  KFtcKGEtelwpXSspLyQxL2k7CSMgaGFjayBmb3IgdGhpbmdzIHRoYXQgdGFrZSB0aGUgYWRkcmVz
  cyBvZgogCXMvXihccyspLy8JCSYmIGRvIHskbmV3IC49ICcgJzsgbmV4dDt9OwotCXMvXjBYKFsw
  LTlBLUZdKylbVUxdKi8vaSAKKwlzL14wWChbMC05QS1GXSspW1VMXSovL2kKIAkgICAgJiYgZG8g
  e215ICRoZXggPSAkMTsKIAkJICAgJGhleCA9fiBzL14wKy8vOwogCQkgICBpZiAobGVuZ3RoICRo
  ZXggPiA4ICYmICEkQ29uZmlne3VzZTY0Yml0aW50fSkgewpAQCAtMzgwLDEwICs0NTUsMTYgQEAK
  ICAgICAgICAgfTsKIAkjIEVsaW1pbmF0ZSB0eXBlZGVmcwogCS9cKChbXHdcc10rKVtcKlxzXSpc
  KVxzKltcd1woXS8gJiYgZG8geworCSAgICBteSAkZG9pdCA9IDE7CiAJICAgIGZvcmVhY2ggKHNw
  bGl0IC9ccysvLCAkMSkgeyAgIyBNYWtlIHN1cmUgYWxsIHRoZSB3b3JkcyBhcmUgdHlwZXMsCi0J
  CWxhc3QgdW5sZXNzICgkaXNhdHlwZXskX30gb3IgJF8gZXEgJ3N0cnVjdCcgb3IgJF8gZXEgJ3Vu
  aW9uJyk7CisJICAgICAgICB1bmxlc3MoJGlzYXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnIG9y
  ICRfIGVxICd1bmlvbicpeworCQkgICAgJGRvaXQgPSAwOworCQkgICAgbGFzdDsKKwkJfQorCSAg
  ICB9CisJICAgIGlmKCAkZG9pdCApeworCQlzL1woW1x3XHNdK1tcKlxzXSpcKS8vICYmIG5leHQ7
  ICAgICAgIyB0aGVuIGVsaW1pbmF0ZSB0aGVtLgogCSAgICB9Ci0JICAgIHMvXChbXHdcc10rW1wq
  XHNdKlwpLy8gJiYgbmV4dDsgICAgICAjIHRoZW4gZWxpbWluYXRlIHRoZW0uCiAJfTsKIAkjIHN0
  cnVjdC91bmlvbiBtZW1iZXIsIGluY2x1ZGluZyBhcnJheXM6CiAJcy9eKFtfQS1aXVx3KihcW1te
  XF1dK1xdKT8oKFwufC0+KVtfQS1aXVx3KihcW1teXF1dK1xdKT8pKykvL2kgJiYgZG8gewpAQCAt
  NDU4LDcgKzUzOSw3IEBACiAKICAgICAgICAgd2hpbGUgKGxlbmd0aCAkaW4pIHsKICAgICAgICAg
  ICAgIGlmICgkcHJlX3N1Yl90cmlfZ3JhcGhzKSB7Ci0gICAgICAgICAgICAgICAgIyBQcmVwcm9j
  ZXNzIGFsbCB0cmktZ3JhcGhzIAorICAgICAgICAgICAgICAgICMgUHJlcHJvY2VzcyBhbGwgdHJp
  LWdyYXBocwogICAgICAgICAgICAgICAgICMgaW5jbHVkaW5nIHRoaW5ncyBzdHVjayBpbiBxdW90
  ZWQgc3RyaW5nIGNvbnN0YW50cy4KICAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/PS8jL2c7
  ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pz18ICAjfAogICAgICAgICAgICAgICAgICRp
  biA9fiBzL1w/XD9cIS98L2c7ICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/IXwgIHx8CkBA
  IC00NzEsMTcgKzU1MiwxOSBAQAogICAgICAgICAgICAgICAgICRpbiA9fiBzL1w/XD8+L30vZzsg
  ICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/PnwgIH18CiAgICAgICAgICAgICB9CiAJICAg
  IGlmICgkaW4gPX4gL15cI2lmZGVmIF9fTEFOR1VBR0VfUEFTQ0FMX18vKSB7Ci0gICAgICAgICAg
  ICAgICAgIyBUcnU2NCBkaXNhc3NlbWJsZXIuaCBldmlsbmVzczogbWl4ZWQgQyBhbmQgUGFzY2Fs
  LgorCQkjIFRydTY0IGRpc2Fzc2VtYmxlci5oIGV2aWxuZXNzOiBtaXhlZCBDIGFuZCBQYXNjYWwu
  CiAJCXdoaWxlICg8SU4+KSB7Ci0JCSAgICBsYXN0IGlmIC9eXCNlbmRpZi87IAorCQkgICAgbGFz
  dCBpZiAvXlwjZW5kaWYvOwogCQl9CisJCSRpbiA9ICIiOwogCQluZXh0IFJFQUQ7CiAJICAgIH0K
  IAkgICAgaWYgKCRpbiA9fiAvXmV4dGVybiBpbmxpbmUgLyAmJiAjIElubGluZWQgYXNzZW1ibGVy
  LgogCQkkXk8gZXEgJ2xpbnV4JyAmJiAkZmlsZSA9fiBtISg/Ol58Lylhc20vW14vXStcLmgkISkg
  ewotIAkJd2hpbGUgKDxJTj4pIHsKLQkJICAgIGxhc3QgaWYgL159LzsgCisJCXdoaWxlICg8SU4+
  KSB7CisJCSAgICBsYXN0IGlmIC9efS87CiAJCX0KKwkJJGluID0gIiI7CiAJCW5leHQgUkVBRDsK
  IAkgICAgfQogICAgICAgICAgICAgaWYgKCRpbiA9fiBzL1xcJC8vKSB7ICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgIyBcLW5ld2xpbmUK
  UH2PH592
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTM1NCw2ICszNTQsNyBAQAog
  CQl1c2UgcmUgImV2YWwiOwogCQlteSAkdHlwZWxpc3QgPSBqb2luICd8Jywga2V5cyAlaXNhdHlw
  ZTsKIAkJJG5ldyA9fiBzWycKKwkJICAoPzooPzpfXyk/Y29uc3QoPzpfXyk/XHMrKT8KIAkJICAo
  PzooPzp1bik/c2lnbmVkXHMrKT8KIAkJICAoPzpsb25nXHMrKT8KIAkJICAoPzokdHlwZWxpc3Qp
  XHMrCkBAIC0zNjIsNiArMzYzLDcgQEAKIAkJICAnXQogCQkgW215IFwkJDFdZ3g7CiAJCSRuZXcg
  PX4gc1snCisJCSAgKD86KD86X18pP2NvbnN0KD86X18pP1xzKyk/CiAJCSAgKD86KD86dW4pP3Np
  Z25lZFxzKyk/CiAJCSAgKD86bG9uZ1xzKyk/CiAJCSAgKD86JHR5cGVsaXN0KVxzKwpAQCAtNzM0
  LDkgKzczNiwxNSBAQAogIyBub24tR0NDPykgQyBjb21waWxlcnMsIGJ1dCBnY2MgdXNlcyBhbiBh
  ZGRpdGlvbmFsIGluY2x1ZGUgZGlyZWN0b3J5Lgogc3ViIGluY19kaXJzCiB7Ci0gICAgbXkgJGZy
  b21fZ2NjICAgID0gYCRDb25maWd7Y2N9IC12IDI+JjFgOwotICAgICRmcm9tX2djYyAgICAgICA9
  fiBzOl5SZWFkaW5nIHNwZWNzIGZyb20gKC4qPykvc3BlY3NcYi4qOiQxL2luY2x1ZGU6czsKLQor
  ICAgIG15ICRmcm9tX2djYyAgICA9IGBMQ19BTEw9QyAkQ29uZmlne2NjfSAtdiAyPiYxYDsKKyAg
  ICBpZiggISggJGZyb21fZ2NjID1+IHM6XlJlYWRpbmcgc3BlY3MgZnJvbSAoLio/KS9zcGVjc1xi
  Lio6JDEvaW5jbHVkZTpzICkgKQorICAgIHsgIyBnY2MtNCsgOgorICAgICAgICRmcm9tX2djYyAg
  ID0gYExDX0FMTD1DICRDb25maWd7Y2N9IC1wcmludC1zZWFyY2gtZGlycyAyPiYxYDsKKyAgICAg
  ICBpZiAoICEoJGZyb21fZ2NjID1+IHMvXmluc3RhbGw6XHMqKFteXHNdK1teXHNcL10pKFtcc1wv
  XSopLiokLyQxXC9pbmNsdWRlL3MpICkKKyAgICAgICB7CisgICAgICAgICAgICRmcm9tX2djYyA9
  ICcnOworICAgICAgIH07CisgICAgfTsKICAgICBsZW5ndGgoJGZyb21fZ2NjKSA/ICgkZnJvbV9n
  Y2MsICRDb25maWd7dXNyaW5jfSkgOiAoJENvbmZpZ3t1c3JpbmN9KTsKIH0KIAo=
  UH2PH593
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTUxNCw3ICs1MTQsNyBAQAog
  CQl9CiAJICAgIH0gZWxzZSB7CiAJCWlmICgkaW5pZiAmJiAkbmV3ICF+IC9kZWZpbmVkXHMqXCgk
  LykgewotCQkgICAgJG5ldyAuPSAnKGRlZmluZWQoJicgLiAkaWQgLiAnKSA/ICYnIC4gJGlkIC4g
  JyA6IDApJzsKKwkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAmJyAuICRp
  ZCAuICcgOiB1bmRlZiknOwogCQl9IGVsc2lmICgvXlxbLykgewogCQkgICAgJG5ldyAuPSAiIFwk
  JGlkIjsKIAkJfSBlbHNlIHsKQEAgLTc3MiwyNSArNzcyLDMzIEBACiAgICAgbXkgKCVkZWZpbmUp
  ID0gX2V4dHJhY3RfY2NfZGVmaW5lcygpOwogCiAgICAgb3BlbiAgUFJFQU1CTEUsICI+JHByZWFt
  YmxlIiBvciBkaWUgIkNhbm5vdCBvcGVuICRwcmVhbWJsZTogICQhIjsKLSAgICAgICAgcHJpbnQg
  UFJFQU1CTEUgIiMgVGhpcyBmaWxlIHdhcyBjcmVhdGVkIGJ5IGgycGggdmVyc2lvbiAkVkVSU0lP
  TlxuIjsKKwlwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2
  ZXJzaW9uICRWRVJTSU9OXG4iOwogCi0gICAgICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlZGVmaW5l
  KSB7Ci0gICAgICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJF
  QU1CTEUgIiMgJF89JGRlZmluZXskX31cbiI7Ci0gICAgICAgICAgICB9Ci0KLSAgICAgICAgICAg
  IGlmICgkZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKLSAgICAgICAgICAgICAg
  ICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYk
  XykgeyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmlu
  ZXskX30gPX4gL15cdyskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAg
  ICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZp
  bmV7JF99IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNlIHsKLSAgICAgICAgICAgICAgICBw
  cmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7IFwiIiwKLSAgICAgICAgICAgICAgICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7
  JF99KSwgIlwiIH0gfVxuXG4iOwotICAgICAgICAgICAgfQotICAgICAgICB9CisJZm9yZWFjaCAo
  c29ydCBrZXlzICVkZWZpbmUpIHsKKwkgICAgaWYgKCRvcHRfRCkgeworCQlwcmludCBQUkVBTUJM
  RSAiIyAkXz0kZGVmaW5leyRffVxuIjsKKwkgICAgfQorCSAgICBpZiAoJGRlZmluZXskX30gPX4g
  L15cKCguKilcKSQvKSB7CisJCSMgcGFyZW50aGVzaXplZCB2YWx1ZTogIGQ9KHYpCisJCSRkZWZp
  bmV7JF99ID0gJDE7CisJICAgIH0KKwkgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/KFxk
  Kyk/XC5cZCsoW2VFXVsrLV0/XGQrKT8pW0ZMXT8kLykgeworCQkjIGZsb2F0OgorCQlwcmludCBQ
  UkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1c
  blxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL14oWystXT9cZCspVT9MezAsMn0k
  L2kpIHsKKwkJIyBpbnRlZ2VyOgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVm
  aW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmlu
  ZXskX30gPX4gL15cdyskLykgeworCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVm
  aW5lZCAmJF8pIHsgc3ViICRfKCkgeyAmJGRlZmluZXskX30gfSB9XG5cbiI7CisJICAgIH0gZWxz
  ZSB7CisJCXByaW50IFBSRUFNQkxFCisJCSAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIg
  JF8oKSB7IFwiIiwKKwkJICAgIHF1b3RlbWV0YSgkZGVmaW5leyRffSksICJcIiB9IH1cblxuIjsK
  KwkgICAgfQorCX0KICAgICBjbG9zZSBQUkVBTUJMRSAgICAgICAgICAgICAgIG9yIGRpZSAiQ2Fu
  bm90IGNsb3NlICRwcmVhbWJsZTogICQhIjsKIH0KIApAQCAtODAyLDE1ICs4MTAsMTQgQEAKIHsK
  ICAgICBteSAlZGVmaW5lOwogICAgIG15ICRhbGxzeW1ib2xzICA9IGpvaW4gIiAiLAotICAgICAg
  ICBAQ29uZmlneydjY3N5bWJvbHMnLCAnY3Bwc3ltYm9scycsICdjcHBjY3N5bWJvbHMnfTsKKwlA
  Q29uZmlneydjY3N5bWJvbHMnLCAnY3Bwc3ltYm9scycsICdjcHBjY3N5bWJvbHMnfTsKIAogICAg
  ICMgU3BsaXQgY29tcGlsZXIgcHJlLWRlZmluaXRpb25zIGludG8gYGtleT12YWx1ZScgcGFpcnM6
  Ci0gICAgZm9yZWFjaCAoc3BsaXQgL1xzKy8sICRhbGxzeW1ib2xzKSB7Ci0gICAgICAgIC8oLis/
  KT0oLispLyBhbmQgJGRlZmluZXskMX0gPSAkMjsKLQotICAgICAgICBpZiAoJG9wdF9EKSB7Ci0g
  ICAgICAgICAgICBwcmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7Ci0gICAgICAgIH0KKyAg
  ICB3aGlsZSAoJGFsbHN5bWJvbHMgPX4gLyhbXlxzXSspPSgoXFxcc3xbXlxzXSkrKS9nKSB7CisJ
  JGRlZmluZXskMX0gPSAkMjsKKwlpZiAoJG9wdF9EKSB7CisJICAgIHByaW50IFNUREVSUiAiJF86
  ICAkMSAtPiAkMlxuIjsKKwl9CiAgICAgfQogCiAgICAgcmV0dXJuICVkZWZpbmU7CkBAIC05NDUs
  MTAgKzk1MiwxMCBAQAogRG9lc24ndCBoYW5kbGUgY29tcGxpY2F0ZWQgZXhwcmVzc2lvbnMgYnVp
  bHQgcGllY2VtZWFsLCBhIGxhOgogCiAgICAgZW51bSB7Ci0gICAgICAgIEZJUlNUX1ZBTFVFLAot
  ICAgICAgICBTRUNPTkRfVkFMVUUsCisJRklSU1RfVkFMVUUsCisJU0VDT05EX1ZBTFVFLAogICAg
  ICNpZmRlZiBBQkMKLSAgICAgICAgVEhJUkRfVkFMVUUKKwlUSElSRF9WQUxVRQogICAgICNlbmRp
  ZgogICAgIH07CiAK
  UH2PH594
  --- utils/h2ph.PL
  +++ utils/h2ph.PL
  @@ -788,6 +788,11 @@ sub build_preamble_if_necessary
   
       open  PREAMBLE, ">$preamble" or die "Cannot open $preamble:  $!";
   	print PREAMBLE "# This file was created by h2ph version $VERSION\n";
  +        # Prevent non-portable hex constants from warning.
  +        #
  +        # We still produce an overflow warning if we can't represent
  +        # a hex constant as an integer.
  +        print PREAMBLE "no warnings qw(portable);\n";
   
   	foreach (sort keys %define) {
   	    if ($opt_D) {
  @@ -814,6 +819,18 @@ DEFINE
   		# integer:
   		print PREAMBLE
   		    "unless (defined &$_) { sub $_() { $1 } }\n\n";
  +            } elsif ($define{$_} =~ /^([+-]?0x[\da-f]+)U?L{0,2}$/i) {
  +                # hex integer
  +                # Special cased, since perl warns on hex integers
  +                # that can't be represented in a UV.
  +                #
  +                # This way we get the warning at time of use, so the user
  +                # only gets the warning if they happen to use this
  +                # platform-specific definition.
  +                my $code = $1;
  +                $code = "hex('$code')" if length $code > 10;
  +                print PREAMBLE
  +                    "unless (defined &$_) { sub $_() { $code } }\n\n";
   	    } elsif ($define{$_} =~ /^\w+$/) {
   		my $def = $define{$_};
   		if ($isatype{$def}) {
  UH2PH
  --- lib/h2ph.t
  +++ lib/h2ph.t
  @@ -48,7 +48,7 @@ $result = runperl( progfile => '_h2ph_pre.ph',
                      stderr => 1 );
   like( $result, qr/syntax OK$/, "preamble compiles");
   
  -$result = runperl( switches => ["-w"],
  +$result = runperl( switches => ['-I.', "-w"],
                      stderr => 1,
                      prog => <<'PROG' );
   $SIG{__WARN__} = sub { die $_[0] }; require q(lib/h2ph.pht);
  LH2PH1
  --- lib/h2ph.t
  +++ lib/h2ph.t
  @@ -48,7 +48,7 @@ $result = runperl( progfile => '_h2ph_pre.ph',
                      stderr => 1 );
   like( $result, qr/syntax OK$/, "preamble compiles");
   
  -$result = runperl( switches => ["-w"], 
  +$result = runperl( switches => ['-I.', "-w"], 
                      stderr => 1,
                      prog => <<'PROG' );
   $SIG{__WARN__} = sub { die $_[0] }; require q(lib/h2ph.pht);
  LH2PH2
  --- lib/h2ph.t
  +++ lib/h2ph.t
  @@ -41,7 +41,7 @@ $result = runperl( progfile => 'lib/h2ph.pht',
                      stderr => 1 );
   like( $result, qr/syntax OK$/, "output compiles");
   
  -$result = runperl( switches => ["-w"], 
  +$result = runperl( switches => ['-I.',"-w"], 
                      prog => '$SIG{__WARN__} = sub { die $_[0] }; require q(lib/h2ph.pht);');
   is( $result, '', "output free of warnings" );
   
  LH2PH3
  LS0tIGV4dC9TREJNX0ZpbGUvc2RibS9zZGJtLmMKKysrIGV4dC9TREJNX0ZpbGUvc2RibS9zZGJt
  LmMKQEAgLTc4LDggKzc4LDggQEAgc2RibV9vcGVuKHJlZ2lzdGVyIGNoYXIgKmZpbGUsIHJlZ2lz
  dGVyIGludCBmbGFncywgcmVnaXN0ZXIgaW50IG1vZGUpCiAJcmVnaXN0ZXIgY2hhciAqZGlybmFt
  ZTsKIAlyZWdpc3RlciBjaGFyICpwYWduYW1lOwogCXNpemVfdCBmaWxlbGVuOwotCWNvbnN0IHNp
  emVfdCBkaXJmZXh0X2xlbiA9IHNpemVvZihESVJGRVhUICIiKTsKLQljb25zdCBzaXplX3QgcGFn
  ZmV4dF9sZW4gPSBzaXplb2YoUEFHRkVYVCAiIik7CisJY29uc3Qgc2l6ZV90IGRpcmZleHRfc2l6
  ZSA9IHNpemVvZihESVJGRVhUICIiKTsKKwljb25zdCBzaXplX3QgcGFnZmV4dF9zaXplID0gc2l6
  ZW9mKFBBR0ZFWFQgIiIpOwogCiAJaWYgKGZpbGUgPT0gTlVMTCB8fCAhKmZpbGUpCiAJCXJldHVy
  biBlcnJubyA9IEVJTlZBTCwgKERCTSAqKSBOVUxMOwpAQCAtODgsMTcgKzg4LDE3IEBAIHNkYm1f
  b3BlbihyZWdpc3RlciBjaGFyICpmaWxlLCByZWdpc3RlciBpbnQgZmxhZ3MsIHJlZ2lzdGVyIGlu
  dCBtb2RlKQogICovCiAJZmlsZWxlbiA9IHN0cmxlbihmaWxlKTsKIAotCWlmICgoZGlybmFtZSA9
  IChjaGFyICopIG1hbGxvYyhmaWxlbGVuICsgZGlyZmV4dF9sZW4gKyAxCi0JCQkJICAgICAgICsg
  ZmlsZWxlbiArIHBhZ2ZleHRfbGVuICsgMSkpID09IE5VTEwpCisJaWYgKChkaXJuYW1lID0gKGNo
  YXIgKikgbWFsbG9jKGZpbGVsZW4gKyBkaXJmZXh0X3NpemUKKwkJCQkgICAgICAgKyBmaWxlbGVu
  ICsgcGFnZmV4dF9zaXplKSkgPT0gTlVMTCkKIAkJcmV0dXJuIGVycm5vID0gRU5PTUVNLCAoREJN
  ICopIE5VTEw7CiAvKgogICogYnVpbGQgdGhlIGZpbGUgbmFtZXMKICAqLwogCW1lbWNweShkaXJu
  YW1lLCBmaWxlLCBmaWxlbGVuKTsKLQltZW1jcHkoZGlybmFtZSArIGZpbGVsZW4sIERJUkZFWFQs
  IGRpcmZleHRfbGVuICsgMSk7Ci0JcGFnbmFtZSA9IGRpcm5hbWUgKyBmaWxlbGVuICsgZGlyZmV4
  dF9sZW4gKyAxOworCW1lbWNweShkaXJuYW1lICsgZmlsZWxlbiwgRElSRkVYVCwgZGlyZmV4dF9z
  aXplKTsKKwlwYWduYW1lID0gZGlybmFtZSArIGZpbGVsZW4gKyBkaXJmZXh0X3NpemU7CiAJbWVt
  Y3B5KHBhZ25hbWUsIGZpbGUsIGZpbGVsZW4pOwotCW1lbWNweShwYWduYW1lICsgZmlsZWxlbiwg
  UEFHRkVYVCwgcGFnZmV4dF9sZW4gKyAxKTsKKwltZW1jcHkocGFnbmFtZSArIGZpbGVsZW4sIFBB
  R0ZFWFQsIHBhZ2ZleHRfc2l6ZSk7CiAKIAlkYiA9IHNkYm1fcHJlcChkaXJuYW1lLCBwYWduYW1l
  LCBmbGFncywgbW9kZSk7CiAJZnJlZSgoY2hhciAqKSBkaXJuYW1lKTsK
  SDBMFILEC
  LS0tIGNwYW4vRXh0VXRpbHMtTWFrZU1ha2VyL2xpYi9FeHRVdGlscy9NTV9BSVgucG0KKysrIGNw
  YW4vRXh0VXRpbHMtTWFrZU1ha2VyL2xpYi9FeHRVdGlscy9NTV9BSVgucG0KQEAgLTUwLDcgKzUw
  LDkgQEAgc3ViIHhzX2Rsc3ltc19leHQgewogCiBzdWIgeHNfZGxzeW1zX2FyZyB7CiAgICAgbXko
  JHNlbGYsICRmaWxlKSA9IEBfOwotICAgIHJldHVybiBxcXstYkU6JHtmaWxlfX07CisgICAgbXkg
  JGFyZyA9IHFxey1iRToke2ZpbGV9fTsKKyAgICAkYXJnID0gJy1XbCwnLiRhcmcgaWYgJENvbmZp
  Z3tsZGRsZmxhZ3N9ID1+IC8tV2wsLWJFOi87CisgICAgcmV0dXJuICRhcmc7CiB9CiAKIHN1YiBp
  bml0X290aGVycyB7Cg==
  MMAIXPM
  LS0tIGNwYW4vVGltZS1Mb2NhbC90L0xvY2FsLnQKKysrIGNwYW4vVGltZS1Mb2NhbC90L0xvY2Fs
  LnQKQEAgLTg1LDE5ICs4NSwxNyBAQCBteSAkZXBvY2hfaXNfNjQKIAogZm9yICggQHRpbWUsIEBu
  ZWdfdGltZSApIHsKICAgICBteSAoICR5ZWFyLCAkbW9uLCAkbWRheSwgJGhvdXIsICRtaW4sICRz
  ZWMgKSA9IEAkXzsKLSAgICAkeWVhciAtPSAxOTAwOwogICAgICRtb24tLTsKIAogU0tJUDogewog
  ICAgICAgICBza2lwICcxOTcwIHRlc3Qgb24gVk9TIGZhaWxzLicsIDEyCi0gICAgICAgICAgICBp
  ZiAkXk8gZXEgJ3ZvcycgJiYgJHllYXIgPT0gNzA7CisgICAgICAgICAgICBpZiAkXk8gZXEgJ3Zv
  cycgJiYgJHllYXIgPT0gMTk3MDsKICAgICAgICAgc2tpcCAndGhpcyBwbGF0Zm9ybSBkb2VzIG5v
  dCBzdXBwb3J0IG5lZ2F0aXZlIGVwb2Nocy4nLCAxMgotICAgICAgICAgICAgaWYgJHllYXIgPCA3
  MCAmJiAhJG5lZ19lcG9jaF9vazsKKyAgICAgICAgICAgIGlmICR5ZWFyIDwgMTk3MCAmJiAhJG5l
  Z19lcG9jaF9vazsKIAogICAgICAgICAjIFRlc3QgdGltZWxvY2FsKCkKICAgICAgICAgewotICAg
  ICAgICAgICAgbXkgJHllYXJfaW4gPSAkeWVhciA8IDcwID8gJHllYXIgKyAxOTAwIDogJHllYXI7
  Ci0gICAgICAgICAgICBteSAkdGltZSA9IHRpbWVsb2NhbCggJHNlYywgJG1pbiwgJGhvdXIsICRt
  ZGF5LCAkbW9uLCAkeWVhcl9pbiApOworICAgICAgICAgICAgbXkgJHRpbWUgPSB0aW1lbG9jYWwo
  ICRzZWMsICRtaW4sICRob3VyLCAkbWRheSwgJG1vbiwgJHllYXIgKTsKIAogICAgICAgICAgICAg
  bXkgKCAkcywgJG0sICRoLCAkRCwgJE0sICRZICkgPSBsb2NhbHRpbWUoJHRpbWUpOwogCkBAIC0x
  MDYsMTMgKzEwNCwxMiBAQCBTS0lQOiB7CiAgICAgICAgICAgICBpcyggJGgsICRob3VyLCAgICAg
  InRpbWVsb2NhbCBob3VyIGZvciBAJF8iICk7CiAgICAgICAgICAgICBpcyggJEQsICRtZGF5LCAg
  ICAgInRpbWVsb2NhbCBkYXkgZm9yIEAkXyIgKTsKICAgICAgICAgICAgIGlzKCAkTSwgJG1vbiwg
  ICAgICAidGltZWxvY2FsIG1vbnRoIGZvciBAJF8iICk7Ci0gICAgICAgICAgICBpcyggJFksICR5
  ZWFyLCAgICAgInRpbWVsb2NhbCB5ZWFyIGZvciBAJF8iICk7CisgICAgICAgICAgICBpcyggJFks
  ICR5ZWFyIC0gMTkwMCwgICAgICJ0aW1lbG9jYWwgeWVhciBmb3IgQCRfIiApOwogICAgICAgICB9
  CiAKICAgICAgICAgIyBUZXN0IHRpbWVnbSgpCiAgICAgICAgIHsKLSAgICAgICAgICAgIG15ICR5
  ZWFyX2luID0gJHllYXIgPCA3MCA/ICR5ZWFyICsgMTkwMCA6ICR5ZWFyOwotICAgICAgICAgICAg
  bXkgJHRpbWUgPSB0aW1lZ20oICRzZWMsICRtaW4sICRob3VyLCAkbWRheSwgJG1vbiwgJHllYXJf
  aW4gKTsKKyAgICAgICAgICAgIG15ICR0aW1lID0gdGltZWdtKCAkc2VjLCAkbWluLCAkaG91ciwg
  JG1kYXksICRtb24sICR5ZWFyICk7CiAKICAgICAgICAgICAgIG15ICggJHMsICRtLCAkaCwgJEQs
  ICRNLCAkWSApID0gZ210aW1lKCR0aW1lKTsKIApAQCAtMTIxLDE0ICsxMTgsMTMgQEAgU0tJUDog
  ewogICAgICAgICAgICAgaXMoICRoLCAkaG91ciwgICAgICJ0aW1lZ20gaG91ciBmb3IgQCRfIiAp
  OwogICAgICAgICAgICAgaXMoICRELCAkbWRheSwgICAgICJ0aW1lZ20gZGF5IGZvciBAJF8iICk7
  CiAgICAgICAgICAgICBpcyggJE0sICRtb24sICAgICAgInRpbWVnbSBtb250aCBmb3IgQCRfIiAp
  OwotICAgICAgICAgICAgaXMoICRZLCAkeWVhciwgICAgICJ0aW1lZ20geWVhciBmb3IgQCRfIiAp
  OworICAgICAgICAgICAgaXMoICRZLCAkeWVhciAtIDE5MDAsICAgICAidGltZWdtIHllYXIgZm9y
  IEAkXyIgKTsKICAgICAgICAgfQogICAgIH0KIH0KIAogZm9yIChAYmFkX3RpbWUpIHsKICAgICBt
  eSAoICR5ZWFyLCAkbW9uLCAkbWRheSwgJGhvdXIsICRtaW4sICRzZWMgKSA9IEAkXzsKLSAgICAk
  eWVhciAtPSAxOTAwOwogICAgICRtb24tLTsKIAogICAgIGV2YWwgeyB0aW1lZ20oICRzZWMsICRt
  aW4sICRob3VyLCAkbWRheSwgJG1vbiwgJHllYXIgKSB9OwpAQCAtMjI5LDYgKzIyNSwzMCBAQCBT
  S0lQOgogICAgICk7CiB9CiAKKyMgMi1kaWdpdCB5ZWFycworeworCW15ICRjdXJyZW50X3llYXIg
  PSAoIGxvY2FsdGltZSgpIClbNV07CisJbXkgJHByZV9icmVhayAgICA9ICggJGN1cnJlbnRfeWVh
  ciArIDQ5ICkgLSAxMDA7CisJbXkgJGJyZWFrICAgICAgICA9ICggJGN1cnJlbnRfeWVhciArIDUw
  ICkgLSAxMDA7CisJbXkgJHBvc3RfYnJlYWsgICA9ICggJGN1cnJlbnRfeWVhciArIDUxICkgLSAx
  MDA7CisKKwlpcygKKwkJKCAoIGxvY2FsdGltZSggdGltZWxvY2FsKCAwLCAwLCAwLCAxLCAxLCAk
  cHJlX2JyZWFrICkgKSApWzVdICksCisJCSRwcmVfYnJlYWsgKyAxMDAsCisJCSJ5ZWFyICRwcmVf
  YnJlYWsgaXMgdHJlYXRlZCBhcyBuZXh0IGNlbnR1cnkiLAorCSk7CisJaXMoCisJCSggKCBsb2Nh
  bHRpbWUoIHRpbWVsb2NhbCggMCwgMCwgMCwgMSwgMSwgJGJyZWFrICkgKSApWzVdICksCisJCSRi
  cmVhayArIDEwMCwKKwkJInllYXIgJGJyZWFrIGlzIHRyZWF0ZWQgYXMgbmV4dCBjZW50dXJ5IiwK
  KwkpOworCWlzKAorCQkoICggbG9jYWx0aW1lKCB0aW1lbG9jYWwoIDAsIDAsIDAsIDEsIDEsICRw
  b3N0X2JyZWFrICkgKSApWzVdICksCisJCSRwb3N0X2JyZWFrLAorCQkieWVhciAkcG9zdF9icmVh
  ayBpcyB0cmVhdGVkIGFzIGN1cnJlbnQgY2VudHVyeSIsCisJKTsKK30KKwogU0tJUDoKIHsKICAg
  ICBza2lwICdUaGVzZSB0ZXN0cyBvbmx5IHJ1biBmb3IgdGhlIHBhY2thZ2UgbWFpbnRhaW5lci4n
  LCA4Cg==
  TIMELOCALT1
  LS0tIGNwYW4vVGltZS1Mb2NhbC90L0xvY2FsLnQKKysrIGNwYW4vVGltZS1Mb2NhbC90L0xvY2Fs
  LnQKQEAgLTkxLDcgKzkxLDcgQEAgZm9yIChAdGltZSwgQG5lZ190aW1lKSB7CiAKICAgICAgICAg
  IyBUZXN0IHRpbWVsb2NhbCgpCiAgICAgICAgIHsKLSAgICAgICAgICAgIG15ICR5ZWFyX2luID0g
  JHllYXIgPCA3MCA/ICR5ZWFyICsgMTkwMCA6ICR5ZWFyOworICAgICAgICAgICAgbXkgJHllYXJf
  aW4gPSAkeWVhciArIDE5MDA7CiAgICAgICAgICAgICBteSAkdGltZSA9IHRpbWVsb2NhbCgkc2Vj
  LCRtaW4sJGhvdXIsJG1kYXksJG1vbiwkeWVhcl9pbik7CiAKICAgICAgICAgICAgIG15KCRzLCRt
  LCRoLCRELCRNLCRZKSA9IGxvY2FsdGltZSgkdGltZSk7CkBAIC0xMDcsNyArMTA3LDcgQEAgZm9y
  IChAdGltZSwgQG5lZ190aW1lKSB7CiAKICAgICAgICAgIyBUZXN0IHRpbWVnbSgpCiAgICAgICAg
  IHsKLSAgICAgICAgICAgIG15ICR5ZWFyX2luID0gJHllYXIgPCA3MCA/ICR5ZWFyICsgMTkwMCA6
  ICR5ZWFyOworICAgICAgICAgICAgbXkgJHllYXJfaW4gPSAkeWVhciArIDE5MDA7CiAgICAgICAg
  ICAgICBteSAkdGltZSA9IHRpbWVnbSgkc2VjLCRtaW4sJGhvdXIsJG1kYXksJG1vbiwkeWVhcl9p
  bik7CiAKICAgICAgICAgICAgIG15KCRzLCRtLCRoLCRELCRNLCRZKSA9IGdtdGltZSgkdGltZSk7
  CkBAIC0xMjUsNyArMTI1LDYgQEAgZm9yIChAdGltZSwgQG5lZ190aW1lKSB7CiAKIGZvciAoQGJh
  ZF90aW1lKSB7CiAgICAgbXkoJHllYXIsICRtb24sICRtZGF5LCAkaG91ciwgJG1pbiwgJHNlYykg
  PSBAJF87Ci0gICAgJHllYXIgLT0gMTkwMDsKICAgICAkbW9uLS07CiAKICAgICBldmFsIHsgdGlt
  ZWdtKCRzZWMsJG1pbiwkaG91ciwkbWRheSwkbW9uLCR5ZWFyKSB9OwpAQCAtMTM0LDE0ICsxMzMs
  MTQgQEAgZm9yIChAYmFkX3RpbWUpIHsKIH0KIAogewotICAgIGlzKHRpbWVsb2NhbCgwLDAsMSwx
  LDAsOTApIC0gdGltZWxvY2FsKDAsMCwwLDEsMCw5MCksIDM2MDAsCisgICAgaXModGltZWxvY2Fs
  KDAsMCwxLDEsMCwxOTkwKSAtIHRpbWVsb2NhbCgwLDAsMCwxLDAsMTk5MCksIDM2MDAsCiAgICAg
  ICAgJ29uZSBob3VyIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gY2FsbHMgdG8gdGltZWxvY2FsJyk7
  CiAKLSAgICBpcyh0aW1lbG9jYWwoMSwyLDMsMSwwLDEwMCkgLSB0aW1lbG9jYWwoMSwyLDMsMzEs
  MTEsOTkpLCAyNCAqIDM2MDAsCisgICAgaXModGltZWxvY2FsKDEsMiwzLDEsMCwyMDAwKSAtIHRp
  bWVsb2NhbCgxLDIsMywzMSwxMSwxOTk5KSwgMjQgKiAzNjAwLAogICAgICAgICdvbmUgZGF5IGRp
  ZmZlcmVuY2UgYmV0d2VlbiB0d28gY2FsbHMgdG8gdGltZWxvY2FsJyk7CiAKICAgICAjIERpZmYg
  YmV3ZWVuIEphbiAxLCAxOTgwIGFuZCBNYXIgMSwgMTk4MCA9ICgzMSArIDI5ID0gNjAgZGF5cykK
  LSAgICBpcyh0aW1lZ20oMCwwLDAsIDEsIDIsIDgwKSAtIHRpbWVnbSgwLDAsMCwgMSwgMCwgODAp
  LCA2MCAqIDI0ICogMzYwMCwKKyAgICBpcyh0aW1lZ20oMCwwLDAsIDEsIDIsIDE5ODApIC0gdGlt
  ZWdtKDAsMCwwLCAxLCAwLCAxOTgwKSwgNjAgKiAyNCAqIDM2MDAsCiAgICAgICAgJzYwIGRheSBk
  aWZmZXJlbmNlIGJldHdlZW4gdHdvIGNhbGxzIHRvIHRpbWVnbScpOwogfQogCg==
  TIMELOCALT2
  LS0tIGV4dC9UaW1lLUxvY2FsL3QvTG9jYWwudAorKysgZXh0L1RpbWUtTG9jYWwvdC9Mb2NhbC50
  CkBAIC04NCw3ICs4NCw3IEBAIGZvciAoQHRpbWUsIEBuZWdfdGltZSkgewogCiAgICAgIyBUZXN0
  IHRpbWVsb2NhbCgpCiAgICAgewotICAgICAgICBteSAkeWVhcl9pbiA9ICR5ZWFyIDwgNzAgPyAk
  eWVhciArIDE5MDAgOiAkeWVhcjsKKyAgICAgICAgbXkgJHllYXJfaW4gPSAkeWVhciArIDE5MDA7
  CiAgICAgICAgIG15ICR0aW1lID0gdGltZWxvY2FsKCRzZWMsJG1pbiwkaG91ciwkbWRheSwkbW9u
  LCR5ZWFyX2luKTsKIAogICAgICAgICBteSgkcywkbSwkaCwkRCwkTSwkWSkgPSBsb2NhbHRpbWUo
  JHRpbWUpOwpAQCAtMTAwLDcgKzEwMCw3IEBAIGZvciAoQHRpbWUsIEBuZWdfdGltZSkgewogCiAg
  ICAgIyBUZXN0IHRpbWVnbSgpCiAgICAgewotICAgICAgICBteSAkeWVhcl9pbiA9ICR5ZWFyIDwg
  NzAgPyAkeWVhciArIDE5MDAgOiAkeWVhcjsKKyAgICAgICAgbXkgJHllYXJfaW4gPSAkeWVhciAr
  IDE5MDA7CiAgICAgICAgIG15ICR0aW1lID0gdGltZWdtKCRzZWMsJG1pbiwkaG91ciwkbWRheSwk
  bW9uLCR5ZWFyX2luKTsKIAogICAgICAgICBteSgkcywkbSwkaCwkRCwkTSwkWSkgPSBnbXRpbWUo
  JHRpbWUpOwpAQCAtMTE3LDcgKzExNyw2IEBAIGZvciAoQHRpbWUsIEBuZWdfdGltZSkgewogCiBm
  b3IgKEBiYWRfdGltZSkgewogICAgIG15KCR5ZWFyLCAkbW9uLCAkbWRheSwgJGhvdXIsICRtaW4s
  ICRzZWMpID0gQCRfOwotICAgICR5ZWFyIC09IDE5MDA7CiAgICAgJG1vbi0tOwogCiAgICAgZXZh
  bCB7IHRpbWVnbSgkc2VjLCRtaW4sJGhvdXIsJG1kYXksJG1vbiwkeWVhcikgfTsKQEAgLTEyNiwx
  NCArMTI1LDE0IEBAIGZvciAoQGJhZF90aW1lKSB7CiB9CiAKIHsKLSAgICBpcyh0aW1lbG9jYWwo
  MCwwLDEsMSwwLDkwKSAtIHRpbWVsb2NhbCgwLDAsMCwxLDAsOTApLCAzNjAwLAorICAgIGlzKHRp
  bWVsb2NhbCgwLDAsMSwxLDAsMTk5MCkgLSB0aW1lbG9jYWwoMCwwLDAsMSwwLDE5OTApLCAzNjAw
  LAogICAgICAgICdvbmUgaG91ciBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGNhbGxzIHRvIHRpbWVs
  b2NhbCcpOwogCi0gICAgaXModGltZWxvY2FsKDEsMiwzLDEsMCwxMDApIC0gdGltZWxvY2FsKDEs
  MiwzLDMxLDExLDk5KSwgMjQgKiAzNjAwLAorICAgIGlzKHRpbWVsb2NhbCgxLDIsMywxLDAsMjAw
  MCkgLSB0aW1lbG9jYWwoMSwyLDMsMzEsMTEsMTk5OSksIDI0ICogMzYwMCwKICAgICAgICAnb25l
  IGRheSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGNhbGxzIHRvIHRpbWVsb2NhbCcpOwogCiAgICAg
  IyBEaWZmIGJld2VlbiBKYW4gMSwgMTk4MCBhbmQgTWFyIDEsIDE5ODAgPSAoMzEgKyAyOSA9IDYw
  IGRheXMpCi0gICAgaXModGltZWdtKDAsMCwwLCAxLCAyLCA4MCkgLSB0aW1lZ20oMCwwLDAsIDEs
  IDAsIDgwKSwgNjAgKiAyNCAqIDM2MDAsCisgICAgaXModGltZWdtKDAsMCwwLCAxLCAyLCAxOTgw
  KSAtIHRpbWVnbSgwLDAsMCwgMSwgMCwgMTk4MCksIDYwICogMjQgKiAzNjAwLAogICAgICAgICc2
  MCBkYXkgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBjYWxscyB0byB0aW1lZ20nKTsKIH0KIAo=
  TIMELOCALT3
  LS0tIGxpYi9UaW1lL0xvY2FsLnQKKysrIGxpYi9UaW1lL0xvY2FsLnQKQEAgLTk2LDcgKzk2LDcg
  QEAgZm9yIChAdGltZSwgQG5lZ190aW1lKSB7CiAgICAgICAgICAgICBpZiAkeWVhciA8IDcwICYm
  ICEgJG5lZ19lcG9jaF9vazsKIAogICAgICAgICB7Ci0gICAgICAgICAgICBteSAkeWVhcl9pbiA9
  ICR5ZWFyIDwgNzAgPyAkeWVhciArIDE5MDAgOiAkeWVhcjsKKyAgICAgICAgICAgIG15ICR5ZWFy
  X2luID0gJHllYXIgKyAxOTAwOwogICAgICAgICAgICAgbXkgJHRpbWUgPSB0aW1lbG9jYWwoJHNl
  YywkbWluLCRob3VyLCRtZGF5LCRtb24sJHllYXJfaW4pOwogCiAgICAgICAgICAgICBteSgkcywk
  bSwkaCwkRCwkTSwkWSkgPSBsb2NhbHRpbWUoJHRpbWUpOwpAQCAtMTEwLDcgKzExMCw3IEBAIGZv
  ciAoQHRpbWUsIEBuZWdfdGltZSkgewogICAgICAgICB9CiAKICAgICAgICAgewotICAgICAgICAg
  ICAgbXkgJHllYXJfaW4gPSAkeWVhciA8IDcwID8gJHllYXIgKyAxOTAwIDogJHllYXI7CisgICAg
  ICAgICAgICBteSAkeWVhcl9pbiA9ICR5ZWFyICsgMTkwMDsKICAgICAgICAgICAgIG15ICR0aW1l
  ID0gdGltZWdtKCRzZWMsJG1pbiwkaG91ciwkbWRheSwkbW9uLCR5ZWFyX2luKTsKIAogICAgICAg
  ICAgICAgbXkoJHMsJG0sJGgsJEQsJE0sJFkpID0gZ210aW1lKCR0aW1lKTsKQEAgLTEyNyw3ICsx
  MjcsNiBAQCBmb3IgKEB0aW1lLCBAbmVnX3RpbWUpIHsKIAogZm9yIChAYmFkX3RpbWUpIHsKICAg
  ICBteSgkeWVhciwgJG1vbiwgJG1kYXksICRob3VyLCAkbWluLCAkc2VjKSA9IEAkXzsKLSAgICAk
  eWVhciAtPSAxOTAwOwogICAgICRtb24tLTsKIAogICAgIGV2YWwgeyB0aW1lZ20oJHNlYywkbWlu
  LCRob3VyLCRtZGF5LCRtb24sJHllYXIpIH07CkBAIC0xMzYsMTQgKzEzNSwxNCBAQCBmb3IgKEBi
  YWRfdGltZSkgewogfQogCiB7Ci0gICAgaXModGltZWxvY2FsKDAsMCwxLDEsMCw5MCkgLSB0aW1l
  bG9jYWwoMCwwLDAsMSwwLDkwKSwgMzYwMCwKKyAgICBpcyh0aW1lbG9jYWwoMCwwLDEsMSwwLDE5
  OTApIC0gdGltZWxvY2FsKDAsMCwwLDEsMCwxOTkwKSwgMzYwMCwKICAgICAgICAnb25lIGhvdXIg
  ZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBjYWxscyB0byB0aW1lbG9jYWwnKTsKIAotICAgIGlzKHRp
  bWVsb2NhbCgxLDIsMywxLDAsMTAwKSAtIHRpbWVsb2NhbCgxLDIsMywzMSwxMSw5OSksIDI0ICog
  MzYwMCwKKyAgICBpcyh0aW1lbG9jYWwoMSwyLDMsMSwwLDIwMDApIC0gdGltZWxvY2FsKDEsMiwz
  LDMxLDExLDE5OTkpLCAyNCAqIDM2MDAsCiAgICAgICAgJ29uZSBkYXkgZGlmZmVyZW5jZSBiZXR3
  ZWVuIHR3byBjYWxscyB0byB0aW1lbG9jYWwnKTsKIAogICAgICMgRGlmZiBiZXdlZW4gSmFuIDEs
  IDE5ODAgYW5kIE1hciAxLCAxOTgwID0gKDMxICsgMjkgPSA2MCBkYXlzKQotICAgIGlzKHRpbWVn
  bSgwLDAsMCwgMSwgMiwgODApIC0gdGltZWdtKDAsMCwwLCAxLCAwLCA4MCksIDYwICogMjQgKiAz
  NjAwLAorICAgIGlzKHRpbWVnbSgwLDAsMCwgMSwgMiwgMTk4MCkgLSB0aW1lZ20oMCwwLDAsIDEs
  IDAsIDE5ODApLCA2MCAqIDI0ICogMzYwMCwKICAgICAgICAnNjAgZGF5IGRpZmZlcmVuY2UgYmV0
  d2VlbiB0d28gY2FsbHMgdG8gdGltZWdtJyk7CiB9CiAK
  TIMELOCALT4
  LS0tIGxpYi9UaW1lL0xvY2FsLnQKKysrIGxpYi9UaW1lL0xvY2FsLnQKQEAgLTgzLDcgKzgzLDcg
  QEAgZm9yIChAdGltZSwgQG5lZ190aW1lKSB7CiAgICAgfSBlbHNpZiAoJHllYXIgPCA3MCAmJiAh
  ICRuZWdfZXBvY2hfb2spIHsKICAgICAgICAgc2tpcCgxLCAic2tpcHBpbmcgbmVnYXRpdmUgZXBv
  Y2guXG4iKSBmb3IgMS4uNjsKICAgICB9IGVsc2UgewotICAgICAgICBteSAkeWVhcl9pbiA9ICR5
  ZWFyIDwgNzAgPyAkeWVhciArIDE5MDAgOiAkeWVhcjsKKyAgICAgICAgbXkgJHllYXJfaW4gPSAk
  eWVhciArIDE5MDA7CiAgICAgICAgIG15ICR0aW1lID0gdGltZWxvY2FsKCRzZWMsJG1pbiwkaG91
  ciwkbWRheSwkbW9uLCR5ZWFyX2luKTsKIAogICAgICAgICBteSgkcywkbSwkaCwkRCwkTSwkWSkg
  PSBsb2NhbHRpbWUoJHRpbWUpOwpAQCAtMTAxLDcgKzEwMSw3IEBAIGZvciAoQHRpbWUsIEBuZWdf
  dGltZSkgewogICAgIH0gZWxzaWYgKCR5ZWFyIDwgNzAgJiYgISAkbmVnX2Vwb2NoX29rKSB7CiAg
  ICAgICAgIHNraXAoMSwgInNraXBwaW5nIG5lZ2F0aXZlIGVwb2NoLlxuIikgZm9yIDEuLjY7CiAg
  ICAgfSBlbHNlIHsKLSAgICAgICAgbXkgJHllYXJfaW4gPSAkeWVhciA8IDcwID8gJHllYXIgKyAx
  OTAwIDogJHllYXI7CisgICAgICAgIG15ICR5ZWFyX2luID0gJHllYXIgKyAxOTAwOwogICAgICAg
  ICBteSAkdGltZSA9IHRpbWVnbSgkc2VjLCRtaW4sJGhvdXIsJG1kYXksJG1vbiwkeWVhcl9pbik7
  CiAKICAgICAgICAgbXkoJHMsJG0sJGgsJEQsJE0sJFkpID0gZ210aW1lKCR0aW1lKTsKQEAgLTEx
  Nyw3ICsxMTcsNiBAQCBmb3IgKEB0aW1lLCBAbmVnX3RpbWUpIHsKIAogZm9yIChAYmFkX3RpbWUp
  IHsKICAgICBteSgkeWVhciwgJG1vbiwgJG1kYXksICRob3VyLCAkbWluLCAkc2VjKSA9IEAkXzsK
  LSAgICAkeWVhciAtPSAxOTAwOwogICAgICRtb24tLTsKIAogICAgIGV2YWwgeyB0aW1lZ20oJHNl
  YywkbWluLCRob3VyLCRtZGF5LCRtb24sJHllYXIpIH07CkBAIC0xMjUsMTQgKzEyNCwxNCBAQCBm
  b3IgKEBiYWRfdGltZSkgewogICAgIG9rKCRALCBxci8uKm91dCBvZiByYW5nZS4qLywgJ2ludmFs
  aWQgdGltZSBjYXVzZWQgYW4gZXJyb3InKTsKIH0KIAotb2sodGltZWxvY2FsKDAsMCwxLDEsMCw5
  MCkgLSB0aW1lbG9jYWwoMCwwLDAsMSwwLDkwKSwgMzYwMCwKK29rKHRpbWVsb2NhbCgwLDAsMSwx
  LDAsMTk5MCkgLSB0aW1lbG9jYWwoMCwwLDAsMSwwLDE5OTApLCAzNjAwLAogICAgJ29uZSBob3Vy
  IGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gY2FsbHMgdG8gdGltZWxvY2FsJyk7CiAKLW9rKHRpbWVs
  b2NhbCgxLDIsMywxLDAsMTAwKSAtIHRpbWVsb2NhbCgxLDIsMywzMSwxMSw5OSksIDI0ICogMzYw
  MCwKK29rKHRpbWVsb2NhbCgxLDIsMywxLDAsMjAwMCkgLSB0aW1lbG9jYWwoMSwyLDMsMzEsMTEs
  MTk5OSksIDI0ICogMzYwMCwKICAgICdvbmUgZGF5IGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gY2Fs
  bHMgdG8gdGltZWxvY2FsJyk7CiAKICMgRGlmZiBiZXdlZW4gSmFuIDEsIDE5ODAgYW5kIE1hciAx
  LCAxOTgwID0gKDMxICsgMjkgPSA2MCBkYXlzKQotb2sodGltZWdtKDAsMCwwLCAxLCAyLCA4MCkg
  LSB0aW1lZ20oMCwwLDAsIDEsIDAsIDgwKSwgNjAgKiAyNCAqIDM2MDAsCitvayh0aW1lZ20oMCww
  LDAsIDEsIDIsIDE5ODApIC0gdGltZWdtKDAsMCwwLCAxLCAwLCAxOTgwKSwgNjAgKiAyNCAqIDM2
  MDAsCiAgICAnNjAgZGF5IGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gY2FsbHMgdG8gdGltZWdtJyk7
  CiAKICMgYnVnaWQgIzE5MzkzCg==
  TIMELOCALT5
  LS0tIHBwLmMKKysrIHBwLmMKQEAgLTM2NTMsOCArMzY1MywxMiBAQCBQUChwcF9jcnlwdCkKICNp
  ZiBkZWZpbmVkKF9fR0xJQkNfXykgfHwgZGVmaW5lZChfX0VNWF9fKQogCWlmIChQTF9yZWVudHJh
  bnRfYnVmZmVyLT5fY3J5cHRfc3RydWN0X2J1ZmZlcikgewogCSAgICBQTF9yZWVudHJhbnRfYnVm
  ZmVyLT5fY3J5cHRfc3RydWN0X2J1ZmZlci0+aW5pdGlhbGl6ZWQgPSAwOwotCSAgICAvKiB3b3Jr
  IGFyb3VuZCBnbGliYy0yLjIuNSBidWcgKi8KKyNpZiAoZGVmaW5lZChfX0dMSUJDX18pICYmIF9f
  R0xJQkNfXyA9PSAyKSAmJiBcCisgICAgKGRlZmluZWQoX19HTElCQ19NSU5PUl9fKSAmJiBfX0dM
  SUJDX01JTk9SX18gPj0gMiAmJiBfX0dMSUJDX01JTk9SX18gPCA0KQorCSAgICAvKiB3b3JrIGFy
  b3VuZCBnbGliYy0yLjIuNSBidWcsIGhhcyBiZWVuIGZpeGVkIGF0IHNvbWUKKwkgICAgICogdGlt
  ZSBpbiBnbGliYy0yLjMuWCAqLwogCSAgICBQTF9yZWVudHJhbnRfYnVmZmVyLT5fY3J5cHRfc3Ry
  dWN0X2J1ZmZlci0+Y3VycmVudF9zYWx0Yml0cyA9IDA7CisjZW5kaWYKIAl9CiAjZW5kaWYKICAg
  ICB9Cg==
  PPCLIBC
  LS0tIENvbmZpZ3VyZQorKysgQ29uZmlndXJlCkBAIC0zMTQ5LDcgKzMxNDksNyBAQCBlbHNlCiBm
  aQogJHJtIC1mIGdjY3ZlcnMqCiBjYXNlICIkZ2NjdmVyc2lvbiIgaW4KLTEqKSBjcHA9YC4vbG9j
  IGdjYy1jcHAgJGNwcCAkcHRoYCA7OworMS4qKSBjcHA9YC4vbG9jIGdjYy1jcHAgJGNwcCAkcHRo
  YCA7OwogZXNhYwogY2FzZSAiJGdjY3ZlcnNpb24iIGluCiAnJykgZ2Njb3NhbmR2ZXJzPScnIDs7
  CkBAIC0zOTIzLDEzICszOTIzLDEzIEBAIGRmbHQ9JycKIGNhc2UgIiRoaW50IiBpbgogZGVmYXVs
  dHxyZWNvbW1lbmRlZCkKIAljYXNlICIkZ2NjdmVyc2lvbiIgaW4KLQkxKikgZGZsdD0nLWZwY2Mt
  c3RydWN0LXJldHVybicgOzsKKwkxLiopIGRmbHQ9Jy1mcGNjLXN0cnVjdC1yZXR1cm4nIDs7CiAJ
  ZXNhYwogCWNhc2UgIiRvcHRpbWl6ZSIgaW4KIAkqLWcqKSBkZmx0PSIkZGZsdCAtRERFQlVHR0lO
  RyI7OwogCWVzYWMKIAljYXNlICIkZ2NjdmVyc2lvbiIgaW4KLQkyKikgaWYgdGVzdCAtZCAvZXRj
  L2NvbmYva2NvbmZpZy5kICYmCisJMi4qKSBpZiB0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQg
  JiYKIAkJCSRjb250YWlucyBfUE9TSVhfVkVSU0lPTiAkdXNyaW5jL3N5cy91bmlzdGQuaCA+L2Rl
  di9udWxsIDI+JjEKIAkJdGhlbgogCQkJZGZsdD0iJGRmbHQgLXBvc2l4IgpAQCAtMzkzNyw3ICsz
  OTM3LDcgQEAgZGVmYXVsdHxyZWNvbW1lbmRlZCkKIAkJOzsKIAllc2FjCiAJY2FzZSAiJGdjY3Zl
  cnNpb24iIGluCi0JMSopIDs7CisJMS4qKSA7OwogCTIuWzAtOF0qKSA7OwogCT8qKSAJZWNobyAi
  ICIKIAkJZWNobyAiQ2hlY2tpbmcgaWYgeW91ciBjb21waWxlciBhY2NlcHRzIC1mbm8tc3RyaWN0
  LWFsaWFzaW5nIiAyPiYxCkBAIC00MDI4LDcgKzQwMjgsNyBAQCBlc2FjCiA6IHRoZSBmb2xsb3dp
  bmcgd2VlZHMgb3B0aW9ucyBmcm9tIGNjZmxhZ3MgdGhhdCBhcmUgb2Ygbm8gaW50ZXJlc3QgdG8g
  Y3BwCiBjcHBmbGFncz0iJGNjZmxhZ3MiCiBjYXNlICIkZ2NjdmVyc2lvbiIgaW4KLTEqKSBjcHBm
  bGFncz0iJGNwcGZsYWdzIC1EX19HTlVDX18iCisxLiopIGNwcGZsYWdzPSIkY3BwZmxhZ3MgLURf
  X0dOVUNfXyIKIGVzYWMKIGNhc2UgIiRtaXBzX3R5cGUiIGluCiAnJyk7Owo=
  CONFGCC10561
  LS0tIENvbmZpZ3VyZQorKysgQ29uZmlndXJlCkBAIC0zOTA5LDcgKzM5MDksNyBAQCBlbHNlCiBm
  aQogJHJtIC1mIHRyeSB0cnkuKgogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwPWAuL2xv
  YyBnY2MtY3BwICRjcHAgJHB0aGAgOzsKKzEuKikgY3BwPWAuL2xvYyBnY2MtY3BwICRjcHAgJHB0
  aGAgOzsKIGVzYWMKIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgogJycpIGdjY29zYW5kdmVycz0nJyA7
  OwpAQCAtMzk0OSw3ICszOTQ5LDcgQEAgZXNhYwogIyBnY2MgMy4qIGNvbXBsYWluIGFib3V0IGFk
  ZGluZyAtSWRpcmVjdG9yaWVzIHRoYXQgdGhleSBhbHJlYWR5IGtub3cgYWJvdXQsCiAjIHNvIHdl
  IHdpbGwgdGFrZSB0aG9zZSBvZmYgZnJvbSBsb2NpbmNwdGguCiBjYXNlICIkZ2NjdmVyc2lvbiIg
  aW4KLTMqKQorMy4qKQogICAgIGVjaG8gIm1haW4oKXt9Ij50cnkuYwogICAgIGZvciBpbmNkaXIg
  aW4gJGxvY2luY3B0aDsgZG8KICAgICAgICB3YXJuPWAkY2MgJGNjZmxhZ3MgLUkkaW5jZGlyIC1j
  IHRyeS5jIDI+JjEgfCBcCkBAIC00NzI0LDEzICs0NzI0LDEzIEBAIGRmbHQ9JycKIGNhc2UgIiRo
  aW50IiBpbgogZGVmYXVsdHxyZWNvbW1lbmRlZCkKIAljYXNlICIkZ2NjdmVyc2lvbiIgaW4KLQkx
  KikgZGZsdD0nLWZwY2Mtc3RydWN0LXJldHVybicgOzsKKwkxLiopIGRmbHQ9Jy1mcGNjLXN0cnVj
  dC1yZXR1cm4nIDs7CiAJZXNhYwogCWNhc2UgIiRvcHRpbWl6ZSIgaW4KIAkqLWcqKSBkZmx0PSIk
  ZGZsdCAtRERFQlVHR0lORyI7OwogCWVzYWMKIAljYXNlICIkZ2NjdmVyc2lvbiIgaW4KLQkyKikg
  aWYgdGVzdCAtZCAvZXRjL2NvbmYva2NvbmZpZy5kICYmCisJMi4qKSBpZiB0ZXN0IC1kIC9ldGMv
  Y29uZi9rY29uZmlnLmQgJiYKIAkJCSRjb250YWlucyBfUE9TSVhfVkVSU0lPTiAkdXNyaW5jL3N5
  cy91bmlzdGQuaCA+L2Rldi9udWxsIDI+JjEKIAkJdGhlbgogCQkJIyBJbnRlcmFjdGl2ZSBTeXN0
  ZW1zIChJU0MpIFBPU0lYIG1vZGUuCkBAIC00NzM5LDcgKzQ3MzksNyBAQCBkZWZhdWx0fHJlY29t
  bWVuZGVkKQogCQk7OwogCWVzYWMKIAljYXNlICIkZ2NjdmVyc2lvbiIgaW4KLQkxKikgOzsKKwkx
  LiopIDs7CiAJMi5bMC04XSopIDs7CiAJPyopIAllY2hvICIgIgogCQllY2hvICJDaGVja2luZyBp
  ZiB5b3VyIGNvbXBpbGVyIGFjY2VwdHMgLWZuby1zdHJpY3QtYWxpYXNpbmciIDI+JjEKQEAgLTQ4
  NjcsNyArNDg2Nyw3IEBAIGNhc2UgIiRjcHBmbGFncyIgaW4KICopICBjcHBmbGFncz0iJGNwcGZs
  YWdzICRjY2ZsYWdzIiA7OwogZXNhYwogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwZmxh
  Z3M9IiRjcHBmbGFncyAtRF9fR05VQ19fIgorMS4qKSBjcHBmbGFncz0iJGNwcGZsYWdzIC1EX19H
  TlVDX18iCiBlc2FjCiBjYXNlICIkbWlwc190eXBlIiBpbgogJycpOzsK
  CONFGCC10588
  LS0tIENvbmZpZ3VyZQorKysgQ29uZmlndXJlCkBAIC00NDg1LDcgKzQ0ODUsNyBAQCBlbHNlCiBm
  aQogJHJtIC1mIHRyeSB0cnkuKgogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwPWAuL2xv
  YyBnY2MtY3BwICRjcHAgJHB0aGAgOzsKKzEuKikgY3BwPWAuL2xvYyBnY2MtY3BwICRjcHAgJHB0
  aGAgOzsKIGVzYWMKIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgogJycpIGdjY29zYW5kdmVycz0nJyA7
  OwpAQCAtNDUyNSw3ICs0NTI1LDcgQEAgZXNhYwogIyBnY2MgMy4qIGNvbXBsYWluIGFib3V0IGFk
  ZGluZyAtSWRpcmVjdG9yaWVzIHRoYXQgdGhleSBhbHJlYWR5IGtub3cgYWJvdXQsCiAjIHNvIHdl
  IHdpbGwgdGFrZSB0aG9zZSBvZmYgZnJvbSBsb2NpbmNwdGguCiBjYXNlICIkZ2NjdmVyc2lvbiIg
  aW4KLTMqKQorMy4qKQogICAgIGVjaG8gIm1haW4oKXt9Ij50cnkuYwogICAgIGZvciBpbmNkaXIg
  aW4gJGxvY2luY3B0aDsgZG8KICAgICAgICB3YXJuPWAkY2MgJGNjZmxhZ3MgLUkkaW5jZGlyIC1j
  IHRyeS5jIDI+JjEgfCBcCkBAIC01MDUwLDEzICs1MDUwLDEzIEBAIGVzYWMKIGNhc2UgIiRoaW50
  IiBpbgogZGVmYXVsdHxyZWNvbW1lbmRlZCkKIAljYXNlICIkZ2NjdmVyc2lvbiIgaW4KLQkxKikg
  ZGZsdD0iJGRmbHQgLWZwY2Mtc3RydWN0LXJldHVybiIgOzsKKwkxLiopIGRmbHQ9IiRkZmx0IC1m
  cGNjLXN0cnVjdC1yZXR1cm4iIDs7CiAJZXNhYwogCWNhc2UgIiRvcHRpbWl6ZTokREVCVUdHSU5H
  IiBpbgogCSotZyo6b2xkKSBkZmx0PSIkZGZsdCAtRERFQlVHR0lORyI7OwogCWVzYWMKIAljYXNl
  ICIkZ2NjdmVyc2lvbiIgaW4KLQkyKikgaWYgdGVzdCAtZCAvZXRjL2NvbmYva2NvbmZpZy5kICYm
  CisJMi4qKSBpZiB0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYKIAkJCSRjb250YWlucyBf
  UE9TSVhfVkVSU0lPTiAkdXNyaW5jL3N5cy91bmlzdGQuaCA+L2Rldi9udWxsIDI+JjEKIAkJdGhl
  bgogCQkJIyBJbnRlcmFjdGl2ZSBTeXN0ZW1zIChJU0MpIFBPU0lYIG1vZGUuCkBAIC01MDY1LDcg
  KzUwNjUsNyBAQCBkZWZhdWx0fHJlY29tbWVuZGVkKQogCQk7OwogCWVzYWMKIAljYXNlICIkZ2Nj
  dmVyc2lvbiIgaW4KLQkxKikgOzsKKwkxLiopIDs7CiAJMi5bMC04XSopIDs7CiAJPyopIAllY2hv
  ICIgIgogCQllY2hvICJDaGVja2luZyBpZiB5b3VyIGNvbXBpbGVyIGFjY2VwdHMgLWZuby1zdHJp
  Y3QtYWxpYXNpbmciIDI+JjEKQEAgLTUxNzksNyArNTE3OSw3IEBAIGNhc2UgIiRjcHBmbGFncyIg
  aW4KICopICBjcHBmbGFncz0iJGNwcGZsYWdzICRjY2ZsYWdzIiA7OwogZXNhYwogY2FzZSAiJGdj
  Y3ZlcnNpb24iIGluCi0xKikgY3BwZmxhZ3M9IiRjcHBmbGFncyAtRF9fR05VQ19fIgorMS4qKSBj
  cHBmbGFncz0iJGNwcGZsYWdzIC1EX19HTlVDX18iCiBlc2FjCiBjYXNlICIkbWlwc190eXBlIiBp
  bgogJycpOzsK
  CONFGCC10510
  LS0tIENvbmZpZ3VyZQorKysgQ29uZmlndXJlCkBAIC00NTkxLDcgKzQ1OTEsNyBAQCBlbHNlCiBm
  aQogJHJtIC1mIHRyeSB0cnkuKgogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwPWAuL2xv
  YyBnY2MtY3BwICRjcHAgJHB0aGAgOzsKKzEuKikgY3BwPWAuL2xvYyBnY2MtY3BwICRjcHAgJHB0
  aGAgOzsKIGVzYWMKIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgogJycpIGdjY29zYW5kdmVycz0nJyA7
  OwpAQCAtNDYzMSw3ICs0NjMxLDcgQEAgZXNhYwogIyBnY2MgMy4qIGNvbXBsYWluIGFib3V0IGFk
  ZGluZyAtSWRpcmVjdG9yaWVzIHRoYXQgdGhleSBhbHJlYWR5IGtub3cgYWJvdXQsCiAjIHNvIHdl
  IHdpbGwgdGFrZSB0aG9zZSBvZmYgZnJvbSBsb2NpbmNwdGguCiBjYXNlICIkZ2NjdmVyc2lvbiIg
  aW4KLTMqKQorMy4qKQogICAgIGVjaG8gIm1haW4oKXt9Ij50cnkuYwogICAgIGZvciBpbmNkaXIg
  aW4gJGxvY2luY3B0aDsgZG8KICAgICAgICB3YXJuPWAkY2MgJGNjZmxhZ3MgLUkkaW5jZGlyIC1j
  IHRyeS5jIDI+JjEgfCBcCkBAIC01MzI4LDEzICs1MzI4LDEzIEBAIGZpCiBjYXNlICIkaGludCIg
  aW4KIGRlZmF1bHR8cmVjb21tZW5kZWQpCiAJY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0JMSopIGRm
  bHQ9IiRkZmx0IC1mcGNjLXN0cnVjdC1yZXR1cm4iIDs7CisJMS4qKSBkZmx0PSIkZGZsdCAtZnBj
  Yy1zdHJ1Y3QtcmV0dXJuIiA7OwogCWVzYWMKIAljYXNlICIkb3B0aW1pemU6JERFQlVHR0lORyIg
  aW4KIAkqLWcqOm9sZCkgZGZsdD0iJGRmbHQgLURERUJVR0dJTkciOzsKIAllc2FjCiAJY2FzZSAi
  JGdjY3ZlcnNpb24iIGluCi0JMiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYK
  KwkyLiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYKIAkJCSRjb250YWlucyBf
  UE9TSVhfVkVSU0lPTiAkdXNyaW5jL3N5cy91bmlzdGQuaCA+L2Rldi9udWxsIDI+JjEKIAkJdGhl
  bgogCQkJIyBJbnRlcmFjdGl2ZSBTeXN0ZW1zIChJU0MpIFBPU0lYIG1vZGUuCkBAIC01MzQzLDcg
  KzUzNDMsNyBAQCBkZWZhdWx0fHJlY29tbWVuZGVkKQogCQk7OwogCWVzYWMKIAljYXNlICIkZ2Nj
  dmVyc2lvbiIgaW4KLQkxKikgOzsKKwkxLiopIDs7CiAJMi5bMC04XSopIDs7CiAJPyopCXNldCBz
  dHJpY3QtYWxpYXNpbmcgLWZuby1zdHJpY3QtYWxpYXNpbmcKIAkJZXZhbCAkY2hlY2tjY2ZsYWcK
  QEAgLTU0NDUsNyArNTQ0NSw3IEBAIGNhc2UgIiRjcHBmbGFncyIgaW4KICopICBjcHBmbGFncz0i
  JGNwcGZsYWdzICRjY2ZsYWdzIiA7OwogZXNhYwogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikg
  Y3BwZmxhZ3M9IiRjcHBmbGFncyAtRF9fR05VQ19fIgorMS4qKSBjcHBmbGFncz0iJGNwcGZsYWdz
  IC1EX19HTlVDX18iCiBlc2FjCiBjYXNlICIkbWlwc190eXBlIiBpbgogJycpOzsK
  CONFGCC10520
  LS0tIENvbmZpZ3VyZQorKysgQ29uZmlndXJlCkBAIC00NjU3LDcgKzQ2NTcsNyBAQCBlbHNlCiBm
  aQogJHJtIC1mIHRyeSB0cnkuKgogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwPWAuL2xv
  YyBnY2MtY3BwICRjcHAgJHB0aGAgOzsKKzEuKikgY3BwPWAuL2xvYyBnY2MtY3BwICRjcHAgJHB0
  aGAgOzsKIGVzYWMKIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgogJycpIGdjY29zYW5kdmVycz0nJyA7
  OwpAQCAtNDY5Nyw3ICs0Njk3LDcgQEAgZXNhYwogIyBnY2MgMy4qIGNvbXBsYWluIGFib3V0IGFk
  ZGluZyAtSWRpcmVjdG9yaWVzIHRoYXQgdGhleSBhbHJlYWR5IGtub3cgYWJvdXQsCiAjIHNvIHdl
  IHdpbGwgdGFrZSB0aG9zZSBvZmYgZnJvbSBsb2NpbmNwdGguCiBjYXNlICIkZ2NjdmVyc2lvbiIg
  aW4KLTMqKQorMy4qKQogICAgIGVjaG8gIm1haW4oKXt9Ij50cnkuYwogICAgIGZvciBpbmNkaXIg
  aW4gJGxvY2luY3B0aDsgZG8KICAgICAgICB3YXJuPWAkY2MgJGNjZmxhZ3MgLUkkaW5jZGlyIC1j
  IHRyeS5jIDI+JjEgfCBcCkBAIC01NDA5LDEzICs1NDA5LDEzIEBAIGZpCiBjYXNlICIkaGludCIg
  aW4KIGRlZmF1bHR8cmVjb21tZW5kZWQpCiAJY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0JMSopIGRm
  bHQ9IiRkZmx0IC1mcGNjLXN0cnVjdC1yZXR1cm4iIDs7CisJMS4qKSBkZmx0PSIkZGZsdCAtZnBj
  Yy1zdHJ1Y3QtcmV0dXJuIiA7OwogCWVzYWMKIAljYXNlICIkb3B0aW1pemU6JERFQlVHR0lORyIg
  aW4KIAkqLWcqOm9sZCkgZGZsdD0iJGRmbHQgLURERUJVR0dJTkciOzsKIAllc2FjCiAJY2FzZSAi
  JGdjY3ZlcnNpb24iIGluCi0JMiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYK
  KwkyLiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYKIAkJCSRjb250YWlucyBf
  UE9TSVhfVkVSU0lPTiAkdXNyaW5jL3N5cy91bmlzdGQuaCA+L2Rldi9udWxsIDI+JjEKIAkJdGhl
  bgogCQkJIyBJbnRlcmFjdGl2ZSBTeXN0ZW1zIChJU0MpIFBPU0lYIG1vZGUuCkBAIC01NDI0LDcg
  KzU0MjQsNyBAQCBkZWZhdWx0fHJlY29tbWVuZGVkKQogCQk7OwogCWVzYWMKIAljYXNlICIkZ2Nj
  dmVyc2lvbiIgaW4KLQkxKikgOzsKKwkxLiopIDs7CiAJMi5bMC04XSopIDs7CiAJPyopCXNldCBz
  dHJpY3QtYWxpYXNpbmcgLWZuby1zdHJpY3QtYWxpYXNpbmcKIAkJZXZhbCAkY2hlY2tjY2ZsYWcK
  QEAgLTU1MzMsNyArNTUzMyw3IEBAIGNhc2UgIiRjcHBmbGFncyIgaW4KICopICBjcHBmbGFncz0i
  JGNwcGZsYWdzICRjY2ZsYWdzIiA7OwogZXNhYwogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikg
  Y3BwZmxhZ3M9IiRjcHBmbGFncyAtRF9fR05VQ19fIgorMS4qKSBjcHBmbGFncz0iJGNwcGZsYWdz
  IC1EX19HTlVDX18iCiBlc2FjCiBjYXNlICIkbWlwc190eXBlIiBpbgogJycpOzsKQEAgLTIyOTYx
  LDcgKzIyOTYxLDcgQEAgZmkKIAogOiBhZGQgLURfRk9SVElGWV9TT1VSQ0UgaWYgZmVhc2libGUg
  YW5kIG5vdCBhbHJlYWR5IHRoZXJlCiBjYXNlICIkZ2NjdmVyc2lvbiIgaW4KLTQuKikJY2FzZSAi
  JG9wdGltaXplJGNjZmxhZ3MiIGluCitbNDU2Nzg5XS4qfFsxLTldWzAtOV0qKQljYXNlICIkb3B0
  aW1pemUkY2NmbGFncyIgaW4KIAkqLU8qKQljYXNlICIkY2NmbGFncyRjcHBzeW1ib2xzIiBpbgog
  CQkqX0ZPUlRJRllfU09VUkNFPSopICMgRG9uJ3QgYWRkIGl0IGFnYWluLgogCQkJZWNobyAiWW91
  IHNlZW0gdG8gaGF2ZSAtRF9GT1JUSUZZX1NPVVJDRSBhbHJlYWR5LCBub3QgYWRkaW5nIGl0LiIg
  PiY0Cg==
  CONFGCC10522
  LS0tIENvbmZpZ3VyZQorKysgQ29uZmlndXJlCkBAIC00NzAzLDcgKzQ3MDMsNyBAQCBlbHNlCiBm
  aQogJHJtIC1mIHRyeSB0cnkuKgogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwPWAuL2xv
  YyBnY2MtY3BwICRjcHAgJHB0aGAgOzsKKzEuKikgY3BwPWAuL2xvYyBnY2MtY3BwICRjcHAgJHB0
  aGAgOzsKIGVzYWMKIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgogJycpIGdjY29zYW5kdmVycz0nJyA7
  OwpAQCAtNDc0Myw3ICs0NzQzLDcgQEAgZXNhYwogIyBnY2MgMy4qIGNvbXBsYWluIGFib3V0IGFk
  ZGluZyAtSWRpcmVjdG9yaWVzIHRoYXQgdGhleSBhbHJlYWR5IGtub3cgYWJvdXQsCiAjIHNvIHdl
  IHdpbGwgdGFrZSB0aG9zZSBvZmYgZnJvbSBsb2NpbmNwdGguCiBjYXNlICIkZ2NjdmVyc2lvbiIg
  aW4KLTMqKQorMy4qKQogICAgIGVjaG8gIm1haW4oKXt9Ij50cnkuYwogICAgIGZvciBpbmNkaXIg
  aW4gJGxvY2luY3B0aDsgZG8KICAgICAgICB3YXJuPWAkY2MgJGNjZmxhZ3MgLUkkaW5jZGlyIC1j
  IHRyeS5jIDI+JjEgfCBcCkBAIC01NDY5LDEzICs1NDY5LDEzIEBAIGZpCiBjYXNlICIkaGludCIg
  aW4KIGRlZmF1bHR8cmVjb21tZW5kZWQpCiAJY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0JMSopIGRm
  bHQ9IiRkZmx0IC1mcGNjLXN0cnVjdC1yZXR1cm4iIDs7CisJMS4qKSBkZmx0PSIkZGZsdCAtZnBj
  Yy1zdHJ1Y3QtcmV0dXJuIiA7OwogCWVzYWMKIAljYXNlICIkb3B0aW1pemU6JERFQlVHR0lORyIg
  aW4KIAkqLWcqOm9sZCkgZGZsdD0iJGRmbHQgLURERUJVR0dJTkciOzsKIAllc2FjCiAJY2FzZSAi
  JGdjY3ZlcnNpb24iIGluCi0JMiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYK
  KwkyLiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYKIAkJCSRjb250YWlucyBf
  UE9TSVhfVkVSU0lPTiAkdXNyaW5jL3N5cy91bmlzdGQuaCA+L2Rldi9udWxsIDI+JjEKIAkJdGhl
  bgogCQkJIyBJbnRlcmFjdGl2ZSBTeXN0ZW1zIChJU0MpIFBPU0lYIG1vZGUuCkBAIC01NDg0LDcg
  KzU0ODQsNyBAQCBkZWZhdWx0fHJlY29tbWVuZGVkKQogCQk7OwogCWVzYWMKIAljYXNlICIkZ2Nj
  dmVyc2lvbiIgaW4KLQkxKikgOzsKKwkxLiopIDs7CiAJMi5bMC04XSopIDs7CiAJPyopCXNldCBz
  dHJpY3QtYWxpYXNpbmcgLWZuby1zdHJpY3QtYWxpYXNpbmcKIAkJZXZhbCAkY2hlY2tjY2ZsYWcK
  QEAgLTU2MDIsNyArNTYwMiw3IEBAIGNhc2UgIiRjcHBmbGFncyIgaW4KICAgICA7OwogZXNhYwog
  Y2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwZmxhZ3M9IiRjcHBmbGFncyAtRF9fR05VQ19f
  IgorMS4qKSBjcHBmbGFncz0iJGNwcGZsYWdzIC1EX19HTlVDX18iCiBlc2FjCiBjYXNlICIkbWlw
  c190eXBlIiBpbgogJycpOzsKQEAgLTIzNjEyLDcgKzIzNjEyLDcgQEAgZmkKIAogOiBhZGQgLURf
  Rk9SVElGWV9TT1VSQ0UgaWYgZmVhc2libGUgYW5kIG5vdCBhbHJlYWR5IHRoZXJlCiBjYXNlICIk
  Z2NjdmVyc2lvbiIgaW4KLVs0NV0uKikJY2FzZSAiJG9wdGltaXplJGNjZmxhZ3MiIGluCitbNDU2
  Nzg5XS4qfFsxLTldWzAtOV0qKQljYXNlICIkb3B0aW1pemUkY2NmbGFncyIgaW4KIAkqLU8qKQlj
  YXNlICIkY2NmbGFncyRjcHBzeW1ib2xzIiBpbgogCQkqX0ZPUlRJRllfU09VUkNFPSopICMgRG9u
  J3QgYWRkIGl0IGFnYWluLgogCQkJZWNobyAiWW91IHNlZW0gdG8gaGF2ZSAtRF9GT1JUSUZZX1NP
  VVJDRSBhbHJlYWR5LCBub3QgYWRkaW5nIGl0LiIgPiY0Cg==
  CONFGCC10526
  LS0tIENvbmZpZ3VyZQorKysgQ29uZmlndXJlCkBAIC00Njg5LDcgKzQ2ODksNyBAQCBlbHNlCiBm
  aQogJHJtIC1mIHRyeSB0cnkuKgogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwPWAuL2xv
  YyBnY2MtY3BwICRjcHAgJHB0aGAgOzsKKzEuKikgY3BwPWAuL2xvYyBnY2MtY3BwICRjcHAgJHB0
  aGAgOzsKIGVzYWMKIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgogJycpIGdjY29zYW5kdmVycz0nJyA7
  OwpAQCAtNDcyOSw3ICs0NzI5LDcgQEAgZXNhYwogIyBnY2MgMy4qIGNvbXBsYWluIGFib3V0IGFk
  ZGluZyAtSWRpcmVjdG9yaWVzIHRoYXQgdGhleSBhbHJlYWR5IGtub3cgYWJvdXQsCiAjIHNvIHdl
  IHdpbGwgdGFrZSB0aG9zZSBvZmYgZnJvbSBsb2NpbmNwdGguCiBjYXNlICIkZ2NjdmVyc2lvbiIg
  aW4KLTMqKQorMy4qKQogICAgIGVjaG8gIm1haW4oKXt9Ij50cnkuYwogICAgIGZvciBpbmNkaXIg
  aW4gJGxvY2luY3B0aDsgZG8KICAgICAgICB3YXJuPWAkY2MgJGNjZmxhZ3MgLUkkaW5jZGlyIC1j
  IHRyeS5jIDI+JjEgfCBcCkBAIC01NDU1LDEzICs1NDU1LDEzIEBAIGZpCiBjYXNlICIkaGludCIg
  aW4KIGRlZmF1bHR8cmVjb21tZW5kZWQpCiAJY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0JMSopIGRm
  bHQ9IiRkZmx0IC1mcGNjLXN0cnVjdC1yZXR1cm4iIDs7CisJMS4qKSBkZmx0PSIkZGZsdCAtZnBj
  Yy1zdHJ1Y3QtcmV0dXJuIiA7OwogCWVzYWMKIAljYXNlICIkb3B0aW1pemU6JERFQlVHR0lORyIg
  aW4KIAkqLWcqOm9sZCkgZGZsdD0iJGRmbHQgLURERUJVR0dJTkciOzsKIAllc2FjCiAJY2FzZSAi
  JGdjY3ZlcnNpb24iIGluCi0JMiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYK
  KwkyLiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYKIAkJCSRjb250YWlucyBf
  UE9TSVhfVkVSU0lPTiAkdXNyaW5jL3N5cy91bmlzdGQuaCA+L2Rldi9udWxsIDI+JjEKIAkJdGhl
  bgogCQkJIyBJbnRlcmFjdGl2ZSBTeXN0ZW1zIChJU0MpIFBPU0lYIG1vZGUuCkBAIC01NDcwLDcg
  KzU0NzAsNyBAQCBkZWZhdWx0fHJlY29tbWVuZGVkKQogCQk7OwogCWVzYWMKIAljYXNlICIkZ2Nj
  dmVyc2lvbiIgaW4KLQkxKikgOzsKKwkxLiopIDs7CiAJMi5bMC04XSopIDs7CiAJPyopCXNldCBz
  dHJpY3QtYWxpYXNpbmcgLWZuby1zdHJpY3QtYWxpYXNpbmcKIAkJZXZhbCAkY2hlY2tjY2ZsYWcK
  QEAgLTU1ODgsNyArNTU4OCw3IEBAIGNhc2UgIiRjcHBmbGFncyIgaW4KICAgICA7OwogZXNhYwog
  Y2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwZmxhZ3M9IiRjcHBmbGFncyAtRF9fR05VQ19f
  IgorMS4qKSBjcHBmbGFncz0iJGNwcGZsYWdzIC1EX19HTlVDX18iCiBlc2FjCiBjYXNlICIkbWlw
  c190eXBlIiBpbgogJycpOzsKQEAgLTIzMDI2LDcgKzIzMDI2LDcgQEAgZmkKIAogOiBhZGQgLURf
  Rk9SVElGWV9TT1VSQ0UgaWYgZmVhc2libGUgYW5kIG5vdCBhbHJlYWR5IHRoZXJlCiBjYXNlICIk
  Z2NjdmVyc2lvbiIgaW4KLVs0NTY3XS4qKQljYXNlICIkb3B0aW1pemUkY2NmbGFncyIgaW4KK1s0
  NTY3ODldLip8WzEtOV1bMC05XSopCWNhc2UgIiRvcHRpbWl6ZSRjY2ZsYWdzIiBpbgogCSotTyop
  CWNhc2UgIiRjY2ZsYWdzJGNwcHN5bWJvbHMiIGluCiAJCSpfRk9SVElGWV9TT1VSQ0U9KikgIyBE
  b24ndCBhZGQgaXQgYWdhaW4uCiAJCQllY2hvICJZb3Ugc2VlbSB0byBoYXZlIC1EX0ZPUlRJRllf
  U09VUkNFIGFscmVhZHksIG5vdCBhZGRpbmcgaXQuIiA+JjQK
  CONFGCC10528
  LS0tIENvbmZpZ3VyZQorKysgQ29uZmlndXJlCkBAIC00NzAzLDcgKzQ3MDMsNyBAQCBlbHNlCiBm
  aQogJHJtIC1mIHRyeSB0cnkuKgogY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwPWAuL2xv
  YyBnY2MtY3BwICRjcHAgJHB0aGAgOzsKKzEuKikgY3BwPWAuL2xvYyBnY2MtY3BwICRjcHAgJHB0
  aGAgOzsKIGVzYWMKIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgogJycpIGdjY29zYW5kdmVycz0nJyA7
  OwpAQCAtNDc0Myw3ICs0NzQzLDcgQEAgZXNhYwogIyBnY2MgMy4qIGNvbXBsYWluIGFib3V0IGFk
  ZGluZyAtSWRpcmVjdG9yaWVzIHRoYXQgdGhleSBhbHJlYWR5IGtub3cgYWJvdXQsCiAjIHNvIHdl
  IHdpbGwgdGFrZSB0aG9zZSBvZmYgZnJvbSBsb2NpbmNwdGguCiBjYXNlICIkZ2NjdmVyc2lvbiIg
  aW4KLTMqKQorMy4qKQogICAgIGVjaG8gIm1haW4oKXt9Ij50cnkuYwogICAgIGZvciBpbmNkaXIg
  aW4gJGxvY2luY3B0aDsgZG8KICAgICAgICB3YXJuPWAkY2MgJGNjZmxhZ3MgLUkkaW5jZGlyIC1j
  IHRyeS5jIDI+JjEgfCBcCkBAIC01NDY5LDEzICs1NDY5LDEzIEBAIGZpCiBjYXNlICIkaGludCIg
  aW4KIGRlZmF1bHR8cmVjb21tZW5kZWQpCiAJY2FzZSAiJGdjY3ZlcnNpb24iIGluCi0JMSopIGRm
  bHQ9IiRkZmx0IC1mcGNjLXN0cnVjdC1yZXR1cm4iIDs7CisJMS4qKSBkZmx0PSIkZGZsdCAtZnBj
  Yy1zdHJ1Y3QtcmV0dXJuIiA7OwogCWVzYWMKIAljYXNlICIkb3B0aW1pemU6JERFQlVHR0lORyIg
  aW4KIAkqLWcqOm9sZCkgZGZsdD0iJGRmbHQgLURERUJVR0dJTkciOzsKIAllc2FjCiAJY2FzZSAi
  JGdjY3ZlcnNpb24iIGluCi0JMiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYK
  KwkyLiopIGlmICR0ZXN0IC1kIC9ldGMvY29uZi9rY29uZmlnLmQgJiYKIAkJCSRjb250YWlucyBf
  UE9TSVhfVkVSU0lPTiAkdXNyaW5jL3N5cy91bmlzdGQuaCA+L2Rldi9udWxsIDI+JjEKIAkJdGhl
  bgogCQkJIyBJbnRlcmFjdGl2ZSBTeXN0ZW1zIChJU0MpIFBPU0lYIG1vZGUuCkBAIC01NDg0LDcg
  KzU0ODQsNyBAQCBkZWZhdWx0fHJlY29tbWVuZGVkKQogCQk7OwogCWVzYWMKIAljYXNlICIkZ2Nj
  dmVyc2lvbiIgaW4KLQkxKikgOzsKKwkxLiopIDs7CiAJMi5bMC04XSopIDs7CiAJPyopCXNldCBz
  dHJpY3QtYWxpYXNpbmcgLWZuby1zdHJpY3QtYWxpYXNpbmcKIAkJZXZhbCAkY2hlY2tjY2ZsYWcK
  QEAgLTU2MDIsNyArNTYwMiw3IEBAIGNhc2UgIiRjcHBmbGFncyIgaW4KICAgICA7OwogZXNhYwog
  Y2FzZSAiJGdjY3ZlcnNpb24iIGluCi0xKikgY3BwZmxhZ3M9IiRjcHBmbGFncyAtRF9fR05VQ19f
  IgorMS4qKSBjcHBmbGFncz0iJGNwcGZsYWdzIC1EX19HTlVDX18iCiBlc2FjCiBjYXNlICIkbWlw
  c190eXBlIiBpbgogJycpOzsKQEAgLTIzMjI5LDcgKzIzMjI5LDcgQEAgZmkKIAogOiBhZGQgLURf
  Rk9SVElGWV9TT1VSQ0UgaWYgZmVhc2libGUgYW5kIG5vdCBhbHJlYWR5IHRoZXJlCiBjYXNlICIk
  Z2NjdmVyc2lvbiIgaW4KLVs0NTY3ODldLiopCWNhc2UgIiRvcHRpbWl6ZSRjY2ZsYWdzIiBpbgor
  WzQ1Njc4OV0uKnxbMS05XVswLTldKikJY2FzZSAiJG9wdGltaXplJGNjZmxhZ3MiIGluCiAJKi1P
  KikJY2FzZSAiJGNjZmxhZ3MkY3Bwc3ltYm9scyIgaW4KIAkJKl9GT1JUSUZZX1NPVVJDRT0qKSAj
  IERvbid0IGFkZCBpdCBhZ2Fpbi4KIAkJCWVjaG8gIllvdSBzZWVtIHRvIGhhdmUgLURfRk9SVElG
  WV9TT1VSQ0UgYWxyZWFkeSwgbm90IGFkZGluZyBpdC4iID4mNAo=
  CONFGCC10
  LS0tIGV4dC9EeW5hTG9hZGVyL0R5bmFMb2FkZXJfcG0uUEwKKysrIGV4dC9EeW5hTG9hZGVyL0R5
  bmFMb2FkZXJfcG0uUEwKQEAgLTQ5NCwxMiArNDk0LDE4IEBAIHN1YiBkbF9maW5kZmlsZSB7CiAg
  ICAgICAgICAgICBmb3JlYWNoICRuYW1lIChAbmFtZXMpIHsKIAkJbXkoJGZpbGUpID0gIiRkaXIk
  ZGlyc2VwJG5hbWUiOwogICAgICAgICAgICAgICAgIHByaW50IFNUREVSUiAiIGNoZWNraW5nIGlu
  ICRkaXIgZm9yICRuYW1lXG4iIGlmICRkbF9kZWJ1ZzsKLQkJJGZpbGUgPSAoJGRvX2V4cGFuZCkg
  PyBkbF9leHBhbmRzcGVjKCRmaWxlKSA6ICgtZiAkZmlsZSAmJiAkZmlsZSk7Ci0JCSMkZmlsZSA9
  IF9jaGVja19maWxlKCRmaWxlKTsKLQkJaWYgKCRmaWxlKSB7CisJCWlmICgkZG9fZXhwYW5kICYm
  ICgkZmlsZSA9IGRsX2V4cGFuZHNwZWMoJGZpbGUpKSkgeworICAgICAgICAgICAgICAgICAgICBw
  dXNoIEBmb3VuZCwgJGZpbGU7CisgICAgICAgICAgICAgICAgICAgIG5leHQgYXJnOyAjIG5vIG5l
  ZWQgdG8gbG9vayBhbnkgZnVydGhlcgorCQl9CisJCWVsc2lmICgtZiAkZmlsZSkgewogICAgICAg
  ICAgICAgICAgICAgICBwdXNoKEBmb3VuZCwgJGZpbGUpOwogICAgICAgICAgICAgICAgICAgICBu
  ZXh0IGFyZzsgIyBubyBuZWVkIHRvIGxvb2sgYW55IGZ1cnRoZXIKICAgICAgICAgICAgICAgICB9
  CisJCWVsc2lmIChkbF9sb2FkX2ZpbGUoJGZpbGUsIDApKSB7CisgICAgICAgICAgICAgICAgICAg
  IHB1c2ggQGZvdW5kLCAkZmlsZTsKKyAgICAgICAgICAgICAgICAgICAgbmV4dCBhcmc7ICMgbm8g
  bmVlZCB0byBsb29rIGFueSBmdXJ0aGVyCisJCX0KICAgICAgICAgICAgIH0KICAgICAgICAgfQog
  ICAgIH0K
  BIGSURDL
  LS0tIGxpYi9FeHRVdGlscy9MaWJsaXN0LnBtCisrKyBsaWIvRXh0VXRpbHMvTGlibGlzdC5wbQpA
  QCAtMTQyLDYgKzE0Miw4IEBAIHN1YiBfdW5peF9vczJfZXh0IHsKICAgICAgICAgICAgICAgICAg
  JiYgKCEgJENvbmZpZ3snYXJjaG5hbWUnfSA9fiAvUk1cZFxkXGQtc3ZyNC8pCiAJCSAmJiAoJHRo
  aXNsaWIgLj0gIl9zIikgKXsgIyB3ZSBtdXN0IGV4cGxpY2l0bHkgdXNlIF9zIHZlcnNpb24KIAkg
  ICAgfSBlbHNpZiAoLWYgKCRmdWxsbmFtZT0iJHRoaXNwdGgvbGliJHRoaXNsaWIkQ29uZmlnX2xp
  YmV4dCIpKXsKKyAgICAgIH0gZWxzaWYgKCReTyBlcSAnZGFyd2luJyAmJiByZXF1aXJlIER5bmFM
  b2FkZXIgJiYgZGVmaW5lZCAmRHluYUxvYWRlcjo6ZGxfbG9hZF9maWxlCisgICAgICAgICAgICAg
  ICAgICYmIER5bmFMb2FkZXI6OmRsX2xvYWRfZmlsZSggJGZ1bGxuYW1lID0gIiR0aGlzcHRoL2xp
  YiR0aGlzbGliLiRzbyIsIDAgKSl7CiAJICAgIH0gZWxzaWYgKC1mICgkZnVsbG5hbWU9IiR0aGlz
  cHRoLyR0aGlzbGliJENvbmZpZ19saWJleHQiKSl7CiAJICAgIH0gZWxzaWYgKC1mICgkZnVsbG5h
  bWU9IiR0aGlzcHRoL1NsaWIkdGhpc2xpYiRDb25maWdfbGliZXh0IikpewogCSAgICB9IGVsc2lm
  ICgkXk8gZXEgJ2RndXgnCg==
  EUMMBIGSUR580
  LS0tIGxpYi9FeHRVdGlscy9MaWJsaXN0L0tpZC5wbQorKysgbGliL0V4dFV0aWxzL0xpYmxpc3Qv
  S2lkLnBtCkBAIC0xMzAsNiArMTMwLDggQEAgc3ViIF91bml4X29zMl9leHQgewogICAgICAgICAg
  ICAgICAgICAmJiAoJENvbmZpZ3snYXJjaG5hbWUnfSAhfiAvUk1cZFxkXGQtc3ZyNC8pCiAJCSAm
  JiAoJHRoaXNsaWIgLj0gIl9zIikgKXsgIyB3ZSBtdXN0IGV4cGxpY2l0bHkgdXNlIF9zIHZlcnNp
  b24KIAkgICAgfSBlbHNpZiAoLWYgKCRmdWxsbmFtZT0iJHRoaXNwdGgvbGliJHRoaXNsaWIkQ29u
  ZmlnX2xpYmV4dCIpKXsKKyAgICAgIH0gZWxzaWYgKCAkXk8gZXEgJ2RhcndpbicgJiYgcmVxdWly
  ZSBEeW5hTG9hZGVyICYmIGRlZmluZWQgJkR5bmFMb2FkZXI6OmRsX2xvYWRfZmlsZQorICAgICAg
  ICAgICAgICAgICAmJiBEeW5hTG9hZGVyOjpkbF9sb2FkX2ZpbGUoICRmdWxsbmFtZSA9ICIkdGhp
  c3B0aC9saWIkdGhpc2xpYi4kc28iLCAwICkpewogCSAgICB9IGVsc2lmICgtZiAoJGZ1bGxuYW1l
  PSIkdGhpc3B0aC8kdGhpc2xpYiRDb25maWdfbGliZXh0IikpewogICAgICAgICAgICAgfSBlbHNp
  ZiAoLWYgKCRmdWxsbmFtZT0iJHRoaXNwdGgvbGliJHRoaXNsaWIuZGxsJENvbmZpZ19saWJleHQi
  KSl7CiAJICAgIH0gZWxzaWYgKC1mICgkZnVsbG5hbWU9IiR0aGlzcHRoL1NsaWIkdGhpc2xpYiRD
  b25maWdfbGliZXh0Iikpewo=
  EUMMBIGSUR511
  LS0tIGNwYW4vRXh0VXRpbHMtTWFrZU1ha2VyL2xpYi9FeHRVdGlscy9MaWJsaXN0L0tpZC5wbQor
  KysgY3Bhbi9FeHRVdGlscy1NYWtlTWFrZXIvbGliL0V4dFV0aWxzL0xpYmxpc3QvS2lkLnBtCkBA
  IC0xMzAsNiArMTMwLDggQEAgc3ViIF91bml4X29zMl9leHQgewogICAgICAgICAgICAgICAgICAm
  JiAoJENvbmZpZ3snYXJjaG5hbWUnfSAhfiAvUk1cZFxkXGQtc3ZyNC8pCiAJCSAmJiAoJHRoaXNs
  aWIgLj0gIl9zIikgKXsgIyB3ZSBtdXN0IGV4cGxpY2l0bHkgdXNlIF9zIHZlcnNpb24KIAkgICAg
  fSBlbHNpZiAoLWYgKCRmdWxsbmFtZT0iJHRoaXNwdGgvbGliJHRoaXNsaWIkQ29uZmlnX2xpYmV4
  dCIpKXsKKyAgICAgIH0gZWxzaWYgKCAkXk8gZXEgJ2RhcndpbicgJiYgcmVxdWlyZSBEeW5hTG9h
  ZGVyICYmIGRlZmluZWQgJkR5bmFMb2FkZXI6OmRsX2xvYWRfZmlsZQorICAgICAgICAgICAgICAg
  ICAmJiBEeW5hTG9hZGVyOjpkbF9sb2FkX2ZpbGUoICRmdWxsbmFtZSA9ICIkdGhpc3B0aC9saWIk
  dGhpc2xpYi4kc28iLCAwICkpewogCSAgICB9IGVsc2lmICgtZiAoJGZ1bGxuYW1lPSIkdGhpc3B0
  aC8kdGhpc2xpYiRDb25maWdfbGliZXh0IikpewogICAgICAgICAgICAgfSBlbHNpZiAoLWYgKCRm
  dWxsbmFtZT0iJHRoaXNwdGgvbGliJHRoaXNsaWIuZGxsJENvbmZpZ19saWJleHQiKSl7CiAJICAg
  IH0gZWxzaWYgKC1mICgkZnVsbG5hbWU9IiR0aGlzcHRoL1NsaWIkdGhpc2xpYiRDb25maWdfbGli
  ZXh0Iikpewo=
  EUMMBIGSUR513
  LS0tIGNwYW4vRXh0VXRpbHMtTWFrZU1ha2VyL2xpYi9FeHRVdGlscy9MaWJsaXN0L0tpZC5wbQor
  KysgY3Bhbi9FeHRVdGlscy1NYWtlTWFrZXIvbGliL0V4dFV0aWxzL0xpYmxpc3QvS2lkLnBtCkBA
  IC0xMzMsNiArMTMzLDggQEAgc3ViIF91bml4X29zMl9leHQgewogCSAgICB9IGVsc2lmICgtZiAo
  JGZ1bGxuYW1lPSIkdGhpc3B0aC9saWIkdGhpc2xpYiRDb25maWdfbGliZXh0IikpewogCSAgICB9
  IGVsc2lmIChkZWZpbmVkKCRDb25maWdfZGxleHQpCiAgICAgICAgICAgICAgICAgICYmIC1mICgk
  ZnVsbG5hbWU9IiR0aGlzcHRoL2xpYiR0aGlzbGliLiRDb25maWdfZGxleHQiKSl7CisgICAgICB9
  IGVsc2lmICgkXk8gZXEgJ2RhcndpbicgJiYgcmVxdWlyZSBEeW5hTG9hZGVyICYmIGRlZmluZWQg
  JkR5bmFMb2FkZXI6OmRsX2xvYWRfZmlsZQorICAgICAgICAgICAgICAgICAmJiBEeW5hTG9hZGVy
  OjpkbF9sb2FkX2ZpbGUoICRmdWxsbmFtZSA9ICIkdGhpc3B0aC9saWIkdGhpc2xpYi4kc28iLCAw
  ICkpewogCSAgICB9IGVsc2lmICgtZiAoJGZ1bGxuYW1lPSIkdGhpc3B0aC8kdGhpc2xpYiRDb25m
  aWdfbGliZXh0IikpewogCSAgICB9IGVsc2lmICgtZiAoJGZ1bGxuYW1lPSIkdGhpc3B0aC9saWIk
  dGhpc2xpYi5kbGwkQ29uZmlnX2xpYmV4dCIpKXsKIAkgICAgfSBlbHNpZiAoLWYgKCRmdWxsbmFt
  ZT0iJHRoaXNwdGgvU2xpYiR0aGlzbGliJENvbmZpZ19saWJleHQiKSl7Cg==
  EUMMBIGSUR515
  LS0tIGNwYW4vRXh0VXRpbHMtTWFrZU1ha2VyL2xpYi9FeHRVdGlscy9MaWJsaXN0L0tpZC5wbQor
  KysgY3Bhbi9FeHRVdGlscy1NYWtlTWFrZXIvbGliL0V4dFV0aWxzL0xpYmxpc3QvS2lkLnBtCkBA
  IC0xNzQsNiArMTc0LDEwIEBAIHN1YiBfdW5peF9vczJfZXh0IHsKICAgICAgICAgICAgICAgICAm
  JiAtZiAoICRmdWxsbmFtZSA9ICIkdGhpc3B0aC9saWIkdGhpc2xpYi4kQ29uZmlnX2RsZXh0IiAp
  ICkKICAgICAgICAgICAgIHsKICAgICAgICAgICAgIH0KKyAgICAgICAgICAgIGVsc2lmICggJF5P
  IGVxICdkYXJ3aW4nICYmIHJlcXVpcmUgRHluYUxvYWRlciAmJiBkZWZpbmVkICZEeW5hTG9hZGVy
  OjpkbF9sb2FkX2ZpbGUKKyAgICAgICAgICAgICAgICAmJiBEeW5hTG9hZGVyOjpkbF9sb2FkX2Zp
  bGUoICRmdWxsbmFtZSA9ICIkdGhpc3B0aC9saWIkdGhpc2xpYi4kc28iLCAwICkgKQorICAgICAg
  ICAgICAgeworICAgICAgICAgICAgfQogICAgICAgICAgICAgZWxzaWYgKCAtZiAoICRmdWxsbmFt
  ZSA9ICIkdGhpc3B0aC8kdGhpc2xpYiRDb25maWdfbGliZXh0IiApICkgewogICAgICAgICAgICAg
  fQogICAgICAgICAgICAgZWxzaWYgKCAtZiAoICRmdWxsbmFtZSA9ICIkdGhpc3B0aC9saWIkdGhp
  c2xpYi5kbGwkQ29uZmlnX2xpYmV4dCIgKSApIHsK
  EUMMBIGSUR
  diff --git a/Makefile.SH b/Makefile.SH
  index 6e4d5ee684f..bebe50dc131 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -67,8 +67,16 @@ true)
                               -compatibility_version \
   				${api_revision}.${api_version}.${api_subversion} \
   			     -current_version \
  -				${revision}.${patchlevel}.${subversion} \
  -			     -install_name \$(shrpdir)/\$@"
  +				${revision}.${patchlevel}.${subversion}"
  +		case "$osvers" in
  +	        1[5-9]*|[2-9]*)
  +			shrpldflags="$shrpldflags -install_name `pwd`/\$@ -Xlinker -headerpad_max_install_names"
  +			exeldflags="-Xlinker -headerpad_max_install_names"
  +			;;
  +		*)
  +			shrpldflags="$shrpldflags -install_name \$(shrpdir)/\$@"
  +			;;
  +		esac
   		;;
   	cygwin*)
   		shrpldflags="$shrpldflags -Wl,--out-implib=libperl.dll.a -Wl,--image-base,0x52000000"
  @@ -339,6 +347,14 @@ MANIFEST_SRT = MANIFEST.srt
   
   !GROK!THIS!
   
  +case "$useshrplib$osname" in
  +truedarwin)
  +	$spitshell >>$Makefile <<!GROK!THIS!
  +PERL_EXE_LDFLAGS=$exeldflags
  +!GROK!THIS!
  +	;;
  +esac
  +
   case "$usecrosscompile$perl" in
   define?*)
   	$spitshell >>$Makefile <<!GROK!THIS!
  @@ -1050,6 +1066,20 @@ $(PERL_EXE): $& $(perlmain_dep) $(LIBPERL) $(static_ext) ext.libs $(PERLEXPORT)
   	$(SHRPENV) $(CC) -o perl $(CLDFLAGS) $(CCDLFLAGS) $(perlmain_objs) $(LLIBPERL) $(static_ext) `cat ext.libs` $(libs)
   !NO!SUBS!
           ;;
  +
  +	darwin)
  +	    case "$useshrplib$osvers" in
  +	    true1[5-9]*|true[2-9]*) $spitshell >>$Makefile <<'!NO!SUBS!'
  +	$(SHRPENV) $(CC) -o perl $(PERL_EXE_LDFLAGS) $(CLDFLAGS) $(CCDLFLAGS) $(perlmain_objs) $(static_ext) $(LLIBPERL) `cat ext.libs` $(libs)
  +!NO!SUBS!
  +	       ;;
  +	    *) $spitshell >>$Makefile <<'!NO!SUBS!'
  +	$(SHRPENV) $(CC) -o perl $(CLDFLAGS) $(CCDLFLAGS) $(perlmain_objs) $(static_ext) $(LLIBPERL) `cat ext.libs` $(libs)
  +!NO!SUBS!
  +	       ;;
  +	    esac
  +        ;;
  +
           *) $spitshell >>$Makefile <<'!NO!SUBS!'
   	$(SHRPENV) $(CC) -o perl $(CLDFLAGS) $(CCDLFLAGS) $(perlmain_objs) $(static_ext) $(LLIBPERL) `cat ext.libs` $(libs)
   !NO!SUBS!
  diff --git a/installperl b/installperl
  index 3bf79d2d6fc..6cd65a09238 100755
  --- installperl
  +++ installperl
  @@ -304,6 +304,7 @@ elsif ($^O ne 'dos') {
   	safe_unlink("$installbin/$perl_verbase$ver$exe_ext");
   	copy("perl$exe_ext", "$installbin/$perl_verbase$ver$exe_ext");
   	strip("$installbin/$perl_verbase$ver$exe_ext");
  +	fix_dep_names("$installbin/$perl_verbase$ver$exe_ext");
   	chmod(0755, "$installbin/$perl_verbase$ver$exe_ext");
       }
       else {
  @@ -388,6 +389,7 @@ foreach my $file (@corefiles) {
       if (copy_if_diff($file,"$installarchlib/CORE/$file")) {
   	if ($file =~ /\.(\Q$so\E|\Q$dlext\E)$/) {
   	    strip("-S", "$installarchlib/CORE/$file") if $^O eq 'darwin';
  +	    fix_dep_names("$installarchlib/CORE/$file");
   	    chmod($SO_MODE, "$installarchlib/CORE/$file");
   	} else {
   	    chmod($NON_SO_MODE, "$installarchlib/CORE/$file");
  @@ -791,4 +793,27 @@ sub strip
       }
   }
   
  +sub fix_dep_names {
  +    my $file = shift;
  +
  +    $^O eq "darwin" && $Config{osvers} =~ /^(1[5-9]|[2-9])/
  +      && $Config{useshrplib}
  +      or return;
  +
  +    my @opts;
  +    my $so = $Config{so};
  +    my $libperl = "$Config{archlibexp}/CORE/libperl.$Config{so}";
  +    if ($file =~ /\blibperl.\Q$Config{so}\E$/a) {
  +        push @opts, -id => $libperl;
  +    }
  +    else {
  +        push @opts, -change => getcwd . "/libperl.$so", $libperl;
  +    }
  +    push @opts, $file;
  +
  +    $opts{verbose} and print "  install_name_tool @opts\n";
  +    system "install_name_tool", @opts
  +      and die "Cannot update $file dependency paths\n";
  +}
  +
   # ex: set ts=8 sts=4 sw=4 et:
  END
DEVEL_PATCHPERL

$fatpacked{"Devel/PatchPerl/Hints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL_HINTS';
  package Devel::PatchPerl::Hints;$Devel::PatchPerl::Hints::VERSION='2.08';use strict;use warnings;use MIME::Base64 qw[decode_base64];use File::Spec;our@ISA=qw[Exporter];our@EXPORT_OK=qw[hint_file hints];my%hints=('bitrig'=>'IyBoaW50cy9vcGVuYnNkLnNoCiMKIyBoaW50cyBmaWxlIGZvciBPcGVuQlNEOyBUb2RkIE1pbGxl
  ciA8bWlsbGVydEBvcGVuYnNkLm9yZz4KIyBFZGl0ZWQgdG8gYWxsb3cgQ29uZmlndXJlIGNvbW1h
  bmQtbGluZSBvdmVycmlkZXMgYnkKIyAgQW5keSBEb3VnaGVydHkgPGRvdWdoZXJhQGxhZmF5ZXR0
  ZS5lZHU+CiMKIyBUbyBidWlsZCB3aXRoIGRpc3RyaWJ1dGlvbiBwYXRocywgdXNlOgojCS4vQ29u
  ZmlndXJlIC1kZXMgLURvcGVuYnNkX2Rpc3RyaWJ1dGlvbj1kZWZpbmVkCiMKCiMgT3BlbkJTRCBo
  YXMgYSBiZXR0ZXIgbWFsbG9jIHRoYW4gcGVybC4uLgp0ZXN0ICIkdXNlbXltYWxsb2MiIHx8IHVz
  ZW15bWFsbG9jPSduJwoKIyBDdXJyZW50bHksIHZmb3JrKDIpIGlzIG5vdCBhIHJlYWwgd2luIG92
  ZXIgZm9yaygyKS4KdXNldmZvcms9IiR1bmRlZiIKCiMKIyBOb3QgYWxsIHBsYXRmb3JtcyBzdXBw
  b3J0IGR5bmFtaWMgbG9hZGluZy4uLgojIEZvciB0aGUgY2FzZSBvZiAiJG9wZW5ic2RfZGlzdHJp
  YnV0aW9uIiwgdGhlIGhpbnRzIGZpbGUKIyBuZWVkcyB0byBrbm93IHdoZXRoZXIgd2UgYXJlIHVz
  aW5nIGR5bmFtaWMgbG9hZGluZyBzbyB0aGF0CiMgaXQgY2FuIHNldCB0aGUgbGlicGVybCBuYW1l
  IGFwcHJvcHJpYXRlbHkuCiMgQWxsb3cgY29tbWFuZCBsaW5lIG92ZXJyaWRlcy4KIwojQVJDSD1g
  YXJjaCB8IHNlZCAncy9eT3BlbkJTRC4vLydgCkFSQ0g9YGFyY2ggfCBzZWQgJ3MvXkJpdHJpZy4v
  LydgCmNhc2UgIiR7QVJDSH0tJHtvc3ZlcnN9IiBpbgoqKQoJdGVzdCAteiAiJHVzZWRsIiAmJiB1
  c2VkbD0kZGVmaW5lCgkjIFdlIHVzZSAtZlBJQyBoZXJlIGJlY2F1c2UgLWZwaWMgaXMgKk5PVCog
  ZW5vdWdoIGZvciBzb21lIG9mIHRoZQoJIyBleHRlbnNpb25zIGxpa2UgVGsgb24gc29tZSBPcGVu
  QlNEIHBsYXRmb3JtcyAoaWU6IHNwYXJjKQoJY2NjZGxmbGFncz0iLURQSUMgLWZQSUMgJGNjY2Rs
  ZmxhZ3MiCgljYXNlICIkb3N2ZXJzIiBpbgoJKikgIyBmcm9tIDMuMSBvbndhcmRzCgkJbGQ9JHtj
  YzotY2N9CgkJbGRkbGZsYWdzPSItc2hhcmVkIC1mUElDICRsZGRsZmxhZ3MiCgkJbGlic3dhbnRl
  ZD1gZWNobyAkbGlic3dhbnRlZCB8IHNlZCAncy8gZGwgLyAvJ2AKCQk7OwoJZXNhYwoKCSMgV2Ug
  bmVlZCB0byBmb3JjZSBsZCB0byBleHBvcnQgc3ltYm9scyBvbiBFTEYgcGxhdGZvcm1zLgoJIyBX
  aXRob3V0IHRoaXMsIGRsb3BlbigpIGlzIGNyaXBwbGVkLgoJRUxGPWAke2NjOi1jY30gLWRNIC1F
  IC0gPC9kZXYvbnVsbCB8IGdyZXAgX19FTEZfX2AKCXRlc3QgLW4gIiRFTEYiICYmIGxkZmxhZ3M9
  Ii1XbCwtRSAkbGRmbGFncyIKCTs7CmVzYWMKCiMgbWFsbG9jIHdyYXAgY2F1c2VzIHByb2JsZW1z
  IG9uIG02OGsKaWYgWyBYIiR1c2VtYWxsb2N3cmFwIiA9IFgiIiBdOyB0aGVuCgljYXNlICIke0FS
  Q0h9IiBpbgoJKikgICAgdXNlbWFsbG9jd3JhcD0iZGVmaW5lIiA7OwoJZXNhYwpmaQoKIyBPcGVu
  QlNEIGRvZXNuJ3QgbmVlZCBsaWJjcnlwdCBidXQgbWFueSBmb2xrcyBrZWVwIGEgc3R1YiBsaWIK
  IyBhcm91bmQgZm9yIG9sZCBOZXRCU0QgYmluYXJpZXMuCmxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3
  YW50ZWQgfCBzZWQgJ3MvIGNyeXB0IC8gLydgCgojIENvbmZpZ3VyZSBjYW4ndCBmaWd1cmUgdGhp
  cyBvdXQgbm9uLWludGVyYWN0aXZlbHkKZF9zdWlkc2FmZT0kZGVmaW5lCgojIGNjIGlzIGdjYyBz
  byB3ZSBjYW4gZG8gYmV0dGVyIHRoYW4gLU8KIyBBbGxvdyBhIGNvbW1hbmQtbGluZSBvdmVycmlk
  ZSwgc3VjaCBhcyAtRG9wdGltaXplPS1nCmNhc2UgIiR7QVJDSH0tJHtvc3ZlcnN9IiBpbgoqKQog
  ICB0ZXN0ICIkb3B0aW1pemUiIHx8IG9wdGltaXplPSctTzInCiAgIDs7CmVzYWMKCiMgVGhpcyBz
  Y3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1
  cmUgCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1c2VyIGZvciB3aGV0aGVyIHRvIHVzZSB0
  aHJlYWRzLgpjYXQgPiBVVS91c2V0aHJlYWRzLmNidSA8PCdFT0NCVScKY2FzZSAiJHVzZXRocmVh
  ZHMiIGluCiRkZWZpbmV8dHJ1ZXxbeVldKikKCSMgYW55IG9wZW5ic2QgdmVyc2lvbiBkZXBlbmRl
  bmNpZXMgd2l0aCBwdGhyZWFkcz8KCWNjZmxhZ3M9Ii1wdGhyZWFkICRjY2ZsYWdzIgoJbGRmbGFn
  cz0iLXB0aHJlYWQgJGxkZmxhZ3MiCmVzYWMKRU9DQlUKCiMgV2hlbiBidWlsZGluZyBpbiB0aGUg
  T3BlbkJTRCB0cmVlIHdlIHVzZSBkaWZmZXJlbnQgcGF0aHMKIyBUaGlzIGlzIG9ubHkgcGFydCBv
  ZiB0aGUgc3RvcnksIHRoZSByZXN0IGNvbWVzIGZyb20gY29uZmlnLm92ZXIKY2FzZSAiJG9wZW5i
  c2RfZGlzdHJpYnV0aW9uIiBpbgonJ3wkdW5kZWZ8ZmFsc2UpIDs7CiopCgkjIFdlIHB1dCB0aGlu
  Z3MgaW4gL3Vzciwgbm90IC91c3IvbG9jYWwKCXByZWZpeD0nL3VzcicKCXByZWZpeGV4cD0nL3Vz
  cicKCXN5c21hbj0nL3Vzci9zaGFyZS9tYW4vbWFuMScKCWxpYnB0aD0nL3Vzci9saWInCglnbGli
  cHRoPScvdXNyL2xpYicKCSMgTG9jYWwgdGhpbmdzLCBob3dldmVyLCBkbyBnbyBpbiAvdXNyL2xv
  Y2FsCglzaXRlcHJlZml4PScvdXNyL2xvY2FsJwoJc2l0ZXByZWZpeGV4cD0nL3Vzci9sb2NhbCcK
  CSMgUG9ydHMgaW5zdGFsbHMgbm9uLXN0ZCBsaWJzIGluIC91c3IvbG9jYWwvbGliIHNvIGxvb2sg
  dGhlcmUgdG9vCglsb2NpbmNwdGg9Jy91c3IvbG9jYWwvaW5jbHVkZScKCWxvY2xpYnB0aD0nL3Vz
  ci9sb2NhbC9saWInCgkjIExpbmsgcGVybCB3aXRoIHNoYXJlZCBsaWJwZXJsCglpZiBbICIkdXNl
  ZGwiID0gIiRkZWZpbmUiIC1hIC1yICRzcmMvc2hsaWJfdmVyc2lvbiBdOyB0aGVuCgkJdXNlc2hy
  cGxpYj10cnVlCgkJbGlicGVybD1gLiAkc3JjL3NobGliX3ZlcnNpb247IGVjaG8gbGlicGVybC5z
  by4ke21ham9yfS4ke21pbm9yfWAKCWZpCgk7Owplc2FjCgojIGVuZAo=','cygwin'=>'IyEgL2Jpbi9zaAojIGN5Z3dpbi5zaCAtIGhpbnRzIGZvciBidWlsZGluZyBwZXJsIHVzaW5nIHRo
  ZSBDeWd3aW4gZW52aXJvbm1lbnQgZm9yIFdpbjMyCiMKCiMgbm90IG90aGVyd2lzZSBzZXR0YWJs
  ZQpleGVfZXh0PScuZXhlJwpmaXJzdG1ha2VmaWxlPSdHTlVtYWtlZmlsZScKY2FzZSAiJGxkbGli
  cHRobmFtZSIgaW4KJycpIGxkbGlicHRobmFtZT1QQVRIIDs7CmVzYWMKYXJjaG9ianM9J2N5Z3dp
  bi5vJwoKIyBtYW5kYXRvcnkgKG92ZXJyaWRlcyBpbmNvcnJlY3QgZGVmYXVsdHMpCnRlc3QgLXog
  IiRjYyIgJiYgY2M9J2djYycKaWYgdGVzdCAteiAiJHBsaWJwdGgiCnRoZW4KICAgIHBsaWJwdGg9
  YGdjYyAtcHJpbnQtZmlsZS1uYW1lPWxpYmMuYWAKICAgIHBsaWJwdGg9YGRpcm5hbWUgJHBsaWJw
  dGhgCiAgICBwbGlicHRoPWBjZCAkcGxpYnB0aCAmJiBwd2RgCmZpCnNvPSdkbGwnCiMgLSBlbGlt
  aW5hdGUgLWxjLCBpbXBsaWVkIGJ5IGdjYyBhbmQgYSBzeW1saW5rIHRvIGxpYmN5Z3dpbi5hCmxp
  YnN3YW50ZWQ9YGVjaG8gIiAkbGlic3dhbnRlZCAiIHwgc2VkIC1lICdzLyBjIC8gL2cnYAojIC0g
  ZWxpbWluYXRlIC1sbSwgc3ltbGluayB0byBsaWJjeWd3aW4uYQpsaWJzd2FudGVkPWBlY2hvICIg
  JGxpYnN3YW50ZWQgIiB8IHNlZCAtZSAncy8gbSAvIC9nJ2AKIyAtIGVsaW1pbmF0ZSAtbHV0aWws
  IHN5bWJvbHMgYXJlIGFsbCBpbiBsaWJjeWd3aW4uYQpsaWJzd2FudGVkPWBlY2hvICIgJGxpYnN3
  YW50ZWQgIiB8IHNlZCAtZSAncy8gdXRpbCAvIC9nJ2AKIyAtIGFkZCBsaWJnZGJtX2NvbXBhdCAk
  bGlic3dhbnRlZApsaWJzd2FudGVkPSIkbGlic3dhbnRlZCBnZGJtX2NvbXBhdCIKdGVzdCAteiAi
  JG9wdGltaXplIiAmJiBvcHRpbWl6ZT0nLU8zJwptYW4zZXh0PSczcG0nCnRlc3QgLXogIiR1c2U2
  NGJpdGludCIgJiYgdXNlNjRiaXRpbnQ9J2RlZmluZScKdGVzdCAteiAiJHVzZWl0aHJlYWRzIiAm
  JiB1c2VpdGhyZWFkcz0nZGVmaW5lJwpjY2ZsYWdzPSIkY2NmbGFncyAtRFBFUkxfVVNFX1NBRkVf
  UFVURU5WIC1VX19TVFJJQ1RfQU5TSV9fIC1EX0dOVV9TT1VSQ0UiCiMgLSBvdGhlcndpc2UgaTY4
  Ni1jeWd3aW4KYXJjaG5hbWU9J2N5Z3dpbicKCiMgZHluYW1pYyBsb2FkaW5nCiMgLSBvdGhlcndp
  c2UgLWZwaWMKY2NjZGxmbGFncz0nICcKbGRkbGZsYWdzPScgLS1zaGFyZWQnCnRlc3QgLXogIiRs
  ZCIgJiYgbGQ9J2crKycKCmNhc2UgIiRvc3ZlcnMiIGluCiAgICAjIENvbmZpZ3VyZSBnZXRzIHRo
  ZXNlIHdyb25nIGlmIHRoZSBJUEMgc2VydmVyIGlzbid0IHlldCBydW5uaW5nOgogICAgIyBvbmx5
  IHVzZSBmb3IgMS41LjcgYW5kIG9ud2FyZHMKICAgIFsyLTldKnwxLls2LTldKnwxLlsxLTVdWzAt
  OV0qfDEuNS5bNy05XSp8MS41LlsxLTZdWzAtOV0qKQogICAgICAgIGRfc2VtY3RsX3NlbWlkX2Rz
  PSdkZWZpbmUnCiAgICAgICAgZF9zZW1jdGxfc2VtdW49J2RlZmluZScKICAgICAgICA7Owplc2Fj
  CgpjYXNlICIkb3N2ZXJzIiBpbgogICAgWzItOV0qfDEuWzYtOV0qKQogICAgICAgICMgSVB2NiBv
  bmx5IHNpbmNlIDEuNwogICAgICAgIGRfaW5ldG50b3A9J2RlZmluZScKICAgICAgICBkX2luZXRw
  dG9uPSdkZWZpbmUnCiAgICAgICAgOzsKICAgICopCiAgICAgICAgIyBJUHY2IG5vdCBpbXBsZW1l
  bnRlZCBiZWZvcmUgY3lnd2luLTEuNwogICAgICAgIGRfaW5ldG50b3A9J3VuZGVmJwogICAgICAg
  IGRfaW5ldHB0b249J3VuZGVmJwplc2FjCgojIGNvbXBpbGUgV2luMzJDT1JFICJtb2R1bGUiIGFz
  IHN0YXRpYy4gdHJ5IHRvIGF2b2lkIHRoZSBzcGFjZS4KaWYgdGVzdCAteiAiJHN0YXRpY19leHQi
  OyB0aGVuCiAgc3RhdGljX2V4dD0iV2luMzJDT1JFIgplbHNlCiAgc3RhdGljX2V4dD0iJHN0YXRp
  Y19leHQgV2luMzJDT1JFIgpmaQoKIyBXaW45eCBwcm9ibGVtIHdpdGggbm9uLWJsb2NraW5nIHJl
  YWQgZnJvbSBhIGNsb3NlZCBwaXBlCmRfZW9mbmJsaz0nZGVmaW5lJwoKIyBzdXBwcmVzcyBhdXRv
  LWltcG9ydCB3YXJuaW5ncwpsZGZsYWdzPSIkbGRmbGFncyAtV2wsLS1lbmFibGUtYXV0by1pbXBv
  cnQgLVdsLC0tZXhwb3J0LWFsbC1zeW1ib2xzIC1XbCwtLWVuYWJsZS1hdXRvLWltYWdlLWJhc2Ui
  CmxkZGxmbGFncz0iJGxkZGxmbGFncyAkbGRmbGFncyIKCiMgc3RyaXAgZXhlJ3MgYW5kIGRsbCdz
  LCBiZXR0ZXIgZG8gaXQgYWZ0ZXJ3YXJkcwojbGRmbGFncz0iJGxkZmxhZ3MgLXMiCiNjY2RsZmxh
  Z3M9IiRjY2RsZmxhZ3MgLXMiCiNsZGRsZmxhZ3M9IiRsZGRsZmxhZ3MgLXMiCg==','darwin'=>'IyMKIyBEYXJ3aW4gKE1hYyBPUykgaGludHMKIyBXaWxmcmVkbyBTYW5jaGV6IDx3c2FuY2hlekB3
  c2FuY2hlei5uZXQ+CiMjCgojIwojIFBhdGhzCiMjCgojIENvbmZpZ3VyZSBoYXNuJ3QgZmlndXJl
  ZCBvdXQgdGhlIHZlcnNpb24gbnVtYmVyIHlldC4gIEJ1bW1lci4KcGVybF9yZXZpc2lvbj1gYXdr
  ICcvZGVmaW5lWyAJXStQRVJMX1JFVklTSU9OLyB7cHJpbnQgJDN9JyAkc3JjL3BhdGNobGV2ZWwu
  aGAKcGVybF92ZXJzaW9uPWBhd2sgJy9kZWZpbmVbIAldK1BFUkxfVkVSU0lPTi8ge3ByaW50ICQz
  fScgJHNyYy9wYXRjaGxldmVsLmhgCnBlcmxfc3VidmVyc2lvbj1gYXdrICcvZGVmaW5lWyAJXStQ
  RVJMX1NVQlZFUlNJT04vIHtwcmludCAkM30nICRzcmMvcGF0Y2hsZXZlbC5oYAp2ZXJzaW9uPSIk
  e3BlcmxfcmV2aXNpb259LiR7cGVybF92ZXJzaW9ufS4ke3Blcmxfc3VidmVyc2lvbn0iCgojIFBy
  ZXRlbmQgdGhhdCBEYXJ3aW4gZG9lc24ndCBrbm93IGFib3V0IHRob3NlIHN5c3RlbSBjYWxscyBp
  biBUaWdlcgojICgxMC40L2RhcndpbiA4KSBhbmQgZWFybGllciBbcGVybCAjMjQxMjJdCmNhc2Ug
  IiRvc3ZlcnMiIGluClsxLThdLiopCiAgICBkX3NldHJlZ2lkPSd1bmRlZicKICAgIGRfc2V0cmV1
  aWQ9J3VuZGVmJwogICAgZF9zZXRyZ2lkPSd1bmRlZicKICAgIGRfc2V0cnVpZD0ndW5kZWYnCiAg
  ICA7Owplc2FjCgojIGZpbml0ZSgpIGRlcHJlY2F0ZWQgaW4gMTAuOSwgdXNlIGlzZmluaXRlKCkg
  aW5zdGVhZC4KY2FzZSAiJG9zdmVycyIgaW4KWzEtOF0uKikgOzsKKikgZF9maW5pdGU9J3VuZGVm
  JyA7Owplc2FjCgojIFRoaXMgd2FzIHByZXZpb3VzbHkgdXNlZCBpbiBhbGwgYnV0IGNhdXNlcyB0
  aHJlZSBjYXNlcwojIChubyAtRGRwcmVmaXg9LCAtRHByZWZpeD0vdXNyLCAtRHByZWZpeD0vc29t
  ZS90aGluZy9lbHNlKQojIGJ1dCB0aGF0IGNhdXNlZCB0b28gbXVjaCBncmllZi4KIyB2ZW5kb3Js
  aWI9Ii9TeXN0ZW0vTGlicmFyeS9QZXJsLyR7dmVyc2lvbn0iOyAjIEFwcGxlLXN1cHBsaWVkIG1v
  ZHVsZXMKCmNhc2UgIiRkYXJ3aW5fZGlzdHJpYnV0aW9uIiBpbgokZGVmaW5lKSAjIFdlIGFyZSBi
  dWlsZGluZy9yZXBsYWNpbmcgdGhlIGJ1aWx0LWluIHBlcmwKCXByZWZpeD0nL3Vzcic7CglpbnN0
  YWxscHJlZml4PScvdXNyJzsKCWJpbj0nL3Vzci9iaW4nOwoJc2l0ZXByZWZpeD0nL3Vzci9sb2Nh
  bCc7CgkjIFdlIGRvbid0IHdhbnQgL3Vzci9iaW4vSEVBRCBpc3N1ZXMuCglzaXRlYmluPScvdXNy
  L2xvY2FsL2Jpbic7CglzaXRlc2NyaXB0PScvdXNyL2xvY2FsL2Jpbic7CglpbnN0YWxsdXNyYmlu
  cGVybD0nZGVmaW5lJzsgIyBZb3Uga25ldyB3aGF0IHlvdSB3ZXJlIGRvaW5nLgoJcHJpdmxpYj0i
  L1N5c3RlbS9MaWJyYXJ5L1BlcmwvJHt2ZXJzaW9ufSI7CglzaXRlbGliPSIvTGlicmFyeS9QZXJs
  LyR7dmVyc2lvbn0iOwoJdmVuZG9ycHJlZml4PScvJzsKCXVzZXZlbmRvcnByZWZpeD0nZGVmaW5l
  JzsKCXZlbmRvcmJpbj0nL3Vzci9iaW4nOwoJdmVuZG9yc2NyaXB0PScvdXNyL2Jpbic7Cgl2ZW5k
  b3JsaWI9Ii9OZXR3b3JrL0xpYnJhcnkvUGVybC8ke3ZlcnNpb259IjsKCSMgNEJTRCB1c2VzICR7
  cHJlZml4fS9zaGFyZS9tYW4sIG5vdCAke3ByZWZpeH0vbWFuLgoJbWFuMWRpcj0nL3Vzci9zaGFy
  ZS9tYW4vbWFuMSc7CgltYW4zZGlyPScvdXNyL3NoYXJlL21hbi9tYW4zJzsKCSMgQnV0IHVzZXJz
  JyBpbnN0YWxscyBzaG91bGRuJ3QgdG91Y2ggdGhlIHN5c3RlbSBtYW4gcGFnZXMuCgkjIFRyYW5z
  aWVudCBvYnNvbGV0ZWQgc3R5bGUuCglzaXRlbWFuMT0nL3Vzci9sb2NhbC9zaGFyZS9tYW4vbWFu
  MSc7CglzaXRlbWFuMz0nL3Vzci9sb2NhbC9zaGFyZS9tYW4vbWFuMyc7CgkjIE5ldyBzdHlsZS4K
  CXNpdGVtYW4xZGlyPScvdXNyL2xvY2FsL3NoYXJlL21hbi9tYW4xJzsKCXNpdGVtYW4zZGlyPScv
  dXNyL2xvY2FsL3NoYXJlL21hbi9tYW4zJzsKCTs7CmVzYWMKCiMjCiMgVG9vbCBjaGFpbiBzZXR0
  aW5ncwojIwoKIyBTaW5jZSB3ZSBjYW4gYnVpbGQgZmF0LCB0aGUgYXJjaG5hbWUgZG9lc24ndCBu
  ZWVkIHRoZSBwcm9jZXNzb3IgdHlwZQphcmNobmFtZT0nZGFyd2luJzsKCiMgbm0gaXNuJ3Qga25v
  d24gdG8gd29yayBhZnRlciBTbm93IExlb3BhcmQgYW5kIFhDb2RlIDQ7IHRlc3Rpbmcgd2l0aCBP
  UyBYIDEwLjUKIyBhbmQgWGNvZGUgMyBzaG93cyBhIHdvcmtpbmcgbm0sIGJ1dCBwcmV0ZW5kaW5n
  IGl0IGRvZXNuJ3Qgd29yayBwcm9kdWNlcyBubwojIHByb2JsZW1zLgp1c2VubT0nZmFsc2UnOwoK
  Y2FzZSAiJG9wdGltaXplIiBpbgonJykKIyAgICBPcHRpbWl6aW5nIGZvciBzaXplIGFsc28gbWVh
  biBsZXNzIHJlc2lkZW50IG1lbW9yeSB1c2FnZSBvbiB0aGUgcGFydAojIG9mIFBlcmwuICBBcHBs
  ZSBhc3NlcnRzIHRoYXQgdGhpcyBpcyBhIG1vcmUgaW1wb3J0YW50IG9wdGltaXphdGlvbiB0aGFu
  CiMgc2F2aW5nIG9uIENQVSBjeWNsZXMuICBHaXZlbiB0aGF0IG1lbW9yeSBzcGVlZCBoYXMgbm90
  IGluY3JlYXNlZCBhdAojIHBhY2Ugd2l0aCBDUFUgc3BlZWQgb3ZlciB0aW1lIChvbiBhbnkgcGxh
  dGZvcm0pLCB0aGlzIGlzIHByb2JhYmx5IGEKIyByZWFzb25hYmxlIGFzc2VydGlvbi4KaWYgWyAt
  eiAiJHtvcHRpbWl6ZX0iIF07IHRoZW4KICBjYXNlICJgJHtjYzotZ2NjfSAtdiAyPiYxYCIgaW4K
  ICAgICoiZ2NjIHZlcnNpb24gMy4iKikgb3B0aW1pemU9Jy1PcycgOzsKICAgICopIG9wdGltaXpl
  PSctTzMnIDs7CiAgZXNhYwplbHNlCiAgb3B0aW1pemU9Jy1PMycKZmkKOzsKZXNhYwoKIyAtZm5v
  LWNvbW1vbiBiZWNhdXNlIGNvbW1vbiBzeW1ib2xzIGFyZSBub3QgYWxsb3dlZCBpbiBNSF9EWUxJ
  QgojIC1EUEVSTF9EQVJXSU46IGFwcGFyZW50bHkgdGhlIF9fQVBQTEVfXyBpcyBub3Qgc2FuY3Rp
  b25lZCBieSBBcHBsZQojIGFzIHRoZSB3YXkgdG8gZGlmZmVyZW50aWF0ZSBNYWMgT1MgWC4gIChU
  aGUgb2ZmaWNpYWwgbGluZSBpcyB0aGF0CiMgKm5vKiBjcHAgc3ltYm9sIGRvZXMgZGlmZmVyZW50
  aWF0ZSBNYWMgT1MgWC4pCmNjZmxhZ3M9IiR7Y2NmbGFnc30gLWZuby1jb21tb24gLURQRVJMX0RB
  UldJTiIKCiMgQXQgbGVhc3Qgb24gRGFyd2luIDEuMy54OgojCiMgIyBkZWZpbmUgSU5UMzJfTUlO
  IC0yMTQ3NDgzNjQ4CiMgaW50IG1haW4gKCkgewojICBkb3VibGUgYSA9IElOVDMyX01JTjsKIyAg
  cHJpbnRmICgiSU5UMzJfTUlOPSVnXG4iLCBhKTsKIyAgcmV0dXJuIDA7CiMgfQojIHdpbGwgb3V0
  cHV0OgojIElOVDMyX01JTj0yLjE0NzQ4ZSswOQojIE5vdGUgdGhhdCB0aGUgSU5UMzJfTUlOIGhh
  cyBiZWNvbWUgcG9zaXRpdmUuCiMgSU5UMzJfTUlOIGlzIHNldCBpbiAvdXNyL2luY2x1ZGUvc3Rk
  aW50LmggYnk6CiMgI2RlZmluZSBJTlQzMl9NSU4gICAgICAgIC0yMTQ3NDgzNjQ4CiMgd2hpY2gg
  c2VlbXMgdG8gYnJlYWsgdGhlIGdjYy4gIERlZmluaW5nIElOVDMyX01JTiBhcyAoLTIxNDc0ODM2
  NDctMSkKIyBzZWVtcyB0byB3b3JrLiAgSU5UNjRfTUlOIHNlZW1zIHRvIGJlIHNpbWlsYXJseSBi
  cm9rZW4uCiMgLS0gTmljaG9sYXMgQ2xhcmssIEtlbiBXaWxsaWFtcywgYW5kIEVkd2FyZCBNb3kK
  IwojIFRoaXMgc2VlbXMgdG8gaGF2ZSBiZWVuIGZpeGVkIHNpbmNlIGF0IGxlYXN0IE1hYyBPUyBY
  IDEwLjEuMywKIyBzdGRpbnQuaCBkZWZpbmluZyBJTlQzMl9NSU4gYXMgKC1JTlQzMl9NQVgtMSkK
  IyAtLSBFZHdhcmQgTW95CiMKaWYgdGVzdCAtZiAvdXNyL2luY2x1ZGUvc3RkaW50Lmg7IHRoZW4K
  ICBjYXNlICIkKGdyZXAgJ14jZGVmaW5lIElOVDMyX01JTicgL3Vzci9pbmNsdWRlL3N0ZGludC5o
  KSIgaW4KICAqLTIxNDc0ODM2NDgpIGNjZmxhZ3M9IiR7Y2NmbGFnc30gLURJTlQzMl9NSU5fQlJP
  S0VOIC1ESU5UNjRfTUlOX0JST0tFTiIgOzsKICBlc2FjCmZpCgojIEF2b2lkIEFwcGxlJ3MgY3Bw
  IHByZWNvbXBpbGVyLCBiZXR0ZXIgZm9yIGV4dGVuc2lvbnMKaWYgWyAiWGBlY2hvIHwgJHtjY30g
  LW5vLWNwcC1wcmVjb21wIC1FIC0gMj4mMSA+L2Rldi9udWxsYCIgPSAiWCIgXTsgdGhlbgogICAg
  Y3BwZmxhZ3M9IiR7Y3BwZmxhZ3N9IC1uby1jcHAtcHJlY29tcCIKCiAgICAjIFRoaXMgaXMgbmVj
  ZXNzYXJ5IGJlY2F1c2UgcGVybCdzIGJ1aWxkIHN5c3RlbSBkb2Vzbid0CiAgICAjIGFwcGx5IGNw
  cGZsYWdzIHRvIGNjIGNvbXBpbGUgbGluZXMgYXMgaXQgc2hvdWxkLgogICAgY2NmbGFncz0iJHtj
  Y2ZsYWdzfSAke2NwcGZsYWdzfSIKZmkKCiMgS25vd24gb3B0aW1pemVyIHByb2JsZW1zLgpjYXNl
  ICJgY2MgLXYgMj4mMWAiIGluCiAgKiIzLjEgMjAwMjAxMDUiKikgdG9rZV9jZmxhZ3M9J29wdGlt
  aXplPSIiJyA7Owplc2FjCgojIFNoYXJlZCBsaWJyYXJ5IGV4dGVuc2lvbiBpcyAuZHlsaWIuCiMg
  QnVuZGxlIGV4dGVuc2lvbiBpcyAuYnVuZGxlLgpzbz0nZHlsaWInOwpkbGV4dD0nYnVuZGxlJzsK
  dXNlZGw9J2RlZmluZSc7CgojIDEwLjQgY2FuIHVzZSBkbG9wZW4uCiMgMTAuNCBicm9rZSBwb2xs
  KCkuCmNhc2UgIiRvc3ZlcnMiIGluClsxLTddLiopCiAgICBkbHNyYz0nZGxfZHlsZC54cyc7CiAg
  ICA7OwoqKQogICAgZGxzcmM9J2RsX2Rsb3Blbi54cyc7CiAgICBkX3BvbGw9J3VuZGVmJzsKICAg
  IGlfcG9sbD0ndW5kZWYnOwogICAgOzsKZXNhYwoKY2FzZSAiJGNjZGxmbGFncyIgaW4JCSMgSWYg
  cGFzc2VkIGluIGZyb20gY29tbWFuZCBsaW5lLCBwcmVzdW1lIHVzZXIga25vd3MgYmVzdAonJykK
  ICAgY2NjZGxmbGFncz0nICc7ICMgc3BhY2UsIG5vdCBlbXB0eSwgYmVjYXVzZSBvdGhlcndpc2Ug
  d2UgZ2V0IC1mcGljCjs7CmVzYWMKCiMgQWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgbGQsIGJ1
  dCBtb2RpZnkgaXQgYXMgbmVjZXNzYXJ5IGJlbG93CmNhc2UgIiRsZCIgaW4KICAgICcnKSBjYXNl
  ICIkY2MiIGluCiAgICAgICAgIyBJZiB0aGUgY2MgaXMgZXhwbGljaXRseSBzb21ldGhpbmcgZWxz
  ZSB0aGFuIGNjIChvciBlbXB0eSksCiAgICAgICAgIyBzZXQgdGhlIGxkIHRvIGJlIHRoYXQgZXhw
  bGljaXRseSBzb21ldGhpbmcgZWxzZS4gIENvbnZlcnNlbHksCiAgICAgICAgIyBpZiB0aGUgY2Mg
  aXMgJ2NjJyAob3IgZW1wdHkpLCBzZXQgdGhlIGxkIHRvIGJlICdjYycuCiAgICAgICAgY2N8Jycp
  IGxkPSdjYyc7OwogICAgICAgICopIGxkPSIkY2MiIDs7CiAgICAgICAgZXNhYwogICAgICAgIDs7
  CmVzYWMKCiMgRnJvbSBodHRwOi8vZnRwLm5ldGJzZC5vcmcvcHViL3BrZ3NyYy9jdXJyZW50L3Br
  Z3NyYy9tay9wbGF0Zm9ybS9EYXJ3aW4ubWsKIyBhbmQgaHR0cHM6Ly90cmFjLm1hY3BvcnRzLm9y
  Zy93aWtpL1hjb2RlVmVyc2lvbkluZm8KIyBhbmQgaHR0cHM6Ly90cmFjLm1hY3BvcnRzLm9yZy93
  aWtpL1VzaW5nVGhlUmlnaHRDb21waWxlcgojIGFuZCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS95
  YW1heWEvMjkyNDI5MgojIGFuZCBodHRwOi8vb3BlbnNvdXJjZS5hcHBsZS5jb20vc291cmNlL2Ns
  YW5nLwojCiMgTm90ZSB0aGF0IFhjb2RlIGdldHMgdXBkYXRlcyBvbiBvbGRlciBzeXN0ZW1zIHNv
  bWV0aW1lcywgYW5kIGluCiMgZ2VuZXJhbCB0aGF0IHRoZSBPUyBsZXZlbHMgYW5kIFhDb2RlIGxl
  dmVscyBhcmUgbm90IHN5bmNocm9uaXplZAojIHNpbmNlIG5ldyByZWxlYXNlcyBvZiBYQ29kZSB1
  c3VhbGx5IHN1cHBvcnQgYm90aCBzb21lIG5ldyBhbmQgc29tZQojIG9sZCBPUyByZWxlYXNlcy4K
  IwojIE5vdGUgdGhhdCBBcHBsZSBoaWphY2tzIHRoZSBjbGFuZyBwcmVwcm9jZXNzb3Igc3ltYm9s
  cyBfX2NsYW5nX21ham9yX18KIyBhbmQgX19jbGFuZ19taW5vcl9fIHNvIHRoZXkgY2Fubm90IGJl
  IHVzZWQgKGVhc2lseSkgdG8gZGV0ZWN0IHRoZQojIGFjdHVhbCBjbGFuZyByZWxlYXNlLiAgRm9y
  IGV4YW1wbGU6CiMKIyAiWW9zZW1pdGUgMTAuMTAueCAxNC54LnkgNi4zIChjbGFuZyAzLjYgYXMg
  Ni4xLzYwMi4wLjQ5KSIKIwojIG1lYW5zIHRoYXQgdGhlIFhjb2RlIDYuMyBwcm92aWRlZCB0aGUg
  Y2xhbmcgNi4zIGJ1dCBjYWxsZWQgaXQgNi4xCiMgKF9fY2xhbmdfbWFqb3JfXywgX19jbGFuZ19t
  aW5vcl9fKSBhbmQgaW4gYWRkaXRpb24gdGhlIHByZXByb2Nlc3NvcgojIHN5bWJvbCBfX2FwcGxl
  X2J1aWxkX3ZlcnNpb25fXyB3YXMgNjAyMDA0OS4KIwojIENvZGVuYW1lICAgICAgICBPUyAgICAg
  IEtlcm5lbCAgWGNvZGUKIwojIENoZWV0YWggICAgICAgICAxMC4wLnggIDEuMy4xCiMgUHVtYSAg
  ICAgICAgICAgIDEwLjEgICAgMS40LjEKIyAgICAgICAgICAgICAgICAgMTAuMS54ICA1LngueQoj
  IEphZ3VhciAgICAgICAgICAxMC4yLnggIDYueC55CiMgUGFudGhlciAgICAgICAgIDEwLjMueCAg
  Ny54LnkKIyBUaWdlciAgICAgICAgICAgMTAuNC54ICA4LngueSAgIDIuMCAgIChnY2M0IDQuMC4w
  KQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMi4yICAgKGdjYzQgNC4wLjEpCiMg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLjIuMSAoZ2NjIDMuMykKIyAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgIDIuNSA/CiMgTGVvcGFyZCAgICAgICAgIDEwLjUueCAg
  OS54LnkgICAzLjAgICAoZ2NjIDQuMC4xIGRlZmF1bHQpCiMgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAzLjEgICAoZ2NjIDQuMi4xKQojIFNub3cgTGVvcGFyZCAgICAxMC42LnggIDEw
  LngueSAgMy4yICAgKGxsdm0gZ2NjIDQuMiwgY2xhbmcgMi4zIGFzIDEuMCkKIyAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgIDMuMi4xIChjbGFuZyAxLjAuMSBhcyAxLjAuMS8yNCkKIyAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMuMi4yIChjbGFuZyAxLjAuMiBhcyAxLjAu
  Mi8zMikKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMuMi4zIChjbGFuZyAxLjUg
  YXMgMS41LzYwKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNC4wLjEgKGNsYW5n
  IDIuOSBhcyAyLjAvMTM4KQojIExpb24gICAgICAgICAgICAxMC43LnggIDExLngueSAgNC4xICAg
  KGxsdm0gZ2NjIDQuMi4xLCBjbGFuZyAzLjAgYXMgMi4xLzE2My43LjEpCiMgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICA0LjIgICAoY2xhbmcgMy4wIGFzIDMuMC8yMTEuMTAuMSkKIyAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQuMy4zIChjbGFuZyAzLjEgYXMgMy4xLzMx
  OC4wLjYxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNC40ICAgKGNsYW5nIDMu
  MSBhcyA0LjAvNDIxLjAuNTcpCiMgTW91bnRhaW4gTGlvbiAgIDEwLjgueCAgMTIueC55ICA0LjUg
  ICAoY2xhbmcgMy4xIGFzIDQuMS80MjEuMTEuNjUsIHJlYWwgZ2NjIHJlbW92ZWQsIHRoZXJlIGlz
  IGdjYyBidXQgaXQncyByZWFsbHkgY2xhbmcpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICA0LjYgICAoY2xhbmcgMy4yIGFzIDQuMi80MjUuMC4yNCkKIyAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgIDUuMCAgIChjbGFuZyAzLjMgYXMgNS4wLzUwMC4yLjc1KQojICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgNS4xICAgKGNsYW5nIDMuNCBhcyA1LjEvNTAzLjAu
  MzgpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1LjEuMSAoY2xhbmcgMy40IGFz
  IDUuMS81MDMuMC40MCkKIyBNYXZlcmlja3MgICAgICAgMTAuOS54ICAxMy54LnkgIDYuMC4xIChj
  bGFuZyAzLjUgYXMgNi4wLzYwMC4wLjUxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgNi4xICAgKGNsYW5nIDMuNSBhcyA2LjAvNjAwLjAuNTQpCiMgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICA2LjEuMSAoY2xhbmcgMy41IGFzIDYuMC82MDAuMC41NikKIyAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgIDYuMiAgIChjbGFuZyAzLjUgYXMgNi4wLzYwMC4wLjU3
  KQojIFlvc2VtaXRlICAgICAgICAxMC4xMC54IDE0LngueSAgNi4zICAgKGNsYW5nIDMuNiBhcyA2
  LjEvNjAyLjAuNDkpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2LjMuMSAoY2xh
  bmcgMy42IGFzIDYuMS82MDIuMC40OSkKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  IDYuMy4yIChjbGFuZyAzLjYgYXMgNi4xLzYwMi4wLjUzKQojIEVsIENhcGl0YW4gICAgICAxMC4x
  MS54IDE1LngueSAgNy4wICAgKGNsYW5nIDMuNyBhcyA3LjAvNzAwLjAuNzIpCiMgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICA3LjEgICAoY2xhbmcgMy43IGFzIDcuMC83MDAuMS43NikK
  IyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcuMiAgIChjbGFuZyAzLjcgYXMgNy4w
  LjIvNzAwLjEuODEpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3LjIuMSAoY2xh
  bmcgMy43IGFzIDcuMC4yLzcwMC4xLjgxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgNy4zICAgKGNsYW5nIDMuOCBhcyA3LjMuMC83MDMuMC4yOSkKIyBTaWVycmEgICAgICAgICAg
  MTAuMTIueCAxNi54LnkgIDguMC4wIChjbGFuZyAzLjggYXMgOC4wLzgwMC4wLjM4KQojCgojIFBy
  b2Nlc3NvcnMgU3VwcG9ydGVkCiMKIyBQb3dlclBDIChQUEMpOiAgICAgICAxMC4wLnggLSAxMC41
  LjggKGZpbmFsIDEwLjUueCkKIyBQb3dlclBDIHZpYSBSb3NldHRhOiAxMC40LjQgLSAxMC42Ljgg
  KGZpbmFsIDEwLjYueCkKIyBJQS0zMjogICAgICAgICAgICAgICAxMC40LjQgLSAxMC42LjggKHRo
  b3VnaCBzdGlsbCBzdXBwb3J0ZWQgb24geDg2LTY0KQojIHg4Ni02NDogICAgICAgICAgICAgIDEw
  LjQuNyAtIGN1cnJlbnQKCiMgTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VUIHNlbGVjdHMgdGhlIG1p
  bmltdW0gT1MgbGV2ZWwgd2Ugd2FudCB0byBzdXBwb3J0CiMKIyBJdCBpcyBuZWVkZWQgZm9yIE9T
  IHJlbGVhc2VzIGJlZm9yZSAxMC42LgojCiMgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xp
  YnJhcnkvbWFjL2RvY3VtZW50YXRpb24vRGV2ZWxvcGVyVG9vbHMvQ29uY2VwdHVhbC9jcm9zc19k
  ZXZlbG9wbWVudC9Db25maWd1cmluZy9jb25maWd1cmluZy5odG1sCiMKIyBJZiBpdCBpcyBzZXQs
  IHdlIGFsc28gcHJvcGFnYXRlIGl0cyB2YWx1ZSB0byBjY2ZsYWdzIGFuZCBsZGZsYWdzCiMgdXNp
  bmcgdGhlIC1tbWFjb3N4LXZlcnNpb24tbWluIGZsYWcuICBJZiBpdCBpcyBub3Qgc2V0LCB3ZSB1
  c2UKIyB0aGUgT1MgWCByZWxlYXNlIGFzIHRoZSBtaW4gdmFsdWUgZm9yIHRoZSBmbGFnLgoKIyBB
  ZGRzICItbW1hY29zeC12ZXJzaW9uLW1pbj0kMiIgdG8gIiQxIiB1bmxlc3MgaXQgYWxyZWFkeSBp
  cyB0aGVyZS4KYWRkX21hY29zeF92ZXJzaW9uX21pbiAoKSB7CiAgbG9jYWwgdgogIGV2YWwgInY9
  XCQkMSIKICBjYXNlICIgJHYgIiBpbgogICoiLW1tYWNvc3gtdmVyc2lvbi1taW4iKikKICAgICBl
  Y2hvICJOT1QgYWRkaW5nIC1tbWFjb3N4LXZlcnNpb24tbWluPSQyIHRvICQxICgkdikiID4mNAog
  ICAgIDs7CiAgKikgZWNobyAiQWRkaW5nIC1tbWFjb3N4LXZlcnNpb24tbWluPSQyIHRvICQxIiA+
  JjQKICAgICBldmFsICIkMT0nJHYgLW1tYWNvc3gtdmVyc2lvbi1taW49JDInIgogICAgIDs7CiAg
  ZXNhYwp9CgojIFBlcmwgYnVuZGxlcyBkbyBub3QgZXhwZWN0IHR3by1sZXZlbCBuYW1lc3BhY2Us
  IGFkZGVkIGluIERhcndpbiAxLjQuCiMgQnV0IHN0YXJ0aW5nIGZyb20gcGVybCA1LjguMS9EYXJ3
  aW4gNyB0aGUgZGVmYXVsdCBpcyB0aGUgdHdvLWxldmVsLgpjYXNlICIkb3N2ZXJzIiBpbiAgIyBO
  b3RlOiBvc3ZlcnMgaXMgdGhlIGtlcm5lbCB2ZXJzaW9uLCBub3QgdGhlIDEwLngKMS5bMC0zXS4q
  KSAjIE9TIFggMTAuMC54CiAgIGxkZGxmbGFncz0iJHtsZGZsYWdzfSAtYnVuZGxlIC11bmRlZmlu
  ZWQgc3VwcHJlc3MiCiAgIDs7CjEuKikgICAgICAgIyBPUyBYIDEwLjEKICAgbGRmbGFncz0iJHts
  ZGZsYWdzfSAtZmxhdF9uYW1lc3BhY2UiCiAgIGxkZGxmbGFncz0iJHtsZGZsYWdzfSAtYnVuZGxl
  IC11bmRlZmluZWQgc3VwcHJlc3MiCiAgIDs7ClsyLTZdLiopICAgIyBPUyBYIDEwLjEueCAtIDEw
  LjIueCAodGhvdWdoIFsyLTRdIG5ldmVyIGV4aXN0ZWQgcHVibGljbHkpCiAgIGxkZmxhZ3M9IiR7
  bGRmbGFnc30gLWZsYXRfbmFtZXNwYWNlIgogICBsZGRsZmxhZ3M9IiR7bGRmbGFnc30gLWJ1bmRs
  ZSAtdW5kZWZpbmVkIHN1cHByZXNzIgogICA7OwpbNy05XS4qKSAgICMgT1MgWCAxMC4zLnggLSAx
  MC41LngKICAgbGRkbGZsYWdzPSIke2xkZmxhZ3N9IC1idW5kbGUgLXVuZGVmaW5lZCBkeW5hbWlj
  X2xvb2t1cCIKICAgY2FzZSAiJGxkIiBpbgogICAgICAgKk1BQ09TWF9ERVBMT1lNRU5UX1RBUkdF
  VCopIDs7CiAgICAgICAqKSBsZD0iZW52IE1BQ09TWF9ERVBMT1lNRU5UX1RBUkdFVD0xMC4zICR7
  bGR9IiA7OwogICBlc2FjCiAgIDs7CiopICAgICAgICAjIE9TIFggMTAuNi54IC0gY3VycmVudAog
  ICAjIFRoZSBNQUNPU1hfREVQTE9ZTUVOVF9UQVJHRVQgaXMgbm90IG5lZWRlZCwKICAgIyBidXQg
  dGhlIC1tbWFjb3N4LXZlcnNpb24tbWluIG9wdGlvbiBpcyBhbHdheXMgdXNlZC4KCiAgICMgV2Ug
  bm93IHVzZSBNQUNPU1hfREVQTE9ZTUVOVF9UQVJHRVQsIGlmIHNldCwgYXMgYW4gb3ZlcnJpZGUg
  YnkKICAgIyBjYXB0dXJpbmcgaXRzIHZhbHVlIGFuZCBhZGRpbmcgaXQgdG8gdGhlIGZsYWdzLgog
  ICAgY2FzZSAiJE1BQ09TWF9ERVBMT1lNRU5UX1RBUkdFVCIgaW4KICAgIFsxLTldWzAtOV0uKikK
  ICAgICAgYWRkX21hY29zeF92ZXJzaW9uX21pbiBjY2ZsYWdzICRNQUNPU1hfREVQTE9ZTUVOVF9U
  QVJHRVQKICAgICAgYWRkX21hY29zeF92ZXJzaW9uX21pbiBsZGZsYWdzICRNQUNPU1hfREVQTE9Z
  TUVOVF9UQVJHRVQKICAgICAgOzsKICAgICcnKQogICAgICAjIEVtcHR5IE1BQ09TWF9ERVBMT1lN
  RU5UX1RBUkdFVCBpcyBva2F5LgogICAgICA7OwogICAgKikKICAgICAgY2F0IDw8RU9NID4mNAoK
  KioqIFVuZXhwZWN0ZWQgTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VUPSRNQUNPU1hfREVQTE9ZTUVO
  VF9UQVJHRVQKKioqCioqKiBQbGVhc2UgZWl0aGVyIHNldCBpdCB0byBhIHZhbGlkIG1hY09TIHZl
  cnNpb24gbnVtYmVyIChlLmcuLCAxMC4xNSkgb3IgdG8gZW1wdHkuCgpFT00KICAgICAgZXhpdCAx
  CiAgICAgIDs7CiAgICBlc2FjCgogICAgIyBLZWVwIHRoZSBwcm9kdmVycyBsZWFkaW5nIHdoaXRl
  c3BhY2UgKENvbmZpZ3VyZSBtYWdpYykuCiAgICAjIENhbm5vdCB1c2UgJG9zdmVycyBoZXJlIHNp
  bmNlIHRoYXQgaXMgdGhlIGtlcm5lbCB2ZXJzaW9uLgogICAgIyBzd192ZXJzIG91dHB1dCAgICAg
  ICAgICAgICAgICAgd2hhdCB3ZSB3YW50CiAgICAjICJQcm9kdWN0VmVyc2lvbjogICAgMTAuMTAu
  NSIgICAiMTAuMTAiCiAgICAjICJQcm9kdWN0VmVyc2lvbjogICAgMTAuMTEiICAgICAiMTAuMTEi
  CiAgICAgICAgcHJvZHZlcnM9YHN3X3ZlcnN8YXdrICcvXlByb2R1Y3RWZXJzaW9uOi97cHJpbnQg
  JDJ9J3xhd2sgLUYuICd7cHJpbnQgJDEiLiIkMn0nYAogICAgY2FzZSAiJHByb2R2ZXJzIiBpbgog
  ICAgWzEtOV1bMC05XS4qKQogICAgICBhZGRfbWFjb3N4X3ZlcnNpb25fbWluIGNjZmxhZ3MgJHBy
  b2R2ZXJzCiAgICAgIGFkZF9tYWNvc3hfdmVyc2lvbl9taW4gbGRmbGFncyAkcHJvZHZlcnMKICAg
  ICAgOzsKICAgICopCiAgICAgIGNhdCA8PEVPTSA+JjQKCioqKiBVbmV4cGVjdGVkIHByb2R1Y3Qg
  dmVyc2lvbiAkcHJvZHZlcnMuCioqKgoqKiogVHJ5IHJ1bm5pbmcgc3dfdmVycyBhbmQgc2VlIHdo
  YXQgaXRzIFByb2R1Y3RWZXJzaW9uIHNheXMuCgpFT00KICAgICAgZXhpdCAxCiAgICBlc2FjCgog
  ICAgZGFyd2luX21ham9yPSQoZWNobyAkb3N2ZXJzfGF3ayAtRi4gJ3twcmludCAkMX0nKQoKICAg
  ICMgbWFjT1MgMTAuMTIgKGRhcndpbiAxNi4wLjApIGRlcHJlY2F0ZWQgc3lzY2FsbCgpLgogICAg
  aWYgWyAiJGRhcndpbl9tYWpvciIgLWdlIDE2IF07IHRoZW4KICAgICAgICBkX3N5c2NhbGw9J3Vu
  ZGVmJwogICAgICAgICMgSWYgZGVwbG95aW5nIHRvIHByZS0xMC4xMiwgc3VwcHJlc3MgVGltZTo6
  SGlSZXMncyBkZXRlY3Rpb24gb2YgdGhlIHN5c3RlbSBjbG9ja19nZXR0aW1lKCkKICAgICAgICBj
  YXNlICIkTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VUIiBpbgogICAgICAgICAgMTAuWzYtOV18MTAu
  MTB8MTAuMTEpCiAgICAgICAgICBjY2ZsYWdzPSIkY2NmbGFncyAtV2Vycm9yPXBhcnRpYWwtYXZh
  aWxhYmlsaXR5IC1EX0RBUldJTl9GRUFUVVJFX0NMT0NLX0dFVFRJTUU9MCIKICAgICAgICAgIDs7
  CiAgICAgICAgKikKICAgICAgICAgIDs7CiAgICAgICAgZXNhYwogICAgZmkKCiAgIGxkZGxmbGFn
  cz0iJHtsZGZsYWdzfSAtYnVuZGxlIC11bmRlZmluZWQgZHluYW1pY19sb29rdXAiCiAgIDs7CmVz
  YWMKCmxkbGlicHRobmFtZT0nRFlMRF9MSUJSQVJZX1BBVEgnOwoKIyB1c2VzaHJwbGliPXRydWUg
  cmVzdWx0cyBpbiBtdWNoIHNsb3dlciBzdGFydHVwIHRpbWVzLgojICdmYWxzZScgaXMgdGhlIGRl
  ZmF1bHQgdmFsdWUuICBVc2UgQ29uZmlndXJlIC1EdXNlc2hycGxpYiB0byBvdmVycmlkZS4KCmNh
  dCA+IFVVL2FyY2huYW1lLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS9hcmNobmFtZS5j
  YnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUgCiMgYWZ0ZXIgaXQgaGFzIG90
  aGVyd2lzZSBkZXRlcm1pbmVkIHRoZSBhcmNoaXRlY3R1cmUgbmFtZS4KY2FzZSAiJGxkZmxhZ3Mi
  IGluCioiLWZsYXRfbmFtZXNwYWNlIiopIDs7ICMgQmFja3dhcmQgY29tcGF0LCBiZSBmbGF0Lgoj
  IElmIHdlIGFyZSB1c2luZyB0d28tbGV2ZWwgbmFtZXNwYWNlLCB3ZSB3aWxsIG11bmdlIHRoZSBh
  cmNobmFtZSB0byBzaG93IGl0LgoqKSBhcmNobmFtZT0iJHthcmNobmFtZX0tMmxldmVsIiA7Owpl
  c2FjCkVPQ0JVCgojIDY0LWJpdCBhZGRyZXNzaW5nIHN1cHBvcnQuIEN1cnJlbnRseSBzdHJpY3Rs
  eSBleHBlcmltZW50YWwuIERGRCAyMDA1LTA2LTA2CmNhc2UgIiR1c2U2NGJpdGFsbCIgaW4KJGRl
  ZmluZXx0cnVlfFt5WV0qKQpjYXNlICIkb3N2ZXJzIiBpbgpbMS03XS4qKQogICAgIGNhdCA8PEVP
  TSA+JjQKCgoKKioqIDY0LWJpdCBhZGRyZXNzaW5nIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE1hYyBP
  UyBYIHZlcnNpb25zCioqKiBiZWxvdyAxMC40ICgiVGlnZXIiKSBvciBEYXJ3aW4gdmVyc2lvbnMg
  YmVsb3cgOC4gUGxlYXNlIHRyeQoqKiogYWdhaW4gd2l0aG91dCAtRHVzZTY0Yml0YWxsLiAoLUR1
  c2U2NGJpdGludCB3aWxsIHdvcmssIGhvd2V2ZXIuKQoKRU9NCiAgICAgZXhpdCAxCiAgOzsKKikK
  ICAgIGNhc2UgIiRvc3ZlcnMiIGluCiAgICA4LiopCiAgICAgICAgY2F0IDw8RU9NID4mNAoKCgoq
  KiogUGVybCA2NC1iaXQgYWRkcmVzc2luZyBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCBmb3IgTWFj
  IE9TIFgKKioqIDEwLjQgKCJUaWdlciIpIGFuZCBEYXJ3aW4gdmVyc2lvbiA4LiBTeXN0ZW0gViBJ
  UEMgaXMgZGlzYWJsZWQKKioqIGR1ZSB0byBwcm9ibGVtcyB3aXRoIHRoZSA2NC1iaXQgdmVyc2lv
  bnMgb2YgbXNnY3RsLCBzZW1jdGwsCioqKiBhbmQgc2htY3RsLiBZb3Ugc2hvdWxkIGFsc28gZXhw
  ZWN0IHRoZSBmb2xsb3dpbmcgdGVzdCBmYWlsdXJlczoKKioqCioqKiAgICBleHQvdGhyZWFkcy1z
  aGFyZWQvdC93YWl0ICh0aHJlYWRlZCBidWlsZHMgb25seSkKCkVPTQoKICAgICAgICBbICIkZF9t
  c2djdGwiIF0gfHwgZF9tc2djdGw9J3VuZGVmJwogICAgICAgIFsgIiRkX3NlbWN0bCIgXSB8fCBk
  X3NlbWN0bD0ndW5kZWYnCiAgICAgICAgWyAiJGRfc2htY3RsIiBdIHx8IGRfc2htY3RsPSd1bmRl
  ZicKICAgIDs7CiAgICBlc2FjCgogICAgY2FzZSBgdW5hbWUgLXBgIGluIAogICAgcG93ZXJwYykg
  YXJjaD1wcGM2NCA7OwogICAgaTM4NikgYXJjaD14ODZfNjQgOzsKICAgICopIGNhdCA8PEVPTSA+
  JjQKCioqKiBEb24ndCByZWNvZ25pemUgcHJvY2Vzc29yLCBjYW4ndCBzcGVjaWZ5IDY0IGJpdCBj
  b21waWxhdGlvbi4KCkVPTQogICAgOzsKICAgIGVzYWMKICAgIGZvciB2YXIgaW4gY2NmbGFncyBj
  cHBmbGFncyBsZCBsZGZsYWdzCiAgICBkbwogICAgICAgZXZhbCAkdmFyPSJcJCR7dmFyfVwgLWFy
  Y2hcICRhcmNoIgogICAgZG9uZQoKICAgIDs7CmVzYWMKOzsKZXNhYwoKIyMKIyBTeXN0ZW0gbGli
  cmFyaWVzCiMjCgojIHZmb3JrIHdvcmtzCnVzZXZmb3JrPSd0cnVlJzsKCiMgbWFsbG9jIHdyYXAg
  d29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUn
  IDs7CmVzYWMKCiMgb3VyIG1hbGxvYyB3b3JrcyAoYnV0IGFsbG93IHVzZXJzIHRvIG92ZXJyaWRl
  KQpjYXNlICIkdXNlbXltYWxsb2MiIGluCicnKSB1c2VteW1hbGxvYz0nbicgOzsKZXNhYwojIEhv
  d2V2ZXIgc2JyaygpIHJldHVybnMgLTEgKGZhaWx1cmUpIHNvbWV3aGVyZSBpbiBsaWIvdW5pY29y
  ZS9ta3RhYmxlcyBhdAojIGFyb3VuZCAxNE0sIHNvIHdlIG5lZWQgdG8gdXNlIHN5c3RlbSBtYWxs
  b2MoKSBhcyBvdXIgc2JyaygpCiMKIyBzYnJrKCkgaW4gRGFyd2luIGRlcHJlY2F0ZWQgc2luY2Ug
  TWF2ZXJpY2tzICgxMC45KSwgaXQgc3RpbGwgZXhpc3RzCiMgaW4gWW9zZW1pdGUgKDEwLjEwKSBi
  dXQgdGhhdCBpcyBqdXN0IGFuIGVtdWxhdGlvbiwgYW5kIGZhaWxzIGZvcgojIGFsbG9jYXRpb25z
  IGJleW9uZCA0TUIuICBPbmUgc2hvdWxkIHVzZSBlLmcuIG1tYXAgaW5zdGVhZCAob3Igc3lzdGVt
  CiMgbWFsbG9jLCBhcyBzdWdnZXN0ZWQgYWJvdmUsIHRoYXQgYnV0IGlzIGtpbmQgb2YgYmFja3dh
  cmQpLgptYWxsb2NfY2ZsYWdzPSdjY2ZsYWdzPSItRFVTRV9QRVJMX1NCUksgLURQRVJMX1NCUktf
  VklBX01BTExPQyAkY2NmbGFncyInCgojIExvY2FsZXMgYXJlbid0IGZlZWxpbmcgd2VsbC4KTENf
  QUxMPUM7IGV4cG9ydCBMQ19BTEw7CkxBTkc9QzsgZXhwb3J0IExBTkc7CgojCiMgVGhlIGxpYnJh
  cmllcyBhcmUgbm90IHRocmVhZHNhZmUgYXMgb2YgT1MgWCAxMC4xLgojCiMgRml4IHdoZW4gQXBw
  bGUgZml4ZXMgbGliYy4KIwpjYXNlICIkdXNldGhyZWFkcyR1c2VpdGhyZWFkcyIgaW4KICAqZGVm
  aW5lKikKICBjYXNlICIkb3N2ZXJzIiBpbgogICAgWzEyMzQ1XS4qKSAgICAgY2F0IDw8RU9NID4m
  NAoKCgoqKiogV2FybmluZywgdGhlcmUgbWlnaHQgYmUgcHJvYmxlbXMgd2l0aCB5b3VyIGxpYnJh
  cmllcyB3aXRoCioqKiByZWdhcmRzIHRvIHRocmVhZGluZy4gIFRoZSB0ZXN0IGV4dC90aHJlYWRz
  L3QvbGliYy50IGlzIGxpa2VseQoqKiogdG8gZmFpbC4KCkVPTQogICAgOzsKICAgICopIHVzZXJl
  ZW50cmFudD0nZGVmaW5lJzs7CiAgZXNhYwoKZXNhYwoKIyBGaW5rIGNhbiBpbnN0YWxsIGEgR0RC
  TSBsaWJyYXJ5IHRoYXQgY2xhaW1zIHRvIGhhdmUgdGhlIE9EQk0gaW50ZXJmYWNlcwojIGJ1dCBQ
  ZXJsIGR5bmFsb2FkZXIgY2Fubm90IGZvciBzb21lIHJlYXNvbiB1c2UgdGhhdCBsaWJyYXJ5LiAg
  V2UgZG9uJ3QKIyByZWFsbHkgbmVlZCBPREJNX0ZJbGUsIHRob3VnaCwgc28gbGV0J3MganVzdCBo
  aW50IE9EQk0gYXdheS4KaV9kYm09dW5kZWY7CgojIENvbmZpZ3VyZSBkb2Vzbid0IGRldGVjdCBy
  YW5saWIgb24gVGlnZXIgcHJvcGVybHkuCiMgTmVpbFcgc2F5cyB0aGlzIHNob3VsZCBiZSBhY2Nl
  cHRhYmxlIG9uIGFsbCBkYXJ3aW4gdmVyc2lvbnMuCnJhbmxpYj0ncmFubGliJwoKIyBDYXRjaCBN
  YWNQb3J0cyBnY2MvZysrIGV4dHJhIGxpYmRpcgpjYXNlICIkKCRjYyAtdiAyPiYxKSIgaW4KKiJN
  YWNQb3J0cyBnY2MiKikgbG9jbGlicHRoPSIkbG9jbGlicHRoIC9vcHQvbG9jYWwvbGliL2xpYmdj
  YyIgOzsKZXNhYwoKIyMKIyBCdWlsZCBwcm9jZXNzCiMjCgojIENhc2UtaW5zZW5zaXRpdmUgZmls
  ZXN5c3RlbXMgZG9uJ3QgZ2V0IGFsb25nIHdpdGggTWFrZWZpbGUgYW5kCiMgbWFrZWZpbGUgaW4g
  dGhlIHNhbWUgcGxhY2UuICBTaW5jZSBEYXJ3aW4gdXNlcyBHTlUgbWFrZSwgdGhpcyBkb2RnZXMK
  IyB0aGUgcHJvYmxlbS4KZmlyc3RtYWtlZmlsZT1HTlVtYWtlZmlsZTsKCiMgUGFydHMgb2YgdGhl
  IHN5c3RlbSBjYWxsIHNldGVudigpLCBpbiBwYXJ0aWN1bGFyIGluIGFuIGF0Zm9yayBoYW5kbGVy
  LgojIFRoaXMgY2F1c2VzIHByb2JsZW1zIHdoZW4gdGhlIGNoaWxkIHRyaWVzIHRvIGNsZWFuIHVw
  IGVudmlyb25bXSwgc28KIyBsZXQgbGliYyBtYW5hZ2UgZW52aXJvbltdLgpjYXQgPj4gY29uZmln
  Lm92ZXIgPDwnRU9PVkVSJwppZiB0ZXN0ICIkZF91bnNldGVudiIgPSAiJGRlZmluZSIgLWEgXAog
  ICAgYGV4cHIgIiRjY2ZsYWdzIiA6ICcuKi1EUEVSTF9VU0VfU0FGRV9QVVRFTlYnYCAtZXEgMDsg
  dGhlbgogICAgICAgIGNjZmxhZ3M9IiRjY2ZsYWdzIC1EUEVSTF9VU0VfU0FGRV9QVVRFTlYiCmZp
  CkVPT1ZFUgoKIyBpZiB5b3UgdXNlIGEgbmV3ZXIgdG9vbGNoYWluIGJlZm9yZSBPUyBYIDEwLjkg
  dGhlc2UgZnVuY3Rpb25zIG1heSBiZQojIGluY29ycmVjdGx5IGRldGVjdGVkLCBzbyBkaXNhYmxl
  IHRoZW0KIyBPUyBYIDEwLjEwLnggY29ycmVzcG9uZHMgdG8ga2VybmVsIDE0LngKY2FzZSAiJG9z
  dmVycyIgaW4KICAgIFsxLTldLip8MVswLTNdLiopCglkX2xpbmthdD11bmRlZgoJZF9vcGVuYXQ9
  dW5kZWYKCWRfcmVuYW1lYXQ9dW5kZWYKCWRfdW5saW5rYXQ9dW5kZWYKCWRfZmNobW9kYXQ9dW5k
  ZWYKCTs7CmVzYWMKCiMgbWtvc3RlbXAoKSB3YXMgYXV0b2RldGVjdGVkIGFzIHByZXNlbnQgYnV0
  IGZvdW5kIHRvIG5vdCBiZSBsaW5rYWJsZQojIG9uIDE1LjYuMC4gIFVua25vd24gd2hhdCBvdGhl
  ciBPUyB2ZXJzaW9ucyBhcmUgYWZmZWN0ZWQuCmRfbWtvc3RlbXA9dW5kZWYK','dragonfly'=>'IyBoaW50cy9kcmFnb25mbHkuc2gKIwojIFRoaXMgZmlsZSBpcyBtb3N0bHkgY29waWVkIGZyb20g
  aGludHMvZnJlZWJzZC5zaCB3aXRoIHRoZSBPUyB2ZXJzaW9uCiMgaW5mb3JtYXRpb24gdGFrZW4g
  b3V0IGFuZCBvbmx5IHRoZSBGcmVlQlNELTQgaW5mb3JtYXRpb24gaW50YWN0LgojIFBsZWFzZSBj
  aGVjayB3aXRoIFRvZGQgV2lsbGV5IDx4dG9kZHhAZ21haWwuY29tPiBiZWZvcmUgbWFraW5nCiMg
  bW9kaWZpY2F0aW9ucyB0byB0aGlzIGZpbGUuIFNlZSBodHRwOi8vd3d3LmRyYWdvbmZseWJzZC5v
  cmcvCgpjYXNlICIkb3N2ZXJzIiBpbgoqKSAgdXNldmZvcms9J3RydWUnCiAgICBjYXNlICIkdXNl
  bXltYWxsb2MiIGluCgkiIikgdXNlbXltYWxsb2M9J24nCgkgICAgOzsKICAgIGVzYWMKICAgIGxp
  YnN3YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQgJ3MvIG1hbGxvYyAvIC8nYAogICAgOzsK
  ZXNhYwoKIyBEeW5hbWljIExvYWRpbmcgZmxhZ3MgaGF2ZSBub3QgY2hhbmdlZCBtdWNoLCBzbyB0
  aGV5IGFyZSBzZXBhcmF0ZWQKIyBvdXQgaGVyZSB0byBhdm9pZCBkdXBsaWNhdGluZyB0aGVtIGV2
  ZXJ5d2hlcmUuCmNhc2UgIiRvc3ZlcnMiIGluCiopICBvYmpmb3JtYXQ9YC91c3IvYmluL29iamZv
  cm1hdGAKICAgIGxpYnB0aD0iL3Vzci9saWIgL3Vzci9sb2NhbC9saWIiCiAgICBnbGlicHRoPSIv
  dXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIKICAgIGxkZmxhZ3M9Ii1XbCwtRSAiCiAgICBsZGRsZmxh
  Z3M9Ii1zaGFyZWQgIgogICAgY2NjZGxmbGFncz0nLURQSUMgLWZQSUMnCiAgICA7Owplc2FjCgpj
  YXNlICIkb3N2ZXJzIiBpbgoqKSAgY2NmbGFncz0iJHtjY2ZsYWdzfSAtREhBU19GUFNFVE1BU0sg
  LURIQVNfRkxPQVRJTkdQT0lOVF9IIgogICAgaWYgL3Vzci9iaW4vZmlsZSAtTCAvdXNyL2xpYi9s
  aWJjLnNvIHwgL3Vzci9iaW4vZ3JlcCAtdnEgIm5vdCBzdHJpcHBlZCIgOyB0aGVuCgl1c2VubT1m
  YWxzZQogICAgZmkKICAgIDs7CmVzYWMKCmNhdCA8PCdFT00nID4mNAoKU29tZSB1c2VycyBoYXZl
  IHJlcG9ydGVkIHRoYXQgQ29uZmlndXJlIGhhbHRzIHdoZW4gdGVzdGluZyBmb3IKdGhlIE9fTk9O
  QkxPQ0sgc3ltYm9sIHdpdGggYSBzeW50YXggZXJyb3IuICBUaGlzIGlzIGFwcGFyZW50bHkgYQpz
  aCBlcnJvci4gIFJlcnVubmluZyBDb25maWd1cmUgd2l0aCBrc2ggYXBwYXJlbnRseSBmaXhlcyB0
  aGUKcHJvYmxlbS4gIFRyeQogICAgICAga3NoIENvbmZpZ3VyZSBbeW91ciBvcHRpb25zXQoKRU9N
  CgojIEZyb206IEFudG9uIEJlcmV6aW4gPHRvYmV6QHBsYWIua3UuZGs+CiMgVG86IHBlcmw1LXBv
  cnRlcnNAcGVybC5vcmcKIyBTdWJqZWN0OiBbUEFUQ0ggNS4wMDVfNTRdIENvbmZpZ3VyZSAtIGhp
  bnRzL2ZyZWVic2Quc2ggc2lnbmFsIGhhbmRsZXIgdHlwZQojIERhdGU6IDMwIE5vdiAxOTk4IDE5
  OjQ2OjI0ICswMTAwCiMgTWVzc2FnZS1JRDogPDg2NHNyaGh2Y3YuZnNmQGxpb24ucGxhYi5rdS5k
  az4KCnNpZ25hbF90PSd2b2lkJwpkX3ZvaWRzaWc9J2RlZmluZScKCiMgVGhpcyBzY3JpcHQgVVUv
  dXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRl
  ciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMuCmNh
  dCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRl
  ZmluZXx0cnVlfFt5WV0qKQogICAgY2FzZSAiJG9zdmVycyIgaW4KICAgICopICBsZGZsYWdzPSIt
  cHRocmVhZCAkbGRmbGFncyIKCgkjIEJvdGggaW4gNC54IGFuZCA1LnggZ2V0aG9zdGJ5YWRkcl9y
  IGV4aXN0cyBidXQKCSMgaXQgaXMgIlRlbXBvcmFyeSBmdW5jdGlvbiwgbm90IHRocmVhZHNhZmUi
  Li4uCgkjIFByZXN1bWFibHkgZWFybGllciBpdCBkaWRuJ3QgZXZlbiBleGlzdC4KCWRfZ2V0aG9z
  dGJ5YWRkcl9yPSJ1bmRlZiIKCWRfZ2V0aG9zdGJ5YWRkcl9yX3Byb3RvPSIwIgoKCTs7CiAgICBl
  c2FjCmVzYWMKRU9DQlUKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAi
  IGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMKCnRlc3QgIiRvcHRpbWl6ZSIg
  fHwgb3B0aW1pemU9Jy1PMicKCiMgQ29uZmlndXJlIGNhbid0IGZpbmQgZGxvcGVuKCkgd2hlbiB1
  c2luZyBnKysKIyBsaW51eCwgZnJlZWJzZCBhbmQgc29sYXJpcyBoaW50cyBoYXZlIHRoZSBzYW1l
  IHdvcmthcm91bmQKY2FzZSAiJGNjIiBpbgoqZysrKikKICBkX2Rsb3Blbj0nZGVmaW5lJwogIDs7
  CmVzYWMK','freebsd'=>'IyBPcmlnaW5hbCBiYXNlZCBvbiBpbmZvIGZyb20KIyBDYXJsIE0uIEZvbmdoZWlzZXIgPGNtZkBp
  bnMuaW5mb25ldC5uZXQ+CiMgRGF0ZTogVGh1LCAyOCBKdWwgMTk5NCAxOToxNzowNSAtMDUwMCAo
  Q0RUKQojCiMgQWRkaXRpb25hbCAxLjEuNSBkZWZpbmVzIGZyb20gCiMgT2xsaXZpZXIgUm9iZXJ0
  IDxPbGxpdmllci5Sb2JlcnRAa2VsdGlhLmZybXVnLmZyLm5ldD4KIyBEYXRlOiBXZWQsIDI4IFNl
  cCAxOTk0IDAwOjM3OjQ2ICswMTAwIChNRVQpCiMKIyBBZGRpdGlvbmFsIDIuKiBkZWZpbmVzIGZy
  b20KIyBPbGxpdmllciBSb2JlcnQgPE9sbGl2aWVyLlJvYmVydEBrZWx0aWEuZnJtdWcuZnIubmV0
  PgojIERhdGU6IFNhdCwgOCBBcHIgMTk5NSAyMDo1Mzo0MSArMDIwMCAoTUVUIERTVCkKIwojIEFk
  ZGl0aW9uYWwgMi4wLjUgYW5kIDIuMSBkZWZpbmVkIGZyb20KIyBPbGxpdmllciBSb2JlcnQgPE9s
  bGl2aWVyLlJvYmVydEBrZWx0aWEuZnJtdWcuZnIubmV0PgojIERhdGU6IEZyaSwgMTIgTWF5IDE5
  OTUgMTQ6MzA6MzggKzAyMDAgKE1FVCBEU1QpCiMKIyBBZGRpdGlvbmFsIDIuMiBkZWZpbmVzIGZy
  b20KIyBNYXJrIE11cnJheSA8bWFya0Bncm9uZGFyLnphPgojIERhdGU6IFdlZCwgNiBOb3YgMTk5
  NiAwOTo0NDo1OCArMDIwMCAoTUVUKQojCiMgTW9kaWZpZWQgdG8gZW5zdXJlIHdlIHJlcGxhY2Ug
  LWxjIHdpdGggLWxjX3IsIGFuZAojIHRvIHB1dCBpbiBwbGFjZS1ob2xkZXJzIGZvciB2YXJpb3Vz
  IHNwZWNpZmljIGhpbnRzLgojIEFuZHkgRG91Z2hlcnR5IDxkb3VnaGVyYUBsYWZheWV0dGUuZWR1
  PgojIERhdGU6IFR1ZSBNYXIgMTAgMTY6MDc6MDAgRVNUIDE5OTgKIwojIFN1cHBvcnQgZm9yIEZy
  ZWVCU0QvRUxGCiMgT2xsaXZpZXIgUm9iZXJ0IDxyb2JlcnRvQGtlbHRpYS5mcmVlbml4LmZyPgoj
  IERhdGU6IFdlZCBTZXAgIDIgMTY6MjI6MTIgQ0VTVCAxOTk4CiMKIyBUaGUgdHdvIGZsYWdzICIt
  ZnBpYyAtRFBJQyIgYXJlIHVzZWQgdG8gaW5kaWNhdGUgYQojIHdpbGwtYmUtc2hhcmVkIG9iamVj
  dC4gIENvbmZpZ3VyZSB3aWxsIGd1ZXNzIHRoZSAtZnBpYywgKGFuZCB0aGUKIyAtRFBJQyBpcyBu
  b3QgdXNlZCBieSBwZXJsIHByb3BlcikgYnV0IHRoZSBmdWxsIGRlZmluZSBpcyBpbmNsdWRlZCB0
  byAKIyBiZSBjb25zaXN0ZW50IHdpdGggdGhlIEZyZWVCU0QgZ2VuZXJhbCBzaGFyZWQgbGlicyBi
  dWlsZGluZyBwcm9jZXNzLgojCiMgc2V0cmV1aWQgYW5kIGZyaWVuZHMgYXJlIGluaGVyZW50bHkg
  YnJva2VuIGluIGFsbCB2ZXJzaW9ucyBvZiBGcmVlQlNECiMgYmVmb3JlIDIuMS1jdXJyZW50IChi
  ZWZvcmUgYXBwcm94IGRhdGUgNC8xNS85NSkuIEl0IGlzIGZpeGVkIGluIDIuMC41CiMgYW5kIHdo
  YXQtd2lsbC1iZS0yLjEKIwoKY2FzZSAiJG9zdmVycyIgaW4KMC4qfDEuMCopCgl1c2VkbD0iJHVu
  ZGVmIgoJOzsKMS4xKikKCW1hbGxvY3R5cGU9J3ZvaWQgKicKCWdyb3Vwc3R5cGU9J2ludCcKCWRf
  c2V0cmVnaWQ9J3VuZGVmJwoJZF9zZXRyZXVpZD0ndW5kZWYnCglkX3NldHJnaWQ9J3VuZGVmJwoJ
  ZF9zZXRydWlkPSd1bmRlZicKCTs7CjIuMC1yZWxlYXNlKikKCWRfc2V0cmVnaWQ9J3VuZGVmJwoJ
  ZF9zZXRyZXVpZD0ndW5kZWYnCglkX3NldHJnaWQ9J3VuZGVmJwoJZF9zZXRydWlkPSd1bmRlZicK
  CTs7CiMKIyBUcnlpbmcgdG8gY292ZXIgMi4wLjUsIDIuMS1jdXJyZW50IGFuZCBmdXR1cmUgMi4x
  LzIuMgojIEl0IGRvZXMgbm90IGNvdmVydCBhbGwgMi4xLWN1cnJlbnQgdmVyc2lvbnMgYXMgdGhl
  IG91dHB1dCBvZiB1bmFtZQojIGNoYW5nZWQgYSBmZXcgdGltZXMuCiMKIyBFdmVuIHRob3VnaCBz
  ZXRldWlkL3NldGVnaWQgYXJlIGF2YWlsYWJsZSwgdGhleSd2ZSBiZWVuIHR1cm5lZCBvZmYKIyBi
  ZWNhdXNlIHBlcmwgaXNuJ3QgY29kZWQgd2l0aCBzYXZlZCBzZXRbdWddaWQgdmFyaWFibGVzIGlu
  IG1pbmQuCiMgSW4gYWRkaXRpb24sIGEgc21hbGwgcGF0Y2ggaXMgcmVxdWlyZWQgdG8gc3VpZHBl
  cmwgdG8gYXZvaWQgYSBzZWN1cml0eQojIHByb2JsZW0gd2l0aCBGcmVlQlNELgojCjIuMC41Knwy
  LjAtYnVpbHQqfDIuMSopCiAJdXNldmZvcms9J3RydWUnCgljYXNlICIkdXNlbXltYWxsb2MiIGlu
  CgkgICAgIiIpIHVzZW15bWFsbG9jPSduJwoJICAgICAgICA7OwoJZXNhYwoJZF9zZXRyZWdpZD0n
  ZGVmaW5lJwoJZF9zZXRyZXVpZD0nZGVmaW5lJwoJZF9zZXRlZ2lkPSd1bmRlZicKCWRfc2V0ZXVp
  ZD0ndW5kZWYnCgl0ZXN0IC1yIC4vYnJva2VuLWRiLm1zZyAmJiAuIC4vYnJva2VuLWRiLm1zZwoJ
  OzsKIwojIDIuMiBhbmQgYWJvdmUgaGF2ZSBwaGttYWxsb2MoMykuCiMgZG9uJ3QgdXNlIC1sbWFs
  bG9jIChtYXliZSB0aGVyZSdzIGFuIG9sZCBvbmUgZnJvbSAxLjEuNS4xIGZsb2F0aW5nIGFyb3Vu
  ZCkKMi4yKikKIAl1c2V2Zm9yaz0ndHJ1ZScKCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4KCSAgICAi
  IikgdXNlbXltYWxsb2M9J24nCgkgICAgICAgIDs7Cgllc2FjCglsaWJzd2FudGVkPWBlY2hvICRs
  aWJzd2FudGVkIHwgc2VkICdzLyBtYWxsb2MgLyAvJ2AKCWxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3
  YW50ZWQgfCBzZWQgJ3MvIGJpbmQgLyAvJ2AKCSMgaWNvbnYgZ29uZSBpbiBQZXJsIDUuOC4xLCBi
  dXQgaWYgc29tZW9uZSBjb21waWxlcyA1LjguMCBvciBlYXJsaWVyLgoJbGlic3dhbnRlZD1gZWNo
  byAkbGlic3dhbnRlZCB8IHNlZCAncy8gaWNvbnYgLyAvJ2AKCWRfc2V0cmVnaWQ9J2RlZmluZScK
  CWRfc2V0cmV1aWQ9J2RlZmluZScKCWRfc2V0ZWdpZD0nZGVmaW5lJwoJZF9zZXRldWlkPSdkZWZp
  bmUnCgkjIGRfZG9zdWlkPSdkZWZpbmUnICMgT2Jzb2xldGUuCgk7OwoqKQl1c2V2Zm9yaz0ndHJ1
  ZScKCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4KCSAgICAiIikgdXNlbXltYWxsb2M9J24nCgkgICAg
  ICAgIDs7Cgllc2FjCglsaWJzd2FudGVkPWBlY2hvICRsaWJzd2FudGVkIHwgc2VkICdzLyBtYWxs
  b2MgLyAvJ2AKCTs7CmVzYWMKCmNhc2UgIiRvc3ZlcnMiIGluCjEwLiopCgkjIGR0cmFjZSBvbiAx
  MC54IG5lZWRzIGxpYmVsZiBzeW1ib2xzLCBidXQgd2UgZG9uJ3Qga25vdyBpZiB0aGUKCSMgdXNl
  ciBpcyBnb2luZyB0byByZXF1ZXN0IHVzZWR0cmFjZSBhbmQgdGhlcmUncyBubyAuY2J1IGZvciB1
  c2VkdHJhY2UKCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIGVsZiIKCTs7CmVzYWMKCiMgRHluYW1p
  YyBMb2FkaW5nIGZsYWdzIGhhdmUgbm90IGNoYW5nZWQgbXVjaCwgc28gdGhleSBhcmUgc2VwYXJh
  dGVkCiMgb3V0IGhlcmUgdG8gYXZvaWQgZHVwbGljYXRpbmcgdGhlbSBldmVyeXdoZXJlLgpjYXNl
  ICIkb3N2ZXJzIiBpbgowLip8MS4wKikgOzsKCjEuKnwyLiopCgljY2NkbGZsYWdzPSctRFBJQyAt
  ZnBpYycKCWxkZGxmbGFncz0iLUJzaGFyZWFibGUgJGxkZGxmbGFncyIKCTs7CgozKnw0Knw1Knw2
  KikKICAgICAgICBvYmpmb3JtYXQ9YC91c3IvYmluL29iamZvcm1hdGAKICAgICAgICBpZiBbIHgk
  b2JqZm9ybWF0ID0geGFvdXQgXTsgdGhlbgogICAgICAgICAgICBpZiBbIC1lIC91c3IvbGliL2Fv
  dXQgXTsgdGhlbgogICAgICAgICAgICAgICAgbGlicHRoPSIvdXNyL2xpYi9hb3V0IC91c3IvbG9j
  YWwvbGliIC91c3IvbGliIgogICAgICAgICAgICAgICAgZ2xpYnB0aD0iL3Vzci9saWIvYW91dCAv
  dXNyL2xvY2FsL2xpYiAvdXNyL2xpYiIKICAgICAgICAgICAgZmkKICAgICAgICAgICAgbGRkbGZs
  YWdzPSctQnNoYXJlYWJsZScKICAgICAgICBlbHNlCiAgICAgICAgICAgIGxpYnB0aD0iL3Vzci9s
  aWIgL3Vzci9sb2NhbC9saWIiCiAgICAgICAgICAgIGdsaWJwdGg9Ii91c3IvbGliIC91c3IvbG9j
  YWwvbGliIgogICAgICAgICAgICBsZGZsYWdzPSItV2wsLUUgIgogICAgICAgICAgICBsZGRsZmxh
  Z3M9Ii1zaGFyZWQgIgogICAgICAgIGZpCiAgICAgICAgY2NjZGxmbGFncz0nLURQSUMgLWZQSUMn
  CiAgICAgICAgOzsKKikKICAgICAgIGxpYnB0aD0iL3Vzci9saWIgL3Vzci9sb2NhbC9saWIiCiAg
  ICAgICBnbGlicHRoPSIvdXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIKICAgICAgIGxkZmxhZ3M9Ii1X
  bCwtRSAiCiAgICAgICAgbGRkbGZsYWdzPSItc2hhcmVkICIKICAgICAgICBjY2NkbGZsYWdzPSct
  RFBJQyAtZlBJQycKICAgICAgIDs7CmVzYWMKCmNhc2UgIiRvc3ZlcnMiIGluCjAuKnwxLip8Mi4q
  fDMuKikgOzsKCiopCgljY2ZsYWdzPSIke2NjZmxhZ3N9IC1ESEFTX0ZQU0VUTUFTSyAtREhBU19G
  TE9BVElOR1BPSU5UX0giCglpZiAvdXNyL2Jpbi9maWxlIC1MIC91c3IvbGliL2xpYmMuc28gfCAv
  dXNyL2Jpbi9ncmVwIC12cSAibm90IHN0cmlwcGVkIiA7IHRoZW4KCSAgICB1c2VubT1mYWxzZQoJ
  ZmkKICAgICAgICA7Owplc2FjCgpjYXQgPDwnRU9NJyA+JjQKClNvbWUgdXNlcnMgaGF2ZSByZXBv
  cnRlZCB0aGF0IENvbmZpZ3VyZSBoYWx0cyB3aGVuIHRlc3RpbmcgZm9yCnRoZSBPX05PTkJMT0NL
  IHN5bWJvbCB3aXRoIGEgc3ludGF4IGVycm9yLiAgVGhpcyBpcyBhcHBhcmVudGx5IGEKc2ggZXJy
  b3IuICBSZXJ1bm5pbmcgQ29uZmlndXJlIHdpdGgga3NoIGFwcGFyZW50bHkgZml4ZXMgdGhlCnBy
  b2JsZW0uICBUcnkKCWtzaCBDb25maWd1cmUgW3lvdXIgb3B0aW9uc10KCkVPTQoKIyBGcm9tOiBB
  bnRvbiBCZXJlemluIDx0b2JlekBwbGFiLmt1LmRrPgojIFRvOiBwZXJsNS1wb3J0ZXJzQHBlcmwu
  b3JnCiMgU3ViamVjdDogW1BBVENIIDUuMDA1XzU0XSBDb25maWd1cmUgLSBoaW50cy9mcmVlYnNk
  LnNoIHNpZ25hbCBoYW5kbGVyIHR5cGUKIyBEYXRlOiAzMCBOb3YgMTk5OCAxOTo0NjoyNCArMDEw
  MAojIE1lc3NhZ2UtSUQ6IDw4NjRzcmhodmN2LmZzZkBsaW9uLnBsYWIua3UuZGs+CgpzaWduYWxf
  dD0ndm9pZCcKZF92b2lkc2lnPSdkZWZpbmUnCgojIHNldCBsaWJwZXJsLnNvLlguWCBmb3IgMi4y
  LlgKY2FzZSAiJG9zdmVycyIgaW4KMi4yKikKICAgICMgdW5mb3J0dW5hdGVseSB0aGlzIGNvZGUg
  Z2V0cyBleGVjdXRlZCBiZWZvcmUKICAgICMgdGhlIGVxdWl2YWxlbnQgaW4gdGhlIG1haW4gQ29u
  ZmlndXJlIHNvIHdlIGNvcHkgYSBsaXR0bGUKICAgICMgZnJvbSBDb25maWd1cmUgWFhYIENvbmZp
  Z3VyZSBzaG91bGQgYmUgZml4ZWQuCiAgICBpZiAkdGVzdCAtciAkc3JjL3BhdGNobGV2ZWwuaDt0
  aGVuCiAgICAgICBwYXRjaGxldmVsPWBhd2sgJy9kZWZpbmVbIAldK1BFUkxfVkVSU0lPTi8ge3By
  aW50ICQzfScgJHNyYy9wYXRjaGxldmVsLmhgCiAgICAgICBzdWJ2ZXJzaW9uPWBhd2sgJy9kZWZp
  bmVbIAldK1BFUkxfU1VCVkVSU0lPTi8ge3ByaW50ICQzfScgJHNyYy9wYXRjaGxldmVsLmhgCiAg
  ICBlbHNlCiAgICAgICBwYXRjaGxldmVsPTAKICAgICAgIHN1YnZlcnNpb249MAogICAgZmkKICAg
  IGxpYnBlcmw9ImxpYnBlcmwuc28uJHBhdGNobGV2ZWwuJHN1YnZlcnNpb24iCiAgICB1bnNldCBw
  YXRjaGxldmVsCiAgICB1bnNldCBzdWJ2ZXJzaW9uCiAgICA7Owplc2FjCgojIFRoaXMgc2NyaXB0
  IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlIAoj
  IGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgdGhyZWFk
  cy4KY2F0ID4gVVUvdXNldGhyZWFkcy5jYnUgPDwnRU9DQlUnCmNhc2UgIiR1c2V0aHJlYWRzIiBp
  bgokZGVmaW5lfHRydWV8W3lZXSopCiAgICAgICAgbGNfcj1gL3NiaW4vbGRjb25maWcgLXJ8Z3Jl
  cCAnOi1sY19yJ3xhd2sgJ3twcmludCAkTkZ9J3xzZWQgLW4gJyRwJ2AKICAgICAgICBjYXNlICIk
  b3N2ZXJzIiBpbiAgCgkwLip8MS4qfDIuMCp8Mi4xKikgICBjYXQgPDxFT00gPiY0CkkgZGlkIG5v
  dCBrbm93IHRoYXQgRnJlZUJTRCAkb3N2ZXJzIHN1cHBvcnRzIFBPU0lYIHRocmVhZHMuCgpGZWVs
  IGZyZWUgdG8gcmVwb3J0IHRoYXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL1BlcmwvcGVybDUvaXNz
  dWVzIG90aGVyd2lzZS4KRU9NCgkgICAgICBleGl0IDEKCSAgICAgIDs7CgogICAgICAgIDIuMi5b
  MC03XSopCiAgICAgICAgICAgICAgY2F0IDw8RU9NID4mNApQT1NJWCB0aHJlYWRzIGFyZSBub3Qg
  c3VwcG9ydGVkIHdlbGwgYnkgRnJlZUJTRCAkb3N2ZXJzLgoKUGxlYXNlIGNvbnNpZGVyIHVwZ3Jh
  ZGluZyB0byBhdCBsZWFzdCBGcmVlQlNEIDIuMi44LApvciBwcmVmZXJhYmx5IHRvIHRoZSBtb3N0
  IHJlY2VudCAtUkVMRUFTRSBvciAtU1RBQkxFCnZlcnNpb24gKHNlZSBodHRwOi8vd3d3LmZyZWVi
  c2Qub3JnL3JlbGVhc2VzLykuCgooV2hpbGUgMi4yLjcgZG9lcyBoYXZlIHB0aHJlYWRzLCBpdCBo
  YXMgc29tZSBwcm9ibGVtcwogd2l0aCB0aGUgY29tYmluYXRpb24gb2YgdGhyZWFkcyBhbmQgcGlw
  ZXMgYW5kIHRoZXJlZm9yZQogbWFueSBQZXJsIHRlc3RzIHdpbGwgZWl0aGVyIGhhbmcgb3IgZmFp
  bC4pCkVPTQoJICAgICAgZXhpdCAxCgkgICAgICA7OwoKCVszLTVdLiopCgkgICAgICBpZiBbICEg
  LXIgIiRsY19yIiBdOyB0aGVuCgkgICAgICBjYXQgPDxFT00gPiY0ClBPU0lYIHRocmVhZHMgc2hv
  dWxkIGJlIHN1cHBvcnRlZCBieSBGcmVlQlNEICRvc3ZlcnMgLS0KYnV0IHlvdXIgc3lzdGVtIGlz
  IG1pc3NpbmcgdGhlIHNoYXJlZCBsaWJjX3IuCigvc2Jpbi9sZGNvbmZpZyAtciBkb2Vzbid0IGZp
  bmQgYW55KS4KCkNvbnNpZGVyIHVzaW5nIHRoZSBsYXRlc3QgU1RBQkxFIHJlbGVhc2UuCkVPTQoJ
  CSBleGl0IDEKCSAgICAgIGZpCgkgICAgICAjIDUwMDAxNiBpcyB0aGUgZmlyc3Qgb3NyZWxkYXRl
  IGluIHdoaWNoIG9uZSBjb3VsZAoJICAgICAgIyBqdXN0IGxpbmsgYWdhaW5zdCBsaWJjX3Igd2l0
  aG91dCBkaXNwb3Npbmcgb2YgbGliYwoJICAgICAgIyBhdCB0aGUgc2FtZSB0aW1lLiAgNTAwMDE2
  IC4uLiB1cCB0byB3aGF0ZXZlciBpdCB3YXMKCSAgICAgICMgb24gdGhlIDMxc3Qgb2YgQXVndXN0
  IDIwMDMgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aCAtcHRocmVhZCwKCSAgICAgICMgYnV0IGl0IGlz
  IG5vdCBuZWNlc3NhcnkuCgoJICAgICAgIyBBbnRvbiBCZXJlemluIHNheXMgdGhhdCBwb3N0IDUw
  MHNvbWV0aGluZyB3ZSdyZSB3cm9uZyB0byBiZQoJICAgICAgIyB0byBiZSB1c2luZyAtbGNfciwg
  YW5kIHNob3VsZCBqdXN0IGJlIHVzaW5nIC1wdGhyZWFkIG9uIHRoZQoJICAgICAgIyBsaW5rZXIg
  bGluZS4KCSAgICAgICMgU28gcHJlc3VtYWJseSByZWFsbHkgd2Ugc2hvdWxkIGJlIGNoZWNraW5n
  IHRoYXQgJG9zdmVyIGlzIDUuKikKCSAgICAgICMgYW5kIHRoYXQgYC9zYmluL3N5c2N0bCAtbiBr
  ZXJuLm9zcmVsZGF0ZWAgLWdlIDUwMDAxNgoJICAgICAgIyBvciAtbHQgNTAwc29tZXRoaW5nIGFu
  ZCBvbmx5IGluIHRoYXQgcmFuZ2Ugbm90IGRvaW5nIHRoaXM6CgkgICAgICBsZGZsYWdzPSItcHRo
  cmVhZCAkbGRmbGFncyIKCgkgICAgICAjIEJvdGggaW4gNC54IGFuZCA1LnggZ2V0aG9zdGJ5YWRk
  cl9yIGV4aXN0cyBidXQKCSAgICAgICMgaXQgaXMgIlRlbXBvcmFyeSBmdW5jdGlvbiwgbm90IHRo
  cmVhZHNhZmUiLi4uCgkgICAgICAjIFByZXN1bWFibHkgZWFybGllciBpdCBkaWRuJ3QgZXZlbiBl
  eGlzdC4KCSAgICAgIGRfZ2V0aG9zdGJ5YWRkcl9yPSJ1bmRlZiIKCSAgICAgIGRfZ2V0aG9zdGJ5
  YWRkcl9yX3Byb3RvPSIwIgoJICAgICAgOzsKCgkqKQoJICAgICAgIyA3LnggZG9lc24ndCBpbnN0
  YWxsIGxpYmNfciBieSBkZWZhdWx0LCBhbmQgQ29uZmlndXJlCgkgICAgICAjIHdvdWxkIGZhaWwg
  aW4gdGhlIGNvZGUgZm9sbG93aW5nCgkgICAgICAjCgkgICAgICAjIGdldGhvc3RieWFkZHJfcigp
  IGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGltcGxlbWVudGVkIGluIDYueCsKCSAgICAgIGxkZmxhZ3M9
  Ii1wdGhyZWFkICRsZGZsYWdzIgoJICAgICAgOzsKCgllc2FjCgogICAgICAgIGNhc2UgIiRvc3Zl
  cnMiIGluCiAgICAgICAgWzEtNF0qKQoJICAgIHNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBz
  ZWQgLWUgJ3MvIGMgLyBjX3IgLydgCgkgICAgc2hpZnQKCSAgICBsaWJzd2FudGVkPSIkKiIKCSAg
  ICA7OwogICAgICAgICopCgkgICAgc2V0IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAn
  cy8gYyAvLydgCgkgICAgc2hpZnQKCSAgICBsaWJzd2FudGVkPSIkKiIKCSAgICA7OwoJZXNhYwoJ
  ICAgIAoJIyBDb25maWd1cmUgd2lsbCBwcm9iYWJseSBwaWNrIHRoZSB3cm9uZyBsaWJjIHRvIHVz
  ZSBmb3Igbm0gc2Nhbi4KCSMgVGhlIHNhZmVzdCBxdWljay1maXggaXMganVzdCB0byBub3QgdXNl
  IG5tIGF0IGFsbC4uLgoJdXNlbm09ZmFsc2UKCiAgICAgICAgY2FzZSAiJG9zdmVycyIgaW4KICAg
  ICAgICAyLjIuOCopCiAgICAgICAgICAgICMgLi4uIGJ1dCB0aGlzIGRvZXMgbm90IGFwcGx5IGZv
  ciAyLjIuOCAtIHdlIGtub3cgaXQncyBzYWZlCiAgICAgICAgICAgIGxpYmM9IiRsY19yIgogICAg
  ICAgICAgICB1c2VubT10cnVlCiAgICAgICAgICAgOzsKICAgICAgICBlc2FjCgogICAgICAgIHVu
  c2V0IGxjX3IKCgkjIEV2ZW4gd2l0aCB0aGUgbWFsbG9jIG11dGV4ZXMgdGhlIFBlcmwgbWFsbG9j
  IGRvZXMgbm90CgkjIHNlZW0gdG8gYmUgdGhyZWFkc2FmZSBpbiBGcmVlQlNEPwoJY2FzZSAiJHVz
  ZW15bWFsbG9jIiBpbgoJJycpIHVzZW15bWFsbG9jPW4gOzsKCWVzYWMKZXNhYwpFT0NCVQoKIyBt
  YWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4KJycpIHVzZW1hbGxvY3dy
  YXA9J2RlZmluZScgOzsKZXNhYwoKIyBYWFggVW5kZXIgRnJlZUJTRCA2LjAgKGFuZCBwcm9iYWJs
  eSBtb3N0IG90aGVyIHNpbWlsYXIgdmVyc2lvbnMpCiMgUGVybF9kaWUoTlVMTCkgZ2VuZXJhdGVz
  IGEgd2FybmluZzoKIyAgICBwcF9zeXMuYzo0OTE6IHdhcm5pbmc6IG51bGwgZm9ybWF0IHN0cmlu
  ZwojIENvbmZpZ3VyZSBzdXBwb3NlZGx5IHRlc3RzIGZvciB0aGlzLCBidXQgYXBwYXJlbnRseSB0
  aGUgdGVzdCBkb2Vzbid0CiMgd29yay4gIFZvbHVudGVlcnMgd2l0aCBGcmVlQlNEIGFyZSBuZWVk
  ZWQgdG8gaW1wcm92aW5nIHRoZSBDb25maWd1cmUgdGVzdC4KIyBNZWFud2hpbGUsIHRoZSBmb2xs
  b3dpbmcgd29ya2Fyb3VuZCBzaG91bGQgYmUgc2FmZSBvbiBhbGwgdmVyc2lvbnMKIyBvZiBGcmVl
  QlNELgpkX3ByaW50Zl9mb3JtYXRfbnVsbD0ndW5kZWYnCgojIFNlZSBbcGVybCAjMTI4ODY3XQoj
  IEludGVycHJldGluZzogaHR0cHM6Ly9idWdzLmZyZWVic2Qub3JnL2J1Z3ppbGxhL3Nob3dfYnVn
  LmNnaT9pZD0yMTE3NDMjYzEwCiMga2h3IHdvcmthcm91bmQgbm8gbG9uZ2VyIG5lZWRlZCBpbiB0
  aGUgZm9sbG93aW5nIEZSRUVCU0RfS0VSTkVMX1ZFUlNJT05zCiMxMjAwMDA0IGFuZCB1cAojMTEw
  MDUwMiA+PSB2ZXJzaW9uIDwgMTIwMDAwMAojMTAwMzUwNyA+PSB2ZXJzaW9uIDwgMTEwMDAwMAoj
  IEV4cGVyaW1lbnRzIGhhdmUgc2hvd24gdGhhdCB0aGlzIGRvZXNuJ3QgZnVsbHkgd29yay4gIFRo
  ZSBmaXJzdCBrZXJuZWwgd2Uga25vdyBpdCB3b3JrcyBpcyAxMjAwMDU2CgpGUkVFQlNEX0tFUk5F
  TF9WRVJTSU9OPWB1bmFtZSAtVWAKI2lmICBbICRGUkVFQlNEX0tFUk5FTF9WRVJTSU9OIC1sdCAx
  MDAzNTA3IF0gfHwgXAojICAgIFsgJEZSRUVCU0RfS0VSTkVMX1ZFUlNJT04gLWdlIDExMDAwMDAg
  XSAmJiBbICRGUkVFQlNEX0tFUk5FTF9WRVJTSU9OIC1sdCAxMTAwNTAyIF0gfHwgXAojICAgIFsg
  JEZSRUVCU0RfS0VSTkVMX1ZFUlNJT04gLWdlIDEyMDAwMDAgXSAmJiBbICRGUkVFQlNEX0tFUk5F
  TF9WRVJTSU9OIC1sdCAxMjAwMDA0IF0KaWYgIFsgJEZSRUVCU0RfS0VSTkVMX1ZFUlNJT04gLWx0
  IDEyMDAwNTYgXQp0aGVuCiAgICBkX3VzZWxvY2FsZT0ndW5kZWYnCmZpCgojIGh0dHBzOi8vZ2l0
  aHViLmNvbS9QZXJsL3Blcmw1L2lzc3Vlcy8xNTk4NAojIFJlcG9ydGVkIGluIDExLjAtQ1VSUkVO
  VCB3aXRoIGcrKy00LjguNToKIyBJZiB1c2luZyBnKyssIHRoZSBDb25maWd1cmUgc2NhbiBmb3Ig
  ZGxvcGVuKCkgZmFpbHMuCiMgRWFzaWVyIGZvciBub3cgdG8ganVzdCB0byBmb3JjaWJseSBzZXQg
  aXQuCmNhc2UgIiRjYyIgaW4KKmcrKyopCiAgZF9kbG9wZW49J2RlZmluZScKICA7Owplc2FjCgpj
  YXNlIGB1bmFtZSAtcGAgaW4KYXJtfG1pcHMpCiAgOzsKKikKICB0ZXN0ICIkb3B0aW1pemUiIHx8
  IG9wdGltaXplPSctTzInCiAgOzsKZXNhYwo=','gnu'=>'IyBoaW50cy9nbnUuc2gKIyBPcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5OiAgTWFyayBLZXR0ZW5p
  cyA8a2V0dGVuaXNAcGh5cy51dmEubmw+IERlYyAxMCAxOTk4CgojIGxpYm5zbCBpcyB1bnVzYWJs
  ZSBvbiB0aGUgSHVyZC4KIyBYWFggcmVtb3ZlIHRoaXMgb25jZSBTVU5SUEMgaXMgaW1wbGVtZW50
  ZWQuCnNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIGJzZCAvIC8nIC1lICdz
  LyBuc2wgLyAvJyAtZSAncy8gYyAvIHB0aHJlYWQgLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoK
  IyBEZWJpYW4gNC4wIHB1dHMgbmRibSBpbiB0aGUgLWxnZGJtX2NvbXBhdCBsaWJyYXJ5LgpsaWJz
  d2FudGVkPSIkbGlic3dhbnRlZCBnZGJtX2NvbXBhdCIKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2Fz
  ZSAiJHVzZW1hbGxvY3dyYXAiIGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMK
  CiMgVGhlIHN5c3RlbSBtYWxsb2MoKSBpcyBhYm91dCBhcyBmYXN0IGFuZCBhcyBmcnVnYWwgYXMg
  cGVybCdzLgojIFNpbmNlIHRoZSBzeXN0ZW0gbWFsbG9jKCkgaGFzIGJlZW4gdGhlIGRlZmF1bHQg
  c2luY2UgYXQgbGVhc3QKIyA1LjAwMSwgd2UgbWlnaHQgYXMgd2VsbCBsZWF2ZSBpdCB0aGF0IHdh
  eS4gIC0tQUQgIDEwIEphbiAyMDAyCmNhc2UgIiR1c2VteW1hbGxvYyIgaW4KJycpIHVzZW15bWFs
  bG9jPSduJyA7Owplc2FjCgpjYXNlICIkb3B0aW1pemUiIGluCicnKSBvcHRpbWl6ZT0nLU8yJyA7
  Owplc2FjCgpjYXNlICIkcGxpYnB0aCIgaW4KJycpIHBsaWJwdGg9YGdjYyAtcHJpbnQtc2VhcmNo
  LWRpcnMgfCBncmVwIGxpYnJhcmllcyB8CiAgICAgICAgY3V0IC1mMi0gLWQ9IHwgdHIgJzonICR0
  cm5sIHwgZ3JlcCAtdiAnZ2NjJyB8IHNlZCAtZSAnczovJDo6J2AKICAgIHNldCBYICRwbGlicHRo
  ICMgQ29sbGFwc2UgYWxsIGVudHJpZXMgb24gb25lIGxpbmUKICAgIHNoaWZ0CiAgICBwbGlicHRo
  PSIkKiIKICAgIDs7CmVzYWMKCmNhc2UgIiRsaWJjIiBpbgonJykKIyBJZiB5b3UgaGF2ZSBnbGli
  YywgdGhlbiByZXBvcnQgdGhlIHZlcnNpb24gZm9yIC4vbXljb25maWcgYnVnIHJlcG9ydGluZy4K
  IyAoQ29uZmlndXJlIGRvZXNuJ3QgbmVlZCB0byBrbm93IHRoZSBzcGVjaWZpYyB2ZXJzaW9uIHNp
  bmNlIGl0IGp1c3QgdXNlcwojIGdjYyB0byBsb2FkIHRoZSBsaWJyYXJ5IGZvciBhbGwgdGVzdHMu
  KQojIFdlIGRvbid0IHVzZSBfX0dMSUJDX18gYW5kICBfX0dMSUJDX01JTk9SX18gYmVjYXVzZSB0
  aGV5CiMgYXJlIGluc3VmZmljaWVudGx5IHByZWNpc2UgdG8gZGlzdGluZ3Vpc2ggdGhpbmdzIGxp
  a2UKIyBsaWJjLTIuMC42IGFuZCBsaWJjLTIuMC43LgogICAgZm9yIHAgaW4gJHBsaWJwdGgKICAg
  IGRvCiAgICAgICAgZm9yIHRyeWxpYiBpbiBsaWJjLnNvLjAuMyBsaWJjLnNvCiAgICAgICAgZG8K
  ICAgICAgICAgICAgaWYgJHRlc3QgLWUgJHAvJHRyeWxpYjsgdGhlbgogICAgICAgICAgICAgICAg
  bGliYz1gbHMgLWwgJHAvJHRyeWxpYiB8IGF3ayAne3ByaW50ICRORn0nYAogICAgICAgICAgICAg
  ICAgaWYgJHRlc3QgIlgkbGliYyIgIT0gWDsgdGhlbgogICAgICAgICAgICAgICAgICAgIGJyZWFr
  CiAgICAgICAgICAgICAgICBmaQogICAgICAgICAgICBmaQogICAgICAgIGRvbmUKICAgICAgICBp
  ZiAkdGVzdCAiWCRsaWJjIiAhPSBYOyB0aGVuCiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgZmkK
  ICAgIGRvbmUKICAgIDs7CmVzYWMKCiMgRmxhZ3MgbmVlZGVkIHRvIHByb2R1Y2Ugc2hhcmVkIGxp
  YnJhcmllcy4KbGRkbGZsYWdzPSctc2hhcmVkJwoKIyBGbGFncyBuZWVkZWQgYnkgcHJvZ3JhbXMg
  dGhhdCB1c2UgZHluYW1pYyBsaW5raW5nLgpjY2RsZmxhZ3M9Jy1XbCwtRScKCiMgVGhpcyBzY3Jp
  cHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUK
  IyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVh
  ZHMuCmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIg
  aW4KJGRlZmluZXx0cnVlfFt5WV0qKQogICAgICAgIGNjZmxhZ3M9Ii1EX1JFRU5UUkFOVCAtRF9H
  TlVfU09VUkNFICRjY2ZsYWdzIgogICAgICAgIGlmIGVjaG8gJGxpYnN3YW50ZWQgfCBncmVwIC12
  IHB0aHJlYWQgPi9kZXYvbnVsbAogICAgICAgIHRoZW4KICAgICAgICAgICAgc2V0IGBlY2hvIFgg
  IiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYyAvIHB0aHJlYWQgYyAvJ2AKICAgICAgICAgICAg
  c2hpZnQKICAgICAgICAgICAgbGlic3dhbnRlZD0iJCoiCiAgICAgICAgZmkKCgkjIFNvbWVob3cg
  YXQgbGVhc3QgaW4gRGViaWFuIDIuMiB0aGVzZSBtYW5hZ2UgdG8gZXNjYXBlCgkjIHRoZSAjZGVm
  aW5lIGZvcmVzdCBvZiA8ZmVhdHVyZXMuaD4gYW5kIDx0aW1lLmg+IHNvIHRoYXQKCSMgdGhlIGhh
  c3Byb3RvIG1hY3JvIG9mIENvbmZpZ3VyZSBkb2Vzbid0IHNlZSB0aGVzZSBwcm90b3MsCgkjIGV2
  ZW4gd2l0aCB0aGUgLURfR05VX1NPVVJDRS4KCglkX2FzY3RpbWVfcl9wcm90bz0iJGRlZmluZSIK
  CWRfY3J5cHRfcl9wcm90bz0iJGRlZmluZSIKCWRfY3RpbWVfcl9wcm90bz0iJGRlZmluZSIKCWRf
  Z210aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2xvY2FsdGltZV9yX3Byb3RvPSIkZGVmaW5lIgoJ
  ZF9yYW5kb21fcl9wcm90bz0iJGRlZmluZSIKCgk7Owplc2FjCkVPQ0JVCgpjYXQgPiBVVS91c2Vs
  YXJnZWZpbGVzLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2VsYXJnZWZpbGVzLmNi
  dSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0IGhhcyBwcm9t
  cHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbGFyZ2UgZmlsZXMuCmNhc2UgIiR1c2Vs
  YXJnZWZpbGVzIiBpbgonJ3wkZGVmaW5lfHRydWV8W3lZXSopCiMgS2VlcCB0aGlzIGluIHRoZSBs
  ZWZ0IG1hcmdpbi4KY2NmbGFnc191c2VsYXJnZWZpbGVzPSItRF9MQVJHRUZJTEVfU09VUkNFIC1E
  X0ZJTEVfT0ZGU0VUX0JJVFM9NjQiCgoJY2NmbGFncz0iJGNjZmxhZ3MgJGNjZmxhZ3NfdXNlbGFy
  Z2VmaWxlcyIKCTs7CmVzYWMKRU9DQlUKCiMgVGhlIGZvbGxvd2luZyByb3V0aW5lcyBhcmUgb25s
  eSBhdmFpbGFibGUgYXMgc3R1YnMgaW4gR05VIGxpYmMuCiMgWFhYIHJlbW92ZSB0aGlzIG9uY2Ug
  bWV0YWNvbmYgZGV0ZWN0cyB0aGUgR05VIGxpYmMgc3R1YnMuCmRfbXNnY3RsPSd1bmRlZicKZF9t
  c2dnZXQ9J3VuZGVmJwpkX21zZ3Jjdj0ndW5kZWYnCmRfbXNnc25kPSd1bmRlZicKZF9zZW1jdGw9
  J3VuZGVmJwpkX3NlbWdldD0ndW5kZWYnCmRfc2Vtb3A9J3VuZGVmJwpkX3NobWF0PSd1bmRlZicK
  ZF9zaG1jdGw9J3VuZGVmJwpkX3NobWR0PSd1bmRlZicKZF9zaG1nZXQ9J3VuZGVmJwo=','gnukfreebsd'=>'IyEgL2Jpbi9zaAoKIyBTdXBwb3J0IGZvciBEZWJpYW4gR05VL2tGcmVlQlNEIChrZnJlZWJzZC1n
  bnUpCiMgQSBwb3J0IG9mIHRoZSBEZWJpYW4gR05VIHN5c3RlbSB1c2luZyB0aGUgRnJlZUJTRCBr
  ZXJuZWwuCgouIC4vaGludHMvbGludXguc2gKCg==','hpux'=>'IyEvdXNyL2Jpbi9zaAoKIyMjIFNZU1RFTSBBUkNISVRFQ1RVUkUKCiMgRGV0ZXJtaW5lIHRoZSBh
  cmNoaXRlY3R1cmUgdHlwZSBvZiB0aGlzIHN5c3RlbS4KIyBLZWVwIGxlYWRpbmcgdGFiIGJlbG93
  IC0tIENvbmZpZ3VyZSBCbGFjayBNYWdpYyAtLSBSQU0sIDAzLzAyLzk3Cgl4eE9zUmV2TWFqb3I9
  YHVuYW1lIC1yIHwgc2VkIC1lICdzL15bXjAtOV0qLy8nIHwgY3V0IC1kLiAtZjFgOwoJeHhPc1Jl
  dk1pbm9yPWB1bmFtZSAtciB8IHNlZCAtZSAncy9eW14wLTldKi8vJyB8IGN1dCAtZC4gLWYyYDsK
  CXh4T3NSZXY9YGV4cHIgMTAwIFwqICR4eE9zUmV2TWFqb3IgKyAkeHhPc1Jldk1pbm9yYAppZiBb
  ICIkeHhPc1Jldk1ham9yIiAtZ2UgMTAgXTsgdGhlbgogICAgIyBUaGlzIHN5c3RlbSBpcyBydW5u
  aW5nID49IDEwLngKCiAgICAjIFRlc3RlZCBvbiAxMC4wMSBQQTEueCBhbmQgMTAuMjAgUEFbMTJd
  LnguCiAgICAjIElkZWE6IFNjYW4gL3Vzci9pbmNsdWRlL3N5cy91bmlzdGQuaCBmb3IgbWF0Y2hl
  cyB3aXRoCiAgICAjICIjZGVmaW5lIENQVV8qIGBnZXRjb25mICMgQ1BVX1ZFUlNJT05gIiB0byBk
  ZXRlcm1pbmUgQ1BVIHR5cGUuCiAgICAjIE5vdGUgdGhlIHRleHQgZm9sbG93aW5nICJDUFVfIiBp
  cyB1c2VkLCAqTk9UKiB0aGUgY29tbWVudC4KICAgICMKICAgICMgQVNTVU1QVElPTlM6IE51bWJl
  cnMgd2lsbCBjb250aW51ZSB0byBiZSBkZWZpbmVkIGluIGhleCAtLSBhbmQgaW4KICAgICMgL3Vz
  ci9pbmNsdWRlL3N5cy91bmlzdGQuaCAtLSBhbmQgdGhlIENQVV8qICNkZWZpbmVzIHdpbGwgYmUg
  a2VwdAogICAgIyB1cCB0byBkYXRlIHdpdGggbmV3IENQVS9PUyByZWxlYXNlcy4KICAgIHh4Y3B1
  PWBnZXRjb25mIENQVV9WRVJTSU9OYDsgIyBHZXQgdGhlIG51bWJlci4KICAgIHh4Y3B1PWBwcmlu
  dGYgJzB4JXgnICR4eGNwdWA7ICMgY29udmVydCB0byBoZXgKICAgIGFyY2huYW1lPWBzZWQgLW4g
  LWUgInMvXiNbWzpzcGFjZTpdXSpkZWZpbmVbWzpzcGFjZTpdXSpDUFVfLy9wIiAvdXNyL2luY2x1
  ZGUvc3lzL3VuaXN0ZC5oIHwKCXNlZCAtbiAtZSAicy9bWzpzcGFjZTpdXSokeHhjcHVbWzpzcGFj
  ZTpdXS4qLy9wIiB8CglzZWQgLWUgcy9fUklTQy8tUklTQy8gLWUgcy9IUF8vLyAtZSBzL18vLi8g
  LWUgInMvW1s6c3BhY2U6XV0qLy9nImA7CmVsc2UKICAgICMgVGhpcyBzeXN0ZW0gaXMgcnVubmlu
  ZyA8PSA5LngKICAgICMgVGVzdGVkIG9uIDkuMFs1N10gUEEgYW5kIFs3OF0uMCBNQzY4MFsyM10w
  LiAgSWRlYTogQWZ0ZXIgcmVtb3ZpbmcKICAgICMgTUM2ODg4WzEyXSBmcm9tIGNvbnRleHQgc3Ry
  aW5nLCB1c2UgZmlyc3QgQ1BVIGlkZW50aWZpZXIuCiAgICAjCiAgICAjIEFTU1VNUFRJT046IE9u
  bHkgQ1BVIGlkZW50aWZpZXJzIGNvbnRhaW4gbm8gbG93ZXJjYXNlIGxldHRlcnMuCiAgICBhcmNo
  bmFtZT1gZ2V0Y29udGV4dCB8IHRyICcgJyAnXDAxMicgfCBncmVwIC12ICdbYS16XScgfCBncmVw
  IC12IE1DNjg4IHwKCXNlZCAtZSAncy9IUC0vLycgLWUgMXFgOwogICAgc2VsZWN0dHlwZT0naW50
  IConCiAgICBmaQoKIyBGb3Igc29tZSBzdHJhbmdlIHJlYXNvbiwgdGhlIHUzMmFsaWduIHRlc3Qg
  ZnJvbSBDb25maWd1cmUgaGFuZ3MgaW4KIyBIUC1VWCAxMC4yMCBzaW5jZSB0aGUgRGVjZW1iZXIg
  MjAwMSBwYXRjaGVzLiAgU28gaGludCBpdCB0byBhdm9pZAojIHRoZSB0ZXN0LgppZiBbICIkeHhP
  c1Jldk1ham9yIiAtbGUgMTAgXTsgdGhlbgogICAgZF91MzJhbGlnbj0kZGVmaW5lCiAgICBmaQoK
  ZWNobyAiQXJjaG5hbWUgaXMgJGFyY2huYW1lIgoKIyBGaXggWFNsaWIgKENQQU4pIGNvbmZ1c2lv
  biB3aGVuIHJlLXVzaW5nIGEgcHJlZml4IGJ1dCBjaGFuZ2luZyBmcm9tIElMUDMyCiMgdG8gTFA2
  NCBidWlsZHMuICBUaGV5J3JlIE5PVCBiaW5hcnkgY29tcGF0aWJsZSwgc28gcXVpdCBjbGFpbWlu
  ZyB0aGV5IGFyZS4KYXJjaG5hbWU2ND1MUDY0CgoKIyMjIEhQLVVYIE9TIHNwZWNpZmljIGJlaGF2
  aW91cgoKIyAtbGRibSBpcyBvYnNvbGV0ZSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkCiMgLWxCU0Qg
  Y29udGFpbnMgQlNELXN0eWxlIGR1cGxpY2F0ZXMgb2YgU1ZSNCByb3V0aW5lcyB0aGF0IGNhdXNl
  IGNvbmZ1c2lvbgojIC1sUFcgaXMgb2Jzb2xldGUgYW5kIHNob3VsZCBub3QgYmUgdXNlZAojIFRo
  ZSBsaWJyYXJpZXMgY3J5cHQsIG1hbGxvYywgbmRpciwgYW5kIG5ldCBhcmUgZW1wdHkuCnNldCBg
  ZWNobyAiWCAkbGlic3dhbnRlZCAiIHwgc2VkIC1lICdzLyBsZCAvIC8nIC1lICdzLyBkYm0gLyAv
  JyAtZSAncy8gQlNEIC8gLycgLWUgJ3MvIFBXIC8gLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoK
  Y2M9JHtjYzotY2N9CmFyPS91c3IvYmluL2FyCSMgWWVzLCB0cnVseSBvdmVycmlkZS4gIFdlIGRv
  IG5vdCB3YW50IHRoZSBHTlUgYXIuCmZ1bGxfYXI9JGFyCSMgSSByZXBlYXQsIG5vIEdOVSBhci4g
  IGFycnIuCgpzZXQgYGVjaG8gIlggJGNjZmxhZ3MgIiB8IHNlZCAtZSAncy8gLUFbZWFdIC8gLycg
  LWUgJ3MvIC1EX0hQVVhfU09VUkNFIC8gLydgCnNoaWZ0CgljY19jcHBmbGFncz0iJCogLURfSFBV
  WF9TT1VSQ0UiCmNwcGZsYWdzPSItQWEgLURfX1NURENfRVhUX18gJGNjX2NwcGZsYWdzIgoKY2Fz
  ZSAiJHByZWZpeCIgaW4KICAgICIiKSBwcmVmaXg9Jy9vcHQvcGVybDUnIDs7CiAgICBlc2FjCgog
  ICAgZ251X2FzPW5vCiAgICBnbnVfbGQ9bm8KY2FzZSBgJGNjIC12IDI+JjFgIiIgaW4KICAgICpn
  Y2MqKSAgY2Npc2djYz0iJGRlZmluZSIKCSAgICBjY2ZsYWdzPSIkY2NfY3BwZmxhZ3MiCgkgICAg
  aWYgWyAiWCRnY2N2ZXJzaW9uIiA9ICJYIiBdOyB0aGVuCgkJIyBEb25lIHRvbyBsYXRlIGluIENv
  bmZpZ3VyZSBpZiBoaW50ZWQKCQlnY2N2ZXJzaW9uPWAkY2MgLWR1bXB2ZXJzaW9uYAoJCWZpCgkg
  ICAgY2FzZSAiJGdjY3ZlcnNpb24iIGluCgkJWzAxMl0qKSAjIEhQLVVYIGFuZCBnY2MtMi4qIGJy
  ZWFrIFVJTlQzMl9NQVggOi0oCgkJICAgIGNjZmxhZ3M9IiRjY2ZsYWdzIC1EVUlOVDMyX01BWF9C
  Uk9LRU4iCgkJICAgIDs7CgkJWzM0XSopICMgR0NDIChib3RoIDMyYml0IGFuZCA2NGJpdCkgd2ls
  bCBkZWZpbmUgX19TVERDX0VYVF9fCiAgICAgICAgICAgICAgICAgICAgICAgIyBieSBkZWZhdWx0
  IHdoZW4gdXNpbmcgR0NDIDMuMCBhbmQgbmV3ZXIgdmVyc2lvbnMgb2YKICAgICAgICAgICAgICAg
  ICAgICAgICAjIHRoZSBjb21waWxlci4KCQkgICBjcHBmbGFncz0iJGNjX2NwcGZsYWdzIgoJCSAg
  IDs7CgkJZXNhYwoJICAgIGNhc2UgImBnZXRjb25mIEtFUk5FTF9CSVRTIDI+L2Rldi9udWxsYCIg
  aW4KCQkqNjQqKQoJCSAgICBlY2hvICJtYWluKCl7fSI+dHJ5LmMKCQkgICAgY2FzZSAiJGdjY3Zl
  cnNpb24iIGluCgkJCVszNF0qKQoJCQkgICAgY2FzZSAiJGFyY2huYW1lIiBpbgogICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgUEEtUklTQyopCiAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgY2FzZSAiJGNjZmxhZ3MiIGluCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICotbXBhLXJpc2MqKSA7OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAqKSBjY2ZsYWdzPSIkY2NmbGFncyAtbXBhLXJpc2MtMi0wIiA7OwogICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2FjCiAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgOzsKCQkJCWVzYWMKCQkJICAgIDs7CgkJCSopICAjIGdjYyB3aXRoIGdhcyB3
  aWxsIG5vdCBhY2NlcHQgK0RBMi4wCgkJCSAgICBjYXNlICJgJGNjIC1jIC1XYSwrREEyLjAgdHJ5
  LmMgMj4mMWAiIGluCgkJCQkqIitEQTIuMCIqKQkJIyBnYXMKCQkJCSAgICBnbnVfYXM9eWVzCgkJ
  CQkgICAgOzsKCQkJCSopCQkJIyBIUGFzCgkJCQkgICAgY2NmbGFncz0iJGNjZmxhZ3MgLVdhLCtE
  QTIuMCIKCQkJCSAgICA7OwoJCQkJZXNhYwoJCQkgICAgOzsKCQkJZXNhYwoJCSAgICAjIGdjYyB3
  aXRoIGdsZCB3aWxsIG5vdCBhY2NlcHQgK3Zub2NvbXBhdHdhcm5pbmdzCgkJICAgIGNhc2UgImAk
  Y2MgLW8gdHJ5IC1XbCwrdm5vY29tcGF0d2FybmluZ3MgdHJ5LmMgMj4mMWAiIGluCgkJCSoiK3Zu
  b2NvbXBhdCIqKQkJIyBnbGQKCQkJICAgIGdudV9sZD15ZXMKCQkJICAgIDs7CgkJCSopCQkJIyBI
  UGxkCgkJCSAgIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgoJCQkgICAgICAgWzEyXSopCgkJCQkgICAj
  IFdoeSBub3QgMyBhcyB3ZWxsIGhlcmU/CgkJCQkgICAjIFNpbmNlIG5vdCByZWxldmFudCB0byBJ
  QTY0LCBub3QgY2hhbmdlZC4KCQkJCSAgIGxkZmxhZ3M9IiRsZGZsYWdzIC1XbCwrdm5vY29tcGF0
  d2FybmluZ3MiCgkJCQkgICBjY2ZsYWdzPSIkY2NmbGFncyAtV2wsK3Zub2NvbXBhdHdhcm5pbmdz
  IgoJCQkJICAgOzsKCQkJICAgICAgIGVzYWMKCQkJICAgIDs7CgkJCWVzYWMKCQkgICAgcm0gLWYg
  dHJ5LmMKCQkgICAgOzsKCQllc2FjCgkgICAgOzsKICAgICopICAgICAgY2Npc2djYz0nJwoJICAg
  ICMgV2hhdCBjYW5ub3QgYmUgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGggY2NhY2hlIGxpbmtzIDoo
  CgkgICAgY2NfZm91bmQ9IiIKCSAgICBmb3IgcCBpbiBgZWNobyAkUEFUSCB8IHRyIDogJyAnJ2Ag
  OyBkbwoJCXg9IiRwL2NjIgoJCWlmIFsgLWYgJHggXSAmJiBbIC14ICR4IF07IHRoZW4KCQkgICAg
  aWYgWyAtaCAkeCBdOyB0aGVuCgkJCWw9YGxzIC1sICR4IHwgc2VkICdzLC4qLT4gLCwnYAoJCQlj
  YXNlICRsIGluCgkJCSAgICAvKikgeD0kbAkJOzsKCQkJICAgICopICB4PSIkcC8kbCIJOzsKCQkJ
  ICAgIGVzYWMKCQkJZmkKCQkgICAgeD1gZWNobyAkeCB8IHNlZCAncywvXC4vLC8sZydgCgkJICAg
  IGNhc2UgJHggaW4KCQkJKmNjYWNoZSopIDs7CgkJCSopIFsgLXogIiRjY19mb3VuZCIgXSAmJiBj
  Y19mb3VuZD0keCA7OwoJCQllc2FjCgkJICAgIGZpCgkJZG9uZQoJICAgIFsgLXogIiRjY19mb3Vu
  ZCIgXSAmJiBjY19mb3VuZD1gd2hpY2ggY2NgCgkgICAgd2hhdCAkY2NfZm91bmQgPiY0CgkgICAg
  Y2N2ZXJzaW9uPWB3aGF0ICRjY19mb3VuZCB8IGF3ayAnL0NvbXBpbGVyL3twcmludCAkMn0vSXRh
  bml1bS97cHJpbnQgJDYsJDd9L2ZvciBJbnRlZ3JpdHkve3ByaW50ICQ2LCQ3fSdgCgkgICAgY2Fz
  ZSAiJGNjZmxhZ3MiIGluCiAgICAgICAgICAgICAgICItQWUgIiopIDs7CgkJKikgIGNjZmxhZ3M9
  Ii1BZSAtV3AsLUgxNTAwMDAgJGNjX2NwcGZsYWdzIgoJCSAgICAjICt2bm9jb21wYXR3YXJuaW5n
  cyBub3Qga25vd24gaW4gMTAuMTAgYW5kIG9sZGVyCgkJICAgIGlmIFsgJHh4T3NSZXYgLWdlIDEw
  MjAgXTsgdGhlbgoJCQljY2ZsYWdzPSIkY2NmbGFncyAtV2wsK3Zub2NvbXBhdHdhcm5pbmdzIgoJ
  CQlmaQoJCSAgICA7OwogICAgICAgICAgICAgICBlc2FjCgkgICAgIyBOZWVkZWQgYmVjYXVzZSBj
  cHAgZG9lcyBvbmx5IHN1cHBvcnQgLUFhIChub3QgLUFlKQoJICAgIGNwcGxhc3Q9Jy0nCgkgICAg
  Y3BwbWludXM9Jy0nCgkgICAgY3Bwc3RkaW49J2NjIC1FIC1BYSAtRF9fU1REQ19FWFRfXycKCSAg
  ICBjcHBydW49JGNwcHN0ZGluCiMJICAgIGNhc2UgIiRkX2Nhc3RpMzIiIGluCiMJCSIiKSBkX2Nh
  c3RpMzI9J3VuZGVmJyA7OwojCQllc2FjCgkgICAgOzsKICAgIGVzYWMKCiMgV2hlbiBIUC1VWCBy
  dW5zIGEgc2NyaXB0IHdpdGggIiMhIiwgaXQgc2V0cyBhcmd2WzBdIHRvIHRoZSBzY3JpcHQgbmFt
  ZS4KdG9rZV9jZmxhZ3M9J2NjZmxhZ3M9IiRjY2ZsYWdzIC1EQVJHX1pFUk9fSVNfU0NSSVBUIicK
  CiMjIyA2NCBCSVRORVNTCgojIFNvbWUgZ2NjIHZlcnNpb25zIGRvIG5hdGl2ZSA2NCBiaXQgbG9u
  ZyAoZS5nLiAyLjktaHBwYS0wMDAzMTAgYW5kIGdjYy0zLjApCiMgV2UgaGF2ZSB0byBmb3JjZSA2
  NGJpdG5lc3MgdG8gZ28gc2VhcmNoIHRoZSByaWdodCBsaWJyYXJpZXMKICAgIGdjY182NG5hdGl2
  ZT1ubwpjYXNlICIkY2Npc2djYyIgaW4KICAgICRkZWZpbmV8dHJ1ZXxbWXldKQoJZWNobyAnI2lu
  Y2x1ZGUgPHN0ZGlvLmg+XG5pbnQgbWFpbigpe2xvbmcgbDtwcmludGYoIiVkXFxuIixzaXplb2Yo
  bCkpO30nPnRyeS5jCgkkY2MgLW8gdHJ5ICRjY2ZsYWdzICRsZGZsYWdzIHRyeS5jCglpZiBbICJg
  dHJ5YCIgPSAiOCIgXTsgdGhlbgoJICAgIGNhc2UgIiR1c2U2NGJpdGFsbCIgaW4KCQkkZGVmaW5l
  fHRydWV8W1l5XSkgOzsKCQkqKSAgY2F0IDw8RU9NID4mNAoKKioqIFRoaXMgdmVyc2lvbiBvZiBn
  Y2MgdXNlcyA2NCBiaXQgbG9uZ3MuIC1EdXNlNjRiaXRhbGwgaXMKKioqIGltcGxpY2l0bHkgc2V0
  IHRvIGVuYWJsZSBjb250aW51YXRpb24KRU9NCgkJZXNhYwoJICAgIHVzZTY0Yml0YWxsPSRkZWZp
  bmUKCSAgICBnY2NfNjRuYXRpdmU9eWVzCgkgICAgZmkKCTs7CiAgICBlc2FjCgpjYXNlICIkdXNl
  NjRiaXRhbGwiIGluCiAgICAkZGVmaW5lfHRydWV8W3lZXSopIHVzZTY0Yml0aW50PSIkZGVmaW5l
  IiA7OwogICAgZXNhYwoKY2FzZSAiJHVzZW1vcmViaXRzIiBpbgogICAgJGRlZmluZXx0cnVlfFt5
  WV0qKSB1c2U2NGJpdGludD0iJGRlZmluZSI7IHVzZWxvbmdkb3VibGU9IiRkZWZpbmUiIDs7CiAg
  ICBlc2FjCgojIFRoZXJlIGlzIGEgd2VpcmQgcHJlLUM5OSBsb25nIGRvdWJsZSAoYSBzdHJ1Y3Qg
  b2YgZm91ciB1aW4zMl90KQojIGluIEhQLVVYIDEwLjIwIGJ1dCBiZXlvbmQgc3RydG9sZCgpIHRo
  ZXJlJ3Mgbm8gc3VwcG9ydCBmb3IgdGhlbQojIGZvciBleGFtcGxlIGluIDxtYXRoLmg+LgpjYXNl
  ICIkdXNlbG9uZ2RvdWJsZSIgaW4KICAgICRkZWZpbmV8dHJ1ZXxbeVldKikKCWlmIFsgIiR4eE9z
  UmV2TWFqb3IiIC1sdCAxMSBdOyB0aGVuCgkgICAgY2F0IDw8RU9NID4mNAoKKioqIHVzZWxvbmdk
  b3VibGUgKG9yIHVzZW1vcmViaXRzKSBpcyBub3Qgc3VwcG9ydGVkIG9uIEhQLVVYICR4eE9zUmV2
  TWFqb3IuCioqKiBZb3UgbmVlZCBhdCBsZWFzdCBIUC1VWCAxMS4wLgoqKiogQ2Fubm90IGNvbnRp
  bnVlLCBhYm9ydGluZy4KRU9NCgkgICAgZXhpdCAxCglmaQoJOzsKICAgIGVzYWMKCiMgQ29uZmln
  dXJlIGxvbmcgZG91YmxlIHNjYW4gd2lsbCBkZXRlY3QgdGhlIEhQLVVYIDEwLjIwICJsb25nIGRv
  dWJsZSIKIyAoYSBzdHJ1Y3Qgb2YgZm91ciB1aW4zMl90KSBhbmQgdGhpbmsgaXQgaXMgSUVFRSBx
  dWFkLiAgTWFrZSBpdCBub3Qgc28uCmlmIFsgIiR4eE9zUmV2TWFqb3IiIC1sdCAxMSBdOyB0aGVu
  CiAgICBkX2xvbmdkYmw9IiR1bmRlZiIKICAgIGxvbmdkYmxzaXplPTggIyBNYWtlIGl0IGRvdWJs
  ZS4KZmkKCmNhc2UgIiRhcmNobmFtZSIgaW4KICAgIElBNjQqKQoJIyBXaGlsZSBoZXJlLCBvdmVy
  cmlkZSBzbz1zbCBhdXRvLWRldGVjdGlvbgoJc289J3NvJwoJOzsKICAgIGVzYWMKCmNhc2UgIiR1
  c2U2NGJpdGFsbCIgaW4KICAgICRkZWZpbmV8dHJ1ZXxbWXldKQoKCWlmIFsgIiR4eE9zUmV2TWFq
  b3IiIC1sdCAxMSBdOyB0aGVuCgkgICAgY2F0IDw8RU9NID4mNAoKKioqIDY0LWJpdCBjb21waWxh
  dGlvbiBpcyBub3Qgc3VwcG9ydGVkIG9uIEhQLVVYICR4eE9zUmV2TWFqb3IuCioqKiBZb3UgbmVl
  ZCBhdCBsZWFzdCBIUC1VWCAxMS4wLgoqKiogQ2Fubm90IGNvbnRpbnVlLCBhYm9ydGluZy4KRU9N
  CgkgICAgZXhpdCAxCgkgICAgZmkKCglpZiBbICR4eE9zUmV2IC1lcSAxMTAwIF07IHRoZW4KCSAg
  ICAjIEhQLVVYIDExLjAwIHVzZXMgb25seSA0OCBiaXRzIGludGVybmFsbHkgaW4gNjRiaXQgbW9k
  ZSwgbm90IDY0CgkgICAgIyBmb3JjZSBtaW4vbWF4IHRvIDIqKjQ3LTEKCSAgICBzR01USU1FX21h
  eD0xNDA3Mzc0ODgzNTUzMjcKCSAgICBzR01USU1FX21pbj0tNjIxNjcyMTkyMDAKCSAgICBzTE9D
  QUxUSU1FX21heD0xNDA3Mzc0ODgzNTUzMjcKCSAgICBzTE9DQUxUSU1FX21pbj0tNjIxNjcyMTky
  MDAKCSAgICBmaQoKCSMgU2V0IGxpYmMgYW5kIHRoZSBsaWJyYXJ5IHBhdGhzCgljYXNlICIkYXJj
  aG5hbWUiIGluCgkgICAgUEEtUklTQyopCgkJbG9jbGlicHRoPSIkbG9jbGlicHRoIC9saWIvcGEy
  MF82NCIKCQlsaWJjPScvbGliL3BhMjBfNjQvbGliYy5zbCcgOzsKCSAgICBJQTY0KikKCQlsb2Ns
  aWJwdGg9IiRsb2NsaWJwdGggL3Vzci9saWIvaHB1eDY0IgoJCWxpYmM9Jy91c3IvbGliL2hwdXg2
  NC9saWJjLnNvJyA7OwoJICAgIGVzYWMKCWlmIFsgISAtZiAiJGxpYmMiIF07IHRoZW4KCSAgICBj
  YXQgPDxFT00gPiY0CgoqKiogWW91IGRvIG5vdCBzZWVtIHRvIGhhdmUgdGhlIDY0LWJpdCBsaWJj
  LgoqKiogSSBjYW5ub3QgZmluZCB0aGUgZmlsZSAkbGliYy4KKioqIENhbm5vdCBjb250aW51ZSwg
  YWJvcnRpbmcuCkVPTQoJICAgIGV4aXQgMQoJICAgIGZpCgoJY2FzZSAiJGNjaXNnY2MiIGluCgkg
  ICAgJGRlZmluZXx0cnVlfFtZeV0pCgkJIyBUaGUgZml4ZWQgc29ja2V0LmggaGVhZGVyIGZpbGUg
  aXMgd3JvbmcgZm9yIGdjYy00LngKCQkjIG9uIFBBLVJJU0MyLjBXLCBzbyBTb2NrX3R5cGVfdCBp
  cyBzaXplX3Qgd2hpY2ggaXMKCQkjIHVuc2lnbmVkIGxvbmcgd2hpY2ggaXMgNjRiaXQgd2hpY2gg
  aXMgdG9vIGxvbmcKCQljYXNlICIkZ2NjdmVyc2lvbiIgaW4KCQkgICAgNCopIGNhc2UgIiRhcmNo
  bmFtZSIgaW4KCQkJICAgIFBBLVJJU0MqKSBzb2Nrc2l6ZXR5cGU9aW50IDs7CgkJCSAgICBlc2Fj
  CgkJCTs7CgkJICAgIGVzYWMKCgkJIyBGb3IgdGhlIG1vbWVudCwgZG9uJ3QgY2FyZSB0aGF0IGl0
  IGFpbid0IHN1cHBvcnRlZCAoeWV0KQoJCSMgYnkgZ2NjICh1cCB0byBhbmQgaW5jbHVkaW5nIDIu
  OTUuMyksIGNhdXNlIGl0J2xsIGNyYXNoCgkJIyBhbnl3YXkuIEV4cGVjdCBhdXRvLWRldGVjdGlv
  biBvZiA2NC1iaXQgZW5hYmxlZCBnY2Mgb24KCQkjIEhQLVVYIHNvb24sIGluY2x1ZGluZyBhIHVz
  ZXItZnJpZW5kbHkgZXhpdAoJCWNhc2UgJGdjY182NG5hdGl2ZSBpbgoJCSAgICBubykgY2FzZSAi
  JGdjY3ZlcnNpb24iIGluCgkJCSAgICBbMTIzNF0qKQoJCQkJY2NmbGFncz0iJGNjZmxhZ3MgLW1s
  cDY0IgoJCQkJY2FzZSAiJGFyY2huYW1lIiBpbgoJCQkJICAgIFBBLVJJU0MqKQoJCQkJCWxkZmxh
  Z3M9IiRsZGZsYWdzIC1XbCwrREQ2NCIKCQkJCQk7OwoJCQkJICAgIElBNjQqKQoJCQkJCWxkZmxh
  Z3M9IiRsZGZsYWdzIC1tbHA2NCIKCQkJCQk7OwoJCQkJICAgIGVzYWMKCQkJCTs7CgkJCSAgICBl
  c2FjCgkJCTs7CgkJICAgIGVzYWMKCQk7OwoJICAgICopCgkJY2FzZSAiJHVzZTY0Yml0YWxsIiBp
  bgoJCSAgICAkZGVmaW5lfHRydWV8W3lZXSopCgkJCWNjZmxhZ3M9IiRjY2ZsYWdzICtERDY0IgoJ
  CQlsZGZsYWdzPSIkbGRmbGFncyArREQ2NCIKCQkJOzsKCQkgICAgZXNhYwoJCTs7CgkgICAgZXNh
  YwoKCSMgUmVzZXQgdGhlIGxpYnJhcnkgY2hlY2tlciB0byBtYWtlIHN1cmUgbGlicmFyaWVzCgkj
  IGFyZSB0aGUgcmlnaHQgdHlwZQoJIyAoTk9URTogb24gSUE2NCwgdGhpcyBkb2Vzbid0IHdvcmsg
  d2l0aCAuYSBmaWxlcy4pCglsaWJzY2hlY2s9J2Nhc2UgImAvdXNyL2Jpbi9maWxlICR4eHhgIiBp
  bgoJCSAgICAgICAqRUxGLTY0KnwqTFA2NCp8KlBBLVJJU0MyLjAqKSA7OwoJCSAgICAgICAqKSB4
  eHg9L25vLzY0LWJpdCR4eHggOzsKCQkgICAgICAgZXNhYycKCgk7OwoKICAgICopCSMgTm90IGlu
  IDY0LWJpdCBtb2RlCgoJY2FzZSAiJGFyY2huYW1lIiBpbgoJICAgIFBBLVJJU0MqKQoJCWxpYmM9
  Jy9saWIvbGliYy5zbCcgOzsKCSAgICBJQTY0KikKCQlsb2NsaWJwdGg9IiRsb2NsaWJwdGggL3Vz
  ci9saWIvaHB1eDMyIgoJCWxpYmM9Jy91c3IvbGliL2hwdXgzMi9saWJjLnNvJyA7OwoJICAgIGVz
  YWMKCTs7CiAgICBlc2FjCgojIEJ5IHNldHRpbmcgdGhlIGRlZmVycmVkIGZsYWcgYmVsb3csIHRo
  aXMgbWVhbnMgdGhhdCBpZiB5b3UgcnVuIHBlcmwKIyBvbiBhIHN5c3RlbSB0aGF0IGRvZXMgbm90
  IGhhdmUgdGhlIHJlcXVpcmVkIHNoYXJlZCBsaWJyYXJ5IHRoYXQgeW91CiMgbGlua2VkIGl0IHdp
  dGgsIGl0IHdpbGwgZGllIHdoZW4geW91IHRyeSB0byBhY2Nlc3MgYSBzeW1ib2wgaW4gdGhlCiMg
  KG1pc3NpbmcpIHNoYXJlZCBsaWJyYXJ5LiAgSWYgeW91IHdvdWxkIHJhdGhlciBrbm93IGF0IHBl
  cmwgc3RhcnR1cAojIHRpbWUgdGhhdCB5b3UgYXJlIG1pc3NpbmcgYW4gaW1wb3J0YW50IHNoYXJl
  ZCBsaWJyYXJ5LCBzd2l0Y2ggdGhlCiMgY29tbWVudHMgc28gdGhhdCBpbW1lZGlhdGUsIHJhdGhl
  ciB0aGFuIGRlZmVycmVkIGxvYWRpbmcgaXMKIyBwZXJmb3JtZWQuICBFdmVuIHdpdGggaW1tZWRp
  YXRlIGxvYWRpbmcsIHlvdSBjYW4gcG9zdHBvbmUgZXJyb3JzIGZvcgojIHVuZGVmaW5lZCAob3Ig
  bXVsdGlwbHkgZGVmaW5lZCkgcm91dGluZXMgdW50aWwgYWN0dWFsIGFjY2VzcyBieQojIGFkZGlu
  ZyB0aGUgIm5vbmZhdGFsIiBvcHRpb24uCiMgY2NkbGZsYWdzPSItV2wsLUUgLVdsLC1CLGltbWVk
  aWF0ZSAkY2NkbGZsYWdzIgojIGNjZGxmbGFncz0iLVdsLC1FIC1XbCwtQixpbW1lZGlhdGUsLUIs
  bm9uZmF0YWwgJGNjZGxmbGFncyIKaWYgWyAiJGdudV9sZCIgPSAieWVzIiBdOyB0aGVuCiAgICBj
  Y2RsZmxhZ3M9Ii1XbCwtRSAkY2NkbGZsYWdzIgplbHNlCiAgICBjY2RsZmxhZ3M9Ii1XbCwtRSAt
  V2wsLUIsZGVmZXJyZWQgJGNjZGxmbGFncyIKICAgIGZpCgoKIyMjIENPTVBJTEVSIFNQRUNJRklD
  UwoKIyMgTG9jYWwgcmVzdHJpY3Rpb25zIChwb2ludCB0byBSRUFETUUuaHB1eCB0byBsaWZ0IHRo
  ZXNlKQoKIyMgT3B0aW1pemF0aW9uIGxpbWl0cwpjYXQgPnRyeS5jIDw8RU9GCiNpbmNsdWRlIDxz
  dGRpby5oPgojaW5jbHVkZSA8c3lzL3Jlc291cmNlLmg+CgppbnQgbWFpbiAoKQp7CiAgICBzdHJ1
  Y3QgcmxpbWl0IHJsOwogICAgaW50IGkgPSBnZXRybGltaXQgKFJMSU1JVF9EQVRBLCAmcmwpOwog
  ICAgcHJpbnRmICgiJWRcbiIsIChpbnQpKHJsLnJsaW1fY3VyIC8gKDEwMjQgKiAxMDI0KSkpOwog
  ICAgfSAvKiBtYWluICovCkVPRgokY2MgLW8gdHJ5ICRjY2ZsYWdzICRsZGZsYWdzIHRyeS5jCglt
  YXhkc2l6PWB0cnlgCnJtIC1mIHRyeSB0cnkuYyBjb3JlCmlmIFsgJG1heGRzaXogLWxlIDY0IF07
  IHRoZW4KICAgICMgNjQgTWIgaXMgcHJvYmFibHkgbm90IGVub3VnaCB0byBvcHRpbWl6ZSB0b2tl
  LmMKICAgICMgYW5kIHJlZ2V4cC5jIHdpdGggLU8yCiAgICBjYXQgPDxFT00gPiY0CllvdXIga2Vy
  bmVsIGxpbWl0cyB0aGUgZGF0YSBzZWN0aW9uIG9mIHlvdXIgcHJvZ3JhbXMgdG8gJG1heGRzaXog
  TWIsCndoaWNoIGlzIChzYWRseSkgbm90IGVub3VnaCB0byBmdWxseSBvcHRpbWl6ZSBzb21lIHBh
  cnRzIG9mIHRoZQpwZXJsIGJpbmFyeS4gSSdsbCB0cnkgdG8gdXNlIGEgbG93ZXIgb3B0aW1pemF0
  aW9uIGxldmVsIGZvcgp0aG9zZSBwYXJ0cy4gSWYgeW91IGFyZSBhIHN5c2FkbWluLCBhbmQgeW91
  ICpkbyogd2FudCBmdWxsCm9wdGltaXphdGlvbiwgcmFpc2UgdGhlICdtYXhkc2l6JyBrZXJuZWwg
  Y29uZmlndXJhdGlvbiBwYXJhbWV0ZXIKdG8gYXQgbGVhc3QgMHgwODAwMDAwMCAoMTI4IE1iKSBh
  bmQgcmVidWlsZCB5b3VyIGtlcm5lbC4KRU9NCnJlZ2V4ZWNfY2ZsYWdzPScnCmRvb3BfY2ZsYWdz
  PScnCm9wX2NmbGFncz0nJwpvcG1pbmlfY2ZsYWdzPScnCnBlcmxtYWluX2NmbGFncz0nJwpwcF9w
  YWNrX2NmbGFncz0nJwogICAgZmkKCmNhc2UgIiRjY2lzZ2NjIiBpbgogICAgJGRlZmluZXx0cnVl
  fFtZeV0pCgoJY2FzZSAiJG9wdGltaXplIiBpbgoJICAgICIiKSAgICAgICAgICAgb3B0aW1pemU9
  Ii1nIC1PIiA7OwoJICAgICpPWzM0NTY3ODldKikgb3B0aW1pemU9YGVjaG8gIiRvcHRpbWl6ZSIg
  fCBzZWQgLWUgJ3MvT1szLTldL08yLydgIDs7CgkgICAgZXNhYwoJI2xkPSIkY2MiCglsZD0vdXNy
  L2Jpbi9sZAoJY2NjZGxmbGFncz0nLWZQSUMnCgkjbGRkbGZsYWdzPSctc2hhcmVkJwoJbGRkbGZs
  YWdzPSctYicKCWNhc2UgIiRvcHRpbWl6ZSIgaW4KCSAgICAqLWcqLU8qfCotTyotZyopCgkJIyBn
  Y2Mgd2l0aG91dCBnYXMgd2lsbCBub3QgYWNjZXB0IC1nCgkJZWNobyAibWFpbigpe30iPnRyeS5j
  CgkJY2FzZSAiYCRjYyAkb3B0aW1pemUgLWMgdHJ5LmMgMj4mMWAiIGluCgkJICAgICoiLWcgb3B0
  aW9uIGRpc2FibGVkIiopCgkJCXNldCBgZWNobyAiWCAkb3B0aW1pemUgIiB8IHNlZCAtZSAncy8g
  LWcgLyAvJ2AKCQkJc2hpZnQKCQkJb3B0aW1pemU9IiQqIgoJCQk7OwoJCSAgICBlc2FjCgkJOzsK
  CSAgICBlc2FjCglpZiBbICRtYXhkc2l6IC1sZSA2NCBdOyB0aGVuCgkgICAgY2FzZSAiJG9wdGlt
  aXplIiBpbgoJCSpPMiopCgkJICAgIG9wdD1gZWNobyAiJG9wdGltaXplIiB8IHNlZCAtZSAncy9P
  Mi9PMS8nYAoJCSAgICB0b2tlX2NmbGFncz0iJHRva2VfY2ZsYWdzO29wdGltaXplPVwiJG9wdFwi
  IgoJCSAgICByZWdleGVjX2NmbGFncz0ib3B0aW1pemU9XCIkb3B0XCIiCgkJICAgIDs7CgkJZXNh
  YwoJICAgIGZpCgk7OwoKICAgICopCgljYXNlICIkb3B0aW1pemUiIGluCgkgICAgIiIpICAgICAg
  ICAgICBvcHRpbWl6ZT0iK08yICtPbm9saW1pdCIgOzsKCSAgICAqT1szNDU2Nzg5XSopIG9wdGlt
  aXplPWBlY2hvICIkb3B0aW1pemUiIHwgc2VkIC1lICdzL09bMy05XS9PMi8nYCA7OwoJICAgIGVz
  YWMKCWNhc2UgIiRvcHRpbWl6ZSIgaW4KCSAgICAqLU8qfFwKCSAgICAqTzIqKSAgIG9wdD1gZWNo
  byAiJG9wdGltaXplIiB8IHNlZCAtZSAncy8tTy8rTzIvJyAtZSAncy9PMi9PMS8nIC1lICdzLyAq
  K09ub2xpbWl0Ly8nYAoJCSAgICA7OwoJICAgICopICAgICAgb3B0PSIkb3B0aW1pemUiCgkJICAg
  IDs7CgkgICAgZXNhYwoJY2FzZSAiJGFyY2huYW1lIiBpbgoJICAgIFBBLVJJU0MyLjApCgkJY2Fz
  ZSAiJGNjdmVyc2lvbiIgaW4KCQkgICAgQi4xMS4xMS4qKQoJCQkjIG9wbWluaS5jIGFuZCBvcC5j
  IHdpdGggK08yIG1ha2VzIHRoZSBjb21waWxlciBkaWUKCQkJIyBvZiBpbnRlcm5hbCBlcnJvciwg
  Zm9yIHBlcmxtYWluLmMgb25seSArTzAgKG5vIG9wdCkKICAgICAgICAgICAgICAgICAgICAgICAg
  IyB3b3Jrcy4gRGlzYWJsZSArT3ggZm9yIHBwX3BhY2ssIGFzIHRoZSBvcHRpbWl6ZXIKICAgICAg
  ICAgICAgICAgICAgICAgICAgIyBjYXVzZXMgdGhpcyB1bml0IHRvIGZhaWwgKG5vdCBhIGxpbWl0
  IGlzc3VlKQoJCQljYXNlICIkb3B0aW1pemUiIGluCgkJCSpPWzEyXSopCgkJCSAgICBvcHQ9YGVj
  aG8gIiRvcHRpbWl6ZSIgfCBzZWQgLWUgJ3MvTzIvTzEvJyAtZSAncy8gKitPbm9saW1pdC8vJ2AK
  CQkJICAgIG9wbWluaV9jZmxhZ3M9Im9wdGltaXplPVwiJG9wdFwiIgoJCQkgICAgb3BfY2ZsYWdz
  PSJvcHRpbWl6ZT1cIiRvcHRcIiIKCQkJICAgIHBlcmxtYWluX2NmbGFncz0ib3B0aW1pemU9XCJc
  IiIKCQkJICAgIHBwX3BhY2tfY2ZsYWdzPSJvcHRpbWl6ZT1cIlwiIgoJCQkgICAgOzsKCQkJZXNh
  YwoJCSAgICBlc2FjCgkJOzsKCSAgICBJQTY0KikKCQljYXNlICIkY2N2ZXJzaW9uIiBpbgoJCSAg
  ICBCMzkxMEIqQS4wNi4wWzEyMzQ1XSkKCQkJIyA+IGNjIC0tdmVyc2lvbgoJCQkjIGNjOiBIUCBh
  QysrL0FOU0kgQyBCMzkxMEIgQS4wNi4wNSBbSnVsIDI1IDIwMDVdCgkJCSMgSGFzIG9wdGltaXpp
  bmcgcHJvYmxlbXMgd2l0aCAtTzIgYW5kIHVwIGZvciBib3RoCgkJCSMgbWFpbnQgKDUuOC44Kykg
  YW5kIGJsZWFkICg1LjkuMyspCgkJCSMgLU8xLytPMSBwYXNzZWQgYWxsIHRlc3RzIChtKScwNSBb
  IDEwIEphbiAyMDA1IF0KCQkJb3B0aW1pemU9IiRvcHQiCQkJOzsKCQkJQjM5MTBCKkEuMDYuMTUp
  CgkJCSMgPiBjYyAtLXZlcnNpb24KCQkJIyBjYzogSFAgQy9hQysrIEIzOTEwQiBBLjA2LjE1IFtN
  YXkgMTYgMjAwN10KCQkJIyBIYXMgb3B0aW1pemluZyBwcm9ibGVtcyB3aXRoICtPMiBmb3IgYmxl
  YWQgKDUuMTcuNCksCgkJCSMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9QZXJsL3Blcmw1L2lzc3Vl
  cy8xMTc0OC4KCQkJIwoJCQkjICtPMiArT25vbGltaXQgK09ub3Byb2NlbGltICArT3N0b3JlX29y
  ZGVyaW5nIFwKCQkJIyArT25vbGliY2FsbHM9c3RyY21wCgkJCSMgcGFzc2VzIGFsbCB0ZXN0cyAo
  d2l0aC93aXRob3V0IC1EREVCVUdHSU5HKSBbTm92IDE3IDIwMTFdCgkJCWNhc2UgIiRvcHRpbWl6
  ZSIgaW4KCQkJICAgICpPMiopIG9wdGltaXplPSIkb3B0aW1pemUgK09ub3Byb2NlbGltICtPc3Rv
  cmVfb3JkZXJpbmcgK09ub2xpYmNhbGxzPXN0cmNtcCIgOzsKCQkJICAgIGVzYWMKCQkJOzsKCQkg
  ICAgKikgIGRvb3BfY2ZsYWdzPSJvcHRpbWl6ZT1cIiRvcHRcIiIKCQkJb3BfY2ZsYWdzPSJvcHRp
  bWl6ZT1cIiRvcHRcIiIKCQkJI29wdD1gZWNobyAiJG9wdGltaXplIiB8IHNlZCAtZSAncy9PMS9P
  MC8nYAoJCQlnbG9iYWxzX2NmbGFncz0ib3B0aW1pemU9XCIkb3B0XCIiCTs7CgkJICAgIGVzYWMK
  CQk7OwoJICAgIGVzYWMKCWlmIFsgJG1heGRzaXogLWxlIDY0IF07IHRoZW4KCSAgICB0b2tlX2Nm
  bGFncz0iJHRva2VfY2ZsYWdzO29wdGltaXplPVwiJG9wdFwiIgoJICAgIHJlZ2V4ZWNfY2ZsYWdz
  PSJvcHRpbWl6ZT1cIiRvcHRcIiIKCSAgICBmaQoJbGQ9L3Vzci9iaW4vbGQKCWNjY2RsZmxhZ3M9
  JytaJwoJbGRkbGZsYWdzPSctYiArdm5vY29tcGF0d2FybmluZ3MnCgk7OwogICAgZXNhYwoKIyMg
  TEFSR0VGSUxFUwppZiBbICR4eE9zUmV2IC1sdCAxMDIwIF07IHRoZW4KICAgIHVzZWxhcmdlZmls
  ZXM9IiR1bmRlZiIKICAgIGZpCgojY2FzZSAiJHVzZWxhcmdlZmlsZXMtJGNjaXNnY2MiIGluCiMg
  ICAgIiRkZWZpbmUtJGRlZmluZSJ8Jy1kZWZpbmUnKQojCWNhdCA8PEVPTSA+JjQKIwojKioqIEkn
  bSBpZ25vcmluZyBsYXJnZSBmaWxlcyBmb3IgdGhpcyBidWlsZCBiZWNhdXNlCiMqKiogSSBkb24n
  dCBrbm93IGhvdyB0byBkbyB1c2UgbGFyZ2UgZmlsZXMgaW4gSFAtVVggdXNpbmcgZ2NjLgojCiNF
  T00KIwl1c2VsYXJnZWZpbGVzPSIkdW5kZWYiCiMJOzsKIyAgICBlc2FjCgojIE9uY2Ugd2UgaGF2
  ZSB0aGUgY29tcGlsZXIgZmxhZ3MgZGVmaW5lZCwgQ29uZmlndXJlIHdpbGwKIyBleGVjdXRlIHRo
  ZSBmb2xsb3dpbmcgY2FsbC1iYWNrIHNjcmlwdC4gU2VlIGhpbnRzL1JFQURNRS5oaW50cwojIGZv
  ciBkZXRhaWxzLgpjYXQgPiBVVS9jYy5jYnUgPDwnRU9DQlUnCiMgVGhpcyBzY3JpcHQgVVUvY2Mu
  Y2J1IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlIGFmdGVyIGl0CiMgaGFzIHBy
  b21wdGVkIHRoZSB1c2VyIGZvciB0aGUgQyBjb21waWxlciB0byB1c2UuCgojIENvbXBpbGUgYW5k
  IHJ1biB0aGUgYSB0ZXN0IGNhc2UgdG8gc2VlIGlmIGEgY2VydGFpbiBnY2MgYnVnIGlzCiMgcHJl
  c2VudC4gSWYgc28sIGxvd2VyIHRoZSBvcHRpbWl6YXRpb24gbGV2ZWwgd2hlbiBjb21waWxpbmcK
  IyBwcF9wYWNrLmMuICBUaGlzIHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiB1bnBhY2suCgppZiB0ZXN0
  IC16ICIkY2Npc2djYyIgLWEgLXogIiRnY2N2ZXJzaW9uIjsgdGhlbgogICAgOiBubyB0ZXN0cyBu
  ZWVkZWQgZm9yIEhQYwplbHNlCiAgICBlY2hvICIgIgogICAgZWNobyAiVGVzdGluZyBmb3IgYSBj
  ZXJ0YWluIGdjYyBidWcgaXMgZml4ZWQgaW4geW91ciBjb21waWxlci4uLiIKCiAgICAjIFRyeSBj
  b21waWxpbmcgdGhlIHRlc3QgY2FzZS4KICAgIGlmICRjYyAtbyB0MDAxIC1PICRjY2ZsYWdzICRs
  ZGZsYWdzIC1sbSAuLi9oaW50cy90MDAxLmM7IHRoZW4KICAgICAgIGdjY2J1Zz1gJHJ1biAuL3Qw
  MDFgCiAgICAgICBjYXNlICIkZ2NjYnVnIiBpbgogICAgICAgICAgICpmYWlscyopCiAgICAgICAg
  ICAgICAgIGNhdCA+JjQgPDxFT0YKVGhpcyBDIGNvbXBpbGVyICgkZ2NjdmVyc2lvbikgaXMga25v
  d24gdG8gaGF2ZSBvcHRpbWl6ZXIKcHJvYmxlbXMgd2hlbiBjb21waWxpbmcgcHBfcGFjay5jLgoK
  RGlzYWJsaW5nIG9wdGltaXphdGlvbiBmb3IgcHBfcGFjay5jLgpFT0YKICAgICAgICAgICAgICAg
  Y2FzZSAiJHBwX3BhY2tfY2ZsYWdzIiBpbgogICAgICAgICAgICAgICAgICAgJycpIHBwX3BhY2tf
  Y2ZsYWdzPSdvcHRpbWl6ZT0nCiAgICAgICAgICAgICAgICAgICAgICAgZWNobyAicHBfcGFja19j
  ZmxhZ3M9J29wdGltaXplPVwiXCInIiA+PiBjb25maWcuc2ggOzsKICAgICAgICAgICAgICAgICAg
  ICopICBlY2hvICJZb3Ugc3BlY2lmaWVkIHBwX3BhY2tfY2ZsYWdzIHlvdXJzZWxmLCBzbyB3ZSds
  bCBnbyB3aXRoIHlvdXIgdmFsdWUuIiA+JjQgOzsKICAgICAgICAgICAgICAgICAgIGVzYWMKICAg
  ICAgICAgICAgICAgOzsKICAgICAgICAgICAqKSAgZWNobyAiWW91ciBjb21waWxlciBpcyBvay4i
  ID4mNAogICAgICAgICAgICAgICA7OwogICAgICAgICAgIGVzYWMKICAgIGVsc2UKICAgICAgIGVj
  aG8gIiAiCiAgICAgICBlY2hvICIqKiogV0hPQSBUSEVSRSEhISAqKioiID4mNAogICAgICAgZWNo
  byAiICAgIFlvdXIgQyBjb21waWxlciBcIiRjY1wiIGRvZXNuJ3Qgc2VlbSB0byBiZSB3b3JraW5n
  ISIgPiY0CiAgICAgICBjYXNlICIka25vd2l0YWxsIiBpbgogICAgICAgICAgICcnKSBlY2hvICIg
  ICAgWW91J2QgYmV0dGVyIHN0YXJ0IGh1bnRpbmcgZm9yIG9uZSBhbmQgbGV0IG1lIGtub3cgYWJv
  dXQgaXQuIiA+JjQKICAgICAgICAgICAgICAgZXhpdCAxCiAgICAgICAgICAgICAgIDs7CiAgICAg
  ICAgICAgZXNhYwogICAgICAgZmkKCiAgICBybSAtZiB0MDAxJF9vIHQwMDEkX2V4ZQogICAgZmkK
  RU9DQlUKCmNhdCA+Y29uZmlnLmFyY2ggPDwnRU9DQlUnCiMgVGhpcyBzY3JpcHQgVVUvY29uZmln
  LmFyY2ggd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUgYWZ0ZXIKIyBhbGwgb3Ro
  ZXIgY29uZmlndXJhdGlvbnMgYXJlIGRvbmUganVzdCBiZWZvcmUgY29uZmlnLmggaXMgZ2VuZXJh
  dGVkCmNhc2UgIiRhcmNobmFtZTokb3B0aW1pemUiIGluCiAgUEEqOiotZypbLStdTyp8UEEqOipb
  LStdTyotZyopCiAgICBjYXNlICIkY2NmbGFncyIgaW4KICAgICAgKkRENjQqKSA7OwogICAgICAq
  KSBjYXNlICIkY2N2ZXJzaW9uIiBpbgoJICAjIE9ubHkgb24gUEEtUklTQy4gQjM5MTBCIChhQ0Mp
  IGlzIG5vdCBmYXVsdHkKCSAgIyBCLjExLiogYW5kIEEuMTAuKiBhcmUKCSAgW0FCXS4xKikKCSAg
  ICAgICMgY2M6IGVycm9yIDE0MTQ6IENhbid0IGhhbmRsZSBwcmVwcm9jZXNzZWQgZmlsZSBmb28u
  aSBpZiAtZyBhbmQgLU8gc3BlY2lmaWVkLgoJICAgICAgZWNobyAiSFAtVVggQy1BTlNJLUMgb24g
  UEEtUklTQyBkb2VzIG5vdCBhY2NlcHQgYm90aCAtZyBhbmQgLU8gb24gcHJlcHJvY2Vzc2VkIGZp
  bGVzIiA+JjQKCSAgICAgIGVjaG8gIndoZW4gY29tcGlsaW5nIGluIDMyYml0IG1vZGUuIFRoZSBv
  cHRpbWl6ZXIgd2lsbCBiZSBkaXNhYmxlZC4iID4mNAoJICAgICAgb3B0aW1pemU9YGVjaG8gIiRv
  cHRpbWl6ZSIgfCBzZWQgLWUgJ3MvWy0rXU9bMC05XSovLycgLWUgJ3MvK09ub2xpbWl0Ly8nIC1l
  ICdzL14gKi8vJ2AKCSAgICAgIDs7CgkgIGVzYWMKICAgICAgZXNhYwogIGVzYWMKRU9DQlUKCmNh
  dCA+VVUvdXNlbGFyZ2VmaWxlcy5jYnUgPDwnRU9DQlUnCiMgVGhpcyBzY3JpcHQgVVUvdXNlbGFy
  Z2VmaWxlcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRlciBp
  dCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIGxhcmdlIGZpbGVzLgoK
  Y2FzZSAiJGFyY2huYW1lOiR1c2U2NGJpdGFsbDokdXNlNjRiaXRpbnQiIGluCiAgICAqLUxQNjQq
  OnVuZGVmOmRlZmluZSkKCWFyY2huYW1lPWBlY2hvICIkYXJjaG5hbWUiIHwgc2VkICdzLy1MUDY0
  Ly02NGludC8nYAoJZWNobyAiQXJjaG5hbWUgY2hhbmdlZCB0byAkYXJjaG5hbWUiCgk7OwogICAg
  ZXNhYwoKY2FzZSAiJHVzZWxhcmdlZmlsZXMiIGluCiAgICAiInwkZGVmaW5lfHRydWV8W3lZXSop
  CgkjIHRoZXJlIGFyZSBsYXJnZWZpbGUgZmxhZ3MgYXZhaWxhYmxlIHZpYSBnZXRjb25mKDEpCgkj
  IGJ1dCB3ZSBjaGVhdCBmb3Igbm93LiAgKEtlZXAgdGhhdCBpbiB0aGUgbGVmdCBtYXJnaW4uKQpj
  Y2ZsYWdzX3VzZWxhcmdlZmlsZXM9Ii1EX0xBUkdFRklMRV9TT1VSQ0UgLURfRklMRV9PRkZTRVRf
  QklUUz02NCIKCgljYXNlICIgJGNjZmxhZ3MgIiBpbgoJKiIgJGNjZmxhZ3NfdXNlbGFyZ2VmaWxl
  cyAiKikgOzsKCSopIGNjZmxhZ3M9IiRjY2ZsYWdzICRjY2ZsYWdzX3VzZWxhcmdlZmlsZXMiIDs7
  Cgllc2FjCgoJaWYgdGVzdCAteiAiJGNjaXNnY2MiIC1hIC16ICIkZ2NjdmVyc2lvbiI7IHRoZW4K
  CSAgICAjIFRoZSBzdHJpY3QgQU5TSSBtb2RlICgtQWEpIGRvZXNuJ3QgbGlrZSBsYXJnZSBmaWxl
  cy4KCSAgICBjY2ZsYWdzPWBlY2hvICIgJGNjZmxhZ3MgInxzZWQgJ3NAIC1BYSBAIEBnJ2AKCSAg
  ICBjYXNlICIkY2NmbGFncyIgaW4KCQkqLUFlKikgOzsKCQkqKSAgICAgY2NmbGFncz0iJGNjZmxh
  Z3MgLUFlIiA7OwoJCWVzYWMKCSAgICBmaQoJOzsKICAgIGVzYWMKRU9DQlUKCiMgVEhSRUFESU5H
  CgojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycg
  YnkgQ29uZmlndXJlCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1c2VyIGZvciB3aGV0aGVy
  IHRvIHVzZSB0aHJlYWRzLgpjYXQgPlVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIk
  dXNldGhyZWFkcyIgaW4KICAgICRkZWZpbmV8dHJ1ZXxbeVldKikKCWlmIFsgIiR4eE9zUmV2TWFq
  b3IiIC1sdCAxMCBdOyB0aGVuCgkgICAgY2F0IDw8RU9NID4mNAoKSFAtVVggJHh4T3NSZXZNYWpv
  ciBjYW5ub3Qgc3VwcG9ydCBQT1NJWCB0aHJlYWRzLgpDb25zaWRlciB1cGdyYWRpbmcgdG8gYXQg
  bGVhc3QgSFAtVVggMTEuCkNhbm5vdCBjb250aW51ZSwgYWJvcnRpbmcuCkVPTQoJICAgIGV4aXQg
  MQoJICAgIGZpCgoJaWYgWyAiJHh4T3NSZXZNYWpvciIgLWVxIDEwIF07IHRoZW4KCSAgICAjIFVu
  ZGVyIDEwLlgsIGEgdGhyZWFkZWQgcGVybCBjYW4gYmUgYnVpbHQKCSAgICBpZiBbIC1mIC91c3Iv
  aW5jbHVkZS9wdGhyZWFkLmggXTsgdGhlbgoJCWlmIFsgLWYgL3Vzci9saWIvbGliY21hLnNsIF07
  IHRoZW4KCQkgICAgIyBEQ0UgKGZyb20gQ29yZSBPUyBDRCkgaXMgaW5zdGFsbGVkCgoJCSAgICMg
  Q2hlY2sgaWYgaXQgaXMgcHJpc3RpbmUsIG9yIHBhdGNoZWQKCQkgICBjbWF2c249YHdoYXQgL3Vz
  ci9saWIvbGliY21hLnNsIDI+JjEgfCBncmVwIDE5OTZgCgkJICAgaWYgWyAhIC16ICIkY21hdnNu
  IiBdOyB0aGVuCgkJICAgICAgIGNhdCA8PEVPTSA+JjQKBwoqKioqKioqKioqKioqKioqKioqKioq
  KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKClBl
  cmwgd2lsbCBzdXBwb3J0IHRocmVhZGluZyB0aHJvdWdoIC91c3IvbGliL2xpYmNtYS5zbCBmcm9t
  CnRoZSBIUCBEQ0UgcGFja2FnZSwgYnV0IHRoZSB2ZXJzaW9uIGZvdW5kIGlzIHRvbyBvbGQgdG8g
  YmUKcmVsaWFibGUuCgpJZiB5b3UgYXJlIG5vdCBkZXBlbmRpbmcgb24gdGhpcyBzcGVjaWZpYyB2
  ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LApjb25zaWRlciB0byB1cGdyYWRlIHVzaW5nIHBhdGNoIFBI
  U1NfMjM2NzIgKHJlYWQgUkVBRE1FLmhwdXgpCgoqKioqKioqKioqKioqKioqKioqKioqKioqKioq
  KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKCihzbGVlcGlu
  ZyBmb3IgMTAgc2Vjb25kcy4uLikKRU9NCgkJICAgICAgIHNsZWVwIDEwCgkJICAgICAgIGZpCgoJ
  CSAgICAjIEl0IG5lZWRzICMgbGliY21hIGFuZCBPTERfUFRIUkVBRFNfQVBJLiBBbHNvCgkJICAg
  ICMgPHB0aHJlYWQuaD4gbmVlZHMgdG8gYmUgI2luY2x1ZGVkIGJlZm9yZSBhbnkKCQkgICAgIyBv
  dGhlciBpbmNsdWRlcyAoaW4gcGVybC5oKQoKCQkgICAgIyBIUC1VWCAxMC5YIHVzZXMgdGhlIG9s
  ZCBwdGhyZWFkcyBBUEkKCQkgICAgZF9vbGRwdGhyZWFkcz0iJGRlZmluZSIKCgkJICAgICMgaW5j
  bHVkZSBsaWJjbWEgYmVmb3JlIGFsbCB0aGUgb3RoZXJzCgkJICAgIGxpYnN3YW50ZWQ9ImNtYSAk
  bGlic3dhbnRlZCIKCgkJICAgICMgdGVsbCBwZXJsLmggdG8gaW5jbHVkZSA8cHRocmVhZC5oPiBi
  ZWZvcmUgb3RoZXIKCQkgICAgIyBpbmNsdWRlIGZpbGVzCgkJICAgIGNjZmxhZ3M9IiRjY2ZsYWdz
  IC1EUFRIUkVBRF9IX0ZJUlNUIgojIEZpcnN0IGNvbHVtbiBvbiBwdXJwb3NlOgojIHRoaXMgaXMg
  bm90IGEgc3RhbmRhcmQgQ29uZmlndXJlIHZhcmlhYmxlCiMgYnV0IHdlIG5lZWQgdG8gZ2V0IHRo
  aXMgbm90aWNlZC4KcHRocmVhZF9oX2ZpcnN0PSIkZGVmaW5lIgoKCQkgICAgIyBIUC1VWCAxMC5Y
  IHNlZW1zIHRvIGhhdmUgbm8gZWFzeQoJCSAgICAjIHdheSBvZiBkZXRlY3RpbmcgdGhlc2UgKnRp
  bWVfciBwcm90b3MuCgkJICAgIGRfZ210aW1lX3JfcHJvdG89J2RlZmluZScKCQkgICAgZ210aW1l
  X3JfcHJvdG89J1JFRU5UUkFOVF9QUk9UT19JX1RTJwoJCSAgICBkX2xvY2FsdGltZV9yX3Byb3Rv
  PSdkZWZpbmUnCgkJICAgIGxvY2FsdGltZV9yX3Byb3RvPSdSRUVOVFJBTlRfUFJPVE9fSV9UUycK
  CgkJICAgICMgQXZvaWQgdGhlIHBvaXNvbm91cyBjb25mbGljdGluZyAoYW5kIGlycmVsZXZhbnQp
  CgkJICAgICMgcHJvdG90eXBlcyBvZiBzZXRrZXkgKCkuCgkJICAgIGlfY3J5cHQ9IiR1bmRlZiIK
  CgkJICAgICMgQ01BIHJlZGVmaW5lcyBzZWxlY3QgdG8gY21hX3NlbGVjdCwgYW5kIGNtYV9zZWxl
  Y3QKCQkgICAgIyBleHBlY3RzIGludCAqIGluc3RlYWQgb2YgZmRfc2V0ICogKGp1c3QgbGlrZSA5
  LlgpCgkJICAgIHNlbGVjdHR5cGU9J2ludCAqJwoKCQllbGlmIFsgLWYgL3Vzci9saWIvbGlicHRo
  cmVhZC5zbCBdOyB0aGVuCgkJICAgICMgUFRIIHBhY2thZ2UgaXMgaW5zdGFsbGVkCgkJICAgIGxp
  YnN3YW50ZWQ9InB0aHJlYWQgJGxpYnN3YW50ZWQiCgkJZWxzZQoJCSAgICBsaWJzd2FudGVkPSJu
  b190aHJlYWRzX2F2YWlsYWJsZSIKCQkgICAgZmkKCSAgICBlbHNlCgkJbGlic3dhbnRlZD0ibm9f
  dGhyZWFkc19hdmFpbGFibGUiCgkJZmkKCgkgICAgaWYgWyAkbGlic3dhbnRlZCA9ICJub190aHJl
  YWRzX2F2YWlsYWJsZSIgXTsgdGhlbgoJCWNhdCA8PEVPTSA+JjQKCkluIEhQLVVYIDEwLlggZm9y
  IFBPU0lYIHRocmVhZHMgeW91IG5lZWQgYm90aCBvZiB0aGUgZmlsZXMKL3Vzci9pbmNsdWRlL3B0
  aHJlYWQuaCBhbmQgZWl0aGVyIC91c3IvbGliL2xpYmNtYS5zbCBvciAvdXNyL2xpYi9saWJwdGhy
  ZWFkLnNsLgpFaXRoZXIgeW91IG11c3QgdXBncmFkZSB0byBIUC1VWCAxMSBvciBpbnN0YWxsIGEg
  cG9zaXggdGhyZWFkIGxpYnJhcnk6CgogICAgRENFLUNvcmVUb29scyBmcm9tIEhQLVVYIDEwLjIw
  IEhhcmR3YXJlIEV4dGVuc2lvbnMgMy4wIENEIChCMzkyMC0xMzk0MSkKCm9yCgogICAgUFRIIHBh
  Y2thZ2UgZnJvbSBlLmcuIGh0dHA6Ly9ocHV4LmNvbm5lY3Qub3JnLnVrL2hwcGQvaHB1eC9HbnUv
  cHRoLTIuMC43LwoKQ2Fubm90IGNvbnRpbnVlLCBhYm9ydGluZy4KRU9NCgkJZXhpdCAxCgkJZmkK
  CWVsc2UKCSAgICAjIDEyIG1heSB3YW50IHVwcGluZyB0aGUgX1BPU0lYX0NfU09VUkNFIGRhdGVz
  dGFtcC4uLgoJICAgIGNjZmxhZ3M9IiAtRF9QT1NJWF9DX1NPVVJDRT0xOTk1MDZMIC1EX1JFRU5U
  UkFOVCAkY2NmbGFncyIKCSAgICBzZXQgYGVjaG8gWCAiJGxpYnN3YW50ZWQgInwgc2VkIC1lICdz
  LyBjIC8gcHRocmVhZCBjIC8nYAoJICAgIHNoaWZ0CgkgICAgbGlic3dhbnRlZD0iJCoiCgoJICAg
  ICMgSFAtVVggMTEuWCBzZWVtcyB0byBoYXZlIG5vIGVhc3kKCSAgICAjIHdheSBvZiBkZXRlY3Rp
  bmcgdGhlc2UgKnRpbWVfciBwcm90b3MuCgkgICAgZF9nbXRpbWVfcl9wcm90bz0nZGVmaW5lJwoJ
  ICAgIGdtdGltZV9yX3Byb3RvPSdSRUVOVFJBTlRfUFJPVE9fU19UUycKCSAgICBkX2xvY2FsdGlt
  ZV9yX3Byb3RvPSdkZWZpbmUnCgkgICAgbG9jYWx0aW1lX3JfcHJvdG89J1JFRU5UUkFOVF9QUk9U
  T19TX1RTJwoJICAgIGZpCgk7OwogICAgZXNhYwpFT0NCVQoKIyBUaGVyZSB1c2VkIHRvIGJlOgoj
  ICBUaGUgbXlzdGVyaW91cyBpb194cyBtZW1vcnkgY29ycnVwdGlvbiBpbiAxMS4wMCAzMmJpdCBz
  ZWVtcyB0byBnZXQKIyAgZml4ZWQgYnkgbm90IHVzaW5nIFBlcmwncyBtYWxsb2MuICBGbGlwIHNp
  ZGUgaXMgcGVyZm9ybWFuY2UgbG9zcy4KIyAgU28gd2Ugd2FudCBteW1hbGxvYyBmb3IgYWxsIHNp
  dHVhdGlvbnMgcG9zc2libGUKIyBUaGF0IHNldCB1c2VteW1hbGxvYyB0byAnbicgZm9yIHRocmVh
  ZGVkIGJ1aWxkcyBhbmQgbm9uLWdjYyAzMmJpdAojICBub24tZGVidWdnaW5nIGJ1aWxkcyBhbmQg
  J3knIGZvciBhbGwgb3RoZXJzCgp1c2VteW1hbGxvYz0nbicKY2FzZSAiJHVzZXBlcmxpbyIgaW4K
  ICAgICR1bmRlZnxmYWxzZXxbbk5dKikgdXNlbXltYWxsb2M9J3knIDs7CiAgICBlc2FjCgojIG1h
  bGxvYyB3cmFwIHdvcmtzCmNhc2UgIiR1c2VtYWxsb2N3cmFwIiBpbgogICAgJycpIHVzZW1hbGxv
  Y3dyYXA9J2RlZmluZScgOzsKICAgIGVzYWMKCiMgY3RpbWVfciAoKSBhbmQgYXNjdGltZV9yICgp
  IHNlZW0gdG8gaGF2ZSBpc3N1ZXMgZm9yIHZlcnNpb25zIGJlZm9yZQojIEhQLVVYIDExCmlmIFsg
  JHh4T3NSZXZNYWpvciAtbHQgMTEgXTsgdGhlbgogICAgZF9jdGltZV9yPSIkdW5kZWYiCiAgICBk
  X2FzY3RpbWVfcj0iJHVuZGVmIgogICAgZmkKCiMgZnBjbGFzc2lmeSAoKSBpcyBhIG1hY3JvLCB0
  aGUgbGlicmFyeSBjYWxsIGlzIEZwY2xhc3NpZnkKIyBTaW1pbGFybHkgd2l0aCB0aGUgb3RoZXJz
  IGJlbG93LgpkX2ZwY2xhc3NpZnk9J2RlZmluZScKZF9pc25hbj0nZGVmaW5lJwpkX2lzaW5mPSdk
  ZWZpbmUnCmRfaXNmaW5pdGU9J2RlZmluZScKZF91bm9yZGVyZWQ9J2RlZmluZScKIyBOZXh0IG9u
  ZShzKSBuZWVkIHRoZSBsZWFkaW5nIHRhYi4gIFRoZXNlIGFyZSBzcGVjaWFsICdoaW50JyBzeW1i
  b2xzIHRoYXQKIyBhcmUgbm90IHRvIGJlIHByb3BhZ2F0ZWQgdG8gY29uZmlnLnNoLCBhbGwgcmVs
  YXRlZCB0byBwdGhyZWFkcyBkcmFmdCA0CiMgaW50ZXJmYWNlcy4KY2FzZSAiJGRfb2xkcHRocmVh
  ZHMiIGluCiAgICAnJ3wkdW5kZWYpCglkX2NyeXB0X3JfcHJvdG89J3VuZGVmJwoJZF9nZXRncmVu
  dF9yX3Byb3RvPSd1bmRlZicKCWRfZ2V0cHdlbnRfcl9wcm90bz0ndW5kZWYnCglkX3N0cmVycm9y
  X3JfcHJvdG89J3VuZGVmJwoJOzsKICAgIGVzYWMKCiMgSC5NZXJpam4gc2F5cyBpdCdzIG5vdCAx
  OTk4IGFueW1vcmU6IE9EQk0gaXMgbm90IG5lZWRlZCwKIyBhbmQgaXQgc2VlbXMgdG8gYmUgYnVn
  Z3kgaW4gSFAtVVggYW55d2F5LgppX2RibT11bmRlZgoKIyBJbiBIUC1VWGVzIHByaW9yIHRvIDEx
  LjIzIHN0cnRvbGQoKSByZXR1cm5lZCBhIEhQLVVYCiMgc3BlY2lmaWMgdW5pb24gY2FsbGVkIGxv
  bmdfZG91YmxlLCBub3QgYSBDOTkgbG9uZyBkb3VibGUuCmNhc2UgImBncmVwICdkb3VibGUgc3Ry
  dG9sZC5jb25zdCcgL3Vzci9pbmNsdWRlL3N0ZGxpYi5oYCIgaW4KKiJsb25nIGRvdWJsZSBzdHJ0
  b2xkIiopIDs7ICMgc3RydG9sZCBzaG91bGQgYmUgc2FmZS4KKikgZWNobyAiTG9va3MgbGlrZSB5
  b3VyIHN0cnRvbGQoKSBpcyBub24tc3RhbmRhcmQuLi4iID4mNAogICBkX3N0cnRvbGQ9dW5kZWYg
  OzsKZXNhYwoKIyBJbiBwcmUtMTEgSFAtVVhlcyB0aGVyZSByZWFsbHkgaXNuJ3QgaXNmaW5pdGUo
  KSwgZGVzcGl0ZSB3aGF0CiMgQ29uZmlndXJlIG1pZ2h0IHRoaW5rLiAoVGhlcmUgaXMgZmluaXRl
  KCksIHRob3VnaC4pCmNhc2UgImBncmVwICdpc2Zpbml0ZScgL3Vzci9pbmNsdWRlL21hdGguaGAi
  IGluCioiaXNmaW5pdGUiKikgOzsKKikgZF9pc2Zpbml0ZT11bmRlZiA7Owplc2FjCgojIDExLjIz
  IHNheXMgaXQgaGFzIG1icmxlbiBhbmQgbWJydG93YywgYnV0IGNvbXBpbGluZyB0aGVtIGZhaWxz
  IGFzIGl0IGNhbid0CiMgZmluZCB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciBtYnN0YXRlX3Qgd2hp
  Y2ggb25lIG9mIHRoZSBwYXJhbWV0ZXJzIGlzLiAgSXQncwojIG5vdCBpbiB0aGUgaGRyIHRoZSBt
  YW4gcGFnZSBzYXlzIGl0IGlzLiAgUGVyaGFwcyBhIGJldHRlciBDb25maWd1cmUgcHJvYmUgaXMK
  IyBuZWVkZWQsIGJ1dCBmb3Igbm93IHNpbXBseSB1bmRlZmluZSB0aGVtCmRfbWJybGVuPSd1bmRl
  ZicKZF9tYnJ0b3djPSd1bmRlZicKIyBBbmQgdGhpcyBvbmUgaXMgbm90IGtub3cgb24gMTEuMTEg
  KHdpdGggSFAgQy1BTlNJLUMpCmlmIFsgIiR4eE9zUmV2TWFqb3IiIC1sdCAxMSBdIHx8IFsgIiR4
  eE9zUmV2TWlub3IiIC1sdCAxMiBdOyB0aGVuCmRfd2NydG9tYj0ndW5kZWYnCmZpCg==','linux'=>'IyBoaW50cy9saW51eC5zaAojIE9yaWdpbmFsIHZlcnNpb24gYnkgcnNhbmRlcnMKIyBBZGRpdGlv
  bmFsIHN1cHBvcnQgYnkgS2VubmV0aCBBbGJhbm93c2tpIDxramFoZHNAa2phaGRzLmNvbT4KIwoj
  IEVMRiBzdXBwb3J0IGJ5IEguSi4gTHUgPGhqbEBueW5leHN0LmNvbT4KIyBBZGRpdGlvbmFsIGlu
  Zm8gZnJvbSBOaWdlbCBIZWFkIDxuaGVhZEBFU09DLmJpdG5ldD4KIyBhbmQgS2VubmV0aCBBbGJh
  bm93c2tpIDxramFoZHNAa2phaGRzLmNvbT4KIwojIENvbnNvbGlkYXRlZCBieSBBbmR5IERvdWdo
  ZXJ0eSA8ZG91Z2hlcmFAbGFmYXlldHRlLmVkdT4KIwojIFVwZGF0ZWQgVGh1IEZlYiAgOCAxMTo1
  NjoxMCBFU1QgMTk5NgoKIyBVcGRhdGVkIFRodSBNYXkgMzAgMTA6NTA6MjIgRURUIDE5OTYgYnkg
  PGRvdWdoZXJhQGxhZmF5ZXR0ZS5lZHU+CgojIFVwZGF0ZWQgRnJpIEp1biAyMSAxMTowNzo1NCBF
  RFQgMTk5NgojIE5EQk0gc3VwcG9ydCBmb3IgRUxGIHJlLWVuYWJsZWQgYnkgPGtqYWhkc0BramFo
  ZHMuY29tPgoKIyBObyB2ZXJzaW9uIG9mIExpbnV4IHN1cHBvcnRzIHNldHVpZCBzY3JpcHRzLgpk
  X3N1aWRzYWZlPSd1bmRlZicKCiMgTm8gdmVyc2lvbiBvZiBMaW51eCBuZWVkcyBsaWJ1dGlsIGZv
  ciBwZXJsLgppX2xpYnV0aWw9J3VuZGVmJwoKIyBEZWJpYW4gYW5kIFJlZCBIYXQsIGFuZCBwZXJo
  YXBzIG90aGVyIHZlbmRvcnMsIHByb3ZpZGUgYm90aCBydW50aW1lIGFuZAojIGRldmVsb3BtZW50
  IHBhY2thZ2VzIGZvciBzb21lIGxpYnJhcmllcy4gIFRoZSBydW50aW1lIHBhY2thZ2VzIGNvbnRh
  aW4gc2hhcmVkCiMgbGlicmFyaWVzIHdpdGggdmVyc2lvbiBpbmZvcm1hdGlvbiBpbiB0aGVpciBu
  YW1lcyAoZS5nLiwgbGliZ2RibS5zby4xLjcuMyk7CiMgdGhlIGRldmVsb3BtZW50IHBhY2thZ2Vz
  IHN1cHBsZW1lbnQgdGhpcyB3aXRoIHZlcnNpb25sZXNzIHNoYXJlZCBsaWJyYXJpZXMKIyAoZS5n
  LiwgbGliZ2RibS5zbykuCiMKIyBJZiB5b3Ugd2FudCB0byBsaW5rIGFnYWluc3Qgc3VjaCBhIGxp
  YnJhcnksIHlvdSBtdXN0IGluc3RhbGwgdGhlIGRldmVsb3BtZW50CiMgdmVyc2lvbiBvZiB0aGUg
  cGFja2FnZS4KIwojIFRoZXNlIHBhY2thZ2VzIHVzZSBhIC1kZXYgbmFtaW5nIGNvbnZlbnRpb24g
  aW4gYm90aCBEZWJpYW4gYW5kIFJlZCBIYXQ6CiMgICBsaWJnZGJtZzEgIChub24tZGV2ZWxvcG1l
  bnQgdmVyc2lvbiBvZiBHTlUgbGliYyAyLWxpbmtlZCBHREJNIGxpYnJhcnkpCiMgICBsaWJnZGJt
  ZzEtZGV2IChkZXZlbG9wbWVudCB2ZXJzaW9uIG9mIEdOVSBsaWJjIDItbGlua2VkIEdEQk0gbGli
  cmFyeSkKIyBTbyBtYWtlIHN1cmUgdGhhdCBmb3IgYW55IGxpYnJhcmllcyB5b3Ugd2lzaCB0byBs
  aW5rIFBlcmwgd2l0aCB1bmRlcgojIERlYmlhbiBvciBSZWQgSGF0IHlvdSBoYXZlIHRoZSAtZGV2
  IHBhY2thZ2VzIGluc3RhbGxlZC4KCiMgU3VTRSBMaW51eCBjYW4gYmUgdXNlZCBhcyBjcm9zcy1j
  b21waWxhdGlvbiBob3N0IGZvciBDcmF5IFhUNCBDYXRhbW91bnQvUWsuCmlmIHRlc3QgLWQgL29w
  dC94dC1wZQp0aGVuCiAgY2FzZSAiYCR7Y2M6LWNjfSAtViAyPiYxYCIgaW4KICAqY2F0YW1vdW50
  KikgLiBoaW50cy9jYXRhbW91bnQuc2g7IHJldHVybiA7OwogIGVzYWMKZmkKCiMgU29tZSBvcGVy
  YXRpbmcgc3lzdGVtcyAoZS5nLiwgU29sYXJpcyAyLjYpIHdpbGwgbGluayB0byBhIHZlcnNpb25l
  ZCBzaGFyZWQKIyBsaWJyYXJ5IGltcGxpY2l0bHkuICBGb3IgZXhhbXBsZSwgb24gU29sYXJpcywg
  YGxkIGZvby5vIC1sZ2RibScgd2lsbCBmaW5kIGFuCiMgYXBwcm9wcmlhdGUgdmVyc2lvbiBvZiBs
  aWJnZGJtLCBpZiBvbmUgaXMgYXZhaWxhYmxlOyBMaW51eCwgaG93ZXZlciwgZG9lc24ndAojIGRv
  IHRoZSBpbXBsaWNpdCBtYXBwaW5nLgppZ25vcmVfdmVyc2lvbmVkX3NvbGlicz0neScKCiMgQlNE
  IGNvbXBhdGliaWxpdHkgbGlicmFyeSBubyBsb25nZXIgbmVlZGVkCiMgJ2thZmZlJyBoYXMgYSAv
  dXNyL2xpYi9saWJuZXQuc28gd2hpY2ggaXMgbm90IGF0IGFsbCByZWxldmFudCBmb3IgcGVybC4K
  IyBiaW5kIGNhdXNlcyBpc3N1ZXMgd2l0aCBzZXZlcmFsIHJlZW50cmFudCBmdW5jdGlvbnMKc2V0
  IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYnNkIC8gLycgLWUgJ3MvIG5ldCAv
  IC8nIC1lICdzLyBiaW5kIC8gLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoKIyBEZWJpYW4gNC4w
  IHB1dHMgbmRibSBpbiB0aGUgLWxnZGJtX2NvbXBhdCBsaWJyYXJ5LgplY2hvICRsaWJzCmlmIGVj
  aG8gIiAkbGlic3dhbnRlZCAiIHwgZ3JlcCAtcSAnIGdkYm0gJzsgdGhlbgogICAgIyBPbmx5IGFk
  ZCBpZiBnZGJtIGlzIGluIGxpYnN3YW50ZWQuCiAgICBsaWJzd2FudGVkPSIkbGlic3dhbnRlZCBn
  ZGJtX2NvbXBhdCIKZmkKCiMgQ29uZmlndXJlIG1heSBmYWlsIHRvIGZpbmQgbHN0YXQoKSBzaW5j
  ZSBpdCdzIGEgc3RhdGljL2lubGluZQojIGZ1bmN0aW9uIGluIDxzeXMvc3RhdC5oPi4KZF9sc3Rh
  dD1kZWZpbmUKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCicn
  KSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMKCiMgVGhlIHN5c3RlbSBtYWxsb2MoKSBp
  cyBhYm91dCBhcyBmYXN0IGFuZCBhcyBmcnVnYWwgYXMgcGVybCdzLgojIFNpbmNlIHRoZSBzeXN0
  ZW0gbWFsbG9jKCkgaGFzIGJlZW4gdGhlIGRlZmF1bHQgc2luY2UgYXQgbGVhc3QKIyA1LjAwMSwg
  d2UgbWlnaHQgYXMgd2VsbCBsZWF2ZSBpdCB0aGF0IHdheS4gIC0tQUQgIDEwIEphbiAyMDAyCmNh
  c2UgIiR1c2VteW1hbGxvYyIgaW4KJycpIHVzZW15bWFsbG9jPSduJyA7Owplc2FjCgp1bmFtZV9t
  aW51c19tPSJgJHJ1biB1bmFtZSAtbSAyPi9kZXYvbnVsbGAiCnVuYW1lX21pbnVzX209IiR7dW5h
  bWVfbWludXNfbTotIiR0YXJnZXRhcmNoIn0iCgojIENoZWNrIGlmIHdlJ3JlIGFib3V0IHRvIHVz
  ZSBJbnRlbCdzIElDQyBjb21waWxlcgpjYXNlICJgJHtjYzotY2N9IC1WIDI+JjFgIiBpbgoqIklu
  dGVsKFIpIEMiKiIgQ29tcGlsZXIiKikKICAgICMgcmVjb3JkIHRoZSB2ZXJzaW9uLCBmb3JtYXRz
  OgogICAgIyBpY2MgKElDQykgMTAuMSAyMDA4MDgwMQogICAgIyBpY3BjIChJQ0MpIDEwLjEgMjAw
  ODA4MDEKICAgICMgZm9sbG93ZWQgYnkgYSBjb3B5cmlnaHQgb24gdGhlIHNlY29uZCBsaW5lCiAg
  ICBjY3ZlcnNpb249YCR7Y2M6LWNjfSAtLXZlcnNpb24gfCBzZWQgLW4gLWUgJ3MvXmljcFw/YyBc
  KChJQ0MpIFwpXD8vL3AnYAogICAgIyBUaGlzIGlzIG5lZWRlZCBmb3IgQ29uZmlndXJlJ3MgcHJv
  dG90eXBlIGNoZWNrcyB0byB3b3JrIGNvcnJlY3RseQogICAgIyBUaGUgLW1wIGZsYWcgaXMgbmVl
  ZGVkIHRvIHBhc3MgdmFyaW91cyBmbG9hdGluZyBwb2ludCByZWxhdGVkIHRlc3RzCiAgICAjIFRo
  ZSAtbm8tZ2NjIGZsYWcgaXMgbmVlZGVkIG90aGVyd2lzZSwgaWNjIHByZXRlbmRzIChwb29ybHkp
  IHRvIGJlIGdjYwogICAgY2NmbGFncz0iLXdlMTQ3IC1tcCAtbm8tZ2NjICRjY2ZsYWdzIgogICAg
  IyBQcmV2ZW50IHJlbG9jYXRpb24gZXJyb3JzIG9uIDY0Yml0cyBhcmNoCiAgICBjYXNlICIkdW5h
  bWVfbWludXNfbSIgaW4KCSppYTY0KnwqeDg2XzY0KikKCSAgICBjY2NkbGZsYWdzPSctZlBJQycK
  CTs7CiAgICBlc2FjCiAgICAjIElmIHdlJ3JlIHVzaW5nIElDQywgd2UgdXN1YWxseSB3YW50IHRo
  ZSBiZXN0IHBlcmZvcm1hbmNlCiAgICBjYXNlICIkb3B0aW1pemUiIGluCiAgICAnJykgb3B0aW1p
  emU9Jy1PMycgOzsKICAgIGVzYWMKICAgIDs7CioiIFN1biAiKiJDIiopCiAgICAjIFN1bidzIEMg
  Y29tcGlsZXIsIHdoaWNoIG1pZ2h0IGhhdmUgYSAndGFnJyBuYW1lIGJldHdlZW4KICAgICMgJ1N1
  bicgYW5kIHRoZSAnQyc6ICBFeGFtcGxlczoKICAgICMgY2M6IFN1biBDIDUuOSBMaW51eF9pMzg2
  IFBhdGNoIDEyNDg3MS0wMSAyMDA3LzA3LzMxCiAgICAjIGNjOiBTdW4gQ2VyZXMgQyA1LjEwIExp
  bnV4X2kzODYgMjAwOC8wNy8xMAogICAgdGVzdCAiJG9wdGltaXplIiB8fCBvcHRpbWl6ZT0nLXhP
  MicKICAgIGNjY2RsZmxhZ3M9Jy1LUElDJwogICAgbGRkbGZsYWdzPSctRyAtQmR5bmFtaWMnCiAg
  ICAjIFN1biBDIGRvZXNuJ3Qgc3VwcG9ydCBnY2MgYXR0cmlidXRlcywgYnV0LCBpbiBtYW55IGNh
  c2VzLCBkb2Vzbid0CiAgICAjIGNvbXBsYWluIGVpdGhlci4gIE5vdCBhbGwgY2FzZXMsIHRob3Vn
  aC4KICAgIGRfYXR0cmlidXRlX2Zvcm1hdD0ndW5kZWYnCiAgICBkX2F0dHJpYnV0ZV9tYWxsb2M9
  J3VuZGVmJwogICAgZF9hdHRyaWJ1dGVfbm9ubnVsbD0ndW5kZWYnCiAgICBkX2F0dHJpYnV0ZV9u
  b3JldHVybj0ndW5kZWYnCiAgICBkX2F0dHJpYnV0ZV9wdXJlPSd1bmRlZicKICAgIGRfYXR0cmli
  dXRlX3VudXNlZD0ndW5kZWYnCiAgICBkX2F0dHJpYnV0ZV93YXJuX3VudXNlZF9yZXN1bHQ9J3Vu
  ZGVmJwogICAgOzsKZXNhYwoKY2FzZSAiJG9wdGltaXplIiBpbgojIHVzZSAtTzIgYnkgZGVmYXVs
  dCA7IC1PMyBkb2Vzbid0IHNlZW0gdG8gYnJpbmcgc2lnbmlmaWNhbnQgYmVuZWZpdHMgd2l0aCBn
  Y2MKJycpCiAgICBvcHRpbWl6ZT0nLU8yJwogICAgY2FzZSAiJHVuYW1lX21pbnVzX20iIGluCiAg
  ICAgICAgcHBjKikKICAgICAgICAgICAgIyBvbiBwcGMsIGl0IHNlZW1zIHRoYXQgZ2NjIChhdCBs
  ZWFzdCBnY2MgMy4zLjIpIGlzbid0IGhhcHB5CiAgICAgICAgICAgICMgd2l0aCAtTzIgOyBzbyBk
  b3duZ3JhZGUgdG8gLU8xLgogICAgICAgICAgICBvcHRpbWl6ZT0nLU8xJwogICAgICAgIDs7CiAg
  ICAgICAgaWE2NCopCiAgICAgICAgICAgICMgVGhpcyBhcmNoaXRlY3R1cmUgaGFzIGhhZCB2YXJp
  b3VzIHByb2JsZW1zIHdpdGggZ2NjJ3MKICAgICAgICAgICAgIyBpbiB0aGUgMy4yLCAzLjMsIGFu
  ZCAzLjQgcmVsZWFzZXMgd2hlbiBvcHRpbWl6ZWQgdG8gLU8yLiAgU2VlCiAgICAgICAgICAgICMg
  UlQgIzM3MTU2IGZvciBhIGRpc2N1c3Npb24gb2YgdGhlIHByb2JsZW0uCiAgICAgICAgICAgIGNh
  c2UgImAke2NjOi1nY2N9IC12IDI+JjFgIiBpbgogICAgICAgICAgICAqInZlcnNpb24gMy4yIip8
  KiJ2ZXJzaW9uIDMuMyIqfCoidmVyc2lvbiAzLjQiKikKICAgICAgICAgICAgICAgIGNjZmxhZ3M9
  Ii1mbm8tZGVsZXRlLW51bGwtcG9pbnRlci1jaGVja3MgJGNjZmxhZ3MiCiAgICAgICAgICAgIDs7
  CiAgICAgICAgICAgIGVzYWMKICAgICAgICA7OwogICAgZXNhYwogICAgOzsKZXNhYwoKIyBVYnVu
  dHUgMTEuMDQgKGFuZCBsYXRlciwgcHJlc3VtYWJseSkgZG9lc24ndCBrZWVwIG1vc3QgbGlicmFy
  aWVzCiMgKHN1Y2ggYXMgLWxtKSBpbiAvbGliIG9yIC91c3IvbGliLiAgU28gd2UgaGF2ZSB0byBh
  c2sgZ2NjIHRvIHRlbGwgdXMKIyB3aGVyZSB0byBsb29rLiAgV2UgZG9uJ3Qgd2FudCBnY2MncyBv
  d24gbGlicmFyaWVzLCBob3dldmVyLCBzbyB3ZQojIGZpbHRlciB0aG9zZSBvdXQuCiMgVGhpcyBj
  b3VsZCBiZSBjb25kaXRpb25hbCBvbiBVbmJ1bnR1LCBidXQgb3RoZXIgZGlzdHJpYnV0aW9ucyBt
  YXkKIyBmb2xsb3cgc3VpdCwgYW5kIHRoaXMgc2NoZW1lIHNlZW1zIHRvIHdvcmsgZXZlbiBvbiBy
  YXRoZXIgb2xkIGdjYydzLgojIFRoaXMgdW5jb25kaXRpb25hbGx5IHVzZXMgZ2NjIGJlY2F1c2Ug
  ZXZlbiBpZiB0aGUgdXNlciBpcyB1c2luZyBhbm90aGVyCiMgY29tcGlsZXIsIHdlIHN0aWxsIG5l
  ZWQgdG8gZmluZCB0aGUgbWF0aCBsaWJyYXJ5IGFuZCBmcmllbmRzLCBhbmQgSSBkb24ndAojIGtu
  b3cgaG93IG90aGVyIGNvbXBpbGVycyB3aWxsIGNvcGUgd2l0aCB0aGF0IHNpdHVhdGlvbi4KIyBN
  b3JldmVyLCBpZiB0aGUgdXNlciBoYXMgdGhlaXIgb3duIGdjYyBlYXJsaWVyIGluICRQQVRIIHRo
  YW4gdGhlIHN5c3RlbSBnY2MsCiMgd2UgZG9uJ3Qgd2FudCBpdHMgbGlicmFyaWVzLiBTbyB3ZSB0
  cnkgdG8gcHJlZmVyIHRoZSBzeXN0ZW0gZ2NjCiMgU3RpbGwsIGFzIGFuIGVzY2FwZSBoYXRjaCwg
  YWxsb3cgQ29uZmlndXJlIGNvbW1hbmQgbGluZSBvdmVycmlkZXMgdG8KIyBwbGlicHRoIHRvIGJ5
  cGFzcyB0aGlzIGNoZWNrLgppZiBbIC14IC91c3IvYmluL2djYyBdIDsgdGhlbgogICAgZ2NjPS91
  c3IvYmluL2djYwojIGNsYW5nIGFsc28gcHJvdmlkZXMgLXByaW50LXNlYXJjaC1kaXJzCmVsaWYg
  JHtjYzotY2N9IC0tdmVyc2lvbiAyPi9kZXYvbnVsbCB8IGdyZXAgLXEgJ15jbGFuZyAnIDsgdGhl
  bgogICAgZ2NjPSR7Y2M6LWNjfQplbHNlCiAgICBnY2M9Z2NjCmZpCgpjYXNlICIkcGxpYnB0aCIg
  aW4KJycpIHBsaWJwdGg9YExBTkc9QyBMQ19BTEw9QyAkZ2NjICRjY2ZsYWdzICRsZGZsYWdzIC1w
  cmludC1zZWFyY2gtZGlycyB8IGdyZXAgbGlicmFyaWVzIHwKCWN1dCAtZjItIC1kPSB8IHRyICc6
  JyAkdHJubCB8IGdyZXAgLXYgJ2djYycgfCBzZWQgLWUgJ3M6LyQ6OidgCiAgICBzZXQgWCAkcGxp
  YnB0aCAjIENvbGxhcHNlIGFsbCBlbnRyaWVzIG9uIG9uZSBsaW5lCiAgICBzaGlmdAogICAgcGxp
  YnB0aD0iJCoiCiAgICA7Owplc2FjCgojIEZvciB0aGUgbXVzbCBsaWJjLCBwZXJsIHNob3VsZCAj
  ZGVmaW5lIF9HTlVfU09VUkNFLiAgT3RoZXJ3aXNlLCBzb21lCiMgYXZhaWxhYmxlIGZ1bmN0aW9u
  cywgbGlrZSBtZW1lbSwgd29uJ3QgYmUgdXNlZC4gIFNlZSB0aGUgZGlzY3Vzc2lvbiBpbgojIFtw
  ZXJsICMxMzM3NjBdLiAgbXVzbCBkb2Vzbid0IG9mZmVyIGFuIGVhc3kgd2F5IHRvIGlkZW50aWZ5
  IGl0LCBidXQsCiMgYXQgbGVhc3Qgb24gYWxwaW5lIGxpbnV4LCB0aGUgbGRkIC0tdmVyc2lvbiBv
  dXRwdXQgY29udGFpbnMgdGhlCiMgc3RyaW5nICdtdXNsLicKY2FzZSBgbGRkIC0tdmVyc2lvbiAy
  PiYxYCBpbgogICAgbXVzbCopICBjY2ZsYWdzPSIkY2NmbGFncyAtRF9HTlVfU09VUkNFIiA7Owog
  ICAgICAgICopIDs7CmVzYWMKCiMgbGlicXVhZG1hdGggaXMgc29tZXRpbWVzIGluc3RhbGxlZCBh
  cyBnY2MgaW50ZXJuYWwgbGlicmFyeSwKIyBzbyBjb250cmFyeSB0byBvdXIgdXN1YWwgcG9saWN5
  IG9mICpub3QqIGxvb2tpbmcgYXQgZ2NjIGludGVybmFsCiMgZGlyZWN0b3JpZXMgd2Ugbm93ICpk
  byogbG9vayBhdCB0aGVtLCBpbiBjYXNlIHRoZXkgY29udGFpbgojIHRoZSBxdWFkbWF0aCBsaWJy
  YXJ5LgojIFhYWCBUaGlzIG1heSBhcHBseSB0byBvdGhlciBnY2MgaW50ZXJuYWwgbGlicmFyaWVz
  LCBpZiBzdWNoIGV4aXN0LgojIFhYWCBUaGlzIGNvdWxkIGJlIGF0IENvbmZpZ3VyZSBsZXZlbCwg
  YnV0IHRoZW4gdGhlICRnY2MgaXMgbWVzc3kuCmNhc2UgIiR1c2VxdWFkbWF0aCIgaW4KIiRkZWZp
  bmUiKQogIGZvciBkIGluIGBMQU5HPUMgTENfQUxMPUMgJGdjYyAkY2NmbGFncyAkbGRmbGFncyAt
  cHJpbnQtc2VhcmNoLWRpcnMgfCBncmVwIGxpYnJhcmllcyB8IGN1dCAtZjItIC1kPSB8IHRyICc6
  JyAkdHJubCB8IGdyZXAgJ2djYycgfCBzZWQgLWUgJ3M6LyQ6OidgCiAgZG8KICAgIGNhc2UgYGxz
  ICRkLypsaWJxdWFkbWF0aCokc28qIDI+L2Rldi9udWxsYCBpbgogICAgJGQvKmxpYnF1YWRtYXRo
  KiRzbyopIHhsaWJwdGg9IiR4bGlicHRoICRkIiA7OwogICAgZXNhYwogIGRvbmUKICA7Owplc2Fj
  CgpjYXNlICIkbGliYyIgaW4KJycpCiMgSWYgeW91IGhhdmUgZ2xpYmMsIHRoZW4gcmVwb3J0IHRo
  ZSB2ZXJzaW9uIGZvciAuL215Y29uZmlnIGJ1ZyByZXBvcnRpbmcuCiMgKENvbmZpZ3VyZSBkb2Vz
  bid0IG5lZWQgdG8ga25vdyB0aGUgc3BlY2lmaWMgdmVyc2lvbiBzaW5jZSBpdCBqdXN0IHVzZXMK
  IyBnY2MgdG8gbG9hZCB0aGUgbGlicmFyeSBmb3IgYWxsIHRlc3RzLikKIyBXZSBkb24ndCB1c2Ug
  X19HTElCQ19fIGFuZCAgX19HTElCQ19NSU5PUl9fIGJlY2F1c2UgdGhleQojIGFyZSBpbnN1ZmZp
  Y2llbnRseSBwcmVjaXNlIHRvIGRpc3Rpbmd1aXNoIHRoaW5ncyBsaWtlCiMgbGliYy0yLjAuNiBh
  bmQgbGliYy0yLjAuNy4KICAgIGZvciBwIGluICRwbGlicHRoCiAgICBkbwogICAgICAgIGZvciB0
  cnlsaWIgaW4gbGliYy5zby42IGxpYmMuc28KICAgICAgICBkbwogICAgICAgICAgICBpZiAkdGVz
  dCAtZSAkcC8kdHJ5bGliOyB0aGVuCiAgICAgICAgICAgICAgICBsaWJjPWBscyAtbCAkcC8kdHJ5
  bGliIHwgYXdrICd7cHJpbnQgJE5GfSdgCiAgICAgICAgICAgICAgICBpZiAkdGVzdCAiWCRsaWJj
  IiAhPSBYOyB0aGVuCiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgIGZp
  CiAgICAgICAgICAgIGZpCiAgICAgICAgZG9uZQogICAgICAgIGlmICR0ZXN0ICJYJGxpYmMiICE9
  IFg7IHRoZW4KICAgICAgICAgICAgYnJlYWsKICAgICAgICBmaQogICAgZG9uZQogICAgOzsKZXNh
  YwoKaWYgJHtzaDotL2Jpbi9zaH0gLWMgZXhpdDsgdGhlbgogIGVjaG8gJycKICBlY2hvICdZb3Ug
  YXBwZWFyIHRvIGhhdmUgYSB3b3JraW5nIGJhc2guICBHb29kLicKZWxzZQogIGNhdCA8PCAnRU9N
  JyA+JjQKCioqKioqKioqKioqKioqKioqKioqKioqIFdhcm5pbmchICoqKioqKioqKioqKioqKioq
  KioqKgpJdCB3b3VsZCBhcHBlYXIgeW91IGhhdmUgYSBkZWZlY3RpdmUgYmFzaCBzaGVsbCBpbnN0
  YWxsZWQuIFRoaXMgaXMgbGlrZWx5IHRvCmdpdmUgeW91IGEgZmFpbHVyZSBvZiBvcC9leGVjIHRl
  c3QgIzUgZHVyaW5nIHRoZSB0ZXN0IHBoYXNlIG9mIHRoZSBidWlsZCwKVXBncmFkaW5nIHRvIGEg
  cmVjZW50IHZlcnNpb24gKDEuMTQuNCBvciBsYXRlcikgc2hvdWxkIGZpeCB0aGUgcHJvYmxlbS4K
  KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCkVP
  TQoKZmkKCiMgT24gU1BBUkNsaW51eCwKIyBUaGUgZm9sbG93aW5nIGNzaCBjb25zaXN0ZW50bHkg
  Y29yZWR1bXBlZCBpbiB0aGUgdGVzdCBkaXJlY3RvcnkKIyAiL2hvbWUvbWlrZWRsci9wZXJsNS4w
  MDNfOTQvdCIsIHRob3VnaCBub3QgbW9zdCBvdGhlciBkaXJlY3Rvcmllcy4KCiNOYW1lICAgICAg
  ICA6IGNzaCAgICAgICAgICAgICAgICAgICAgRGlzdHJpYnV0aW9uOiBSZWQgSGF0IExpbnV4IChS
  ZW1icmFuZHQpCiNWZXJzaW9uICAgICA6IDUuMi42ICAgICAgICAgICAgICAgICAgICAgICAgVmVu
  ZG9yOiBSZWQgSGF0IFNvZnR3YXJlCiNSZWxlYXNlICAgICA6IDMgICAgICAgICAgICAgICAgICAg
  ICAgICBCdWlsZCBEYXRlOiBGcmkgTWF5IDI0IDE5OjQyOjE0IDE5OTYKI0luc3RhbGwgZGF0ZTog
  VGh1IEp1bCAxMSAxNjoyMDoxNCAxOTk2IEJ1aWxkIEhvc3Q6IGl0Y2h5LnJlZGhhdC5jb20KI0dy
  b3VwICAgICAgIDogU2hlbGxzICAgICAgICAgICAgICAgICAgIFNvdXJjZSBSUE06IGNzaC01LjIu
  Ni0zLnNyYy5ycG0KI1NpemUgICAgICAgIDogMTg0NDE3CiNEZXNjcmlwdGlvbiA6IEJTRCBjLXNo
  ZWxsCgojIEZvciB0aGlzIHJlYXNvbiBJIHN1Z2dlc3QgdXNpbmcgdGhlIG11Y2ggYnVnLWZpeGVk
  IHRjc2ggZm9yIGdsb2JiaW5nCiMgd2hlcmUgYXZhaWxhYmxlLgoKIyBOb3ZlbWJlciAyMDAxOiAg
  VGhhdCB3YXJuaW5nJ3MgcHJldHR5IG9sZCBub3cgYW5kIHByb2JhYmx5IG5vdCBzbwojIHJlbGV2
  YW50LCBlc3BlY2lhbGx5IHNpbmNlIHBlcmwgbm93IHVzZXMgRmlsZTo6R2xvYiBmb3IgZ2xvYmJp
  bmcuCiMgV2UnbGwgc3RpbGwgbG9vayBmb3IgdGNzaCwgYnV0IHRvbmUgZG93biB0aGUgd2Fybmlu
  Z3MuCiMgQW5keSBEb3VnaGVydHksIE5vdi4gNiwgMjAwMQppZiAkY3NoIC1jICdlY2hvICR2ZXJz
  aW9uJyA+L2Rldi9udWxsIDI+JjE7IHRoZW4KICAgIGVjaG8gJ1lvdXIgY3NoIGlzIHJlYWxseSB0
  Y3NoLiAgR29vZC4nCmVsc2UKICAgIGlmIHh4eD1gLi9VVS9sb2MgdGNzaCBibHVyZmwgJHB0aGA7
  ICR0ZXN0IC1mICIkeHh4IjsgdGhlbgoJZWNobyAiRm91bmQgdGNzaC4gIEknbGwgdXNlIGl0IGZv
  ciBnbG9iYmluZy4iCgkjIFdlIGNhbid0IGNoYW5nZSBDb25maWd1cmUncyBzZXR0aW5nIG9mICRj
  c2gsIGR1ZSB0byB0aGUgd2F5CgkjIENvbmZpZ3VyZSBoYW5kbGVzICRkX3BvcnRhYmxlIGFuZCBj
  b21tYW5kcyBmb3VuZCBpbiAkbG9jbGlzdC4KCSMgV2UgY2FuIHNldCB0aGUgdmFsdWUgZm9yIENT
  SCBpbiBjb25maWcuaCBieSBzZXR0aW5nIGZ1bGxfY3NoLgoJZnVsbF9jc2g9JHh4eAogICAgZWxp
  ZiBbIC1mICIkY3NoIiBdOyB0aGVuCgllY2hvICJDb3VsZG4ndCBmaW5kIHRjc2guICBDc2gtYmFz
  ZWQgZ2xvYmJpbmcgbWlnaHQgYmUgYnJva2VuLiIKICAgIGZpCmZpCgojIFNoaW1wZWkgWWFtYXNo
  aXRhIDxzaGltcGVpQHNvY3JhdGVzLnBhdG5ldC5jYWx0ZWNoLmVkdT4KIyBNZXNzYWdlLUlkOiA8
  MzNFRjE2MzQuQjM2QjY1MDBAcG9ib3guY29tPgojCiMgVGhlIERSMiBvZiBNa0xpbnV4IChvc25h
  bWU9bGludXgsYXJjaG5hbWU9cHBjLWxpbnV4KSBtYXkgbmVlZAojIHNwZWNpYWwgZmxhZ3MgcGFz
  c2VkIGluIG9yZGVyIGZvciBkeW5hbWljIGxvYWRpbmcgdG8gd29yay4KIyBpbnN0ZWFkIG9mIHRo
  ZSByZWNvbW1lbmRlZDoKIwojIGNjZGxmbGFncz0nLXJkeW5hbWljJwojCiMgaXQgc2hvdWxkIGJl
  OgojIGNjZGxmbGFncz0nLVdsLC1FJwojCiMgU28gaWYgeW91ciBEUjIgKERSMyBjYW1lIG91dCBz
  dW1tZXIgMTk5OCwgY29uc2lkZXIgdXBncmFkaW5nKQojIGhhcyBwcm9ibGVtcyB3aXRoIGR5bmFt
  aWMgbG9hZGluZywgdW5jb21tZW50IHRoZQojIGZvbGxvd2luZyB0aHJlZSBsaW5lcywgbWFrZSBk
  aXN0Y2xlYW4sIGFuZCByZS1Db25maWd1cmU6CiNjYXNlICJgdW5hbWUgLXIgfCBzZWQgJ3MvXlsw
  LTkuLV0qLy8nYGBhcmNoYCIgaW4KIydvc2ZtYWNoM3BwYycpIGNjZGxmbGFncz0nLVdsLC1FJyA7
  OwojZXNhYwoKY2FzZSAiJHVuYW1lX21pbnVzX20iIGluCnNwYXJjKikKCWNhc2UgIiRjY2NkbGZs
  YWdzIiBpbgoJKi1mcGljKikgY2NjZGxmbGFncz0iYGVjaG8gJGNjY2RsZmxhZ3N8c2VkICdzLy1m
  cGljLy1mUElDLydgIiA7OwoJKi1mUElDKikgOzsKCSopCSBjY2NkbGZsYWdzPSIkY2NjZGxmbGFn
  cyAtZlBJQyIgOzsKCWVzYWMKCTs7CmVzYWMKCiMgU3VTRTguMiBoYXMgL3Vzci9saWIvbGlibmRi
  bSogd2hpY2ggYXJlIGxkIHNjcmlwdHMgcmF0aGVyIHRoYW4KIyB0cnVlIGxpYnJhcmllcy4gVGhl
  IHNjcmlwdHMgY2F1c2UgYmluZGluZyBhZ2FpbnN0IHN0YXRpYwojIHZlcnNpb24gb2YgLWxnZGJt
  IHdoaWNoIGlzIGEgYmFkIGlkZWEuIFNvIGlmIHdlIGhhdmUgJ25tJwojIG1ha2Ugc3VyZSBpdCBj
  YW4gcmVhZCB0aGUgZmlsZQojIE5JLVMgMjAwMy8wOC8wNwpjYXNlICIkbm0iIGluCiAgICAnJykg
  OzsKICAgICopCiAgICBmb3IgcCBpbiAkcGxpYnB0aAogICAgZG8KICAgICAgICBpZiAkdGVzdCAt
  ciAkcC9saWJuZGJtLnNvOyB0aGVuCiAgICAgICAgICAgIGlmICRubSAkcC9saWJuZGJtLnNvID4v
  ZGV2L251bGwgMj4mMSA7IHRoZW4KICAgICAgICAgICAgICAgIGVjaG8gJ1lvdXIgc2hhcmVkIC1s
  bmRibSBzZWVtcyB0byBiZSBhIHJlYWwgbGlicmFyeS4nCiAgICAgICAgICAgICAgICBfbGlibmRi
  bV9yZWFsPTEKICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGZpCiAgICAgICAgZmkK
  ICAgIGRvbmUKICAgIGlmICR0ZXN0ICJYJF9saWJuZGJtX3JlYWwiID0gWDsgdGhlbgogICAgICAg
  IGVjaG8gJ1lvdXIgc2hhcmVkIC1sbmRibSBpcyBub3QgYSByZWFsIGxpYnJhcnkuJwogICAgICAg
  IHNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIG5kYm0gLyAvJ2AKICAgICAg
  ICBzaGlmdAogICAgICAgIGxpYnN3YW50ZWQ9IiQqIgogICAgZmkKICAgIDs7CmVzYWMKCiMgTGlu
  dXggb24gU3lub2xvZ3kuCmlmIFsgLWYgL2V0Yy9zeW5vaW5mby5jb25mIC1hIC1kIC91c3Ivc3lu
  byBdOyB0aGVuCiAgICAjIFRlc3RlZCBvbiBTeW5vbG9neSBEUzIxMyBhbmQgRFM0MTMKICAgICMg
  IE9TIHZlcnNpb24gaW5mbyBpbiAvZXRjLmRlZmF1bHRzL1ZFUlNJT04KICAgICMgIGh0dHA6Ly9m
  b3J1bS5zeW5vbG9neS5jb20vd2lraS9pbmRleC5waHAvV2hhdF9raW5kX29mX0NQVV9kb2VzX215
  X05BU19oYXZlCiAgICAjIFN5bm9sb2d5IERTMjEzIHJ1bm5pbmcgRFNNIDQuMy0zODEwLTAgKDIw
  MTMtMTEtMDYpCiAgICAjICBDUFUgbW9kZWwgTWFydmVsbCBLaXJrd29vZCBtdjYyODIgQVJNdjV0
  ZQogICAgIyAgTGludXggMi42LjMyLjEyICMzODEwIFdlZCBOb3YgNiAwNToxMzo0MSBDU1QgMjAx
  MyBhcm12NXRlbCBHTlUvTGludXgKICAgICMgU3lub2xvZ3kgRFM0MTMgcnVubmluZyBEU00gNC4z
  LTM4MTAtMCAoMjAxMy0xMS0wNikKICAgICMgIENQVSBtb2RlbCBGcmVlc2NhbGUgUW9ySVEgUDEw
  MjIgcHBjIChlNTAwdjIpCiAgICAjICBsaW51eCAyLjYuMzIuMTIgIzM4MTAgcHBjIEdOVS9MaW51
  eAogICAgIyBBbGwgZGV2ZWxvcG1lbnQgc3R1ZmYgaW5zdGFsbGVkIHdpdGggaXBrZyBpcyBpbiAv
  b3B0CiAgICBpZiBbICIkTEFORyIgPSAiIiAtbyAiJExBTkciID0gIkMiIF07IHRoZW4KCWVjaG8g
  J1lvdXIgTEFORyBpcyBzYWZlJwogICAgZWxzZQoJZWNobyAnUGxlYXNlIHNldCAkTEFORyB0byAi
  QyIuIEFsbCBvdGhlciAkTEFORyBzZXR0aW5ncyB3aWxsIGNhdXNlIGhhdm9jJyA+JjQKCUxBTkc9
  QwogICAgZmkKICAgIGVjaG8gJ1NldHRpbmcgdXAgdG8gdXNlIC9vcHQvKicgPiY0CiAgICBsb2Np
  bmNwdGg9Ii9vcHQvaW5jbHVkZSAkbG9jaW5jcHRoIgogICAgbGlicHRoPSIvb3B0L2xpYiAkbGli
  cHRoIgogICAgbGlic3B0aD0iL29wdC9saWIgJGxpYnNwdGgiCiAgICBsb2NsaWJwdGg9Ii9vcHQv
  bGliICRsb2NsaWJwdGgiCiAgICAjIFBPU0lYIHdpbGwgbm90IGxpbmsgd2l0aG91dCB0aGUgcHRo
  cmVhZCBsaWIKICAgIGxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIHB0aHJlYWQiCiAgICBlY2hvICIk
  bGlic3dhbnRlZCIgPiY0CmZpCgojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwg
  Z2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRo
  ZSB1c2VyIGZvciB3aGV0aGVyIHRvIHVzZSB0aHJlYWRzLgpjYXQgPiBVVS91c2V0aHJlYWRzLmNi
  dSA8PCdFT0NCVScKY2FzZSAiJHVzZXRocmVhZHMiIGluCiRkZWZpbmV8dHJ1ZXxbeVldKikKICAg
  ICAgICBjY2ZsYWdzPSItRF9SRUVOVFJBTlQgLURfR05VX1NPVVJDRSAkY2NmbGFncyIKICAgICAg
  ICBpZiBlY2hvICRsaWJzd2FudGVkIHwgZ3JlcCAtdiBwdGhyZWFkID4vZGV2L251bGwKICAgICAg
  ICB0aGVuCiAgICAgICAgICAgIHNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3Mv
  IGMgLyBwdGhyZWFkIGMgLydgCiAgICAgICAgICAgIHNoaWZ0CiAgICAgICAgICAgIGxpYnN3YW50
  ZWQ9IiQqIgogICAgICAgIGZpCgoJIyBTb21laG93IGF0IGxlYXN0IGluIERlYmlhbiAyLjIgdGhl
  c2UgbWFuYWdlIHRvIGVzY2FwZQoJIyB0aGUgI2RlZmluZSBmb3Jlc3Qgb2YgPGZlYXR1cmVzLmg+
  IGFuZCA8dGltZS5oPiBzbyB0aGF0CgkjIHRoZSBoYXNwcm90byBtYWNybyBvZiBDb25maWd1cmUg
  ZG9lc24ndCBzZWUgdGhlc2UgcHJvdG9zLAoJIyBldmVuIHdpdGggdGhlIC1EX0dOVV9TT1VSQ0Uu
  CgoJZF9hc2N0aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2NyeXB0X3JfcHJvdG89IiRkZWZpbmUi
  CglkX2N0aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2dtdGltZV9yX3Byb3RvPSIkZGVmaW5lIgoJ
  ZF9sb2NhbHRpbWVfcl9wcm90bz0iJGRlZmluZSIKCWRfcmFuZG9tX3JfcHJvdG89IiRkZWZpbmUi
  CgoJOzsKZXNhYwpFT0NCVQoKY2F0ID4gVVUvdXNlbGFyZ2VmaWxlcy5jYnUgPDwnRU9DQlUnCiMg
  VGhpcyBzY3JpcHQgVVUvdXNlbGFyZ2VmaWxlcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBi
  eSBDb25maWd1cmUKIyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIg
  dG8gdXNlIGxhcmdlIGZpbGVzLgpjYXNlICIkdXNlbGFyZ2VmaWxlcyIgaW4KJyd8JGRlZmluZXx0
  cnVlfFt5WV0qKQojIEtlZXAgdGhpcyBpbiB0aGUgbGVmdCBtYXJnaW4uCmNjZmxhZ3NfdXNlbGFy
  Z2VmaWxlcz0iLURfTEFSR0VGSUxFX1NPVVJDRSAtRF9GSUxFX09GRlNFVF9CSVRTPTY0IgoKCWNj
  ZmxhZ3M9IiRjY2ZsYWdzICRjY2ZsYWdzX3VzZWxhcmdlZmlsZXMiCgk7Owplc2FjCkVPQ0JVCgoj
  IFB1cmlmeSBmYWlscyB0byBsaW5rIFBlcmwgaWYgYSAiLWxjIiBpcyBwYXNzZWQgaW50byBpdHMg
  bGlua2VyCiMgZHVlIHRvIGR1cGxpY2F0ZSBzeW1ib2xzLgpjYXNlICIkUFVSSUZZIiBpbgokZGVm
  aW5lfHRydWV8W3lZXSopCiAgICBzZXQgYGVjaG8gWCAiJGxpYnN3YW50ZWQgInwgc2VkIC1lICdz
  LyBjIC8gLydgCiAgICBzaGlmdAogICAgbGlic3dhbnRlZD0iJCoiCiAgICA7Owplc2FjCgojIElm
  IHVzaW5nIGcrKywgdGhlIENvbmZpZ3VyZSBzY2FuIGZvciBkbG9wZW4oKSBhbmQgKGVzcGVjaWFs
  bHkpCiMgZGxlcnJvcigpIG1pZ2h0IGZhaWwsIGVhc2llciBqdXN0IHRvIGZvcmNpYmx5IGhpbnQg
  dGhlbSBpbi4KY2FzZSAiJGNjIiBpbgoqZysrKikKICBkX2Rsb3Blbj0nZGVmaW5lJwogIGRfZGxl
  cnJvcj0nZGVmaW5lJwogIDs7CmVzYWMKCiMgVW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzIGxpYmRi
  IGNhbiBnZXQgYnVpbHQgaW4gc3VjaCBhIHdheSBhcyB0bwojIG5lZWQgcHRocmVhZCBleHBsaWNp
  dGx5IGxpbmtlZC4KCmxpYmRiX25lZWRzX3B0aHJlYWQ9Ik4iCgppZiBlY2hvICIgJGxpYnN3YW50
  ZWQgIiB8IGdyZXAgLXYgIiBwdGhyZWFkICIgPi9kZXYvbnVsbAp0aGVuCiAgIGlmIGVjaG8gIiAk
  bGlic3dhbnRlZCAiIHwgZ3JlcCAiIGRiICIgPi9kZXYvbnVsbAogICB0aGVuCiAgICAgZm9yIERC
  RElSIGluICRnbGlicHRoCiAgICAgZG8KICAgICAgIERCTElCPSIkREJESVIvbGliZGIuc28iCiAg
  ICAgICBpZiBbIC1mICREQkxJQiBdCiAgICAgICB0aGVuCiAgICAgICAgIGlmICR7bm06LW5tfSAt
  dSAkREJMSUIgMj4vZGV2L251bGwgfCBncmVwIHB0aHJlYWQgPi9kZXYvbnVsbAogICAgICAgICB0
  aGVuCiAgICAgICAgICAgaWYgbGRkICREQkxJQiB8IGdyZXAgcHRocmVhZCA+L2Rldi9udWxsCiAg
  ICAgICAgICAgdGhlbgogICAgICAgICAgICAgbGliZGJfbmVlZHNfcHRocmVhZD0iTiIKICAgICAg
  ICAgICBlbHNlCiAgICAgICAgICAgICBsaWJkYl9uZWVkc19wdGhyZWFkPSJZIgogICAgICAgICAg
  IGZpCiAgICAgICAgIGZpCiAgICAgICBmaQogICAgIGRvbmUKICAgZmkKZmkKCmNhc2UgIiRsaWJk
  Yl9uZWVkc19wdGhyZWFkIiBpbgogICJZIikKICAgIGxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIHB0
  aHJlYWQiCiAgICA7Owplc2FjCg==','midnightbsd'=>'dXNldmZvcms9J3RydWUnCmNhc2UgIiR1c2VteW1hbGxvYyIgaW4KICAgICIiKSB1c2VteW1hbGxv
  Yz0nbicKICAgICAgICA7Owplc2FjCmxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQg
  J3MvIG1hbGxvYyAvIC8nYAoKb2JqZm9ybWF0PWAvdXNyL2Jpbi9vYmpmb3JtYXRgCmlmIFsgeCRv
  Ympmb3JtYXQgPSB4YW91dCBdOyB0aGVuCiAgICBpZiBbIC1lIC91c3IvbGliL2FvdXQgXTsgdGhl
  bgogICAgICAgIGxpYnB0aD0iL3Vzci9saWIvYW91dCAvdXNyL2xvY2FsL2xpYiAvdXNyL2xpYiIK
  ICAgICAgICBnbGlicHRoPSIvdXNyL2xpYi9hb3V0IC91c3IvbG9jYWwvbGliIC91c3IvbGliIgog
  ICAgZmkKICAgIGxkZGxmbGFncz0nLUJzaGFyZWFibGUnCmVsc2UKICAgIGxpYnB0aD0iL3Vzci9s
  aWIgL3Vzci9sb2NhbC9saWIiCiAgICBnbGlicHRoPSIvdXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIK
  ICAgIGxkZmxhZ3M9Ii1XbCwtRSAiCiAgICBsZGRsZmxhZ3M9Ii1zaGFyZWQgIgpmaQpjY2NkbGZs
  YWdzPSctRFBJQyAtZlBJQycKCmNjZmxhZ3M9IiR7Y2NmbGFnc30gLURIQVNfRlBTRVRNQVNLIC1E
  SEFTX0ZMT0FUSU5HUE9JTlRfSCIKaWYgL3Vzci9iaW4vZmlsZSAtTCAvdXNyL2xpYi9saWJjLnNv
  IHwgL3Vzci9iaW4vZ3JlcCAtdnEgIm5vdCBzdHJpcHBlZCIgOyB0aGVuCiAgICB1c2VubT1mYWxz
  ZQpmaQoKc2lnbmFsX3Q9J3ZvaWQnCmRfdm9pZHNpZz0nZGVmaW5lJwoKIyBUaGlzIHNjcmlwdCBV
  VS91c2V0aHJlYWRzLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZSAKIyBh
  ZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMu
  CmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIgaW4K
  JGRlZmluZXx0cnVlfFt5WV0qKQoJbGRmbGFncz0iLXB0aHJlYWQgJGxkZmxhZ3MiCglzZXQgYGVj
  aG8gWCAiJGxpYnN3YW50ZWQgInwgc2VkIC1lICdzLyBjIC8vJ2AKCXNoaWZ0CglsaWJzd2FudGVk
  PSIkKiIKCSMgQ29uZmlndXJlIHdpbGwgcHJvYmFibHkgcGljayB0aGUgd3JvbmcgbGliYyB0byB1
  c2UgZm9yIG5tIHNjYW4uCgkjIFRoZSBzYWZlc3QgcXVpY2stZml4IGlzIGp1c3QgdG8gbm90IHVz
  ZSBubSBhdCBhbGwuLi4KCXVzZW5tPWZhbHNlCgogICAgICAgIHVuc2V0IGxjX3IKCgkjIEV2ZW4g
  d2l0aCB0aGUgbWFsbG9jIG11dGV4ZXMgdGhlIFBlcmwgbWFsbG9jIGRvZXMgbm90CgkjIHNlZW0g
  dG8gYmUgdGhyZWFkc2FmZSBpbiBNaWRuaWdodEJTRD8KCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4K
  CScnKSB1c2VteW1hbGxvYz1uIDs7Cgllc2FjCmVzYWMKRU9DQlUKCiMgbWFsbG9jIHdyYXAgd29y
  a3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7
  CmVzYWMK','netbsd'=>'IyBoaW50cy9uZXRic2Quc2gKIwojIFBsZWFzZSBjaGVjayB3aXRoIHBhY2thZ2VzQG5ldGJzZC5v
  cmcgYmVmb3JlIG1ha2luZyBtb2RpZmljYXRpb25zCiMgdG8gdGhpcyBmaWxlLgoKY2FzZSAiJGFy
  Y2huYW1lIiBpbgonJykKICAgIGFyY2huYW1lPWB1bmFtZSAtbWAtJHtvc25hbWV9CiAgICA7Owpl
  c2FjCgojIE5ldEJTRCBrZWVwcyBkeW5hbWljIGxvYWRpbmcgZGwqKCkgZnVuY3Rpb25zIGluIC91
  c3IvbGliL2NydDAubywKIyBzbyBDb25maWd1cmUgZG9lc24ndCBmaW5kIHRoZW0gKHVubGVzcyB5
  b3UgYWJhbmRvbiB0aGUgbm0gc2NhbikuCiMgQWxzbywgTmV0QlNEIDAuOWEgd2FzIHRoZSBmaXJz
  dCByZWxlYXNlIHRvIGludHJvZHVjZSBzaGFyZWQKIyBsaWJyYXJpZXMuCiMKY2FzZSAiJG9zdmVy
  cyIgaW4KMC45fDAuOCopCgl1c2VkbD0iJHVuZGVmIgoJOzsKKikKCWNhc2UgYHVuYW1lIC1tYCBp
  bgoJcG1heCkKCQkjIE5ldEJTRCAxLjMgYW5kIDEuMy4xIG9uIHBtYXggc2hpcHBlZCBhbiBgb2xk
  JyBsZC5zbywKCQkjIHdoaWNoIHdpbGwgbm90IHdvcmsuCgkJY2FzZSAiJG9zdmVycyIgaW4KCQkx
  LjN8MS4zLjEpCgkJCWRfZGxvcGVuPSR1bmRlZgoJCQk7OwoJCWVzYWMKCQk7OwoJZXNhYwoJaWYg
  dGVzdCAtZiAvdXNyL2xpYmV4ZWMvbGQuZWxmX3NvOyB0aGVuCgkJIyBFTEYKCQlkX2Rsb3Blbj0k
  ZGVmaW5lCgkJZF9kbGVycm9yPSRkZWZpbmUKCQljY2NkbGZsYWdzPSItRFBJQyAtZlBJQyAkY2Nj
  ZGxmbGFncyIKCQlsZGRsZmxhZ3M9Ii1zaGFyZWQgJGxkZGxmbGFncyIKCQljYXQgPlVVL2NjLmNi
  dSA8PCdFT0NCVScKIyBnY2MgNC42IGRvZXNuJ3Qgc3VwcG9ydCAtLXdob2xlLWFyY2hpdmUsIGJ1
  dCBpdCdzIHJlcXVpcmVkIGZvciB0aGUKIyBzeXN0ZW0gZ2NjIHRvIGJ1aWxkIGNvcnJlY3RseSwg
  c28gY2hlY2sgZm9yIGl0CmVjaG8gJ2ludCBmKHZvaWQpIHsgcmV0dXJuIDA7IH0nID50cnkuYwpp
  ZiAke2NjOi1jY30gJGNjY2RsZmxhZ3MgLWMgdHJ5LmMgLW90cnkubyAyPiYxICYmCiAgICR7Y2M6
  LWNjfSAtLXdob2xlLWFyY2hpdmUgJGxkZGxmbGFncyB0cnkubyAtb3RyeS5zbyAyPiYxIDsgdGhl
  bgogICAgbGRkbGZsYWdzPSItLXdob2xlLWFyY2hpdmUgJGxkZGxmbGFncyIKZmkKcm0gdHJ5LmMg
  dHJ5Lm8gdHJ5LnNvIDI+L2Rldi9udWxsCkVPQ0JVCgkJcnBhdGhmbGFnPSItV2wsLXJwYXRoLCIK
  CQljYXNlICIkb3N2ZXJzIiBpbgoJCTEuWzAtNV0qKQoJCQkjCgkJCSMgSW5jbHVkZSB0aGUgd2hv
  bGUgbGliZ2NjLmEgaW50byB0aGUgcGVybCBleGVjdXRhYmxlCgkJCSMgc28gdGhhdCBjZXJ0YWlu
  IHN5bWJvbHMgbmVlZGVkIGJ5IGxvYWRhYmxlIG1vZHVsZXMKCQkJIyBidWlsdCBhcyBDKysgb2Jq
  ZWN0cyAoX19laF9hbGxvYywgX19wdXJlX3ZpcnR1YWwsCgkJCSMgZXRjLikgd2lsbCBhbHdheXMg
  YmUgZGVmaW5lZC4KCQkJIwoJCQljY2RsZmxhZ3M9Ii1XbCwtd2hvbGUtYXJjaGl2ZSAtbGdjYyBc
  CgkJCQktV2wsLW5vLXdob2xlLWFyY2hpdmUgLVdsLC1FICRjY2RsZmxhZ3MiCgkJCTs7CgkJKikK
  CQkJY2NkbGZsYWdzPSItV2wsLUUgJGNjZGxmbGFncyIKCQkJOzsKCQllc2FjCgllbGlmIHRlc3Qg
  LWYgL3Vzci9saWJleGVjL2xkLnNvOyB0aGVuCgkJIyBhLm91dAoJCWRfZGxvcGVuPSRkZWZpbmUK
  CQlkX2RsZXJyb3I9JGRlZmluZQoJCWNjY2RsZmxhZ3M9Ii1EUElDIC1mUElDICRjY2NkbGZsYWdz
  IgoJCWxkZGxmbGFncz0iLUJzaGFyZWFibGUgJGxkZGxmbGFncyIKCQlycGF0aGZsYWc9Ii1SIgoJ
  ZWxzZQoJCWRfZGxvcGVuPSR1bmRlZgoJCXJwYXRoZmxhZz0KCWZpCgk7Owplc2FjCgojIG5ldGJz
  ZCBoYWQgdGhlc2UgYnV0IHRoZXkgZG9uJ3QgcmVhbGx5IHdvcmsgYXMgYWR2ZXJ0aXNlZCwgaW4g
  dGhlCiMgdmVyc2lvbnMgbGlzdGVkIGJlbG93LiAgaWYgdGhleSBhcmUgZGVmaW5lZCwgdGhlbiB0
  aGVyZSBpc24ndCBhCiMgd2F5IHRvIG1ha2UgcGVybCBjYWxsIHNldHVpZCgpIG9yIHNldGdpZCgp
  LiAgaWYgdGhleSBhcmVuJ3QsIHRoZW4KIyAoJDwsICQ+KSA9ICgkdSwgJHUpOyB3aWxsIHdvcmsg
  KHNhbWUgZm9yICQoLyQpKS4gIHRoaXMgaXMgYmVjYXVzZQojIHlvdSBjYW4gbm90IGNoYW5nZSB0
  aGUgcmVhbCB1c2VyaWQgb2YgYSBwcm9jZXNzIHVuZGVyIDQuNEJTRC4KIyBuZXRic2QgZml4ZWQg
  dGhpcyBpbiAxLjMuMi4KY2FzZSAiJG9zdmVycyIgaW4KMC45KnwxLlswMTJdKnwxLjN8MS4zLjEp
  CglkX3NldHJlZ2lkPSIkdW5kZWYiCglkX3NldHJldWlkPSIkdW5kZWYiCgk7Owplc2FjCmNhc2Ug
  IiRvc3ZlcnMiIGluCjAuOCopCgk7OwoqKQoJZF9nZXRwcm90b2VudF9yPSIkdW5kZWYiCglkX2dl
  dHByb3RvYnluYW1lX3I9IiR1bmRlZiIKCWRfZ2V0cHJvdG9ieW51bWJlcl9yPSIkdW5kZWYiCglk
  X3NldHByb3RvZW50X3I9IiR1bmRlZiIKCWRfZW5kcHJvdG9lbnRfcj0iJHVuZGVmIgoJZF9nZXRz
  ZXJ2ZW50X3I9IiR1bmRlZiIKCWRfZ2V0c2VydmJ5bmFtZV9yPSIkdW5kZWYiCglkX2dldHNlcnZi
  eXBvcnRfcj0iJHVuZGVmIgoJZF9zZXRzZXJ2ZW50X3I9IiR1bmRlZiIKCWRfZW5kc2VydmVudF9y
  PSIkdW5kZWYiCglkX2dldGhvc3RieW5hbWVfcj0iJHVuZGVmIgoJZF9nZXRob3N0YnlhZGRyMl9y
  PSIkdW5kZWYiCglkX2dldGhvc3RieWFkZHJfcj0iJHVuZGVmIgoJZF9zZXRob3N0ZW50X3I9IiR1
  bmRlZiIKCWRfZ2V0aG9zdGVudF9yPSIkdW5kZWYiCglkX2VuZGhvc3RlbnRfcj0iJHVuZGVmIgoJ
  ZF9nZXRwcm90b2VudF9yX3Byb3RvPSIwIgoJZF9nZXRwcm90b2J5bmFtZV9yX3Byb3RvPSIwIgoJ
  ZF9nZXRwcm90b2J5bnVtYmVyX3JfcHJvdG89IjAiCglkX3NldHByb3RvZW50X3JfcHJvdG89IjAi
  CglkX2VuZHByb3RvZW50X3JfcHJvdG89IjAiCglkX2dldHNlcnZlbnRfcl9wcm90bz0iMCIKCWRf
  Z2V0c2VydmJ5bmFtZV9yX3Byb3RvPSIwIgoJZF9nZXRzZXJ2Ynlwb3J0X3JfcHJvdG89IjAiCglk
  X3NldHNlcnZlbnRfcl9wcm90bz0iMCIKCWRfZW5kc2VydmVudF9yX3Byb3RvPSIwIgoJZF9nZXRo
  b3N0YnluYW1lX3JfcHJvdG89IjAiCglkX2dldGhvc3RieWFkZHIyX3JfcHJvdG89IjAiCglkX2dl
  dGhvc3RieWFkZHJfcl9wcm90bz0iMCIKCWRfc2V0aG9zdGVudF9yX3Byb3RvPSIwIgoJZF9lbmRo
  b3N0ZW50X3JfcHJvdG89IjAiCglkX2dldGhvc3RlbnRfcl9wcm90bz0iMCIKCTs7CmVzYWMKCiMg
  VGhlc2UgYXJlIG9ic29sZXRlIGluIGFueSBuZXRic2QuCmRfc2V0cmdpZD0iJHVuZGVmIgpkX3Nl
  dHJ1aWQ9IiR1bmRlZiIKCiMgdGhlcmUncyBubyBwcm9ibGVtIHdpdGggdmZvcmsuCnVzZXZmb3Jr
  PXRydWUKCiMgVGhpcyBpcyB0aGVyZSBidXQgaW4gbWFjaGluZS9pZWVlZnBfaC4KaWVlZWZwX2g9
  ImRlZmluZSIKCiMgVGhpcyBzY3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxl
  ZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9y
  IHdoZXRoZXIgdG8gdXNlIHRocmVhZHMuCmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JV
  JwpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRlZmluZXx0cnVlfFt5WV0qKQoJbHB0aHJlYWQ9Cglm
  b3IgeHh4IGluIHB0aHJlYWQ7IGRvCgkJZm9yIHl5eSBpbiAkbG9jbGlicHRoICRwbGlicHRoICRn
  bGlicHRoIGR1bW15OyBkbwoJCQl6eno9JHl5eS9saWIkeHh4LmEKCQkJaWYgdGVzdCAtZiAiJHp6
  eiI7IHRoZW4KCQkJCWxwdGhyZWFkPSR4eHgKCQkJCWJyZWFrOwoJCQlmaQoJCQl6eno9JHl5eS9s
  aWIkeHh4LnNvCgkJCWlmIHRlc3QgLWYgIiR6enoiOyB0aGVuCgkJCQlscHRocmVhZD0keHh4CgkJ
  CQlicmVhazsKCQkJZmkKCQkJenp6PWBscyAkeXl5L2xpYiR4eHguc28uKiAyPi9kZXYvbnVsbGAK
  CQkJaWYgdGVzdCAiWCR6enoiICE9IFg7IHRoZW4KCQkJCWxwdGhyZWFkPSR4eHgKCQkJCWJyZWFr
  OwoJCQlmaQoJCWRvbmUKCQlpZiB0ZXN0ICJYJGxwdGhyZWFkIiAhPSBYOyB0aGVuCgkJCWJyZWFr
  OwoJCWZpCglkb25lCglpZiB0ZXN0ICJYJGxwdGhyZWFkIiAhPSBYOyB0aGVuCgkJIyBBZGQgLWxw
  dGhyZWFkLgoJCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkICRscHRocmVhZCIKCQkjIFRoZXJlIGlz
  IG5vIGxpYmNfciBhcyBvZiBOZXRCU0QgMS41LjIsIHNvIG5vIGMgLT4gY19yLgoJCSMgVGhpcyB3
  aWxsIGJlIHJldmlzaXRlZCB3aGVuIE5ldEJTRCBnYWlucyBhIG5hdGl2ZSBwdGhyZWFkcwoJCSMg
  aW1wbGVtZW50YXRpb24uCgllbHNlCgkJZWNobyAiJDA6IE5vIFBPU0lYIHRocmVhZHMgbGlicmFy
  eSAoLWxwdGhyZWFkKSBmb3VuZC4gICIgXAoJCSAgICAgIllvdSBtYXkgd2FudCB0byBpbnN0YWxs
  IEdOVSBwdGguICBBYm9ydGluZy4iID4mNAoJCWV4aXQgMQoJZmkKCXVuc2V0IGxwdGhyZWFkCgoJ
  IyBzZXZlcmFsIHJlZW50cmFudCBmdW5jdGlvbnMgYXJlIGVtYmVkZGVkIGluIGxpYmMsIGJ1dCBo
  YXZlbid0CgkjIGJlZW4gYWRkZWQgdG8gdGhlIGhlYWRlciBmaWxlcyB5ZXQuICBMZXQncyBob2xk
  IG9mZiBvbiB1c2luZwoJIyB0aGVtIHVudGlsIHRoZXkgYXJlIGEgdmFsaWQgcGFydCBvZiB0aGUg
  QVBJCgljYXNlICIkb3N2ZXJzIiBpbgoJWzAxMl0uKnwzLlswLTFdKQoJCWRfZ2V0cHJvdG9ieW5h
  bWVfcj0kdW5kZWYKCQlkX2dldHByb3RvYnludW1iZXJfcj0kdW5kZWYKCQlkX2dldHByb3RvZW50
  X3I9JHVuZGVmCgkJZF9nZXRzZXJ2YnluYW1lX3I9JHVuZGVmCgkJZF9nZXRzZXJ2Ynlwb3J0X3I9
  JHVuZGVmCgkJZF9nZXRzZXJ2ZW50X3I9JHVuZGVmCgkJZF9zZXRwcm90b2VudF9yPSR1bmRlZgoJ
  CWRfc2V0c2VydmVudF9yPSR1bmRlZgoJCWRfZW5kcHJvdG9lbnRfcj0kdW5kZWYKCQlkX2VuZHNl
  cnZlbnRfcj0kdW5kZWYgOzsKCWVzYWMKCTs7Cgplc2FjCkVPQ0JVCgojIFNldCBzZW5zaWJsZSBk
  ZWZhdWx0cyBmb3IgTmV0QlNEOiBsb29rIGZvciBsb2NhbCBzb2Z0d2FyZSBpbgojIC91c3IvcGtn
  IChOZXRCU0QgUGFja2FnZXMgQ29sbGVjdGlvbikgYW5kIGluIC91c3IvbG9jYWwuCiMKbG9jbGli
  cHRoPSIvdXNyL3BrZy9saWIgL3Vzci9sb2NhbC9saWIiCmxvY2luY3B0aD0iL3Vzci9wa2cvaW5j
  bHVkZSAvdXNyL2xvY2FsL2luY2x1ZGUiCmNhc2UgIiRycGF0aGZsYWciIGluCicnKQoJbGRmbGFn
  cz0KCTs7CiopCglsZGZsYWdzPQoJZm9yIHl5eSBpbiAkbG9jbGlicHRoOyBkbwoJCWxkZmxhZ3M9
  IiRsZGZsYWdzICRycGF0aGZsYWckeXl5IgoJZG9uZQoJOzsKZXNhYwoKY2FzZSBgdW5hbWUgLW1g
  IGluCmFscGhhKQogICAgZWNobyAnaW50IG1haW4oKSB7fScgPiB0cnkuYwogICAgZ2NjPWAke2Nj
  Oi1jY30gLXYgLWMgdHJ5LmMgMj4mMXxncmVwICdnY2MgdmVyc2lvbiBlZ2NzLTInYAogICAgY2Fz
  ZSAiJGdjYyIgaW4KICAgICcnIHwgImdjYyB2ZXJzaW9uIGVnY3MtMi45NS4iWzMtOV0qKSA7OyAj
  IDIuOTUuMyBvciBiZXR0ZXIgb2theQogICAgKikJY2F0ID4mNCA8PEVPRgoqKioKKioqIFlvdXIg
  Z2NjICgkZ2NjKSBpcyBrbm93biB0byBiZQoqKiogdG9vIGJ1Z2d5IG9uIG5ldGJzZC9hbHBoYSB0
  byBjb21waWxlIFBlcmwgd2l0aCBvcHRpbWl6YXRpb24uCioqKiBJdCBpcyBzdWdnZXN0ZWQgeW91
  IGluc3RhbGwgdGhlIGxhbmcvZ2NjIHBhY2thZ2Ugd2hpY2ggc2hvdWxkCioqKiBoYXZlIGF0IGxl
  YXN0IGdjYyAyLjk1LjMgd2hpY2ggc2hvdWxkIHdvcmsgb2theTogdXNlIGZvciBleGFtcGxlCioq
  KiBDb25maWd1cmUgLURjYz0vdXNyL3BrZy9nY2MtMi45NS4zL2Jpbi9jYy4gIFlvdSBjb3VsZCBh
  bHNvCioqKiBDb25maWd1cmUgLURvcHRpbWl6ZT0tTzAgdG8gY29tcGlsZSBQZXJsIHdpdGhvdXQg
  YW55IG9wdGltaXphdGlvbgoqKiogYnV0IHRoYXQgaXMgbm90IHJlY29tbWVuZGVkLgoqKioKRU9G
  CglleGl0IDEKCTs7CiAgICBlc2FjCiAgICBybSAtZiB0cnkuKgogICAgOzsKZXNhYwoKIyBOZXRC
  U0Qvc3BhcmMgMS41LjMvMS42LjEgZHVtcHMgY29yZSBpbiB0aGUgc2VtaWRfZHMgdGVzdCBvZiBD
  b25maWd1cmUuCmNhc2UgYHVuYW1lIC1tYCBpbgpzcGFyYykgZF9zZW1jdGxfc2VtaWRfZHM9dW5k
  ZWYgOzsKZXNhYwoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4K
  JycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBkb24ndCB1c2UgcGVybCBtYWxs
  b2MgYnkgZGVmYXVsdApjYXNlICIkdXNlbXltYWxsb2MiIGluCicnKSB1c2VteW1hbGxvYz1uIDs7
  CmVzYWMKCiMgTmV0QlNEIDYgZGVmaW5lcyB0aGUgKmF0KCkgZnVuY3Rpb25zIGluIGxpYmMsIGJ1
  dCBlaXRoZXIgZG9lc24ndAojIGltcGxlbWVudCB0aGVtLCBvciBpbXBsZW1lbnRzIHRoZW0gb25s
  eSBmb3IgQVRfRkRDV0QKY2FzZSAiJG9zdmVyIiBpbgpbMS02XS4qKQogICAgICAgIGRfdW5saW5r
  YXQ9IiR1bmRlZiIKICAgICAgICBkX3JlbmFtZWF0PSIkdW5kZWYiCiAgICAgICAgZF9saW5rYXQ9
  IiR1bmRlZiIKICAgICAgICBkX2ZjaG1vZGF0PSIkdW5kZWYiCiAgICAgICAgOzsKZXNhYwoKY2F0
  ID5VVS91c2Vsb25nZG91YmxlLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2Vsb25n
  ZG91YmxlLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0
  IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbG9uZyBkb3VibGVzLgoj
  CiMgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9QZXJsL3Blcmw1L2lzc3Vlcy8xNzg1MyBhbmQgaHR0
  cHM6Ly9naXRodWIuY29tL1BlcmwvcGVybDUvaXNzdWVzLzE3ODU0CmNhc2UgIiR1c2Vsb25nZG91
  YmxlIiBpbgokZGVmaW5lfHRydWV8W3lZXSopCiAgICBjYXQgPnRyeS5jIDw8XFRSWQojaW5jbHVk
  ZSA8c3RkaW8uaD4KI2luY2x1ZGUgPG1hdGguaD4KCmxvbmcgZG91YmxlIHggPSAxLjA7CgppbnQg
  bWFpbihpbnQgYXJnYywgY2hhciAqKmFyZ3YpIHsKICAgIGRvdWJsZSBlMSA9IGV4cCgxLjApOwog
  ICAgLyogYXMgb2YgTmV0QlNEIDkuMCBleHBsKCkganVzdCBjYWxscyBleHAoKSwKICAgICAgIEZh
  aWwgaGVyZSBpZiB0aGV5J3JlIGVxdWFsLiAqLwogICAgcmV0dXJuIGV4cGwoeCkgPT0gKGxvbmcg
  ZG91YmxlKWUxOwp9ClRSWQogICAgaWYgJGNjIC1vIHRyeSAkY2NmbGFncyAkbGRmbGFncyB0cnku
  YyAtbG0gJiYgJHJ1biAuL3RyeTsgdGhlbgogICAgICAgIGVjaG8gIk5ldEJTRCBzZWVtIHRvIGhh
  dmUgZml4ZWQgZXhwbCAoYW5kIGhvcGVmdWxseSBtb3JlKSIgPiY0CiAgICBlbHNlCiAgICAgICAg
  Y2F0IDw8RU9NID4mNAoKV2FybmluZyEgTmV0QlNEJ3MgbG9uZyBkb3VibGUgc3VwcG9ydCBpcyBs
  aW1pdGVkIGVub3VnaCB0aGF0IGl0IHdpbGwgY2F1c2UKdGVzdCBmYWlsdXJlcywgYW5kIHBvc3Np
  Ymx5IGJ1aWxkIGZhaWx1cmVzLCBhbmQgdGhpcyBkb2Vzbid0IGFwcGVhciB0byBoYXZlCmJlZW4g
  Zml4ZWQgaW4gdGhlIHJlbGVhc2UgeW91J3JlIHJ1bm5pbmcuCgpFT00KICAgIGZpCjs7CmVzYWMK
  RU9DQlUK','openbsd'=>'IyBoaW50cy9vcGVuYnNkLnNoCiMKIyBoaW50cyBmaWxlIGZvciBPcGVuQlNEOyBUb2RkIE1pbGxl
  ciA8bWlsbGVydEBvcGVuYnNkLm9yZz4KIyBFZGl0ZWQgdG8gYWxsb3cgQ29uZmlndXJlIGNvbW1h
  bmQtbGluZSBvdmVycmlkZXMgYnkKIyAgQW5keSBEb3VnaGVydHkgPGRvdWdoZXJhQGxhZmF5ZXR0
  ZS5lZHU+CiMKIyBUbyBidWlsZCB3aXRoIGRpc3RyaWJ1dGlvbiBwYXRocywgdXNlOgojCS4vQ29u
  ZmlndXJlIC1kZXMgLURvcGVuYnNkX2Rpc3RyaWJ1dGlvbj1kZWZpbmVkCiMKCiMgT3BlbkJTRCBo
  YXMgYSBiZXR0ZXIgbWFsbG9jIHRoYW4gcGVybC4uLgp0ZXN0ICIkdXNlbXltYWxsb2MiIHx8IHVz
  ZW15bWFsbG9jPSduJwoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIg
  aW4KJycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBDdXJyZW50bHksIHZmb3Jr
  KDIpIGlzIG5vdCBhIHJlYWwgd2luIG92ZXIgZm9yaygyKS4KdXNldmZvcms9IiR1bmRlZiIKCiMg
  SW4gT3BlbkJTRCA8IDMuMywgdGhlIHNldHJlP1t1Z11pZCgpIGFyZSBlbXVsYXRlZCB1c2luZyB0
  aGUKIyBfUE9TSVhfU0FWRURfSURTIGZ1bmN0aW9uYWxpdHkgd2hpY2ggZG9lcyBub3QgaGF2ZSB0
  aGUgc2FtZQojIHNlbWFudGljcyBhcyA0LjNCU0QuICBTdGFydGluZyB3aXRoIE9wZW5CU0QgMy4z
  LCB0aGUgb3JpZ2luYWwKIyBzZW1hbnRpY3MgaGF2ZSBiZWVuIHJlc3RvcmVkLgpjYXNlICIkb3N2
  ZXJzIiBpbgpbMC0yXS4qfDMuWzAtMl0pCglkX3NldHJlZ2lkPSR1bmRlZgoJZF9zZXRyZXVpZD0k
  dW5kZWYKCWRfc2V0cmdpZD0kdW5kZWYKCWRfc2V0cnVpZD0kdW5kZWYKZXNhYwoKIwojIE5vdCBh
  bGwgcGxhdGZvcm1zIHN1cHBvcnQgZHluYW1pYyBsb2FkaW5nLi4uCiMgRm9yIHRoZSBjYXNlIG9m
  ICIkb3BlbmJzZF9kaXN0cmlidXRpb24iLCB0aGUgaGludHMgZmlsZQojIG5lZWRzIHRvIGtub3cg
  d2hldGhlciB3ZSBhcmUgdXNpbmcgZHluYW1pYyBsb2FkaW5nIHNvIHRoYXQKIyBpdCBjYW4gc2V0
  IHRoZSBsaWJwZXJsIG5hbWUgYXBwcm9wcmlhdGVseS4KIyBBbGxvdyBjb21tYW5kIGxpbmUgb3Zl
  cnJpZGVzLgojCkFSQ0g9YGFyY2ggfCBzZWQgJ3MvXk9wZW5CU0QuLy8nYApjYXNlICIke0FSQ0h9
  LSR7b3N2ZXJzfSIgaW4KYWxwaGEtMi5bMC04XXxtaXBzLTIuWzAtOF18cG93ZXJwYy0yLlswLTdd
  fG04OGstWzItNF0uKnxtODhrLTUuWzAtMl18aHBwYS0zLlswLTVdfHZheC0qKQoJdGVzdCAteiAi
  JHVzZWRsIiAmJiB1c2VkbD0kdW5kZWYKCTs7CiopCgl0ZXN0IC16ICIkdXNlZGwiICYmIHVzZWRs
  PSRkZWZpbmUKCSMgV2UgdXNlIC1mUElDIGhlcmUgYmVjYXVzZSAtZnBpYyBpcyAqTk9UKiBlbm91
  Z2ggZm9yIHNvbWUgb2YgdGhlCgkjIGV4dGVuc2lvbnMgbGlrZSBUayBvbiBzb21lIE9wZW5CU0Qg
  cGxhdGZvcm1zIChpZTogc3BhcmMpCgljY2NkbGZsYWdzPSItRFBJQyAtZlBJQyAkY2NjZGxmbGFn
  cyIKCWNhc2UgIiRvc3ZlcnMiIGluCglbMDFdLip8Mi5bMC03XXwyLlswLTddLiopCgkJbGRkbGZs
  YWdzPSItQnNoYXJlYWJsZSAkbGRkbGZsYWdzIgoJCTs7CgkyLls4LTldfDMuMCkKCQlsZD0ke2Nj
  Oi1jY30KCQlsZGRsZmxhZ3M9Ii1zaGFyZWQgLWZQSUMgJGxkZGxmbGFncyIKCQk7OwoJKikgIyBm
  cm9tIDMuMSBvbndhcmRzCgkJbGQ9JHtjYzotY2N9CgkJbGRkbGZsYWdzPSItc2hhcmVkIC1mUElD
  ICRsZGRsZmxhZ3MiCgkJbGlic3dhbnRlZD1gZWNobyAkbGlic3dhbnRlZCB8IHNlZCAncy8gZGwg
  LyAvJ2AKCQk7OwoJZXNhYwoKCSMgV2UgbmVlZCB0byBmb3JjZSBsZCB0byBleHBvcnQgc3ltYm9s
  cyBvbiBFTEYgcGxhdGZvcm1zLgoJIyBXaXRob3V0IHRoaXMsIGRsb3BlbigpIGlzIGNyaXBwbGVk
  LgoJRUxGPWAke2NjOi1jY30gLWRNIC1FIC0gPC9kZXYvbnVsbCB8IGdyZXAgX19FTEZfX2AKCXRl
  c3QgLW4gIiRFTEYiICYmIGxkZmxhZ3M9Ii1XbCwtRSAkbGRmbGFncyIKCTs7CmVzYWMKCiMKIyBU
  d2Vha3MgZm9yIHZhcmlvdXMgdmVyc2lvbnMgb2YgT3BlbkJTRAojCmNhc2UgIiRvc3ZlcnMiIGlu
  CjIuNSkKCSMgT3BlbkJTRCAyLjUgaGFzIGJyb2tlbiBvZGJtIHN1cHBvcnQKCWlfZGJtPSR1bmRl
  ZgoJOzsKZXNhYwoKIyBPcGVuQlNEIGRvZXNuJ3QgbmVlZCBsaWJjcnlwdCBidXQgbWFueSBmb2xr
  cyBrZWVwIGEgc3R1YiBsaWIKIyBhcm91bmQgZm9yIG9sZCBOZXRCU0QgYmluYXJpZXMuCmxpYnN3
  YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQgJ3MvIGNyeXB0IC8gLydgCgojIENvbmZpZ3Vy
  ZSBjYW4ndCBmaWd1cmUgdGhpcyBvdXQgbm9uLWludGVyYWN0aXZlbHkKZF9zdWlkc2FmZT0kZGVm
  aW5lCgojIGNjIGlzIGdjYyBzbyB3ZSBjYW4gZG8gYmV0dGVyIHRoYW4gLU8KIyBBbGxvdyBhIGNv
  bW1hbmQtbGluZSBvdmVycmlkZSwgc3VjaCBhcyAtRG9wdGltaXplPS1nCmNhc2UgIiR7QVJDSH0t
  JHtvc3ZlcnN9IiBpbgpocHBhLTMuM3xtODhrLTIuKnxtODhrLTMuWzAtM10pCiAgIHRlc3QgIiRv
  cHRpbWl6ZSIgfHwgb3B0aW1pemU9Jy1PMCcKICAgOzsKbTg4ay0zLjQpCiAgIHRlc3QgIiRvcHRp
  bWl6ZSIgfHwgb3B0aW1pemU9Jy1PMScKICAgOzsKKikKICAgdGVzdCAiJG9wdGltaXplIiB8fCBv
  cHRpbWl6ZT0nLU8yJwogICA7Owplc2FjCgojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1
  IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlIAojIGFmdGVyIGl0IGhhcyBwcm9t
  cHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgdGhyZWFkcy4KY2F0ID4gVVUvdXNldGhy
  ZWFkcy5jYnUgPDwnRU9DQlUnCmNhc2UgIiR1c2V0aHJlYWRzIiBpbgokZGVmaW5lfHRydWV8W3lZ
  XSopCgkjIGFueSBvcGVuYnNkIHZlcnNpb24gZGVwZW5kZW5jaWVzIHdpdGggcHRocmVhZHM/Cglj
  Y2ZsYWdzPSItcHRocmVhZCAkY2NmbGFncyIKCWxkZmxhZ3M9Ii1wdGhyZWFkICRsZGZsYWdzIgoJ
  Y2FzZSAiJG9zdmVycyIgaW4KCVswLTJdLip8My5bMC0yXSkKCQkjIENoYW5nZSBmcm9tIC1sYyB0
  byAtbGNfcgoJCXNldCBgZWNobyAiWCAkbGlic3dhbnRlZCAiIHwgc2VkICdzLyBjIC8gY19yIC8n
  YAoJCXNoaWZ0CgkJbGlic3dhbnRlZD0iJCoiCgk7OwoJZXNhYwoJY2FzZSAiJG9zdmVycyIgaW4K
  CVswMTJdLip8My5bMC02XSkKICAgICAgICAJIyBCcm9rZW4gdXAgdG8gT3BlbkJTRCAzLjYsIGZp
  eGVkIGluIE9wZW5CU0QgMy43CgkJZF9nZXRzZXJ2YnluYW1lX3I9JHVuZGVmIDs7Cgllc2FjCmVz
  YWMKRU9DQlUKCiMgV2hlbiBidWlsZGluZyBpbiB0aGUgT3BlbkJTRCB0cmVlIHdlIHVzZSBkaWZm
  ZXJlbnQgcGF0aHMKIyBUaGlzIGlzIG9ubHkgcGFydCBvZiB0aGUgc3RvcnksIHRoZSByZXN0IGNv
  bWVzIGZyb20gY29uZmlnLm92ZXIKY2FzZSAiJG9wZW5ic2RfZGlzdHJpYnV0aW9uIiBpbgonJ3wk
  dW5kZWZ8ZmFsc2UpIDs7CiopCgkjIFdlIHB1dCB0aGluZ3MgaW4gL3Vzciwgbm90IC91c3IvbG9j
  YWwKCXByZWZpeD0nL3VzcicKCXByZWZpeGV4cD0nL3VzcicKCXN5c21hbj0nL3Vzci9zaGFyZS9t
  YW4vbWFuMScKCWxpYnB0aD0nL3Vzci9saWInCglnbGlicHRoPScvdXNyL2xpYicKCSMgTG9jYWwg
  dGhpbmdzLCBob3dldmVyLCBkbyBnbyBpbiAvdXNyL2xvY2FsCglzaXRlcHJlZml4PScvdXNyL2xv
  Y2FsJwoJc2l0ZXByZWZpeGV4cD0nL3Vzci9sb2NhbCcKCSMgUG9ydHMgaW5zdGFsbHMgbm9uLXN0
  ZCBsaWJzIGluIC91c3IvbG9jYWwvbGliIHNvIGxvb2sgdGhlcmUgdG9vCglsb2NpbmNwdGg9Jy91
  c3IvbG9jYWwvaW5jbHVkZScKCWxvY2xpYnB0aD0nL3Vzci9sb2NhbC9saWInCgkjIExpbmsgcGVy
  bCB3aXRoIHNoYXJlZCBsaWJwZXJsCglpZiBbICIkdXNlZGwiID0gIiRkZWZpbmUiIC1hIC1yIHNo
  bGliX3ZlcnNpb24gXTsgdGhlbgoJCXVzZXNocnBsaWI9dHJ1ZQoJCWxpYnBlcmw9YC4gLi9zaGxp
  Yl92ZXJzaW9uOyBlY2hvIGxpYnBlcmwuc28uJHttYWpvcn0uJHttaW5vcn1gCglmaQoJOzsKZXNh
  YwoKIyBvcGVuYnNkIGhhcyBhIHByb2JsZW0gcmVnYXJkaW5nIG5ld2xvY2FsZSgpCiMgaHR0cHM6
  Ly9tYXJjLmluZm8vP2w9b3BlbmJzZC1idWdzJm09MTU1MzY0NTY4NjA4NzU5Jnc9MgojIHdoaWNo
  IGlzIGJlaW5nIGZpeGVkLiAgSW4gdGhlIG1lYW50aW1lLCBmb3JiaWQgUE9TSVggMjAwOCBsb2Nh
  bGVzCmRfbmV3bG9jYWxlPSIkdW5kZWYiCgojIGVuZAo=','solaris'=>'IyBoaW50cy9zb2xhcmlzXzIuc2gKIyBDb250cmlidXRpb25zIGJ5IChpbiBhbHBoYWJldGljYWwg
  b3JkZXIpIEFsYW4gQnVybGlzb24sIEFuZHkgRG91Z2hlcnR5LAojIERlYW4gUm9laHJpY2gsIEph
  cmtrbyBIaWV0YW5pZW1pLCBMdXBlIENocmlzdG9waCwgUmljaGFyZCBTb2RlcmJlcmcgYW5kCiMg
  bWFueSBvdGhlcnMuCiMKIyBTZWUgUkVBRE1FLnNvbGFyaXMgZm9yIGFkZGl0aW9uYWwgaW5mb3Jt
  YXRpb24uCiMKIyBGb3IgY29uc2lzdGVuY3kgd2l0aCBnY2MsIHdlIGRvIG5vdCBhZG9wdCBTdW4g
  TWFya2V0aW5nJ3MKIyByZW1vdmFsIG9mIHRoZSAnMi4nIHByZWZpeCBmcm9tIHRoZSBTb2xhcmlz
  IHZlcnNpb24gbnVtYmVyLgojIChDb25maWd1cmUgdHJpZXMgdG8gZGV0ZWN0IGFuIG9sZCBmaXhp
  bmNsdWRlcyBhbmQgbmVlZHMKIyB0aGlzIGluZm9ybWF0aW9uLikKCiMgSWYgcGVybCBmYWlscyB0
  ZXN0cyB0aGF0IGludm9sdmUgZHluYW1pYyBsb2FkaW5nIG9mIGV4dGVuc2lvbnMsIGFuZAojIHlv
  dSBhcmUgdXNpbmcgZ2NjLCBiZSBzdXJlIHRoYXQgeW91IGFyZSBOT1QgdXNpbmcgR05VIGFzIGFu
  ZCBsZC4gIE9uZQojIHdheSB0byBkbyB0aGF0IGlzIHRvIGludm9rZSBDb25maWd1cmUgd2l0aAoj
  CiMgICAgIHNoIENvbmZpZ3VyZSAtRGNjPSdnY2MgLUIvdXNyL2Njcy9iaW4vJwojCiMgIChOb3Rl
  IHRoYXQgdGhlIHRyYWlsaW5nIHNsYXNoIGlzICpyZXF1aXJlZCouKQojICBnY2Mgd2lsbCBvY2Nh
  c2lvbmFsbHkgZW1pdCB3YXJuaW5ncyBhYm91dCAidW51c2VkIHByZWZpeCIsIGJ1dAojICB0aGVz
  ZSBvdWdodCB0byBiZSBoYXJtbGVzcy4gIFNlZSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLgoKIyBT
  b2xhcmlzIGhhcyBzZWN1cmUgU1VJRCBzY3JpcHRzCmRfc3VpZHNhZmU9JHtkX3N1aWRzYWZlOi1k
  ZWZpbmV9CgojIEJlIHBhcmFub2lkIGFib3V0IG5tIGZhaWxpbmcgdG8gZmluZCBzeW1ib2xzCm1p
  c3RydXN0bm09JHttaXN0cnVzdG5tOi1ydW59CgojIFNldmVyYWwgcGVvcGxlIHJlcG9ydGVkIHBy
  b2JsZW1zIHdpdGggcGVybCdzIG1hbGxvYywgZXNwZWNpYWxseQojIHdoZW4gdXNlNjRiaXRhbGwg
  aXMgZGVmaW5lZCBvciB3aGVuIHVzaW5nIGdjYy4KIyAgICAgaHR0cDovL3d3dy54cmF5Lm1wZS5t
  cGcuZGUvbWFpbGluZy1saXN0cy9wZXJsNS1wb3J0ZXJzLzIwMDEtMDEvbXNnMDEzMTguaHRtbAoj
  ICAgICBodHRwOi8vd3d3LnhyYXkubXBlLm1wZy5kZS9tYWlsaW5nLWxpc3RzL3Blcmw1LXBvcnRl
  cnMvMjAwMS0wMS9tc2cwMDQ2NS5odG1sCnVzZW15bWFsbG9jPSR7dXNlbXltYWxsb2M6LWZhbHNl
  fQoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4KJycpIHVzZW1h
  bGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBBdm9pZCBhbGwgbGlicmFyaWVzIGluIC91c3Iv
  dWNibGliLgojIC9saWIgaXMganVzdCBhIHN5bWxpbmsgdG8gL3Vzci9saWIKc2V0IGBlY2hvICRn
  bGlicHRoIHwgc2VkIC1lICdzQC91c3IvdWNibGliQEAnIC1lICdzQCAvbGliIEAgQCdgCmdsaWJw
  dGg9IiQqIgoKIyBTdGFydGluZyB3aXRoIFNvbGFyaXMgMTAsIHdlIGRvbid0IHdhbnQgdmVyc2lv
  bmVkIHNoYXJlZCBsaWJyYXJpZXMgYmVjYXVzZQojIHRob3NlIG9mdGVuIGluZGljYXRlIGEgcHJp
  dmF0ZSB1c2Ugb25seSBsaWJyYXJ5LiAgRXNwZWNpYWxseSBiYWRseSB0aGF0IHdvdWxkCiMgYnJl
  YWsgdGhpbmdzIHdpdGggU1VOV2JkYiAoQmVya2VsZXkgREIpIGJlaW5nIGluc3RhbGxlZCwgd2hp
  Y2ggYnJpbmdzIGluCiMgL3Vzci9saWIvbGliZGIuc28uMSwgYnV0IHRoYXQgaXMgbm90IHJlYWxs
  eSBtZWFudCBmb3IgcHVibGljIGNvbnN1bXB0aW9uLgojICBYWFggUmV2aXNpdCBhZnRlciBwZXJs
  IDUuMTAgLS0gc2hvdWxkIHdlIGFwcGx5IHRoaXMgdG8gb2xkZXIgU29sYXJpcwojIHZlcnNpb25z
  IHRvbz8gIChBLkQuIDExLzIwMDcpLgpjYXNlICJgJHJ1biB1bmFtZSAtcmAiIGluCjUuWzAtOV0p
  IDs7CiopIGlnbm9yZV92ZXJzaW9uZWRfc29saWJzPXkgOzsKZXNhYwoKIyBSZW1vdmUgdW53YW50
  ZWQgbGlicmFyaWVzLiAgLWx1Y2IgY29udGFpbnMgaW5jb21wYXRpYmxlIHJvdXRpbmVzLgojIC1s
  bGQgYW5kIC1sc2VjIGRvbid0IGRvIGFueXRoaW5nIHVzZWZ1bC4gLWxjcnlwdCBkb2VzIG5vdAoj
  IHJlYWxseSBwcm92aWRlIGFueXRoaW5nIHdlIG5lZWQgb3ZlciAtbGMsIHNvIHdlIGRyb3AgaXQs
  IHRvby4KIyAtbG1hbGxvYyBjYW4gY2F1c2UgYSBwcm9ibGVtIHdpdGggR05VIENDICYgU29sYXJp
  cy4gIFNwZWNpZmljYWxseSwKIyBsaWJtYWxsb2MuYSBtYXkgYWxsb2NhdGUgbWVtb3J5IHRoYXQg
  aXMgb25seSA0IGJ5dGUgYWxpZ25lZCwgYnV0CiMgR05VIENDIG9uIHRoZSBTcGFyYyBhc3N1bWVz
  IHRoYXQgZG91YmxlcyBhcmUgOCBieXRlIGFsaWduZWQuCiMgVGhhbmtzIHRvICBIYWxsdmFyZCBC
  LiBGdXJ1c2V0aCA8aC5iLmZ1cnVzZXRoQHVzaXQudWlvLm5vPgpzZXQgYGVjaG8gIiAkbGlic3dh
  bnRlZCAiIHwgc2VkIC1lICdzQCBsZCBAIEAnIC1lICdzQCBtYWxsb2MgQCBAJyAtZSAnc0AgdWNi
  IEAgQCcgLWUgJ3NAIHNlYyBAIEAnIC1lICdzQCBjcnlwdCBAIEAnYApsaWJzd2FudGVkPSIkKiIK
  CiMgTG9vayBmb3IgYXJjaGl0ZWN0dXJlIG5hbWUuICBXZSB3YW50IHRvIHN1Z2dlc3QgYSB1c2Vm
  dWwgZGVmYXVsdC4KY2FzZSAiJGFyY2huYW1lIiBpbgonJykKICAgIGlmIHRlc3QgLWYgL3Vzci9i
  aW4vYXJjaDsgdGhlbgoJYXJjaG5hbWU9YC91c3IvYmluL2FyY2hgCglhcmNobmFtZT0iJHthcmNo
  bmFtZX0tJHtvc25hbWV9IgogICAgZWxpZiB0ZXN0IC1mIC91c3IvdWNiL2FyY2g7IHRoZW4KCWFy
  Y2huYW1lPWAvdXNyL3VjYi9hcmNoYAoJYXJjaG5hbWU9IiR7YXJjaG5hbWV9LSR7b3NuYW1lfSIK
  ICAgIGZpCiAgICA7Owplc2FjCgojCiMgVGhpcyBleHRyYWN0cyB0aGUgbGlicmFyeSBkaXJlY3Rv
  cmllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQgYnkgdGhlIFN1bgojIFdvcmtzaG9wIGNvbXBpbGVy
  LCBnaXZlbiB0aGUgY29tbWFuZC1saW5lIHN1cHBsaWVkIGluICR0cnl3b3Jrc2hvcGNjLgojIFVz
  ZSB0aHVzbHk6IGxvY2xpYnB0aD0iYCRnZXR3b3Jrc2hvcGxpYnNgICRsb2NsaWJwdGgiCiMKCWdl
  dHdvcmtzaG9wbGlicz1gY2F0IDw8J0VORCcKZXZhbCAkdHJ5d29ya3Nob3BjYyAtIyMjIDI+JjEg
  fCBcCnNlZCAtbiAnLyAtWSAvcyEuKiAtWSAiUCxcKFteIl0qXCkiLiohXDEhcCcgfCB0ciAnOicg
  JyAnIHwgXApzZWQgLWUgJ3MhL3Vzci9saWIvc3BhcmN2OSEhJyAtZSAncyEvdXNyL2Njcy9saWIv
  c3BhcmN2OSEhJyBcCiAgICAtZSAncyEvdXNyL2xpYiEhZycgLWUgJ3MhL3Vzci9jY3MvbGliISFn
  JwpFTkQKYAoKY2FzZSAiJGNjIiBpbgonJykgICAgZm9yIGkgaW4gYGxzIC1yIC9vcHQvKnN0dWRp
  byovYmluL2NjYCAvb3B0L1NVTldzcHJvL2Jpbi9jYwogICAgICAgZG8KCSAgICAgICBpZiB0ZXN0
  IC1mICIkaSI7IHRoZW4KCQkgICAgICAgY2M9JGkKCQkgICAgICAgY2F0IDw8RU9GID4mNAoKWW91
  IHNwZWNpZmllZCBubyBjYyBidXQgeW91IHNlZW0gdG8gaGF2ZSB0aGUgV29ya3Nob3AgY29tcGls
  ZXIKKCRjYykgaW5zdGFsbGVkLCB1c2luZyB0aGF0LgpJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxz
  ZSwgc3BlY2lmeSB0aGF0IGluIHRoZSBjb21tYW5kIGxpbmUsCmUuZy4gQ29uZmlndXJlIC1EY2M9
  Z2NjCgpFT0YKCQkJYnJlYWsKCQlmaQoJZG9uZQoJOzsKZXNhYwoKIyMjIyMjIyMjIyMjIyMjIyMj
  IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR2VuZXJhbCBzYW5pdHkgdGVz
  dGluZy4gIFNlZSBiZWxvdyBmb3IgZXhjZXJwdHMgZnJvbSB0aGUgU29sYXJpcyBGQVEuCiMKIyBG
  cm9tIHJvZWhyaWNoQGlyb253b29kLWZkZGkuY3JheS5jb20gV2VkIFNlcCAyNyAxMjo1MTo0NiAx
  OTk1CiMgRGF0ZTogVGh1LCA3IFNlcCAxOTk1IDE2OjMxOjQwIC0wNTAwCiMgRnJvbTogRGVhbiBS
  b2VocmljaCA8cm9laHJpY2hAaXJvbndvb2QtZmRkaS5jcmF5LmNvbT4KIyBUbzogcGVybDUtcG9y
  dGVyc0BhZnJpY2Eubmljb2guY29tCiMgU3ViamVjdDogUmU6IE9uIHBlcmw1L3NvbGFyaXMvZ2Nj
  CiMKIyBIZXJlJ3MgYW5vdGhlciBkcmFmdCBvZiB0aGUgcGVybDUvc29sYXJpcy9nY2Mgc2FuaXR5
  LWNoZWNrZXIuCgpjYXNlIGB0eXBlICR7Y2M6LWNjfWAgaW4KKi91c3IvdWNiL2NjKikgY2F0IDw8
  RU5EID4mNAoKTk9URTogIFNvbWUgcGVvcGxlIGhhdmUgcmVwb3J0ZWQgcHJvYmxlbXMgd2l0aCAv
  dXNyL3VjYi9jYy4KSWYgeW91IGhhdmUgZGlmZmljdWx0aWVzLCBwbGVhc2UgbWFrZSBzdXJlIHRo
  ZSBkaXJlY3RvcnkKY29udGFpbmluZyB5b3VyIEMgY29tcGlsZXIgaXMgYmVmb3JlIC91c3IvdWNi
  IGluIHlvdXIgUEFUSC4KCkVORAo7Owplc2FjCgoKIyBDaGVjayB0aGF0IC9kZXYvZmQgaXMgbW91
  bnRlZC4gIElmIGl0IGlzIG5vdCBtb3VudGVkLCBsZXQgdGhlCiMgdXNlciBrbm93IHRoYXQgc3Vp
  ZCBzY3JpcHRzIG1heSBub3Qgd29yay4KJHJ1biBtb3VudCB8IGdyZXAgJ14vZGV2L2ZkICcgMj4m
  MSA+IC9kZXYvbnVsbApjYXNlICQ/IGluCjApIDs7CiopCgljYXQgPDxFTkQgPiY0CgpOT1RFOiBZ
  b3VyIHN5c3RlbSBkb2VzIG5vdCBoYXZlIC9kZXYvZmQgbW91bnRlZC4gIElmIHlvdSB3YW50IHRv
  CmJlIGFibGUgdG8gdXNlIHNldC11aWQgc2NyaXB0cyB5b3UgbXVzdCBhc2sgeW91ciBzeXN0ZW0g
  YWRtaW5pc3RyYXRvcgp0byBtb3VudCAvZGV2L2ZkLgoKRU5ECgk7Owplc2FjCgoKIyBTZWUgaWYg
  bGlidWNiIGNhbiBiZSBmb3VuZCBpbiAvdXNyL2xpYi4gIElmIGl0IGlzLCB3YXJuIHRoZSB1c2Vy
  CiMgdGhhdCB0aGlzIG1heSBjYXVzZSBwcm9ibGVtcyB3aGlsZSBidWlsZGluZyBQZXJsIGV4dGVu
  c2lvbnMuCmZvdW5kX2xpYnVjYj0nJwpjYXNlICIkcnVuIiBpbgonJykgL3Vzci9iaW4vbHMgL3Vz
  ci9saWIvbGlidWNiKiA+L2Rldi9udWxsIDI+JjEKICAgIGZvdW5kX2xpYnVjYj0kPwogICAgOzsK
  KikgICRydW4gL3Vzci9iaW4vbHMgJy91c3IvbGliL2xpYnVjYionID4vZGV2L251bGwgMj4mMQog
  ICAgZm91bmRfbGlidWNiPSQ/CiAgICA7Owplc2FjCgpjYXNlICRmb3VuZF9saWJ1Y2IgaW4KMCkK
  CWNhdCA8PEVORCA+JjQKCk5PVEU6IGxpYnVjYiBoYXMgYmVlbiBmb3VuZCBpbiAvdXNyL2xpYi4g
  IGxpYnVjYiBzaG91bGQgcmVzaWRlIGluCi91c3IvdWNibGliLiAgWW91IG1heSBoYXZlIHRyb3Vi
  bGUgd2hpbGUgYnVpbGRpbmcgUGVybCBleHRlbnNpb25zLgoKRU5ECjs7CmVzYWMKCiMgVXNlIHNo
  ZWxsIGJ1aWx0LWluICd0eXBlJyBjb21tYW5kIGluc3RlYWQgb2YgL3Vzci9iaW4vd2hpY2ggdG8K
  IyBhdm9pZCBwb3NzaWJsZSBjc2ggc3RhcnQtdXAgcHJvYmxlbXMgYW5kIGFsc28gdG8gdXNlIHRo
  ZSBzYW1lIHNoZWxsCiMgd2UnbGwgYmUgdXNpbmcgdG8gQ29uZmlndXJlIGFuZCBtYWtlIHBlcmwu
  CiMgVGhlIHBhdGggbmFtZSBpcyB0aGUgbGFzdCBmaWVsZCBpbiB0aGUgb3V0cHV0LCBidXQgdGhl
  IHR5cGUgY29tbWFuZAojIGhhcyBhbiBhbm5veWluZyBhcnJheSBvZiBwb3NzaWJsZSBvdXRwdXRz
  LCBlLmcuOgojCW1ha2UgaXMgaGFzaGVkICgvb3B0L2dudS9iaW4vbWFrZSkKIwljYyBpcyAvdXNy
  L3VjYi9jYwojCWZvbyBub3QgZm91bmQKIyB1c2UgYSBjb21tYW5kIGxpa2UgdHlwZSBtYWtlIHwg
  YXdrICd7cHJpbnQgJE5GfScgfCBzZWQgJ3MvWygpXS8vZycKCiMgU2VlIGlmIG1ha2UoMSkgaXMg
  R05VIG1ha2UoMSkuCiMgSWYgaXQgaXMsIG1ha2Ugc3VyZSB0aGUgc2V0Z2lkIGJpdCBpcyBub3Qg
  c2V0LgptYWtlIC12ID4gbWFrZS52ZXJzIDI+JjEKaWYgZ3JlcCBHTlUgbWFrZS52ZXJzID4gL2Rl
  di9udWxsIDI+JjE7IHRoZW4KICAgIHRtcD1gdHlwZSBtYWtlIHwgYXdrICd7cHJpbnQgJE5GfScg
  fCBzZWQgJ3MvWygpXS8vZydgCiAgICBjYXNlICJgJHtsczotJy91c3IvYmluL2xzJ30gLWxMICR0
  bXBgIiBpbgogICAgPz8/Pz8/cyopCgkgICAgY2F0IDw8RU5EID4mMgoKTk9URTogWW91ciBQQVRI
  IHBvaW50cyB0byBHTlUgbWFrZSwgYW5kIHlvdXIgR05VIG1ha2UgaGFzIHRoZSBzZXQtZ3JvdXAt
  aWQKYml0IHNldC4gIFlvdSBtdXN0IGVpdGhlciByZWFycmFuZ2UgeW91ciBQQVRIIHRvIHB1dCAv
  dXNyL2Njcy9iaW4gYmVmb3JlIHRoZQpHTlUgdXRpbGl0aWVzIG9yIHlvdSBtdXN0IGFzayB5b3Vy
  IHN5c3RlbSBhZG1pbmlzdHJhdG9yIHRvIGRpc2FibGUgdGhlCnNldC1ncm91cC1pZCBiaXQgb24g
  R05VIG1ha2UuCgpFTkQKCSAgICA7OwogICAgZXNhYwpmaQpybSAtZiBtYWtlLnZlcnMKCmNhdCA+
  IFVVL2NjLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS9jYy5jYnUgd2lsbCBnZXQgJ2Nh
  bGxlZC1iYWNrJyBieSBDb25maWd1cmUgYWZ0ZXIgaXQKIyBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIg
  Zm9yIHRoZSBDIGNvbXBpbGVyIHRvIHVzZS4KCiMgSWYgdGhlIEMgY29tcGlsZXIgaXMgZ2NjOgoj
  ICAgLSBjaGVjayB0aGUgZml4ZWQtaW5jbHVkZXMKIyAgIC0gY2hlY2sgYXMoMSkgYW5kIGxkKDEp
  LCB0aGV5IHNob3VsZCBub3QgYmUgR05VCiMJKEdOVSBhcyBhbmQgbGQgMi44LjEgYW5kIGxhdGVy
  IGFyZSByZXBvcnRlZGx5IG9rLCBob3dldmVyLikKIyBJZiB0aGUgQyBjb21waWxlciBpcyBub3Qg
  Z2NjOgojICAgLSBDaGVjayBpZiBpdCBpcyB0aGUgV29ya3Nob3AvRm9ydGUgY29tcGlsZXIuCiMg
  ICAgIElmIGl0IGlzLCBwcmVwYXJlIGZvciA2NCBiaXQgYW5kIGxvbmcgZG91Ymxlcy4KIyAgIC0g
  Y2hlY2sgYXMoMSkgYW5kIGxkKDEpLCB0aGV5IHNob3VsZCBub3QgYmUgR05VCiMJKEdOVSBhcyBh
  bmQgbGQgMi44LjEgYW5kIGxhdGVyIGFyZSByZXBvcnRlZGx5IG9rLCBob3dldmVyLikKIwojIFdh
  dGNoIG91dCBpbiBjYXNlIHRoZXkgaGF2ZSBub3Qgc2V0ICRjYy4KCiMgUGVybCBjb21waWxlZCB3
  aXRoIHNvbWUgY29tYmluYXRpb25zIG9mIEdOVSBhcyBhbmQgbGQgbWF5IG5vdAojIGJlIGFibGUg
  dG8gcGVyZm9ybSBkeW5hbWljIGxvYWRpbmcgb2YgZXh0ZW5zaW9ucy4gIElmIHlvdSBoYXZlIGEK
  IyBwcm9ibGVtIHdpdGggZHluYW1pYyBsb2FkaW5nLCBiZSBzdXJlIHRoYXQgeW91IGFyZSB1c2lu
  ZyB0aGUgU29sYXJpcwojIC91c3IvY2NzL2Jpbi9hcyBhbmQgL3Vzci9jY3MvYmluL2xkLiAgWW91
  IGNhbiBkbyB0aGF0IHdpdGgKIwlzaCBDb25maWd1cmUgLURjYz0nZ2NjIC1CL3Vzci9jY3MvYmlu
  LycKIyAobm90ZSB0aGUgdHJhaWxpbmcgc2xhc2ggaXMgcmVxdWlyZWQpLgojIENvbWJpbmF0aW9u
  cyB0aGF0IGFyZSBrbm93biB0byB3b3JrIHdpdGggdGhlIGZvbGxvd2luZyBoaW50czoKIwojICBn
  Y2MtMi43LjIsIEdOVSBhcyAyLjcsIEdOVSBsZCAyLjcKIyAgZWdjcy0xLjAuMywgR05VIGFzIDIu
  OS4xIGFuZCBHTlUgbGQgMi45LjEKIwktLUFuZHkgRG91Z2hlcnR5ICA8ZG91Z2hlcmFAbGFmYXll
  dHRlLmVkdT4KIwlUdWUgQXByIDEzIDE3OjE5OjQzIEVEVCAxOTk5CgojIEdldCBnY2MgdG8gc2hh
  cmUgaXRzIHNlY3JldHMuCmVjaG8gJ2ludCBtYWluKCkgeyByZXR1cm4gMDsgfScgPiB0cnkuYwoJ
  IyBJbmRlbnQgdG8gYXZvaWQgcHJvcGFnYXRpb24gdG8gY29uZmlnLnNoCgl2ZXJib3NlPWAke2Nj
  Oi1jY30gJGNjZmxhZ3MgLXYgLW8gdHJ5IHRyeS5jIDI+JjFgCgojIFhYWCBUT0RPOiAgJ3NwZWNz
  JyBvdXRwdXQgY2hhbmdlZCBmcm9tICdSZWFkaW5nIHNwZWNzIGZyb20nIGluIGdjYy1bMjNdIHRv
  ICdVc2luZwojIGJ1aWx0LWluIHNwZWNzJyBpbiBnY2MtNC4gIFBlcmhhcHMgd2Ugc2hvdWxkIGp1
  c3QgdXNlIHRoZSBzYW1lIGdjYyB0ZXN0IGFzCiMgaW4gQ29uZmlndXJlIHRvIHNlZSBpZiB3ZSdy
  ZSB1c2luZyBnY2MuCmlmIGVjaG8gIiR2ZXJib3NlIiB8IGVncmVwICcoUmVhZGluZyBzcGVjcyBm
  cm9tKXwoVXNpbmcgYnVpbHQtaW4gc3BlY3MpJyA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCSMKCSMg
  VXNpbmcgZ2NjLgoJIwoJY2NfbmFtZT0nZ2NjJwoKCSMgU2VlIGlmIGFzKDEpIGlzIEdOVSBhcygx
  KS4gIEdOVSBhcygxKSBtaWdodCBub3Qgd29yayBmb3IgdGhpcyBqb2IuCglpZiBlY2hvICIkdmVy
  Ym9zZSIgfCBncmVwICcgL3Vzci9jY3MvYmluL2FzICcgPi9kZXYvbnVsbCAyPiYxOyB0aGVuCgkg
  ICAgOgoJZWxzZQoJICAgIGNhdCA8PEVORCA+JjIKCk5PVEU6IFlvdSBhcmUgdXNpbmcgR05VIGFz
  KDEpLiAgR05VIGFzKDEpIG1pZ2h0IG5vdCBidWlsZCBQZXJsLiAgSWYgeW91CmhhdmUgdHJvdWJs
  ZSwgeW91IGNhbiB1c2UgL3Vzci9jY3MvYmluL2FzIGJ5IGluY2x1ZGluZyAtQi91c3IvY2NzL2Jp
  bi8KaW4geW91ciAke2NjOi1jY30gY29tbWFuZC4gIChOb3RlIHRoYXQgdGhlIHRyYWlsaW5nICIv
  IiBpcyByZXF1aXJlZC4pCgpFTkQKCSAgICAjIEFwcGFyZW50bHkgbm90IG5lZWRlZCwgYXQgbGVh
  c3QgZm9yIGFzIDIuNyBhbmQgbGF0ZXIuCgkgICAgIyBjYz0iJHtjYzotY2N9ICRjY2ZsYWdzIC1C
  L3Vzci9jY3MvYmluLyIKCWZpCgoJIyBTZWUgaWYgbGQoMSkgaXMgR05VIGxkKDEpLiAgR05VIGxk
  KDEpIG1pZ2h0IG5vdCB3b3JrIGZvciB0aGlzIGpvYi4KCSMgUmVjb21wdXRlICR2ZXJib3NlIHNp
  bmNlIHdlIG1heSBoYXZlIGp1c3QgY2hhbmdlZCAkY2MuCgl2ZXJib3NlPWAke2NjOi1jY30gJGNj
  ZmxhZ3MgLXYgLW8gdHJ5IHRyeS5jIDI+JjEgfCBncmVwIGxkIDI+JjFgCgoJaWYgZWNobyAiJHZl
  cmJvc2UiIHwgZ3JlcCAnIC91c3IvY2NzL2Jpbi9sZCAnID4vZGV2L251bGwgMj4mMTsgdGhlbgoJ
  ICAgICMgT2ssIGdjYyBkaXJlY3RseSBjYWxscyB0aGUgU29sYXJpcyAvdXNyL2Njcy9iaW4vbGQu
  CgkgICAgOgoJZWxpZiBlY2hvICIkdmVyYm9zZSIgfCBncmVwICJsZDogU29mdHdhcmUgR2VuZXJh
  dGlvbiBVdGlsaXRpZXMiID4vZGV2L251bGwgMj4mMTsgdGhlbgoJICAgICMgSG1tLiAgZ2NjIGRv
  ZXNuJ3QgY2FsbCAvdXNyL2Njcy9iaW4vbGQgZGlyZWN0bHksIGJ1dCBpdAoJICAgICMgZG9lcyBh
  cHBlYXIgdG8gYmUgdXNpbmcgaXQgZXZlbnR1YWxseS4gIGVnY3MtMS4wLjMncyBsZAoJICAgICMg
  d3JhcHBlciBkb2VzIHRoaXMuCgkgICAgIyBNb3N0IFNvbGFyaXMgdmVyc2lvbnMgb2YgbGQgSSd2
  ZSBzZWVuIGNvbnRhaW4gdGhlIG1hZ2ljCgkgICAgIyBzdHJpbmcgdXNlZCBpbiB0aGUgZ3JlcC4K
  CSAgICA6CgllbGlmIGVjaG8gIiR2ZXJib3NlIiB8IGdyZXAgIlNvbGFyaXMgTGluayBFZGl0b3Jz
  IiA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCSAgICAjIEhvd2V2ZXIgc29tZSBTb2xhcmlzIDggdmVy
  c2lvbnMgcHJpb3IgdG8gbGQgNS44LTEuMjg2IGNvbnRhaW4KCSAgICAjIHRoaXMgc3RyaW5nIGlu
  c3RlYWQuCgkgICAgOgoJZWxzZQoJICAgICMgTm8gZXZpZGVuY2UgeWV0IG9mIC91c3IvY2NzL2Jp
  bi9sZC4gIFNvbWUgdmVyc2lvbnMKCSAgICAjIG9mIGVnY3MncyBsZCB3cmFwcGVyIGNhbGwgL3Vz
  ci9jY3MvYmluL2xkIGluIHR1cm4gYnV0CgkgICAgIyBhcHBhcmVudGx5IGRvbid0IHJldmVhbCB0
  aGF0IHVubGVzcyB5b3UgcGFzcyBpbiAtVi4KCSAgICAjIChUaGlzIG1heSBhbGwgZGVwZW5kIG9u
  IGxvY2FsIGNvbmZpZ3VyYXRpb25zIHRvby4pCgoJICAgICMgUmVjb21wdXRlIHZlcmJvc2Ugd2l0
  aCAtV2wsLXYgdG8gZmluZCBHTlUgbGQgaWYgcHJlc2VudAoJICAgIHZlcmJvc2U9YCR7Y2M6LWNj
  fSAkY2NmbGFncyAtV2wsLXYgLW8gdHJ5IHRyeS5jIDI+JjEgfCBncmVwIC9sZCAyPiYxYAoKCSAg
  ICBteWxkPWBlY2hvICR2ZXJib3NlIHwgYXdrICcvXC9sZC8ge3ByaW50ICQxfSdgCgkgICAgIyBU
  aGlzIGFzc3VtZXMgdGhhdCBnY2MncyBvdXRwdXQgd2lsbCBub3QgY2hhbmdlLCBhbmQgdGhhdAoJ
  ICAgICMgL2Z1bGwvcGF0aC90by9sZCB3aWxsIGJlIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBvdXRw
  dXQuCgkgICAgIyBUaHVzIG15bGQgaXMgc29tZXRoaW5nIGxpa2UgL29wdC9nbnUvc3BhcmMtc3Vu
  LXNvbGFyaXMyLjUvYmluL2xkCgoJICAgICMgQWxsb3cgdGhhdCAkbXlsZCBtYXkgYmUgJycsIGR1
  ZSB0byBjaGFuZ2VzIGluIGdjYydzIG91dHB1dAoJICAgIGlmICR7bXlsZDotbGR9IC1WIDI+JjEg
  fAoJCWdyZXAgImxkOiBTb2Z0d2FyZSBHZW5lcmF0aW9uIFV0aWxpdGllcyIgPi9kZXYvbnVsbCAy
  PiYxOyB0aGVuCgkJIyBPaywgL3Vzci9jY3MvYmluL2xkIGV2ZW50dWFsbHkgZG9lcyBnZXQgY2Fs
  bGVkLgoJCToKCSAgICBlbGlmICR7bXlsZDotbGR9IC1WIDI+JjEgfAoJCWdyZXAgIlNvbGFyaXMg
  TGluayBFZGl0b3JzIiA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCQkjIE9rLCAvdXNyL2Njcy9iaW4v
  bGQgZXZlbnR1YWxseSBkb2VzIGdldCBjYWxsZWQuCgkJOgoJICAgIGVsc2UKCQllY2hvICJGb3Vu
  ZCBHTlUgbGQ9JyRteWxkJyIgPiY0CgkJY2F0IDw8RU5EID4mMgoKTk9URTogWW91IGFyZSB1c2lu
  ZyBHTlUgbGQoMSkuICBHTlUgbGQoMSkgbWlnaHQgbm90IGJ1aWxkIFBlcmwuICBJZiB5b3UKaGF2
  ZSB0cm91YmxlLCB5b3UgY2FuIHVzZSAvdXNyL2Njcy9iaW4vbGQgYnkgaW5jbHVkaW5nIC1CL3Vz
  ci9jY3MvYmluLwppbiB5b3VyICR7Y2M6LWNjfSBjb21tYW5kLiAgKE5vdGUgdGhhdCB0aGUgdHJh
  aWxpbmcgIi8iIGlzIHJlcXVpcmVkLikKCkkgd2lsbCB0cnkgdG8gdXNlIEdOVSBsZCBieSBwYXNz
  aW5nIGluIHRoZSAtV2wsLUUgZmxhZywgYnV0IGlmIHRoYXQKZG9lc24ndCB3b3JrLCB5b3Ugc2hv
  dWxkIHVzZSAtQi91c3IvY2NzL2Jpbi8gaW5zdGVhZC4KCkVORAoJCWNjZGxmbGFncz0iJGNjZGxm
  bGFncyAtV2wsLUUiCgkJbGRkbGZsYWdzPSIkbGRkbGZsYWdzIC1XbCwtRSAtc2hhcmVkIgoJICAg
  IGZpCglmaQoKZWxzZQoJIwoJIyBOb3QgdXNpbmcgZ2NjLgoJIwoJY2F0ID4gdHJ5LmMgPDwgJ0VP
  TScKI2luY2x1ZGUgPHN0ZGlvLmg+CmludCBtYWluKCkgewojaWYgZGVmaW5lZChfX1NVTlBST19D
  KQoJcHJpbnRmKCJ3b3Jrc2hvcFxuIik7CiNlbHNlCiNpZiBkZWZpbmVkKF9fU1VOUFJPX0NDKQoJ
  cHJpbnRmKCJ3b3Jrc2hvcCBDQ1xuIik7CiNlbHNlCglwcmludGYoIlxuIik7CiNlbmRpZgojZW5k
  aWYKcmV0dXJuKDApOwp9CkVPTQoJdHJ5d29ya3Nob3BjYz0iJHtjYzotY2N9ICRjY2ZsYWdzIHRy
  eS5jIC1vIHRyeSIKCWlmICR0cnl3b3Jrc2hvcGNjID4vZGV2L251bGwgMj4mMTsgdGhlbgoJCWNj
  X25hbWU9YCRydW4gLi90cnlgCgkJaWYgdGVzdCAiJGNjX25hbWUiID0gIndvcmtzaG9wIjsgdGhl
  bgoJCQljY3ZlcnNpb249ImAke2NjOi1jY30gLVYgMj4mMXxzZWQgLW4gLWUgJzFzL15bQ2NdW0Nj
  OV05KjogLy9wJ2AiCgkJZmkKCQlpZiB0ZXN0ICIkY2NfbmFtZSIgPSAid29ya3Nob3AgQ0MiOyB0
  aGVuCgkJCWNjdmVyc2lvbj0iYCR7Y2M6LUNDfSAtViAyPiYxfHNlZCAtbiAtZSAnMXMvXltDY11b
  Q106IC8vcCdgIgoJCWZpCgkJY2FzZSAiJGNjX25hbWUiIGluCgkJd29ya3Nob3AqKQoJCQkjIFNl
  dHRpbmdzIGZvciBlaXRoZXIgY2Mgb3IgQ0MKCQkJaWYgdGVzdCAhICIkdXNlNjRiaXRhbGxfZG9u
  ZSI7IHRoZW4KCQkJCWxvY2xpYnB0aD0iL3Vzci9saWIgL3Vzci9jY3MvbGliIGAkZ2V0d29ya3No
  b3BsaWJzYCAkbG9jbGlicHRoIgoJCQlmaQoJCQkjIFN1biBDQy9jYyBkb24ndCBzdXBwb3J0IGdj
  YyBhdHRyaWJ1dGVzCgkJCWRfYXR0cmlidXRlX2Zvcm1hdD0ndW5kZWYnCgkJCWRfYXR0cmlidXRl
  X21hbGxvYz0ndW5kZWYnCgkJCWRfYXR0cmlidXRlX25vbm51bGw9J3VuZGVmJwoJCQlkX2F0dHJp
  YnV0ZV9ub3JldHVybj0ndW5kZWYnCgkJCWRfYXR0cmlidXRlX3B1cmU9J3VuZGVmJwoJCQlkX2F0
  dHJpYnV0ZV91bnVzZWQ9J3VuZGVmJwoJCQlkX2F0dHJpYnV0ZV93YXJuX3VudXNlZF9yZXN1bHQ9
  J3VuZGVmJwoJCQljYXNlICIkY2MiIGluCgkJCSpjOTkpCSMgYzk5IHJlamVjdHMgYmFyZSAnLU8n
  LgoJCQkJY2FzZSAiJG9wdGltaXplIiBpbgoJCQkJJyd8LU8pIG9wdGltaXplPS1PMyA7OwoJCQkJ
  ZXNhYwoJCQkJIyBXaXRob3V0IC1YYSBjOTkgZG9lc24ndCBzZWUKCQkJCSMgbWFueSBPUyBpbnRl
  cmZhY2VzLgoJCQkJY2FzZSAiJGNjZmxhZ3MiIGluCgkJCQkqLVhhKikJOzsKCQkJCSopIGNjZmxh
  Z3M9IiRjY2ZsYWdzIC1YYSIgOzsKCQkJCWVzYWMKCQkJCTs7CgkJCWVzYWMKCQkJOzsKCQllc2Fj
  CglmaQoKCSMgU2VlIGlmIGFzKDEpIGlzIEdOVSBhcygxKS4gIEdOVSBtaWdodCBub3Qgd29yayBm
  b3IgdGhpcyBqb2IuCgljYXNlIGBhcyAtLXZlcnNpb24gPCAvZGV2L251bGwgMj4mMWAgaW4KCSpH
  TlUqKQoJCWNhdCA8PEVORCA+JjIKCk5PVEU6IFlvdSBhcmUgdXNpbmcgR05VIGFzKDEpLiAgR05V
  IGFzKDEpIG1pZ2h0IG5vdCBidWlsZCBQZXJsLgpZb3UgbXVzdCBhcnJhbmdlIHRvIHVzZSAvdXNy
  L2Njcy9iaW4vYXMsIHBlcmhhcHMgYnkgYWRkaW5nIC91c3IvY2NzL2Jpbgp0byB0aGUgYmVnaW5u
  aW5nIG9mIHlvdXIgUEFUSC4KCkVORAoJCTs7Cgllc2FjCgoJIyBTZWUgaWYgbGQoMSkgaXMgR05V
  IGxkKDEpLiAgR05VIGxkKDEpIG1pZ2h0IG5vdCB3b3JrIGZvciB0aGlzIGpvYi4KCSMgbGQgLS12
  ZXJzaW9uIGRvZXNuJ3QgcHJvcGVybHkgcmVwb3J0IGl0c2VsZiBhcyBhIEdOVSB0b29sLAoJIyBh
  cyBvZiBsZCB2ZXJzaW9uIDIuNiwgc28gd2UgbmVlZCB0byBiZSBtb3JlIHN0cmljdC4gVFdQIDkv
  NS85NgoJIyBTdW4ncyBsZCBhbHdheXMgZW1pdHMgdGhlICJTb2Z0d2FyZSBHZW5lcmF0aW9uIFV0
  aWxpdGllcyIgc3RyaW5nLgoJaWYgbGQgLVYgMj4mMSB8IGdyZXAgImxkOiBTb2Z0d2FyZSBHZW5l
  cmF0aW9uIFV0aWxpdGllcyIgPi9kZXYvbnVsbCAyPiYxOyB0aGVuCgkgICAgIyBPaywgbGQgaXMg
  L3Vzci9jY3MvYmluL2xkLgoJICAgIDoKCWVsc2UKCSAgICBjYXQgPDxFTkQgPiYyCgpOT1RFOiBZ
  b3UgYXJlIGFwcGFyZW50bHkgdXNpbmcgR05VIGxkKDEpLiAgR05VIGxkKDEpIG1pZ2h0IG5vdCBi
  dWlsZCBQZXJsLgpZb3Ugc2hvdWxkIGFycmFuZ2UgdG8gdXNlIC91c3IvY2NzL2Jpbi9sZCwgcGVy
  aGFwcyBieSBhZGRpbmcgL3Vzci9jY3MvYmluCnRvIHRoZSBiZWdpbm5pbmcgb2YgeW91ciBQQVRI
  LgoKRU5ECglmaQpmaQoKIyBhcyAtLXZlcnNpb24gb3IgbGQgLS12ZXJzaW9uIG1pZ2h0IGR1bXAg
  Y29yZS4Kcm0gLWYgdHJ5IHRyeS5jIGNvcmUKRU9DQlUKCmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1
  IDw8J0VPQ0JVJwojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwgZ2V0ICdjYWxs
  ZWQtYmFjaycgYnkgQ29uZmlndXJlCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1c2VyIGZv
  ciB3aGV0aGVyIHRvIHVzZSB0aHJlYWRzLgpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRlZmluZXx0
  cnVlfFt5WV0qKQoJY2NmbGFncz0iLURfUkVFTlRSQU5UICRjY2ZsYWdzIgoKCSMgLWxwdGhyZWFk
  IG92ZXJyaWRlcyBzb21lIGxpYiBDIGZ1bmN0aW9ucywgc28gcHV0IGl0IGJlZm9yZSBjLgoJc2V0
  IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAicy8gYyAvIHB0aHJlYWQgYyAvImAKCXNo
  aWZ0CglsaWJzd2FudGVkPSIkKiIKCgkjIHNjaGVkX3lpZWxkIGlzIGF2YWlsYWJsZSBpbiB0aGUg
  LWxydCBsaWJyYXJ5LiAgSG93ZXZlciwKCSMgd2UgY2FuIGFsc28gcGljayB1cCB0aGUgZXF1aXZh
  bGVudCB5aWVsZCgpIGZ1bmN0aW9uIGluIHRoZQoJIyBub3JtYWwgQyBsaWJyYXJ5LiAgVG8gYXZv
  aWQgcHVsbGluZyBpbiB1bm5lY2Vzc2FyeQoJIyBsaWJyYXJpZXMsIHdlJ2xsIG5vcm1hbGx5IGF2
  b2lkIHNjaGVkX3lpZWxkKCkvLWxydCBhbmQKCSMganVzdCB1c2UgeWllbGQoKS4gIEhvd2V2ZXIs
  IHdlJ2xsIGhvbm9yIGEgY29tbWFuZC1saW5lCgkjIG92ZXJyaWRlIDogIi1Ec2NoZWRfeWllbGQ9
  c2NoZWRfeWllbGQiLgoJIyBJZiB3ZSBlbmQgdXAgdXNpbmcgc2NoZWRfeWllbGQsIHdlJ3JlIGdv
  aW5nIHRvIG5lZWQgLWxydC4KCXNjaGVkX3lpZWxkPSR7c2NoZWRfeWllbGQ6LXlpZWxkfQoJaWYg
  dGVzdCAiJHNjaGVkX3lpZWxkIiA9ICJzY2hlZF95aWVsZCI7IHRoZW4KCSAgICBzZXQgYGVjaG8g
  WCAiJGxpYnN3YW50ZWQgInwgc2VkIC1lICJzLyBwdGhyZWFkIC8gcnQgcHRocmVhZCAvImAKCSAg
  ICBzaGlmdAoJICAgIGxpYnN3YW50ZWQ9IiQqIgoJZmkKCgkjIE9uIFNvbGFyaXMgMi42IHg4NiB0
  aGVyZSBpcyBhIGJ1ZyB3aXRoIHNpZ3NldGptcCgpIGFuZCBzaWdsb25nam1wKCkKCSMgd2hlbiBs
  aW5rZWQgd2l0aCB0aGUgdGhyZWFkcyBsaWJyYXJ5LCBzdWNoIHRoYXQgd2hhdGV2ZXIgcG9zaXRp
  dmUKCSMgdmFsdWUgeW91IHBhc3MgdG8gc2lnbG9uZ2ptcCgpLCBzaWdzZXRqbXAoKSByZXR1cm5z
  IDEuCgkjIFRoYW5rcyB0byBTaW1vbiBQYXJzb25zIDxTLlBhcnNvbnNAZnRlbC5jby51az4gZm9y
  IHRoaXMgcmVwb3J0LgoJIyBTdW4gQnVnSUQgaXMgNDExNzk0NiwgInNpZ3NldGptcCBhbHdheXMg
  cmV0dXJucyAxIHdoZW4gY2FsbGVkIGJ5CgkjIHNpZ2xvbmdqbXAgaW4gYSBNVCBwcm9ncmFtIi4g
  QXMgb2YgMTk5ODA2MjIsIHRoZXJlIGlzIG5vIHBhdGNoCgkjIGF2YWlsYWJsZS4KCWNhdCA+dHJ5
  LmMgPDwnRU9NJwoJLyogVGVzdCBmb3Igc2lnKHNldHxsb25nKWptcCBidWcuICovCgkjaW5jbHVk
  ZSA8c2V0am1wLmg+CgoJaW50IG1haW4oKQoJewoJICAgIHNpZ2ptcF9idWYgZW52OwoJICAgIGlu
  dCByZXQ7CgoJICAgIHJldCA9IHNpZ3NldGptcChlbnYsIDEpOwoJICAgIGlmIChyZXQpIHsgcmV0
  dXJuIHJldCA9PSAyOyB9CgkgICAgc2lnbG9uZ2ptcChlbnYsIDIpOwoJfQpFT00KCWlmIHRlc3Qg
  ImBhcmNoYCIgPSBpODZwYyAtYSBgdW5hbWUgLXJgID0gNS42ICYmIFwKCSAgICR7Y2M6LWNjfSB0
  cnkuYyAtbHB0aHJlYWQgPi9kZXYvbnVsbCAyPiYxICYmIC4vYS5vdXQ7IHRoZW4KCSAgICBkX3Np
  Z3NldGptcD0kdW5kZWYKCWZpCgoJIyBUaGVzZSBwcm90b3R5cGVzIHNob3VsZCBiZSB2aXNpYmxl
  IHNpbmNlIHdlIHVzaW5nCgkjIC1EX1JFRU5UUkFOVCwgYnV0IHRoYXQgZG9lcyBub3Qgc2VlbSB0
  byB3b3JrLgoJIyBJdCBkb2VzIHNlZW0gdG8gd29yayBmb3IgZ2V0bmV0YnlhZGRyX3IsIHdlaXJk
  bHkgZW5vdWdoLAoJIyBhbmQgb3RoZXIgX3IgZnVuY3Rpb25zLiAoU29sYXJpcyA4KQoKCWRfY3Rl
  cm1pZF9yX3Byb3RvPSIkZGVmaW5lIgoJZF9nZXRob3N0YnlhZGRyX3JfcHJvdG89IiRkZWZpbmUi
  CglkX2dldGhvc3RieW5hbWVfcl9wcm90bz0iJGRlZmluZSIKCWRfZ2V0bmV0YnluYW1lX3JfcHJv
  dG89IiRkZWZpbmUiCglkX2dldHByb3RvYnluYW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2dldHBy
  b3RvYnludW1iZXJfcl9wcm90bz0iJGRlZmluZSIKCWRfZ2V0c2VydmJ5bmFtZV9yX3Byb3RvPSIk
  ZGVmaW5lIgoJZF9nZXRzZXJ2Ynlwb3J0X3JfcHJvdG89IiRkZWZpbmUiCgoJIyBEaXR0by4gKFNv
  bGFyaXMgNykKCWRfcmVhZGRpcl9yX3Byb3RvPSIkZGVmaW5lIgoJZF9yZWFkZGlyNjRfcl9wcm90
  bz0iJGRlZmluZSIKCWRfdG1wbmFtX3JfcHJvdG89IiRkZWZpbmUiCglkX3R0eW5hbWVfcl9wcm90
  bz0iJGRlZmluZSIKCgk7Owplc2FjCkVPQ0JVCgpjYXQgPiBVVS91c2VsYXJnZWZpbGVzLmNidSA8
  PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2VsYXJnZWZpbGVzLmNidSB3aWxsIGdldCAnY2Fs
  bGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBm
  b3Igd2hldGhlciB0byB1c2UgbGFyZ2UgZmlsZXMuCmNhc2UgIiR1c2VsYXJnZWZpbGVzIiBpbgon
  J3wkZGVmaW5lfHRydWV8W3lZXSopCgojIEtlZXAgdGhlc2UgaW4gdGhlIGxlZnQgbWFyZ2luLgpj
  Y2ZsYWdzX3VzZWxhcmdlZmlsZXM9ImAkcnVuIGdldGNvbmYgTEZTX0NGTEFHUyAyPi9kZXYvbnVs
  bGAiCmxkZmxhZ3NfdXNlbGFyZ2VmaWxlcz0iYCRydW4gZ2V0Y29uZiBMRlNfTERGTEFHUyAyPi9k
  ZXYvbnVsbGAiCmxpYnN3YW50ZWRfdXNlbGFyZ2VmaWxlcz0iYCRydW4gZ2V0Y29uZiBMRlNfTElC
  UyAyPi9kZXYvbnVsbHxzZWQgLWUgJ3NAXi1sQEAnIC1lICdzQCAtbEAgQGcnYCIKCiAgICBjY2Zs
  YWdzPSIkY2NmbGFncyAkY2NmbGFnc191c2VsYXJnZWZpbGVzIgogICAgbGRmbGFncz0iJGxkZmxh
  Z3MgJGxkZmxhZ3NfdXNlbGFyZ2VmaWxlcyIKICAgIGxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkICRs
  aWJzd2FudGVkX3VzZWxhcmdlZmlsZXMiCiAgICA7Owplc2FjCkVPQ0JVCgojIFRoaXMgaXMgdHJ1
  bHkgYSBtZXNzLgpjYXNlICIkdXNlbW9yZWJpdHMiIGluCiIkZGVmaW5lInx0cnVlfFt5WV0qKQoJ
  dXNlNjRiaXRpbnQ9IiRkZWZpbmUiCgl1c2Vsb25nZG91YmxlPSIkZGVmaW5lIgoJOzsKZXNhYwoK
  aWYgdGVzdCBgJHJ1biB1bmFtZSAtcGAgPSBpMzg2OyB0aGVuCiAgICBjYXNlICIkdXNlNjRiaXRp
  bnQiIGluCiAgICAiJGRlZmluZSJ8dHJ1ZXxbeVldKikKICAgICAgICAgICAgY2NmbGFncz0iJGNj
  ZmxhZ3MgLURQVFJfSVNfTE9ORyIKICAgICAgICAgICAgOzsKICAgIGVzYWMKZmkKCmlmIHRlc3Qg
  YCRydW4gdW5hbWUgLXBgID0gc3BhcmMgLW8gYCRydW4gdW5hbWUgLXBgID0gaTM4NjsgdGhlbgog
  ICAgY2F0ID4gVVUvdXNlNjRiaXRpbnQuY2J1IDw8J0VPQ0JVJwojIFRoaXMgc2NyaXB0IFVVL3Vz
  ZTY0Yml0aW50LmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVy
  IGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgNjQgYml0IGludGVn
  ZXJzLgpjYXNlICIkdXNlNjRiaXRpbnQiIGluCiIkZGVmaW5lInx0cnVlfFt5WV0qKQoJICAgIGNh
  c2UgImAkcnVuIHVuYW1lIC1yYCIgaW4KCSAgICA1LlswLTRdKQoJCWNhdCA+JjQgPDxFT00KU29s
  YXJpcyBgdW5hbWUgLXJ8c2VkIC1lICdzL141XC4vMi4vJ2AgZG9lcyBub3Qgc3VwcG9ydCA2NC1i
  aXQgaW50ZWdlcnMuCllvdSBzaG91bGQgdXBncmFkZSB0byBhdCBsZWFzdCBTb2xhcmlzIDIuNS4K
  RU9NCgkJZXhpdCAxCgkJOzsKCSAgICBlc2FjCgojIGdjYy0yLjguMSBvbiBTb2xhcmlzIDggd2l0
  aCAtRHVzZTY0Yml0aW50IGZhaWxzIG9wL3BhdC50IHRlc3QgODIyCiMgaWYgd2UgY29tcGlsZSBy
  ZWdleGVjLmMgd2l0aCAtTy4gIFR1cm4gb2ZmIG9wdGltaXphdGlvbiBmb3IgdGhhdCBvbmUKIyBm
  aWxlLiAgU2VlIGhpbnRzL1JFQURNRS5oaW50cyAsIGVzcGVjaWFsbHkKIyA9aGVhZDIgUHJvcGFn
  YXRpbmcgdmFyaWFibGVzIHRvIGNvbmZpZy5zaCwgbWV0aG9kIDMuCiMgIEEuIERvdWdoZXJ0eSAg
  TWF5IDI0LCAyMDAyCiAgICBjYXNlICIke2djY3ZlcnNpb259LSR7b3B0aW1pemV9IiBpbgogICAg
  Mi44Ki1PKikKCSMgSG9ub3IgYSBjb21tYW5kLWxpbmUgb3ZlcnJpZGUgKHJhdGhlciB1bmxpa2Vs
  eSkKCWNhc2UgIiRyZWdleGVjX2NmbGFncyIgaW4KCScnKSBlY2hvICJEaXNhYmxpbmcgb3B0aW1p
  emF0aW9uIG9uIHJlZ2V4ZWMuYyBmb3IgZ2NjICRnY2N2ZXJzaW9uIiA+JjQKCSAgICByZWdleGVj
  X2NmbGFncz0nb3B0aW1pemU9JwoJICAgIGVjaG8gInJlZ2V4ZWNfY2ZsYWdzPSdvcHRpbWl6ZT1c
  IlwiJyIgPj4gY29uZmlnLnNoCgkgICAgOzsKCWVzYWMKCTs7CiAgICBlc2FjCiAgICA7Owplc2Fj
  CkVPQ0JVCgogICAgY2F0ID4gVVUvdXNlNjRiaXRhbGwuY2J1IDw8J0VPQ0JVJwojIFRoaXMgc2Ny
  aXB0IFVVL3VzZTY0Yml0YWxsLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3Vy
  ZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byBiZSBtYXhp
  bWFsbHkgNjQgYml0dHkuCmNhc2UgIiR1c2U2NGJpdGFsbC0kdXNlNjRiaXRhbGxfZG9uZSIgaW4K
  IiRkZWZpbmUtInx0cnVlLXxbeVldKi0pCgkgICAgY2FzZSAiYCRydW4gdW5hbWUgLXJgIiBpbgoJ
  ICAgIDUuWzAtNl0pCgkJY2F0ID4mNCA8PEVPTQpTb2xhcmlzIGB1bmFtZSAtcnxzZWQgLWUgJ3Mv
  XjVcLi8yLi8nYCBkb2VzIG5vdCBzdXBwb3J0IDY0LWJpdCBwb2ludGVycy4KWW91IHNob3VsZCB1
  cGdyYWRlIHRvIGF0IGxlYXN0IFNvbGFyaXMgMi43LgpFT00KCQlleGl0IDEKCQk7OwoJICAgIGVz
  YWMKCSAgICBwcm9jZXNzb3I9YCRydW4gdW5hbWUgLXBgOwoJICAgIGlmIHRlc3QgIiRwcm9jZXNz
  b3IiID0gc3BhcmM7IHRoZW4KCQlsaWJjPScvdXNyL2xpYi9zcGFyY3Y5L2xpYmMuc28nCgkJaWYg
  dGVzdCAhIC1mICRsaWJjOyB0aGVuCgkJICAgIGNhdCA+JjQgPDxFT00KCkkgZG8gbm90IHNlZSB0
  aGUgNjQtYml0IGxpYmMsICRsaWJjLgpDYW5ub3QgY29udGludWUsIGFib3J0aW5nLgoKRU9NCgkJ
  ICAgIGV4aXQgMQoJCWZpCgkgICAgZmkKCSAgICBjYXNlICIke2NjOi1jY30gLXYgMj4vZGV2L251
  bGwiIGluCgkgICAgKmdjYyp8KmcrKyopCgkJZWNobyAnaW50IG1haW4oKSB7IHJldHVybiAwOyB9
  JyA+IHRyeS5jCgkJY2FzZSAiYCR7Y2M6LWNjfSAkY2NmbGFncyAtbWNwdT12OSAtbTY0IC1TIHRy
  eS5jIDI+JjEgfCBncmVwICdtNjQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGNvbmZpZ3VyYXRp
  b24nYCIgaW4KCQkqIm02NCBpcyBub3Qgc3VwcG9ydGVkIiopCgkJICAgIGNhdCA+JjQgPDxFT00K
  CkZ1bGwgNjQtYml0IGJ1aWxkIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBnY2MgY29uZmlndXJh
  dGlvbi4KQ2hlY2sgaHR0cDovL2djYy5nbnUub3JnLyBmb3IgdGhlIGxhdGVzdCBuZXdzIG9mIGF2
  YWlsYWJpbGl0eQpvZiBnY2MgZm9yIDY0LWJpdCBTcGFyYy4KCkNhbm5vdCBjb250aW51ZSwgYWJv
  cnRpbmcuCgpFT00KCQkgICAgZXhpdCAxCgkJICAgIDs7CgkJZXNhYwoJCWlmIHRlc3QgIiRwcm9j
  ZXNzb3IiID0gc3BhcmM7IHRoZW4KCQkgICAgbG9jbGlicHRoPSIvdXNyL2xpYi9zcGFyY3Y5ICRs
  b2NsaWJwdGgiCgkJICAgIGNjZmxhZ3M9IiRjY2ZsYWdzIC1tY3B1PXY5IgoJCWZpCgkJY2NmbGFn
  cz0iJGNjZmxhZ3MgLW02NCIKCgkJIyBUaGlzIGFkZHMgaW4gLVdhLC14YXJjaD12OS4gIEkgc3Vz
  cGVjdCB0aGF0J3Mgc3VwZXJmbHVvdXMsCgkJIyBzaW5jZSB0aGUgLW02NCBhYm92ZSBzaG91bGQg
  ZG8gdGhhdCBhbHJlYWR5LiAgU29tZW9uZQoJCSMgd2l0aCBnY2MtMy54LngsIHBsZWFzZSB0ZXN0
  IHdpdGggZ2NjIC12LiAgIEEuRC4gMjAtTm92LTIwMDMKIwkJaWYgdGVzdCAkcHJvY2Vzc29yID0g
  c3BhcmMgLWEgWGAkcnVuIGdldGNvbmYgWEJTNV9MUDY0X09GRjY0X0NGTEFHUyAyPi9kZXYvbnVs
  bGAgIT0gWDsgdGhlbgojCQkgICAgY2NmbGFncz0iJGNjZmxhZ3MgLVdhLGAkcnVuIGdldGNvbmYg
  WEJTNV9MUDY0X09GRjY0X0NGTEFHUyAyPi9kZXYvbnVsbGAiCiMJCWZpCgkJbGRmbGFncz0iJGxk
  ZmxhZ3MgLW02NCIKCgkJIyBTZWUgW3BlcmwgIzY2NjA0XTogIE9uIFNvbGFyaXMgMTEsIGdjYyAt
  bTY0IG9uIGFtZDY0CgkJIyBhcHBlYXJzIG5vdCB0byB1bmRlcnN0YW5kIC1HLiAgKGdjYyAtRyBo
  YXMgbm90IGNhdXNlZAoJCSMgcHJvYmxlbXMgb24gb3RoZXIgcGxhdGZvcm1zIGluIHRoZSBwYXN0
  LikgIGdjYyB2ZXJzaW9ucwoJCSMgYXQgbGVhc3QgYXMgb2xkIGFzIDMuNC4zIHN1cHBvcnQgLXNo
  YXJlZCwgc28ganVzdAoJCSMgdXNlIHRoYXQgd2l0aCBTb2xhcmlzIDExIGFuZCBsYXRlciwgYnV0
  IGtlZXAKCQkjIHRoZSBvbGQgYmVoYXZpb3IgZm9yIG9sZGVyIFNvbGFyaXMgdmVyc2lvbnMuCgkJ
  Y2FzZSAiJG9zdmVycyIgaW4KCQkJMi4/fDIuMTApIGxkZGxmbGFncz0iJGxkZGxmbGFncyAtRyAt
  bTY0IiA7OwoJCQkqKSBsZGRsZmxhZ3M9IiRsZGRsZmxhZ3MgLXNoYXJlZCAtbTY0IiA7OwoJCWVz
  YWMKCQk7OwoJICAgICopCgkJZ2V0Y29uZmNjZmxhZ3M9ImAkcnVuIGdldGNvbmYgWEJTNV9MUDY0
  X09GRjY0X0NGTEFHUyAyPi9kZXYvbnVsbGAiCgkJZ2V0Y29uZmxkZmxhZ3M9ImAkcnVuIGdldGNv
  bmYgWEJTNV9MUDY0X09GRjY0X0xERkxBR1MgMj4vZGV2L251bGxgIgoJCWdldGNvbmZsZGRsZmxh
  Z3M9ImAkcnVuIGdldGNvbmYgWEJTNV9MUDY0X09GRjY0X0xERkxBR1MgMj4vZGV2L251bGxgIgoJ
  CWVjaG8gImludCBtYWluKCkgeyByZXR1cm4oMCk7IH0gIiA+IHRyeS5jCgkJY2FzZSAiYCR7Y2M6
  LWNjfSAkZ2V0Y29uZmNjZmxhZ3MgdHJ5LmMgMj4mMSB8IGdyZXAgJ2RlcHJlY2F0ZWQnYCIgaW4K
  CQkqIiAteGFyY2g9Z2VuZXJpYzY0IGlzIGRlcHJlY2F0ZWQsIHVzZSAtbTY0ICIqKQoJCSAgICBn
  ZXRjb25mY2NmbGFncz1gZWNobyAkZ2V0Y29uZmNjZmxhZ3MgfCBzZWQgLWUgJ3MveGFyY2g9Z2Vu
  ZXJpYzY0L202NC8nYAoJCSAgICBnZXRjb25mbGRmbGFncz1gZWNobyAkZ2V0Y29uZmxkZmxhZ3Mg
  fCBzZWQgLWUgJ3MveGFyY2g9Z2VuZXJpYzY0L202NC8nYAoJCSAgICBnZXRjb25mbGRkbGZsYWdz
  PWBlY2hvICRnZXRjb25mbGRkbGZsYWdzIHwgc2VkIC1lICdzL3hhcmNoPWdlbmVyaWM2NC9tNjQv
  J2AKCQkgICAgOzsKCQllc2FjCgkJY2NmbGFncz0iJGNjZmxhZ3MgJGdldGNvbmZjY2ZsYWdzIgoJ
  CWxkZmxhZ3M9IiRsZGZsYWdzICRnZXRjb25mbGRmbGFncyIKCQlsZGRsZmxhZ3M9IiRsZGRsZmxh
  Z3MgLUcgJGdldGNvbmZsZGRsZmxhZ3MiCgoJCWVjaG8gImludCBtYWluKCkgeyByZXR1cm4oMCk7
  IH0gIiA+IHRyeS5jCgkJdHJ5d29ya3Nob3BjYz0iJHtjYzotY2N9IHRyeS5jIC1vIHRyeSAkY2Nm
  bGFncyIKCQlpZiB0ZXN0ICIkcHJvY2Vzc29yIiA9IHNwYXJjOyB0aGVuCgkJICAgIGxvY2xpYnB0
  aD0iL3Vzci9saWIvc3BhcmN2OSAvdXNyL2Njcy9saWIvc3BhcmN2OSAkbG9jbGlicHRoIgoJCWZp
  CgkJbG9jbGlicHRoPSJgJGdldHdvcmtzaG9wbGlic2AgJGxvY2xpYnB0aCIKCQk7OwoJICAgIGVz
  YWMKCSAgICB1bnNldCBwcm9jZXNzb3IKCSAgICB1c2U2NGJpdGFsbF9kb25lPXllcwoJICAgIGFy
  Y2huYW1lNjQ9NjQKCSAgICA7Owplc2FjCkVPQ0JVCgogICAgIyBBY3R1YWxseSwgd2Ugd2FudCB0
  byBydW4gdGhpcyBhbHJlYWR5IG5vdywgaWYgc28gcmVxdWVzdGVkLAogICAgIyBiZWNhdXNlIHdl
  IG5lZWQgdG8gZml4IHVwIHRoaW5ncyByaWdodCBub3cuCiAgICBjYXNlICIkdXNlNjRiaXRhbGwi
  IGluCiAgICAiJGRlZmluZSJ8dHJ1ZXxbeVldKikKCSMgQ0JVcyBleHBlY3QgdG8gYmUgcnVuIGlu
  IFVVCgljZCBVVTsgLiAuL3VzZTY0Yml0YWxsLmNidTsgY2QgLi4KCTs7CiAgICBlc2FjCmZpCgpj
  YXQgPiBVVS91c2Vsb25nZG91YmxlLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2Vs
  b25nZG91YmxlLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVy
  IGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbG9uZyBkb3VibGVz
  LgpjYXNlICIkdXNlbG9uZ2RvdWJsZSIgaW4KIiRkZWZpbmUifHRydWV8W3lZXSopCglpZiB0ZXN0
  ICIkY2NfbmFtZSIgPSAid29ya3Nob3AiOyB0aGVuCgkJY2F0ID4gdHJ5LmMgPDwgJ0VPTScKI2lu
  Y2x1ZGUgPHN1bm1hdGguaD4KaW50IG1haW4oKSB7ICh2b2lkKSBwb3dsKDIsIDI1Nik7IHJldHVy
  bigwKTsgfQpFT00KCQlpZiAke2NjOi1jY30gdHJ5LmMgLWxzdW5tYXRoIC1vIHRyeSA+IC9kZXYv
  bnVsbCAyPiYxICYmIC4vdHJ5OyB0aGVuCgkJCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIHN1bm1h
  dGgiCgkJZmkKCWVsc2UKCQljYXQgPiY0IDw8RU9NCgpUaGUgU3VuIFdvcmtzaG9wIG1hdGggbGli
  cmFyeSBpcyBlaXRoZXIgbm90IGF2YWlsYWJsZSBvciBub3Qgd29ya2luZywKc28gSSBkbyBub3Qg
  a25vdyBob3cgdG8gZG8gbG9uZyBkb3VibGVzLCBzb3JyeS4KSSdtIHRoZXJlZm9yZSBkaXNhYmxp
  bmcgdGhlIHVzZSBvZiBsb25nIGRvdWJsZXMuCkVPTQoJCXVzZWxvbmdkb3VibGU9IiR1bmRlZiIK
  CWZpCgk7Owplc2FjCkVPQ0JVCgojCiMgSWYgdW5zZXRlbnYgaXMgYXZhaWxhYmxlLCB1c2UgaXQg
  aW4gY29uanVuY3Rpb24gd2l0aCBQRVJMX1VTRV9TQUZFX1BVVEVOViB0bwojIHdvcmsgYXJvdW5k
  IFN1biBidWdpZCA2MzMzODMwLiAgQm90aCB1bnNldGVudiBhbmQgNjMzMzgzMCBvbmx5IGFwcGVh
  ciBpbgojIFNvbGFyaXMgMTAsIHNvIHdlIGRvbid0IG5lZWQgdG8gcHJvYmUgZXhwbGljaXRseSBm
  b3IgYW4gT1MgdmVyc2lvbi4gIFdlIGhhdmUKIyB0byBhcHBlbmQgdGhpcyB0ZXN0IHRvIHRoZSBl
  bmQgb2YgY29uZmlnLm92ZXIgYXMgaXQgbmVlZHMgdG8gcnVuIGFmdGVyCiMgQ29uZmlndXJlIGhh
  cyBwcm9iZWQgZm9yIHVuc2V0ZW52LCBhbmQgdGhpcyBoaW50cyBmaWxlIGlzIHByb2Nlc3NlZCBi
  ZWZvcmUKIyB0aGF0IGhhcyBoYXBwZW5lZC4KIwpjYXQgPj4gY29uZmlnLm92ZXIgPDwnRU9PVkVS
  JwppZiB0ZXN0ICIkZF91bnNldGVudiIgPSAiJGRlZmluZSIgLWEgXAogICAgYGV4cHIgIiRjY2Zs
  YWdzIiA6ICcuKi1EUEVSTF9VU0VfU0FGRV9QVVRFTlYnYCAtZXEgMDsgdGhlbgogICAgICAgIGNj
  ZmxhZ3M9IiRjY2ZsYWdzIC1EUEVSTF9VU0VfU0FGRV9QVVRFTlYiCmZpCkVPT1ZFUgoKcm0gLWYg
  dHJ5LmMgdHJ5Lm8gdHJ5IGEub3V0CgojIElmIHVzaW5nIEMrKywgdGhlIENvbmZpZ3VyZSBzY2Fu
  IGZvciBkbG9wZW4oKSB3aWxsIGZhaWwgaW4gU29sYXJpcwojIGJlY2F1c2Ugb25lIG9mIHRoZSB0
  d28gKDEpIGFuIGV4dGVybiAiQyIgbGlua2FnZSBkZWZpbml0aW9uIGlzIG5lZWRlZAojICgyKSAj
  aW5jbHVkZSA8ZGxmY24uaD4gaXMgbmVlZGVkLCAqYW5kKiBhIGNhc3QgdG8gKHZvaWQqKCopKCkp
  CiMgaXMgbmVlZGVkIGZvciB0aGUgJmRsb3Blbi4gIEFkZGluZyBhbnkgb2YgdGhlc2Ugd291bGQg
  cmVxdWlyZSBjaGFuZ2luZwojIGEgZGVsaWNhdGUgc3BvdCBpbiBDb25maWd1cmUsIHNvIGVhc2ll
  ciBqdXN0IHRvIGZvcmNlIG91ciBndWVzcyBoZXJlCiMgZm9yIFNvbGFyaXMuICBNdWNoIHRoZSBz
  YW1lIGdvZXMgZm9yIGRsZXJyb3IoKS4KY2FzZSAiJGNjIiBpbgoqZysrKnwqQ0MqKQogIGRfZGxv
  cGVuPSdkZWZpbmUnCiAgZF9kbGVycm9yPSdkZWZpbmUnCiAgOzsKZXNhYwoKIyBPcmFjbGUvU3Vu
  IGJ1aWxkcyB0aGVpciBQZXJsIHNoYXJlZCBzaW5jZSA1LjYuMSwgYW5kIHRoZXkgYWxzbwojIHN0
  cm9uZ2x5IHJlY29tbWVuZCB1c2luZyBzaGFyZWQgbGlicmFyaWVzIGluIGdlbmVyYWwuCiMKIyBG
  dXJ0aGVybW9yZSwgT3BlbkluZGlhbmEgc2VlbXMgdG8gZWZmZWN0aXZlbHkgcmVxdWlyZSBidWls
  ZGluZyBwZXJsCiMgc2hhcmVkLCBvciBvdGhlcndpc2UgcGVybCBzY3JpcHRzIHdvbid0IGV2ZW4g
  ZmluZCB0aGUgUGVybCBsaWJyYXJ5Lgp1c2VzaHJwbGliPSd0cnVlJwo=',);my%files=('freebsd'=>'freebsd.sh','netbsd'=>'netbsd.sh','openbsd'=>'openbsd.sh','linux'=>'linux.sh','dragonfly'=>'dragonfly.sh','darwin'=>'darwin.sh','hpux'=>'hpux.sh','cygwin'=>'cygwin.sh','midnightbsd'=>'midnightbsd.sh','gnukfreebsd'=>'gnukfreebsd.sh','solaris'=>'solaris_2.sh','bitrig'=>'bitrig.sh','gnu'=>'gnu.sh',);sub hint_file {my$os=shift;$os=shift if eval {$os->isa(__PACKAGE__)};$os=$^O unless$os;return unless defined$hints{$os };my$content=decode_base64($hints{$os });return$content unless wantarray;return ($files{$os },$content)}sub hints {return sort keys%hints}qq'nudge nudge wink wink';
DEVEL_PATCHPERL_HINTS

$fatpacked{"Devel/PatchPerl/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL_PLUGIN';
  package Devel::PatchPerl::Plugin;$Devel::PatchPerl::Plugin::VERSION='2.08';use strict;use warnings;qq[Plug it in];
DEVEL_PATCHPERL_PLUGIN

$fatpacked{"Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER';
  package Exporter;require 5.006;our$Debug=0;our$ExportLevel=0;our$Verbose ||= 0;our$VERSION='5.74';our (%Cache);sub as_heavy {require Exporter::Heavy;my$c=(caller(1))[3];$c =~ s/.*:://;\&{"Exporter::Heavy::heavy_$c"}}sub export {goto &{as_heavy()}}sub import {my$pkg=shift;my$callpkg=caller($ExportLevel);if ($pkg eq "Exporter" and @_ and $_[0]eq "import"){*{$callpkg."::import"}=\&import;return}my$exports=\@{"$pkg\::EXPORT"};my$fail=${$pkg .'::'}{EXPORT_FAIL}&& \@{"$pkg\::EXPORT_FAIL"};return export$pkg,$callpkg,@_ if$Verbose or $Debug or $fail && @$fail > 1;my$export_cache=($Cache{$pkg}||= {});my$args=@_ or @_=@$exports;if ($args and not %$export_cache){s/^&//,$export_cache->{$_}=1 foreach (@$exports,@{"$pkg\::EXPORT_OK"})}my$heavy;if ($args or $fail){($heavy=(/\W/ or $args and not exists$export_cache->{$_}or $fail and @$fail and $_ eq $fail->[0]))and last foreach (@_)}else {($heavy=/\W/)and last foreach (@_)}return export$pkg,$callpkg,($args ? @_ : ())if$heavy;local$SIG{__WARN__}=sub {require Carp;&Carp::carp}if not $SIG{__WARN__};*{"$callpkg\::$_"}=\&{"$pkg\::$_"}foreach @_}sub export_fail {my$self=shift;@_}sub export_to_level {goto &{as_heavy()}}sub export_tags {goto &{as_heavy()}}sub export_ok_tags {goto &{as_heavy()}}sub require_version {goto &{as_heavy()}}1;
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_HEAVY';
  package Exporter::Heavy;use strict;no strict 'refs';require Exporter;our$VERSION=$Exporter::VERSION;sub _rebuild_cache {my ($pkg,$exports,$cache)=@_;s/^&// foreach @$exports;@{$cache}{@$exports}=(1)x @$exports;my$ok=\@{"${pkg}::EXPORT_OK"};if (@$ok){s/^&// foreach @$ok;@{$cache}{@$ok}=(1)x @$ok}}sub heavy_export {my$oldwarn=$SIG{__WARN__};local$SIG{__WARN__}=sub {local$SIG{__WARN__}=$oldwarn;my$text=shift;if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//){require Carp;local$Carp::CarpLevel=1;Carp::carp($text)}else {warn$text}};local$SIG{__DIE__}=sub {require Carp;local$Carp::CarpLevel=1;Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")if $_[0]=~ /^Unable to create sub named "(.*?)::"/};my($pkg,$callpkg,@imports)=@_;my($type,$sym,$cache_is_current,$oops);my($exports,$export_cache)=(\@{"${pkg}::EXPORT"},$Exporter::Cache{$pkg}||= {});if (@imports){if (!%$export_cache){_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (grep m{^[/!:]},@imports){my$tagsref=\%{"${pkg}::EXPORT_TAGS"};my$tagdata;my%imports;my($remove,$spec,@names,@allexports);unshift@imports,':DEFAULT' if$imports[0]=~ m/^!/;for$spec (@imports){$remove=$spec =~ s/^!//;if ($spec =~ s/^://){if ($spec eq 'DEFAULT'){@names=@$exports}elsif ($tagdata=$tagsref->{$spec}){@names=@$tagdata}else {warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];++$oops;next}}elsif ($spec =~ m:^/(.*)/$:){my$patn=$1;@allexports=keys %$export_cache unless@allexports;@names=grep(/$patn/,@allexports)}else {@names=($spec)}warn "Import ".($remove ? "del":"add").": @names " if$Exporter::Verbose;if ($remove){for$sym (@names){delete$imports{$sym}}}else {@imports{@names}=(1)x @names}}@imports=keys%imports}my@carp;for$sym (@imports){if (!$export_cache->{$sym}){if ($sym =~ m/^\d/){$pkg->VERSION($sym);if (@imports==1){@imports=@$exports;last}if (@imports==2 and!$imports[1]){@imports=();last}}elsif ($sym !~ s/^&// ||!$export_cache->{$sym}){unless ($cache_is_current){%$export_cache=();_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (!$export_cache->{$sym}){push@carp,qq["$sym" is not exported by the $pkg module];$oops++}}}}if ($oops){require Carp;Carp::croak(join("\n",@carp,"Can't continue after import errors"))}}else {@imports=@$exports}my($fail,$fail_cache)=(\@{"${pkg}::EXPORT_FAIL"},$Exporter::FailCache{$pkg}||= {});if (@$fail){if (!%$fail_cache){my@expanded=map {/^\w/ ? ($_,'&'.$_): $_}@$fail;warn "${pkg}::EXPORT_FAIL cached: @expanded" if$Exporter::Verbose;@{$fail_cache}{@expanded}=(1)x @expanded}my@failed;for$sym (@imports){push(@failed,$sym)if$fail_cache->{$sym}}if (@failed){@failed=$pkg->export_fail(@failed);for$sym (@failed){require Carp;Carp::carp(qq["$sym" is not implemented by the $pkg module ],"on this architecture")}if (@failed){require Carp;Carp::croak("Can't continue after import errors")}}}warn "Importing into $callpkg from $pkg: ",join(", ",sort@imports)if$Exporter::Verbose;for$sym (@imports){(*{"${callpkg}::$sym"}=\&{"${pkg}::$sym"},next)unless$sym =~ s/^(\W)//;$type=$1;no warnings 'once';*{"${callpkg}::$sym"}=$type eq '&' ? \&{"${pkg}::$sym"}: $type eq '$' ? \${"${pkg}::$sym"}: $type eq '@' ? \@{"${pkg}::$sym"}: $type eq '%' ? \%{"${pkg}::$sym"}: $type eq '*' ? *{"${pkg}::$sym"}: do {require Carp;Carp::croak("Can't export symbol: $type$sym")}}}sub heavy_export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}sub _push_tags {my($pkg,$var,$syms)=@_;my@nontag=();my$export_tags=\%{"${pkg}::EXPORT_TAGS"};push(@{"${pkg}::$var"},map {$export_tags->{$_}? @{$export_tags->{$_}}: scalar(push(@nontag,$_),$_)}(@$syms)? @$syms : keys %$export_tags);if (@nontag and $^W){require Carp;Carp::carp(join(", ",@nontag)." are not tags of $pkg")}}sub heavy_require_version {my($self,$wanted)=@_;my$pkg=ref$self || $self;return ${pkg}->VERSION($wanted)}sub heavy_export_tags {_push_tags((caller)[0],"EXPORT",\@_)}sub heavy_export_ok_tags {_push_tags((caller)[0],"EXPORT_OK",\@_)}1;
EXPORTER_HEAVY

$fatpacked{"ExtUtils/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND';
  package ExtUtils::Command;use 5.00503;use strict;use warnings;require Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);@ISA=qw(Exporter);@EXPORT=qw(cp rm_f rm_rf mv cat eqtime mkpath touch test_f test_d chmod dos2unix);$VERSION='7.60';$VERSION =~ tr/_//d;my$Is_VMS=$^O eq 'VMS';my$Is_VMS_mode=$Is_VMS;my$Is_VMS_noefs=$Is_VMS;my$Is_Win32=$^O eq 'MSWin32';if($Is_VMS){my$vms_unix_rpt;my$vms_efs;my$vms_case;if (eval {local$SIG{__DIE__};local@INC=@INC;pop@INC if$INC[-1]eq '.';require VMS::Feature}){$vms_unix_rpt=VMS::Feature::current("filename_unix_report");$vms_efs=VMS::Feature::current("efs_charset");$vms_case=VMS::Feature::current("efs_case_preserve")}else {my$unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';my$efs_charset=$ENV{'DECC$EFS_CHARSET'}|| '';my$efs_case=$ENV{'DECC$EFS_CASE_PRESERVE'}|| '';$vms_unix_rpt=$unix_rpt =~ /^[ET1]/i;$vms_efs=$efs_charset =~ /^[ET1]/i;$vms_case=$efs_case =~ /^[ET1]/i}$Is_VMS_mode=0 if$vms_unix_rpt;$Is_VMS_noefs=0 if ($vms_efs)}my$wild_regex=$Is_VMS ? '*%' : '*?';sub expand_wildcards {@ARGV=map(/[$wild_regex]/o ? glob($_): $_,@ARGV)}sub cat () {expand_wildcards();print while (<>)}sub eqtime {my ($src,$dst)=@ARGV;local@ARGV=($dst);touch();utime((stat($src))[8,9],$dst)}sub rm_rf {expand_wildcards();require File::Path;File::Path::rmtree([grep -e $_,@ARGV],0,0)}sub rm_f {expand_wildcards();for my$file (@ARGV){next unless -f $file;next if _unlink($file);chmod(0777,$file);next if _unlink($file);require Carp;Carp::carp("Cannot delete $file: $!")}}sub _unlink {my$files_unlinked=0;for my$file (@_){my$delete_count=0;$delete_count++ while unlink$file;$files_unlinked++ if$delete_count}return$files_unlinked}sub touch {my$t=time;expand_wildcards();for my$file (@ARGV){open(FILE,">>$file")|| die "Cannot write $file:$!";close(FILE);utime($t,$t,$file)}}sub mv {expand_wildcards();my@src=@ARGV;my$dst=pop@src;if (@src > 1 &&!-d $dst){require Carp;Carp::croak("Too many arguments")}require File::Copy;my$nok=0;for my$src (@src){$nok ||=!File::Copy::move($src,$dst)}return!$nok}sub cp {expand_wildcards();my@src=@ARGV;my$dst=pop@src;if (@src > 1 &&!-d $dst){require Carp;Carp::croak("Too many arguments")}require File::Copy;my$nok=0;for my$src (@src){$nok ||=!File::Copy::copy($src,$dst);utime(time,time,$dst)if$Is_Win32}return$nok}sub chmod {local@ARGV=@ARGV;my$mode=shift(@ARGV);expand_wildcards();if($Is_VMS_mode && $Is_VMS_noefs){require File::Spec;for my$idx (0..$#ARGV){my$path=$ARGV[$idx];next unless -d $path;my@dirs=File::Spec->splitdir($path);$dirs[-1].= '.dir';$path=File::Spec->catfile(@dirs);$ARGV[$idx]=$path}}chmod(oct$mode,@ARGV)|| die "Cannot chmod ".join(' ',$mode,@ARGV).":$!"}sub mkpath {expand_wildcards();require File::Path;File::Path::mkpath([@ARGV],0,0777)}sub test_f {exit(-f $ARGV[0]? 0 : 1)}sub test_d {exit(-d $ARGV[0]? 0 : 1)}sub dos2unix {require File::Find;File::Find::find(sub {return if -d;return unless -w _;return unless -r _;return if -B _;local $\;my$orig=$_;my$temp='.dos2unix_tmp';open ORIG,$_ or do {warn "dos2unix can't open $_: $!";return};open TEMP,">$temp" or do {warn "dos2unix can't create .dos2unix_tmp: $!";return};binmode ORIG;binmode TEMP;while (my$line=<ORIG>){$line =~ s/\015\012/\012/g;print TEMP$line}close ORIG;close TEMP;rename$temp,$orig},@ARGV)}
EXTUTILS_COMMAND

$fatpacked{"ExtUtils/Command/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND_MM';
  package ExtUtils::Command::MM;require 5.006;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(test_harness pod2man perllocal_install uninstall warn_if_old_packlist test_s cp_nonempty);our$VERSION='7.60';$VERSION =~ tr/_//d;my$Is_VMS=$^O eq 'VMS';sub mtime {no warnings 'redefine';local $@;*mtime=(eval {require Time::HiRes}&& defined&Time::HiRes::stat)? sub {(Time::HiRes::stat($_[0]))[9]}: sub {(stat($_[0]))[9]};goto&mtime}sub test_harness {require Test::Harness;require File::Spec;$Test::Harness::verbose=shift;require ExtUtils::Command;my@argv=ExtUtils::Command::expand_wildcards(@ARGV);local@INC=@INC;unshift@INC,map {File::Spec->rel2abs($_)}@_;Test::Harness::runtests(sort {lc$a cmp lc$b}@argv)}sub pod2man {local@ARGV=@_ ? @_ : @ARGV;{local $@;if(!eval {require Pod::Man}){warn "Pod::Man is not available: $@"."Man pages will not be generated during this install.\n";return 0}}require Getopt::Long;my%options=();Getopt::Long::config ('bundling_override');Getopt::Long::GetOptions (\%options,'section|s=s','release|r=s','center|c=s','date|d=s','fixed=s','fixedbold=s','fixeditalic=s','fixedbolditalic=s','official|o','quotes|q=s','lax|l','name|n=s','perm_rw=i','utf8|u');delete$options{utf8}unless$Pod::Man::VERSION >= 2.17;return 0 unless@ARGV;if ($options{official}&&!defined$options{center}){$options{center}=q[Perl Programmer's Reference Guide]}delete$options{lax};my$count=scalar@ARGV / 2;my$plural=$count==1 ? 'document' : 'documents';print "Manifying $count pod $plural\n";do {{my ($pod,$man)=splice(@ARGV,0,2);next if ((-e $man)&& (mtime($man)> mtime($pod))&& (mtime($man)> mtime("Makefile")));my$parser=Pod::Man->new(%options);$parser->parse_from_file($pod,$man)or do {warn("Could not install $man\n");next};if (exists$options{perm_rw}){chmod(oct($options{perm_rw}),$man)or do {warn("chmod $options{perm_rw} $man: $!\n");next}}}}while@ARGV;return 1}sub warn_if_old_packlist {my$packlist=$ARGV[0];return unless -f $packlist;print <<"PACKLIST_WARNING"}sub perllocal_install {my($type,$name)=splice(@ARGV,0,2);my@mod_info=$Is_VMS ? split /\|/,<STDIN> : @ARGV;my$pod;my$time=gmtime($ENV{SOURCE_DATE_EPOCH}|| time);$pod=sprintf <<'POD',scalar($time),$type,$name,$name;do {my($key,$val)=splice(@mod_info,0,2);$pod .= <<POD}while(@mod_info);$pod .= "=back\n\n";$pod =~ s/^ //mg;print$pod;return 1}sub uninstall {my($packlist)=shift@ARGV;require ExtUtils::Install;print <<'WARNING';ExtUtils::Install::uninstall($packlist,1,1);print <<'WARNING'}sub test_s {exit(-s $ARGV[0]? 0 : 1)}sub cp_nonempty {my@args=@ARGV;return 0 unless -s $args[0];require ExtUtils::Command;{local@ARGV=@args[0,1];ExtUtils::Command::cp(@ARGV)}{local@ARGV=@args[2,1];ExtUtils::Command::chmod(@ARGV)}}1;
  WARNING: I have found an old package in
      $packlist.
  Please make sure the two installations are not conflicting
  PACKLIST_WARNING
   =head2 %s: C<%s> L<%s|%s>
  
   =over 4
  
  POD
   =item *
  
   C<$key: $val>
  
  POD
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  We will show what would have been done.
  
  WARNING
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  Please check the list above carefully, there may be errors.
  Remove the appropriate files manually.
  Sorry for the inconvenience.
  
  WARNING
EXTUTILS_COMMAND_MM

$fatpacked{"ExtUtils/Liblist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST';
  package ExtUtils::Liblist;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;use File::Spec;require ExtUtils::Liblist::Kid;our@ISA=qw(ExtUtils::Liblist::Kid File::Spec);sub ext {goto&ExtUtils::Liblist::Kid::ext}sub lsdir {shift;my$rex=qr/$_[1]/;opendir my$dir_fh,$_[0];my@out=grep /$rex/,readdir$dir_fh;closedir$dir_fh;return@out}
EXTUTILS_LIBLIST

$fatpacked{"ExtUtils/Liblist/Kid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST_KID';
  package ExtUtils::Liblist::Kid;use 5.006;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;use ExtUtils::MakeMaker::Config;use Cwd 'cwd';use File::Basename;use File::Spec;sub ext {if ($^O eq 'VMS'){return&_vms_ext}elsif ($^O eq 'MSWin32'){return&_win32_ext}else {return&_unix_os2_ext}}sub _unix_os2_ext {my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;if ($^O =~ /os2|android/ and $Config{perllibs}){$potential_libs .= " " if$potential_libs;$potential_libs .= $Config{perllibs}}return ("","","","",($give_libs ? []: ()))unless$potential_libs;warn "Potential libraries are '$potential_libs':\n" if$verbose;my ($so)=$Config{so};my ($libs)=defined$Config{perllibs}? $Config{perllibs}: $Config{libs};my$Config_libext=$Config{lib_ext}|| ".a";my$Config_dlext=$Config{dlext};require Text::ParseWords;my (@searchpath);my (@libpath)=Text::ParseWords::quotewords('\s+',0,$Config{'libpth'}|| '');my (@ldloadlibs,@bsloadlibs,@extralibs,@ld_run_path,%ld_run_path_seen);my (@libs,%libs_seen);my ($fullname,@fullname);my ($pwd)=cwd();my ($found)=0;if ($^O eq 'darwin' or $^O eq 'next'){$potential_libs =~ s/(^|\s)(-(?:weak_|reexport_|lazy_)?framework)\s+(\S+)/$1-Wl,$2 -Wl,$3/g;$potential_libs =~ s/(^|\s)(-F)\s*(\S+)/$1-Wl,$2 -Wl,$3/g}for my$thislib (Text::ParseWords::quotewords('\s+',0,$potential_libs)){my ($custom_name)='';if ($thislib =~ s/^(-[LR]|-Wl,-R|-Wl,-rpath,)//){my ($ptype)=$1;unless (-d $thislib){warn "$ptype$thislib ignored, directory does not exist\n" if$verbose;next}my ($rtype)=$ptype;if (($ptype eq '-R')or ($ptype =~ m!^-Wl,-[Rr]!)){if ($Config{'lddlflags'}=~ /-Wl,-[Rr]/){$rtype='-Wl,-R'}elsif ($Config{'lddlflags'}=~ /-R/){$rtype='-R'}}unless (File::Spec->file_name_is_absolute($thislib)){warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";$thislib=$self->catdir($pwd,$thislib)}push(@searchpath,$thislib);$thislib=qq{"$thislib"} if$thislib =~ / /;push(@extralibs,"$ptype$thislib");push(@ldloadlibs,"$rtype$thislib");next}if ($thislib =~ m!^-Wl,!){push(@extralibs,$thislib);push(@ldloadlibs,$thislib);next}if ($thislib =~ s/^-l(:)?//){$custom_name=$1 || ''}else {warn "Unrecognized argument in LIBS ignored: '$thislib'\n";next}my ($found_lib)=0;for my$thispth (@searchpath,@libpath){if ((@fullname=$self->lsdir($thispth,"^\Qlib$thislib.$so.\E[0-9]+"))|| (@fullname=$self->lsdir($thispth,"^\Qlib$thislib.\E[0-9]+\Q\.$so"))){$fullname="$thispth/" .(sort {my ($ma)=$a;my ($mb)=$b;$ma =~ tr/A-Za-z/0/s;$ma =~ s/\b(\d)\b/0$1/g;$mb =~ tr/A-Za-z/0/s;$mb =~ s/\b(\d)\b/0$1/g;while (length($ma)< length($mb)){$ma .= ".00"}while (length($mb)< length($ma)){$mb .= ".00"}$mb cmp $ma}@fullname)[0]}elsif (-f ($fullname="$thispth/lib$thislib.$so")&& (($Config{'dlsrc'}ne "dl_dld.xs")|| ($thislib eq "m"))){}elsif (-f ($fullname="$thispth/lib${thislib}_s$Config_libext")&& ($Config{'archname'}!~ /RM\d\d\d-svr4/)&& ($thislib .= "_s")){}elsif (-f ($fullname="$thispth/lib$thislib$Config_libext")){}elsif (defined($Config_dlext)&& -f ($fullname="$thispth/lib$thislib.$Config_dlext")){}elsif ($^O eq 'darwin' && require DynaLoader && defined&DynaLoader::dl_load_file && DynaLoader::dl_load_file($fullname="$thispth/lib$thislib.$so",0)){}elsif (-f ($fullname="$thispth/$thislib$Config_libext")){}elsif (-f ($fullname="$thispth/lib$thislib.dll$Config_libext")){}elsif ($^O eq 'cygwin' && -f ($fullname="$thispth/$thislib.dll")){}elsif (-f ($fullname="$thispth/Slib$thislib$Config_libext")){}elsif ($^O eq 'dgux' && -l ($fullname="$thispth/lib$thislib$Config_libext")&& readlink($fullname)=~ /^elink:/s){}elsif ($custom_name && -f ($fullname="$thispth/$thislib")){}else {warn "$thislib not found in $thispth\n" if$verbose;next}warn "'-l$thislib' found at $fullname\n" if$verbose;push@libs,$fullname unless$libs_seen{$fullname}++;$found++;$found_lib++;my$is_dyna=$^O eq 'aix' ? 1 : ($fullname !~ /\Q$Config_libext\E\z/);my$in_perl=($libs =~ /\B-l:?\Q${thislib}\E\b/s);my ($fullnamedir)=dirname($fullname);push@ld_run_path,$fullnamedir if$is_dyna &&!$in_perl &&!$ld_run_path_seen{$fullnamedir}++;unless ($in_perl || ($Config{'osname'}eq 'next' && ($thislib eq 'm' || $thislib eq 'ndbm'))){push(@extralibs,"-l$custom_name$thislib")}if (($Config{'dlsrc'}=~ /dl_next/ && $Config{'osvers'}lt '4_0')|| ($Config{'dlsrc'}=~ /dl_dld/)){push(@bsloadlibs,"$fullname")}else {if ($is_dyna){push(@ldloadlibs,"-l$custom_name$thislib")unless ($in_perl and $^O eq 'sunos')}else {push(@ldloadlibs,"-l$custom_name$thislib")}}last}warn "Warning (mostly harmless): " ."No library found for -l$thislib\n" unless$found_lib > 0}unless ($found){return ('','','','',($give_libs ? \@libs : ()))}else {return ("@extralibs","@bsloadlibs","@ldloadlibs",join(":",@ld_run_path),($give_libs ? \@libs : ()))}}sub _win32_ext {require Text::ParseWords;my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;return ("","","","",($give_libs ? []: ()))unless$potential_libs;my%libs_seen;my@extralibs;my$cc=$Config{cc}|| '';my$VC=$cc =~ /\bcl\b/i;my$GC=$cc =~ /\bgcc\b/i;my$libext=_win32_lib_extensions();my@searchpath=('');my@libpath=_win32_default_search_paths($VC,$GC);my$pwd=cwd();my$search=1;my@lib_search_list=_win32_make_lib_search_list($potential_libs,$verbose);for (@lib_search_list){my$thislib=$_;if (/^:\w+$/){$search=0 if lc eq ':nosearch';$search=1 if lc eq ':search';_debug("Ignoring unknown flag '$thislib'\n",$verbose)if!/^:(no)?(search|default)$/i;next}unless ($search){s/^-l(.+)$/$1.lib/ unless$GC;s/^-L/-libpath:/ if$VC;push(@extralibs,$_);next}if (s/^-L// and not -d){_debug("$thislib ignored, directory does not exist\n",$verbose);next}elsif (-d){unless (File::Spec->file_name_is_absolute($_)){warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";$_=$self->catdir($pwd,$_)}push(@searchpath,$_);next}my@paths=(@searchpath,@libpath);my ($fullname,$path)=_win32_search_file($thislib,$libext,\@paths,$verbose,$GC);if (!$fullname){warn "Warning (mostly harmless): No library found for $thislib\n";next}_debug("'$thislib' found as '$fullname'\n",$verbose);push(@extralibs,$fullname);$libs_seen{$fullname}=1 if$path}my@libs=sort keys%libs_seen;return ('','','','',($give_libs ? \@libs : ()))unless@extralibs;@extralibs=map {qq["$_"]}@extralibs;@libs=map {qq["$_"]}@libs;my$lib=join(' ',@extralibs);$lib =~ s,/,\\,g;_debug("Result: $lib\n",$verbose);wantarray ? ($lib,'',$lib,'',($give_libs ? \@libs : ())): $lib}sub _win32_make_lib_search_list {my ($potential_libs,$verbose)=@_;my$libs=$Config{'perllibs'};$potential_libs=join(' ',$potential_libs,$libs)if$libs and $potential_libs !~ /:nodefault/i;_debug("Potential libraries are '$potential_libs':\n",$verbose);$potential_libs =~ s,\\,/,g;my@list=Text::ParseWords::quotewords('\s+',0,$potential_libs);return@list}sub _win32_default_search_paths {my ($VC,$GC)=@_;my$libpth=$Config{'libpth'}|| '';$libpth =~ s,\\,/,g;my@libpath=Text::ParseWords::quotewords('\s+',0,$libpth);push@libpath,"$Config{installarchlib}/CORE";push@libpath,split /;/,$ENV{LIB}if$VC and $ENV{LIB};push@libpath,split /;/,$ENV{LIBRARY_PATH}if$GC and $ENV{LIBRARY_PATH};return@libpath}sub _win32_search_file {my ($thislib,$libext,$paths,$verbose,$GC)=@_;my@file_list=_win32_build_file_list($thislib,$GC,$libext);for my$lib_file (@file_list){for my$path (@{$paths}){my$fullname=$lib_file;$fullname="$path\\$fullname" if$path;return ($fullname,$path)if -f $fullname;_debug("'$thislib' not found as '$fullname'\n",$verbose)}}return}sub _win32_build_file_list {my ($lib,$GC,$extensions)=@_;my@pre_fixed=_win32_build_prefixed_list($lib,$GC);return map _win32_attach_extensions($_,$extensions),@pre_fixed}sub _win32_build_prefixed_list {my ($lib,$GC)=@_;return$lib if$lib !~ s/^-l//;return$lib if$lib =~ /^lib/ and!$GC;(my$no_prefix=$lib)=~ s/^lib//i;$lib="lib$lib" if$no_prefix eq $lib;return ($lib,$no_prefix)if$GC;return ($no_prefix,$lib)}sub _win32_attach_extensions {my ($lib,$extensions)=@_;return map _win32_try_attach_extension($lib,$_),@{$extensions}}sub _win32_try_attach_extension {my ($lib,$extension)=@_;return$lib if$lib =~ /\Q$extension\E$/i;return "$lib$extension"}sub _win32_lib_extensions {my@extensions;push@extensions,$Config{'lib_ext'}if$Config{'lib_ext'};push@extensions,'.dll.a' if grep {m!^\.a$!}@extensions;push@extensions,'.lib' unless grep {m!^\.lib$!}@extensions;return \@extensions}sub _debug {my ($message,$verbose)=@_;return if!$verbose;warn$message;return}sub _vms_ext {my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;my (@crtls,$crtlstr);@crtls=(($Config{'ldflags'}=~ m-/Debug-i ? $Config{'dbgprefix'}: '').'PerlShr/Share');push(@crtls,grep {not /\(/}split /\s+/,$Config{'perllibs'});push(@crtls,grep {not /\(/}split /\s+/,$Config{'libc'});if ($self->{PERL_SRC}){my ($locspec,$type);for my$lib (@crtls){if (($locspec,$type)=$lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i){if (lc$type eq '/share'){$locspec .= $Config{'exe_ext'}}elsif (lc$type eq '/library'){$locspec .= $Config{'lib_ext'}}else {$locspec .= $Config{'obj_ext'}}$locspec=$self->catfile($self->{PERL_SRC},$locspec);$lib="$locspec$type" if -e $locspec}}}$crtlstr=@crtls ? join(' ',@crtls): '';unless ($potential_libs){warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if$verbose;return ('','',$crtlstr,'',($give_libs ? []: ()))}my (%found,@fndlibs,$ldlib);my$cwd=cwd();my ($so,$lib_ext,$obj_ext)=@Config{'so','lib_ext','obj_ext' };my (@flibs,%libs_seen);my%libmap=('m'=>'','f77'=>'','F77'=>'','V77'=>'','c'=>'','malloc'=>'','crypt'=>'','resolv'=>'','c_s'=>'','socket'=>'','X11'=>'DECW$XLIBSHR','Xt'=>'DECW$XTSHR','Xm'=>'DECW$XMLIBSHR','Xmu'=>'DECW$XMULIBSHR');warn "Potential libraries are '$potential_libs'\n" if$verbose;my (@dirs,@libs);for my$lib (split ' ',$potential_libs){push(@dirs,$1),next if$lib =~ /^-L(.*)/;push(@dirs,$lib),next if$lib =~ /[:>\]]$/;push(@dirs,$lib),next if -d $lib;push(@libs,$1),next if$lib =~ /^-l(.*)/;push(@libs,$lib)}push(@dirs,split(' ',$Config{'libpth'}));for my$dir (@dirs){unless (-d $dir){warn "Skipping nonexistent Directory $dir\n" if$verbose > 1;$dir='';next}warn "Resolving directory $dir\n" if$verbose;if (File::Spec->file_name_is_absolute($dir)){$dir=VMS::Filespec::vmspath($dir)}else {$dir=$self->catdir($cwd,$dir)}}@dirs=grep {length($_)}@dirs;unshift(@dirs,'');LIB: foreach my$lib (@libs){if (exists$libmap{$lib}){next unless length$libmap{$lib};$lib=$libmap{$lib}}my (@variants,$cand);my ($ctype)='';if ($lib !~ /\.[^:>\]]*$/){push(@variants,"${lib}shr","${lib}rtl","${lib}lib");push(@variants,"lib$lib")if$lib !~ /[:>\]]/}push(@variants,$lib);warn "Looking for $lib\n" if$verbose;for my$variant (@variants){my ($fullname,$name);for my$dir (@dirs){my ($type);$name="$dir$variant";warn "\tChecking $name\n" if$verbose > 2;$fullname=VMS::Filespec::rmsexpand($name);if (defined$fullname and -f $fullname){if ($fullname =~ /(?:$so|exe)$/i){$type='SHR'}elsif ($fullname =~ /(?:$lib_ext|olb)$/i){$type='OLB'}elsif ($fullname =~ /(?:$obj_ext|obj)$/i){warn "Warning (mostly harmless): " ."Plain object file $fullname found in library list\n";$type='OBJ'}else {warn "Warning (mostly harmless): " ."Unknown library type for $fullname; assuming shared\n";$type='SHR'}}elsif (-f ($fullname=VMS::Filespec::rmsexpand($name,$so))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.exe'))){$type='SHR';$name=$fullname unless$fullname =~ /exe;?\d*$/i}elsif (not length($ctype)and (-f ($fullname=VMS::Filespec::rmsexpand($name,$lib_ext))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.olb')))){$type='OLB';$name=$fullname unless$fullname =~ /olb;?\d*$/i}elsif (not length($ctype)and (-f ($fullname=VMS::Filespec::rmsexpand($name,$obj_ext))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.obj')))){warn "Warning (mostly harmless): " ."Plain object file $fullname found in library list\n";$type='OBJ';$name=$fullname unless$fullname =~ /obj;?\d*$/i}if (defined$type){$ctype=$type;$cand=$name;last if$ctype eq 'SHR'}}if ($ctype){push @{$found{$ctype}},$cand;warn "\tFound as $cand (really $fullname), type $ctype\n" if$verbose > 1;push@flibs,$name unless$libs_seen{$fullname}++;next LIB}}warn "Warning (mostly harmless): " ."No library found for $lib\n"}push@fndlibs,@{$found{OBJ}}if exists$found{OBJ};push@fndlibs,map {"$_/Library"}@{$found{OLB}}if exists$found{OLB};push@fndlibs,map {"$_/Share"}@{$found{SHR}}if exists$found{SHR};my$lib=join(' ',@fndlibs);$ldlib=$crtlstr ? "$lib $crtlstr" : $lib;$ldlib =~ s/^\s+|\s+$//g;warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if$verbose;wantarray ? ($lib,'',$ldlib,'',($give_libs ? \@flibs : ())): $lib}1;
EXTUTILS_LIBLIST_KID

$fatpacked{"ExtUtils/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM';
  package ExtUtils::MM;use strict;use warnings;use ExtUtils::MakeMaker::Config;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::Liblist;require ExtUtils::MakeMaker;our@ISA=qw(ExtUtils::Liblist ExtUtils::MakeMaker);{package MM;our@ISA=qw(ExtUtils::MM);sub DESTROY {}}sub _is_win95 {my$have_win32=eval {require Win32};return$have_win32 && defined&Win32::IsWin95 ? Win32::IsWin95():!defined$ENV{SYSTEMROOT}}my%Is=();$Is{VMS}=$^O eq 'VMS';$Is{OS2}=$^O eq 'os2';$Is{MacOS}=$^O eq 'MacOS';if($^O eq 'MSWin32'){_is_win95()? $Is{Win95}=1 : $Is{Win32}=1}$Is{UWIN}=$^O =~ /^uwin(-nt)?$/;$Is{Cygwin}=$^O eq 'cygwin';$Is{NW5}=$Config{osname}eq 'NetWare';$Is{BeOS}=($^O =~ /beos/i or $^O eq 'haiku');$Is{DOS}=$^O eq 'dos';if($Is{NW5}){$^O='NetWare';delete$Is{Win32}}$Is{VOS}=$^O eq 'vos';$Is{QNX}=$^O eq 'qnx';$Is{AIX}=$^O eq 'aix';$Is{Darwin}=$^O eq 'darwin';$Is{OS390}=$^O eq 'os390';$Is{Unix}=!grep {$_}values%Is;map {delete$Is{$_}unless$Is{$_}}keys%Is;_assert(keys%Is==1);my($OS)=keys%Is;my$class="ExtUtils::MM_$OS";eval "require $class" unless$INC{"ExtUtils/MM_$OS.pm"};die $@ if $@;unshift@ISA,$class;sub _assert {my$sanity=shift;die sprintf "Assert failed at %s line %d\n",(caller)[1,2]unless$sanity;return}
EXTUTILS_MM

$fatpacked{"ExtUtils/MM_AIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_AIX';
  package ExtUtils::MM_AIX;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;use ExtUtils::MakeMaker::Config;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub dlsyms {my($self,%attribs)=@_;return '' unless$self->needs_linking;join "\n",$self->xs_dlsyms_iterator(\%attribs)}sub xs_dlsyms_ext {'.exp'}sub xs_dlsyms_arg {my($self,$file)=@_;my$arg=qq{-bE:${file}};$arg='-Wl,'.$arg if$Config{lddlflags}=~ /-Wl,-bE:/;return$arg}sub init_others {my$self=shift;$self->SUPER::init_others;$self->{LDDLFLAGS}||= $Config{lddlflags};$self->{LDDLFLAGS}=~ s#(\s*)\S*\Q$(BASEEXT)\E\S*(\s*)#$1$2#;return}1;
EXTUTILS_MM_AIX

$fatpacked{"ExtUtils/MM_Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_ANY';
  package ExtUtils::MM_Any;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;use Carp;use File::Spec;use File::Basename;BEGIN {our@ISA=qw(File::Spec)}use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);use ExtUtils::MakeMaker::Config;my$Curdir=__PACKAGE__->curdir;my$METASPEC_URL='https://metacpan.org/pod/CPAN::Meta::Spec';my$METASPEC_V=2;sub os_flavor_is {my$self=shift;my%flavors=map {($_=>1)}$self->os_flavor;return (grep {$flavors{$_}}@_)? 1 : 0}sub can_load_xs {return defined&DynaLoader::boot_DynaLoader ? 1 : 0}sub can_run {my ($self,$command)=@_;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}my@possibles;if(File::Spec->file_name_is_absolute($command)){return$self->maybe_command($command)}else {for my$dir (File::Spec->path,File::Spec->curdir){next if!$dir ||!-d $dir;my$abs=File::Spec->catfile($self->os_flavor_is('Win32')? Win32::GetShortPathName($dir): $dir,$command);push@possibles,$abs if$abs=$self->maybe_command($abs)}}return@possibles if wantarray;return shift@possibles}sub can_redirect_error {my$self=shift;$self->os_flavor_is('Unix')or ($self->os_flavor_is('Win32')and!$self->os_flavor_is('Win9x'))or $self->os_flavor_is('OS/2')}my%maketype2true;sub _clear_maketype_cache {%maketype2true=()}sub is_make_type {my($self,$type)=@_;return$maketype2true{$type}if defined$maketype2true{$type};(undef,undef,my$make_basename)=$self->splitpath($self->make);return$maketype2true{$type}=1 if$make_basename =~ /\b$type\b/i;return$maketype2true{$type}=0 if$make_basename =~ /\b[gdn]make\b/i;my$redirect=$self->can_redirect_error ? '2>&1' : '';my$make=$self->make || $self->{MAKE};my$minus_v=`"$make" -v $redirect`;return$maketype2true{$type}=1 if$type eq 'gmake' and $minus_v =~ /GNU make/i;return$maketype2true{$type}=1 if$type eq 'bsdmake' and $minus_v =~ /^usage: make \[-BeikNnqrstWwX\]/im;$maketype2true{$type}=0}my$cached_dep_space;sub can_dep_space {my$self=shift;return$cached_dep_space if defined$cached_dep_space;return$cached_dep_space=1 if$self->is_make_type('gmake');return$cached_dep_space=0 if$self->is_make_type('dmake');return$cached_dep_space=0 if$self->is_make_type('bsdmake');return$cached_dep_space=0}sub quote_dep {my ($self,$arg)=@_;die <<EOF if$arg =~ / / and not $self->can_dep_space;$arg =~ s/( )/\\$1/g;return$arg}sub split_command {my($self,$cmd,@args)=@_;my@cmds=();return(@cmds)unless@args;chomp$cmd;my$len_left=int($self->max_exec_len * 0.70);$len_left -= length$self->_expand_macros($cmd);do {my$arg_str='';my@next_args;while(@next_args=splice(@args,0,2)){my$next_arg_str="\t  ".join ' ',@next_args,"\n";if(!length$arg_str){$arg_str .= $next_arg_str}elsif(length($arg_str)+ length($next_arg_str)> $len_left){unshift@args,@next_args;last}else {$arg_str .= $next_arg_str}}chop$arg_str;push@cmds,$self->escape_newlines("$cmd \n$arg_str")}while@args;return@cmds}sub _expand_macros {my($self,$cmd)=@_;$cmd =~ s{\$\((\w+)\)}{
  Tried to use make dependency with space for make that can't:
    '$arg'
  EOF
          defined $self->{$1} ? $self->{$1} : "\$($1)"
      }e;return$cmd}sub make_type {return 'Unix-style'}sub stashmeta {my($self,$text,$file)=@_;$self->echo($text,$file,{allow_variables=>0,append=>0 })}sub echo {my($self,$text,$file,$opts)=@_;if(!ref$opts){my$append=$opts;$opts={append=>$append || 0 }}$opts->{allow_variables}=0 unless defined$opts->{allow_variables};my$ql_opts={allow_variables=>$opts->{allow_variables}};my@cmds=map {'$(NOECHO) $(ECHO) '.$self->quote_literal($_,$ql_opts)}split /\n/,$text;if($file){my$redirect=$opts->{append}? '>>' : '>';$cmds[0].= " $redirect $file";$_ .= " >> $file" foreach@cmds[1..$#cmds]}return@cmds}sub wraplist {my$self=shift;return join " \\\n\t",@_}sub maketext_filter {return $_[1]}sub escape_dollarsigns {my($self,$text)=@_;$text =~ s{\$ (?!\() }{\$\$}gx;return$text}sub escape_all_dollarsigns {my($self,$text)=@_;$text =~ s{\$}{\$\$}gx;return$text}sub make {my$self=shift;my$make=lc$self->{MAKE};$make =~ s/^(\w+make).*/$1/;$make =~ s/^gnu/g/;return$make}sub all_target {my$self=shift;return <<'MAKE_EXT'}sub _xs_list_basenames {my ($self)=@_;map {(my$b=$_)=~ s/\.xs$//;$b}sort keys %{$self->{XS}}}sub blibdirs_target {my$self=shift;my@dirs=map {uc "\$(INST_$_)"}qw(libdir archlib autodir archautodir bin script man1dir man3dir);if ($self->{XSMULTI}){for my$ext ($self->_xs_list_basenames){my ($v,$d,$f)=File::Spec->splitpath($ext);my@d=File::Spec->splitdir($d);shift@d if$d[0]eq 'lib';push@dirs,$self->catdir('$(INST_ARCHLIB)','auto',@d,$f)}}my@exists=map {$_.'$(DFSEP).exists'}@dirs;my$make=sprintf <<'MAKE',join(' ',@exists);$make .= $self->dir_target(@dirs);return$make}sub clean {my($self,%attribs)=@_;my@m;push(@m,'
  all :: pure_all
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  blibdirs : %s
  	$(NOECHO) $(NOOP)
  
  # Backwards compat with 6.18 through 6.25
  blibdirs.ts : blibdirs
  	$(NOECHO) $(NOOP)
  
  MAKE
  # Delete temporary files but do not touch installed files. We don\'t delete
  # the Makefile here so a later make realclean still has a makefile to use.
  
  clean :: clean_subdirs
  ');my@files=sort values %{$self->{XS}};push@files,map {my$file=$_;map {$file.$_}$self->{OBJ_EXT},qw(.def _def.old .bs .bso .exp .base)}$self->_xs_list_basenames;my@dirs=qw(blib);if($attribs{FILES}){push@dirs,ref$attribs{FILES}? @{$attribs{FILES}}: split /\s+/,$attribs{FILES}}push(@files,qw[$(MAKE_APERL_FILE) MYMETA.json MYMETA.yml perlmain.c tmon.out mon.out so_locations blibdirs.ts pm_to_blib pm_to_blib.ts *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT) $(BOOTSTRAP) $(BASEEXT).bso $(BASEEXT).def lib$(BASEEXT).def $(BASEEXT).exp $(BASEEXT).x]);push(@files,$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));push(@files,$self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));if ($^O eq 'vos'){push(@files,qw[perl*.kp])}else {push(@files,qw[core core.*perl.*.? *perl.core])}push(@files,map {"core." ."[0-9]"x$_}(1..5));push@dirs,$self->extra_clean_files;{my(%f)=map {($_=>1)}@files;@files=sort keys%f}{my(%d)=map {($_=>1)}@dirs;@dirs=sort keys%d}push@m,map "\t$_\n",$self->split_command('- $(RM_F)',@files);push@m,map "\t$_\n",$self->split_command('- $(RM_RF)',@dirs);push@m,<<'MAKE';push(@m,"\t$attribs{POSTOP}\n")if$attribs{POSTOP};join("",@m)}sub clean_subdirs_target {my($self)=shift;return <<'NOOP_FRAG' unless @{$self->{DIR}};my$clean="clean_subdirs :\n";for my$dir (@{$self->{DIR}}){my$subclean=$self->oneliner(sprintf <<'CODE',$dir);$clean .= "\t$subclean\n"}return$clean}sub dir_target {my($self,@dirs)=@_;my$make='';for my$dir (@dirs){$make .= sprintf <<'MAKE',($dir)x 4}return$make}*dist_dir=*distdir;sub distdir {my($self)=shift;my$meta_target=$self->{NO_META}? '' : 'distmeta';my$sign_target=!$self->{SIGN}? '' : 'distsignature';return sprintf <<'MAKE_FRAG',$meta_target,$sign_target}sub dist_test {my($self)=shift;my$mpl_args=join " ",map qq["$_"],@ARGV;my$test=$self->cd('$(DISTVNAME)','$(ABSPERLRUN) Makefile.PL '.$mpl_args,'$(MAKE) $(PASTHRU)','$(MAKE) test $(PASTHRU)');return sprintf <<'MAKE_FRAG',$test}sub xs_dlsyms_arg {return ''}sub xs_dlsyms_ext {die "Pure virtual method"}sub xs_dlsyms_extra {''}sub xs_dlsyms_iterator {my ($self,$attribs)=@_;if ($self->{XSMULTI}){my@m;for my$ext ($self->_xs_list_basenames){my@parts=File::Spec->splitdir($ext);shift@parts if$parts[0]eq 'lib';my$name=join '::',@parts;push@m,$self->xs_make_dlsyms($attribs,$ext .$self->xs_dlsyms_ext,"$ext.xs",$name,$parts[-1],{},[],{},[],$self->xs_dlsyms_extra .q!, 'FILE' => ! .neatvalue($ext),)}return join "\n",@m}else {return$self->xs_make_dlsyms($attribs,$self->{BASEEXT}.$self->xs_dlsyms_ext,'Makefile.PL',$self->{NAME},$self->{DLBASE},$attribs->{DL_FUNCS}|| $self->{DL_FUNCS}|| {},$attribs->{FUNCLIST}|| $self->{FUNCLIST}|| [],$attribs->{IMPORTS}|| $self->{IMPORTS}|| {},$attribs->{DL_VARS}|| $self->{DL_VARS}|| [],$self->xs_dlsyms_extra,)}}sub xs_make_dlsyms {my ($self,$attribs,$target,$dep,$name,$dlbase,$funcs,$funclist,$imports,$vars,$extra)=@_;my@m=("\n$target: $dep\n",q!	$(PERLRUN) -MExtUtils::Mksymlists \\
  	  $(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD) $(DEV_NULL)
  MAKE
  clean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  exit 0 unless chdir '%s';  system '$(MAKE) clean' if -f '$(FIRST_MAKEFILE)';
  CODE
  %s$(DFSEP).exists :: Makefile.PL
  	$(NOECHO) $(MKPATH) %s
  	$(NOECHO) $(CHMOD) $(PERM_DIR) %s
  	$(NOECHO) $(TOUCH) %s$(DFSEP).exists
  
  MAKE
  create_distdir :
  	$(RM_RF) $(DISTVNAME)
  	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
  		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
  
  distdir : create_distdir %s %s
  	$(NOECHO) $(NOOP)
  
  MAKE_FRAG
  disttest : distdir
  	%s
  
  MAKE_FRAG
       -e "Mksymlists('NAME'=>\"!,$name,q!\", 'DLBASE' => '!,$dlbase,q!', 'DL_FUNCS' => !,neatvalue($funcs),q!, 'FUNCLIST' => !,neatvalue($funclist),q!, 'IMPORTS' => !,neatvalue($imports),q!, 'DL_VARS' => !,neatvalue($vars));push@m,$extra if defined$extra;push@m,qq!);"\n!;join '',@m}sub dynamic {my($self)=shift;'
  dynamic :: $(FIRST_MAKEFILE) config $(INST_BOOT) $(INST_DYNAMIC)
  	$(NOECHO) $(NOOP)
  '}sub makemakerdflt_target {return <<'MAKE_FRAG'}sub manifypods_target {my($self)=shift;my$man1pods='';my$man3pods='';my$dependencies='';for my$name (sort keys %{$self->{MAN1PODS}},sort keys %{$self->{MAN3PODS}}){$dependencies .= " \\\n\t$name"}my$manify=<<END;my@man_cmds;for my$num (qw(1 3)){my$pods=$self->{"MAN${num}PODS"};my$p2m=sprintf <<'CMD',"\$(MAN${num}SECTION)","$]" > 5.008 ? " -u" : "";push@man_cmds,$self->split_command($p2m,map {($_,$pods->{$_})}sort keys %$pods)}$manify .= "\t\$(NOECHO) \$(NOOP)\n" unless@man_cmds;$manify .= join '',map {"$_\n"}@man_cmds;return$manify}{my$has_cpan_meta;sub _has_cpan_meta {return$has_cpan_meta if defined$has_cpan_meta;return$has_cpan_meta=!!eval {require CPAN::Meta;CPAN::Meta->VERSION(2.112150);1}}}sub metafile_target {my$self=shift;return <<'MAKE_FRAG' if$self->{NO_META}or!_has_cpan_meta();my$metadata=$self->metafile_data($self->{META_ADD}|| {},$self->{META_MERGE}|| {},);my$meta=$self->_fix_metadata_before_conversion($metadata);my@write_metayml=$self->stashmeta($meta->as_string({version=>"1.4"}),'META_new.yml');my@write_metajson=$self->stashmeta($meta->as_string({version=>"2.0"}),'META_new.json');my$metayml=join("\n\t",@write_metayml);my$metajson=join("\n\t",@write_metajson);return sprintf <<'MAKE_FRAG',$metayml,$metajson}sub _fix_metadata_before_conversion {my ($self,$metadata)=@_;return unless _has_cpan_meta;my$bad_version=$metadata->{version}&& !CPAN::Meta::Validator->new->version('version',$metadata->{version});if($bad_version){warn "Can't parse version '$metadata->{version}'\n";$metadata->{version}=''}my$validator2=CPAN::Meta::Validator->new($metadata);my@errors;push@errors,$validator2->errors if!$validator2->is_valid;my$validator14=CPAN::Meta::Validator->new({%$metadata,'meta-spec'=>{version=>1.4 },});push@errors,$validator14->errors if!$validator14->is_valid;for my$error (@errors){my ($key)=($error =~ /Custom resource '(.*)' must be in CamelCase./);next if!$key;(my$new_key=$key)=~ s/[^_a-zA-Z]//g;$new_key=ucfirst$new_key if!$validator14->custom_1($new_key);$metadata->{resources}{$new_key}=$metadata->{resources}{$key}if$validator14->custom_1($new_key);delete$metadata->{resources}{$key}}my$meta=eval {CPAN::Meta->create($metadata,{lazy_validation=>1 })};warn $@ if $@ and $@ !~ /encountered CODE.*, but JSON can only represent references to arrays or hashes/;if(!$meta || !eval {$meta->as_string({version=>$METASPEC_V })}|| !eval {$meta->as_string}){$meta=bless$metadata,'CPAN::Meta'}my$now_license=$meta->as_struct({version=>2 })->{license};if ($self->{LICENSE}and $self->{LICENSE}ne 'unknown' and @{$now_license}==1 and $now_license->[0]eq 'unknown'){warn "Invalid LICENSE value '$self->{LICENSE}' ignored\n"}$meta}sub _sort_pairs {my$sort=shift;my$pairs=shift;return map {$_=>$pairs->{$_}}sort$sort keys %$pairs}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$self->_hash_merge($h->{$k},$_,$v->{$_})foreach keys %$v}else {$h->{$k}=$v}}sub metafile_data {my$self=shift;my($meta_add,$meta_merge)=@_;$meta_add ||= {};$meta_merge ||= {};my$version=_normalize_version($self->{VERSION});my$release_status=($version =~ /_/)? 'unstable' : 'stable';my%meta=(abstract=>$self->{ABSTRACT}|| 'unknown',author=>defined($self->{AUTHOR})? $self->{AUTHOR}: ['unknown'],dynamic_config=>1,generated_by=>"ExtUtils::MakeMaker version $ExtUtils::MakeMaker::VERSION",license=>[$self->{LICENSE}|| 'unknown' ],'meta-spec'=>{url=>$METASPEC_URL,version=>$METASPEC_V,},name=>$self->{DISTNAME},release_status=>$release_status,version=>$version,no_index=>{directory=>[qw(t inc)]},);$self->_add_requirements_to_meta(\%meta);if (!eval {require JSON::PP;require CPAN::Meta::Converter;CPAN::Meta::Converter->VERSION(2.141170)}){return \%meta}my$v1_add=_metaspec_version($meta_add)!~ /^2/;my ($add_v,$merge_v)=map _metaspec_version($_),$meta_add,$meta_merge;for my$frag ($meta_add,$meta_merge){my$def_v=$frag==$meta_add ? $merge_v : $add_v;$frag=CPAN::Meta::Converter->new($frag,default_version=>$def_v)->upgrade_fragment}while(my($key,$val)=each %$meta_add){if ($v1_add and $key eq 'prereqs'){$meta{$key}{$_}=$val->{$_}for keys %$val}elsif ($key ne 'meta-spec'){$meta{$key}=$val}}while(my($key,$val)=each %$meta_merge){next if$key eq 'meta-spec';$self->_hash_merge(\%meta,$key,$val)}return \%meta}sub _add_requirements_to_meta {my ($self,$meta)=@_;$meta->{prereqs}{configure}{requires}=$self->{ARGS}{CONFIGURE_REQUIRES}? $self->{CONFIGURE_REQUIRES}: {'ExtUtils::MakeMaker'=>0,};$meta->{prereqs}{build}{requires}=$self->{ARGS}{BUILD_REQUIRES}? $self->{BUILD_REQUIRES}: {'ExtUtils::MakeMaker'=>0,};$meta->{prereqs}{test}{requires}=$self->{TEST_REQUIRES}if$self->{ARGS}{TEST_REQUIRES};$meta->{prereqs}{runtime}{requires}=$self->{PREREQ_PM}if$self->{ARGS}{PREREQ_PM};$meta->{prereqs}{runtime}{requires}{perl}=_normalize_version($self->{MIN_PERL_VERSION})if$self->{MIN_PERL_VERSION}}sub _metaspec_version {my ($meta)=@_;return$meta->{'meta-spec'}->{version}if defined$meta->{'meta-spec'}and defined$meta->{'meta-spec'}->{version};return '1.4'}sub _add_requirements_to_meta_v1_4 {my ($self,$meta)=@_;if($self->{ARGS}{CONFIGURE_REQUIRES}){$meta->{configure_requires}=$self->{CONFIGURE_REQUIRES}}else {$meta->{configure_requires}={'ExtUtils::MakeMaker'=>0,}}if($self->{ARGS}{BUILD_REQUIRES}){$meta->{build_requires}=$self->{BUILD_REQUIRES}}else {$meta->{build_requires}={'ExtUtils::MakeMaker'=>0,}}if($self->{ARGS}{TEST_REQUIRES}){$meta->{build_requires}={%{$meta->{build_requires}},%{$self->{TEST_REQUIRES}},}}$meta->{requires}=$self->{PREREQ_PM}if defined$self->{PREREQ_PM};$meta->{requires}{perl}=_normalize_version($self->{MIN_PERL_VERSION})if$self->{MIN_PERL_VERSION}}sub _normalize_version {my ($version)=@_;$version=0 unless defined$version;if (ref$version eq 'version'){$version=$version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}sub _dump_hash {croak "first argument should be a hash ref" unless ref $_[0]eq 'HASH';my$options=shift;my%hash=@_;my@pairs;my$k_sort =exists$options->{key_sort}? $options->{key_sort}: sub {lc$a cmp lc$b};if ($k_sort){croak "'key_sort' should be a coderef" unless ref$k_sort eq 'CODE';@pairs=_sort_pairs($k_sort,\%hash)}else {@pairs=@_}my$yaml=$options->{use_header}? "--- #YAML:1.0\n" : '';my$indent=$options->{indent}|| '';my$k_length=min(($options->{max_key_length}|| 20),max(map {length($_)+ 1}grep {!ref$hash{$_}}keys%hash));my$customs=$options->{customs}|| {};my$k_format="%-${k_length}s";while(@pairs){my($key,$val)=splice@pairs,0,2;$val='~' unless defined$val;if(ref$val eq 'HASH'){if (keys %$val){my%k_options=(delta=>$options->{delta},use_header=>0,indent=>$indent .$options->{delta},);if (exists$customs->{$key}){my%k_custom=%{$customs->{$key}};for my$k (qw(key_sort max_key_length customs)){$k_options{$k}=$k_custom{$k}if exists$k_custom{$k}}}$yaml .= $indent ."$key:\n" ._dump_hash(\%k_options,%$val)}else {$yaml .= $indent ."$key:  {}\n"}}elsif (ref$val eq 'ARRAY'){if(@$val){$yaml .= $indent ."$key:\n";for (@$val){croak "only nested arrays of non-refs are supported" if ref $_;$yaml .= $indent .$options->{delta}."- $_\n"}}else {$yaml .= $indent ."$key:  []\n"}}elsif(ref$val and!blessed($val)){croak "only nested hashes, arrays and objects are supported"}else {$yaml .= $indent .sprintf "$k_format  %s\n","$key:",$val}};return$yaml}sub blessed {return eval {$_[0]->isa("UNIVERSAL")}}sub max {return (sort {$b <=> $a}@_)[0]}sub min {return (sort {$a <=> $b}@_)[0]}sub metafile_file {my$self=shift;my%dump_options=(use_header=>1,delta=>' ' x 4,key_sort=>undef,);return _dump_hash(\%dump_options,@_)}sub distmeta_target {my$self=shift;my@add_meta=($self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']),$self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']));my@add_meta_to_distdir=map {$self->cd('$(DISTVNAME)',$_)}@add_meta;return sprintf <<'MAKE',@add_meta_to_distdir}sub mymeta {my$self=shift;my$file=shift || '';my$mymeta=$self->_mymeta_from_meta($file);my$v2=1;unless ($mymeta){$mymeta=$self->metafile_data($self->{META_ADD}|| {},$self->{META_MERGE}|| {},);$v2=0}$self->_add_requirements_to_meta($mymeta);$mymeta->{dynamic_config}=0;return$mymeta}sub _mymeta_from_meta {my$self=shift;my$metafile=shift || '';return unless _has_cpan_meta();my$meta;for my$file ($metafile,"META.json","META.yml"){next unless -e $file;eval {$meta=CPAN::Meta->load_file($file)->as_struct({version=>2 })};last if$meta}return unless$meta;if ($meta->{generated_by}&& $meta->{generated_by}=~ /ExtUtils::MakeMaker version ([\d\._]+)/){my$eummv=do {no warnings;$1+0};if ($eummv < 6.2501){return}}return$meta}sub write_mymeta {my$self=shift;my$mymeta=shift;return unless _has_cpan_meta();my$meta_obj=$self->_fix_metadata_before_conversion($mymeta);$meta_obj->save('MYMETA.json',{version=>"2.0" });$meta_obj->save('MYMETA.yml',{version=>"1.4" });return 1}sub realclean {my($self,%attribs)=@_;my@dirs=qw($(DISTVNAME));my@files=qw($(FIRST_MAKEFILE) $(MAKEFILE_OLD));if($self->{PERL_CORE}){push@dirs,qw($(INST_AUTODIR) $(INST_ARCHAUTODIR));push@files,values %{$self->{PM}}}if($self->has_link_code){push@files,qw($(OBJECT))}if($attribs{FILES}){if(ref$attribs{FILES}){push@dirs,@{$attribs{FILES}}}else {push@dirs,split /\s+/,$attribs{FILES}}}{my(%f)=map {($_=>1)}@files;@files=sort keys%f}{my(%d)=map {($_=>1)}@dirs;@dirs=sort keys%d}my$rm_cmd=join "\n\t",map {"$_"}$self->split_command('- $(RM_F)',@files);my$rmf_cmd=join "\n\t",map {"$_"}$self->split_command('- $(RM_RF)',@dirs);my$m=sprintf <<'MAKE',$rm_cmd,$rmf_cmd;$m .= "\t$attribs{POSTOP}\n" if$attribs{POSTOP};return$m}sub realclean_subdirs_target {my$self=shift;my@m=<<'EOF';return join '',@m,"\t\$(NOECHO) \$(NOOP)\n" unless @{$self->{DIR}};for my$dir (@{$self->{DIR}}){for my$makefile ('$(MAKEFILE_OLD)','$(FIRST_MAKEFILE)'){my$subrclean .= $self->oneliner(_sprintf562 <<'CODE',$dir,$makefile);push@m,"\t- $subrclean\n"}}return join '',@m}sub signature_target {my$self=shift;return <<'MAKE_FRAG'}sub distsignature_target {my$self=shift;my$add_sign=$self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']);my$sign_dist=$self->cd('$(DISTVNAME)'=>'cpansign -s');my$touch_sig=$self->cd('$(DISTVNAME)'=>'$(TOUCH) SIGNATURE');my$add_sign_to_dist=$self->cd('$(DISTVNAME)'=>$add_sign);return sprintf <<'MAKE',$add_sign_to_dist,$touch_sig,$sign_dist}sub special_targets {my$make_frag=<<'MAKE_FRAG';$make_frag .= <<'MAKE_FRAG' if$ENV{CLEARCASE_ROOT};return$make_frag}sub init_ABSTRACT {my$self=shift;if($self->{ABSTRACT_FROM}and $self->{ABSTRACT}){warn "Both ABSTRACT_FROM and ABSTRACT are set.  "."Ignoring ABSTRACT_FROM.\n";return}if ($self->{ABSTRACT_FROM}){$self->{ABSTRACT}=$self->parse_abstract($self->{ABSTRACT_FROM})or carp "WARNING: Setting ABSTRACT via file "."'$self->{ABSTRACT_FROM}' failed\n"}if ($self->{ABSTRACT}&& $self->{ABSTRACT}=~ m![[:cntrl:]]+!){warn "WARNING: ABSTRACT contains control character(s),"." they will be removed\n";$self->{ABSTRACT}=~ s![[:cntrl:]]+!!g;return}}sub init_INST {my($self)=shift;$self->{INST_ARCHLIB}||= $self->catdir($Curdir,"blib","arch");$self->{INST_BIN}||= $self->catdir($Curdir,'blib','bin');unless ($self->{INST_LIB}){if ($self->{PERL_CORE}){$self->{INST_LIB}=$self->{INST_ARCHLIB}=$self->{PERL_LIB}}else {$self->{INST_LIB}=$self->catdir($Curdir,"blib","lib")}}my@parentdir=split(/::/,$self->{PARENT_NAME});$self->{INST_LIBDIR}=$self->catdir('$(INST_LIB)',@parentdir);$self->{INST_ARCHLIBDIR}=$self->catdir('$(INST_ARCHLIB)',@parentdir);$self->{INST_AUTODIR}=$self->catdir('$(INST_LIB)','auto','$(FULLEXT)');$self->{INST_ARCHAUTODIR}=$self->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)');$self->{INST_SCRIPT}||= $self->catdir($Curdir,'blib','script');$self->{INST_MAN1DIR}||= $self->catdir($Curdir,'blib','man1');$self->{INST_MAN3DIR}||= $self->catdir($Curdir,'blib','man3');return 1}sub init_INSTALL {my($self)=shift;if($self->{ARGS}{INSTALL_BASE}and $self->{ARGS}{PREFIX}){die "Only one of PREFIX or INSTALL_BASE can be given.  Not both.\n"}if($self->{ARGS}{INSTALL_BASE}){$self->init_INSTALL_from_INSTALL_BASE}else {$self->init_INSTALL_from_PREFIX}}sub init_INSTALL_from_PREFIX {my$self=shift;$self->init_lib2arch;for my$num (1,3){my$k='installsiteman'.$num.'dir';$self->{uc$k}||= uc "\$(installman${num}dir)" unless$Config{$k}}for my$num (1,3){my$k='installvendorman'.$num.'dir';unless($Config{$k}){$self->{uc$k}||= $Config{usevendorprefix}? uc "\$(installman${num}dir)" : ''}}$self->{INSTALLSITEBIN}||= '$(INSTALLBIN)' unless$Config{installsitebin};$self->{INSTALLSITESCRIPT}||= '$(INSTALLSCRIPT)' unless$Config{installsitescript};unless($Config{installvendorbin}){$self->{INSTALLVENDORBIN}||= $Config{usevendorprefix}? $Config{installbin}: ''}unless($Config{installvendorscript}){$self->{INSTALLVENDORSCRIPT}||= $Config{usevendorprefix}? $Config{installscript}: ''}my$iprefix=$Config{installprefixexp}|| $Config{installprefix}|| $Config{prefixexp}|| $Config{prefix}|| '';my$vprefix=$Config{usevendorprefix}? $Config{vendorprefixexp}: '';my$sprefix=$Config{siteprefixexp}|| '';$sprefix=$iprefix unless$sprefix;$self->{PREFIX}||= '';if($self->{PREFIX}){@{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)}=('$(PREFIX)')x 3}else {$self->{PERLPREFIX}||= $iprefix;$self->{SITEPREFIX}||= $sprefix;$self->{VENDORPREFIX}||= $vprefix;$self->{PREFIX}='$('.uc$self->{INSTALLDIRS}.'PREFIX)'}my$arch=$Config{archname};my$version=$Config{version};my$libstyle=$Config{installstyle}|| 'lib/perl5';my$manstyle='';if($self->{LIBSTYLE}){$libstyle=$self->{LIBSTYLE};$manstyle=$self->{LIBSTYLE}eq 'lib/perl5' ? 'lib/perl5' : ''}for my$num (1,3){$self->{'INSTALLMAN'.$num.'DIR'}||= 'none' unless$Config{'installman'.$num.'dir'}}my%bin_layouts=(bin=>{s=>$iprefix,t=>'perl',d=>'bin' },vendorbin=>{s=>$vprefix,t=>'vendor',d=>'bin' },sitebin=>{s=>$sprefix,t=>'site',d=>'bin' },script=>{s=>$iprefix,t=>'perl',d=>'bin' },vendorscript=>{s=>$vprefix,t=>'vendor',d=>'bin' },sitescript=>{s=>$sprefix,t=>'site',d=>'bin' },);my%man_layouts=(man1dir=>{s=>$iprefix,t=>'perl',d=>'man/man1',style=>$manstyle,},siteman1dir=>{s=>$sprefix,t=>'site',d=>'man/man1',style=>$manstyle,},vendorman1dir=>{s=>$vprefix,t=>'vendor',d=>'man/man1',style=>$manstyle,},man3dir=>{s=>$iprefix,t=>'perl',d=>'man/man3',style=>$manstyle,},siteman3dir=>{s=>$sprefix,t=>'site',d=>'man/man3',style=>$manstyle,},vendorman3dir=>{s=>$vprefix,t=>'vendor',d=>'man/man3',style=>$manstyle,},);my%lib_layouts=(privlib=>{s=>$iprefix,t=>'perl',d=>'',style=>$libstyle,},vendorlib=>{s=>$vprefix,t=>'vendor',d=>'',style=>$libstyle,},sitelib=>{s=>$sprefix,t=>'site',d=>'site_perl',style=>$libstyle,},archlib=>{s=>$iprefix,t=>'perl',d=>"$version/$arch",style=>$libstyle },vendorarch=>{s=>$vprefix,t=>'vendor',d=>"$version/$arch",style=>$libstyle },sitearch=>{s=>$sprefix,t=>'site',d=>"site_perl/$version/$arch",style=>$libstyle },);if($self->{LIB}){for my$var (keys%lib_layouts){my$Installvar=uc "install$var";if($var =~ /arch/){$self->{$Installvar}||= $self->catdir($self->{LIB},$Config{archname})}else {$self->{$Installvar}||= $self->{LIB}}}}my%type2prefix=(perl=>'PERLPREFIX',site=>'SITEPREFIX',vendor=>'VENDORPREFIX');my%layouts=(%bin_layouts,%man_layouts,%lib_layouts);while(my($var,$layout)=each(%layouts)){my($s,$t,$d,$style)=@{$layout}{qw(s t d style)};my$r='$('.$type2prefix{$t}.')';warn "Prefixing $var\n" if$Verbose >= 2;my$installvar="install$var";my$Installvar=uc$installvar;next if$self->{$Installvar};$d="$style/$d" if$style;$self->prefixify($installvar,$s,$r,$d);warn "  $Installvar == $self->{$Installvar}\n" if$Verbose >= 2}$self->{VENDORARCHEXP}||= $self->{INSTALLVENDORARCH};$self->{VENDORLIBEXP}||= $self->{INSTALLVENDORLIB};return 1}my%map=(lib=>[qw(lib perl5)],arch=>[('lib','perl5',$Config{archname})],bin=>[qw(bin)],man1dir=>[qw(man man1)],man3dir=>[qw(man man3)]);$map{script}=$map{bin};sub init_INSTALL_from_INSTALL_BASE {my$self=shift;@{$self}{qw(PREFIX VENDORPREFIX SITEPREFIX PERLPREFIX)}='$(INSTALL_BASE)';my%install;for my$thing (keys%map){for my$dir (('','SITE','VENDOR')){my$uc_thing=uc$thing;my$key="INSTALL".$dir.$uc_thing;$install{$key}||= ($thing =~ /^man.dir$/ and not $Config{lc$key})? 'none' : $self->catdir('$(INSTALL_BASE)',@{$map{$thing}})}}$install{INSTALLARCHLIB}||= delete$install{INSTALLARCH};$install{INSTALLPRIVLIB}||= delete$install{INSTALLLIB};for my$key (keys%install){$self->{$key}||= $install{$key}}return 1}sub init_VERSION {my($self)=shift;$self->{MAKEMAKER}=$ExtUtils::MakeMaker::Filename;$self->{MM_VERSION}=$ExtUtils::MakeMaker::VERSION;$self->{MM_REVISION}=$ExtUtils::MakeMaker::Revision;$self->{VERSION_FROM}||= '';if ($self->{VERSION_FROM}){$self->{VERSION}=$self->parse_version($self->{VERSION_FROM});if($self->{VERSION}eq 'undef'){carp("WARNING: Setting VERSION via file "."'$self->{VERSION_FROM}' failed\n")}}if (defined$self->{VERSION}){if ($self->{VERSION}!~ /^\s*v?[\d_\.]+\s*$/){require version;my$normal=eval {version->new($self->{VERSION})};$self->{VERSION}=$normal if defined$normal}$self->{VERSION}=~ s/^\s+//;$self->{VERSION}=~ s/\s+$//}else {$self->{VERSION}=''}$self->{VERSION_MACRO}='VERSION';($self->{VERSION_SYM}=$self->{VERSION})=~ s/\W/_/g;$self->{DEFINE_VERSION}='-D$(VERSION_MACRO)=\"$(VERSION)\"';$self->{XS_VERSION}||= $self->{VERSION};$self->{XS_VERSION_MACRO}='XS_VERSION';$self->{XS_DEFINE_VERSION}='-D$(XS_VERSION_MACRO)=\"$(XS_VERSION)\"'}sub init_tools {my$self=shift;$self->{ECHO}||= $self->oneliner('binmode STDOUT, qq{:raw}; print qq{@ARGV}',['-l']);$self->{ECHO_N}||= $self->oneliner('print qq{@ARGV}');$self->{TOUCH}||= $self->oneliner('touch',["-MExtUtils::Command"]);$self->{CHMOD}||= $self->oneliner('chmod',["-MExtUtils::Command"]);$self->{RM_F}||= $self->oneliner('rm_f',["-MExtUtils::Command"]);$self->{RM_RF}||= $self->oneliner('rm_rf',["-MExtUtils::Command"]);$self->{TEST_F}||= $self->oneliner('test_f',["-MExtUtils::Command"]);$self->{TEST_S}||= $self->oneliner('test_s',["-MExtUtils::Command::MM"]);$self->{CP_NONEMPTY}||= $self->oneliner('cp_nonempty',["-MExtUtils::Command::MM"]);$self->{FALSE}||= $self->oneliner('exit 1');$self->{TRUE}||= $self->oneliner('exit 0');$self->{MKPATH}||= $self->oneliner('mkpath',["-MExtUtils::Command"]);$self->{CP}||= $self->oneliner('cp',["-MExtUtils::Command"]);$self->{MV}||= $self->oneliner('mv',["-MExtUtils::Command"]);$self->{MOD_INSTALL}||= $self->oneliner(<<'CODE',['-MExtUtils::Install']);$self->{DOC_INSTALL}||= $self->oneliner('perllocal_install',["-MExtUtils::Command::MM"]);$self->{UNINSTALL}||= $self->oneliner('uninstall',["-MExtUtils::Command::MM"]);$self->{WARN_IF_OLD_PACKLIST}||= $self->oneliner('warn_if_old_packlist',["-MExtUtils::Command::MM"]);$self->{FIXIN}||= $self->oneliner('MY->fixin(shift)',["-MExtUtils::MY"]);$self->{EQUALIZE_TIMESTAMP}||= $self->oneliner('eqtime',["-MExtUtils::Command"]);$self->{UNINST}||= 0;$self->{VERBINST}||= 0;$self->{SHELL}||= $Config{sh};$self->{UMASK_NULL}||= "umask 0";$self->{DEV_NULL}||= "> /dev/null 2>&1";$self->{NOOP}||= '$(TRUE)';$self->{NOECHO}='@' unless defined$self->{NOECHO};$self->{FIRST_MAKEFILE}||= $self->{MAKEFILE}|| 'Makefile';$self->{MAKEFILE}||= $self->{FIRST_MAKEFILE};$self->{MAKEFILE_OLD}||= $self->{MAKEFILE}.'.old';$self->{MAKE_APERL_FILE}||= $self->{MAKEFILE}.'.aperl';$self->{USEMAKEFILE}||= '-f';$self->{MACROSTART}||= '';$self->{MACROEND}||= '';return}sub init_others {my$self=shift;$self->{LD_RUN_PATH}="";$self->{LIBS}=$self->_fix_libs($self->{LIBS});for my$libs (@{$self->{LIBS}}){$libs =~ s/^\s*(.*\S)\s*$/$1/;my(@libs)=$self->extliblist($libs);if ($libs[0]or $libs[1]or $libs[2]){($self->{EXTRALIBS},$self->{BSLOADLIBS},$self->{LDLOADLIBS},$self->{LD_RUN_PATH})=@libs;last}}if ($self->{OBJECT}){$self->{OBJECT}=join(" ",@{$self->{OBJECT}})if ref$self->{OBJECT};$self->{OBJECT}=~ s!\.o(bj)?\b!\$(OBJ_EXT)!g}elsif (($self->{MAGICXS}|| $self->{XSMULTI})&& @{$self->{O_FILES}||[]}){$self->{OBJECT}=join(" ",@{$self->{O_FILES}});$self->{OBJECT}=~ s!\.o(bj)?\b!\$(OBJ_EXT)!g}else {$self->{OBJECT}="";$self->{OBJECT}='$(BASEEXT)$(OBJ_EXT)' if @{$self->{C}||[]}}$self->{OBJECT}=~ s/\n+/ \\\n\t/g;$self->{BOOTDEP}=(-f "$self->{BASEEXT}_BS")? "$self->{BASEEXT}_BS" : "";$self->{PERLMAINCC}||= '$(CC)';$self->{LDFROM}='$(OBJECT)' unless$self->{LDFROM};if (!$self->{LINKTYPE}){$self->{LINKTYPE}=$self->{SKIPHASH}{'dynamic'}? 'static' : ($Config{usedl}? 'dynamic' : 'static')}return}sub _fix_libs {my($self,$libs)=@_;return!defined$libs ? ['']: !ref$libs ? [$libs]: !defined$libs->[0]? ['']: $libs }sub tools_other {my($self)=shift;my@m;for my$tool (qw{SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP FALSE TRUE ECHO ECHO_N UNINST VERBINST MOD_INSTALL DOC_INSTALL UNINSTALL WARN_IF_OLD_PACKLIST MACROSTART MACROEND USEMAKEFILE PM_FILTER FIXIN CP_NONEMPTY}){next unless defined$self->{$tool};push@m,"$tool = $self->{$tool}\n"}return join "",@m}sub init_platform {return ''}sub init_MAKE {my$self=shift;$self->{MAKE}||= $ENV{MAKE}|| $Config{make}}sub manifypods {my$self=shift;my$POD2MAN_macro=$self->POD2MAN_macro();my$manifypods_target=$self->manifypods_target();return <<END_OF_TARGET}sub POD2MAN_macro {my$self=shift;return <<'END_OF_DEF'}sub test_via_harness {my($self,$perl,$tests)=@_;return qq{\t$perl "-MExtUtils::Command::MM" "-MTest::Harness" }.qq{"-e" "undef *Test::Harness::Switches; test_harness(\$(TEST_VERBOSE), '\$(INST_LIB)', '\$(INST_ARCHLIB)')" $tests\n}}sub test_via_script {my($self,$perl,$script)=@_;return qq{\t$perl "-I\$(INST_LIB)" "-I\$(INST_ARCHLIB)" $script\n}}sub tool_autosplit {my($self,%attribs)=@_;my$maxlen=$attribs{MAXLEN}? '$$AutoSplit::Maxlen=$attribs{MAXLEN};' : '';my$asplit=$self->oneliner(sprintf <<'PERL_CODE',$maxlen);return sprintf <<'MAKE_FRAG',$asplit}sub arch_check {my$self=shift;my($pconfig,$cconfig)=@_;return 1 if$self->{PERL_SRC};my($pvol,$pthinks)=$self->splitpath($pconfig);my($cvol,$cthinks)=$self->splitpath($cconfig);$pthinks=$self->canonpath($pthinks);$cthinks=$self->canonpath($cthinks);my$ret=1;if ($pthinks ne $cthinks){print "Have $pthinks\n";print "Want $cthinks\n";$ret=0;my$arch=(grep length,$self->splitdir($pthinks))[-1];print <<END unless$self->{UNINSTALLED_PERL}}return$ret}sub catfile {my$self=shift;return$self->canonpath($self->SUPER::catfile(@_))}sub find_tests {my($self)=shift;return -d 't' ? 't/*.t' : ''}sub find_tests_recursive {my$self=shift;return$self->find_tests_recursive_in('t')}sub find_tests_recursive_in {my($self,$dir)=@_;return '' unless -d $dir;require File::Find;my$base_depth=grep {$_ ne ''}File::Spec->splitdir((File::Spec->splitpath($dir))[1]);my%depths;my$wanted=sub {return unless m!\.t$!;my ($volume,$directories,$file)=File::Spec->splitpath($File::Find::name);my$depth=grep {$_ ne ''}File::Spec->splitdir($directories);$depth -= $base_depth;$depths{$depth }=1};File::Find::find($wanted,$dir);return join ' ',map {$dir .'/*' x $_ .'.t'}sort {$a <=> $b}keys%depths}sub extra_clean_files {return}sub installvars {return qw(PRIVLIB SITELIB VENDORLIB ARCHLIB SITEARCH VENDORARCH BIN SITEBIN VENDORBIN SCRIPT SITESCRIPT VENDORSCRIPT MAN1DIR SITEMAN1DIR VENDORMAN1DIR MAN3DIR SITEMAN3DIR VENDORMAN3DIR)}sub libscan {my($self,$path)=@_;if ($path =~ m<^README\.pod$>i){warn "WARNING: Older versions of ExtUtils::MakeMaker may errantly install $path as part of this distribution. It is recommended to avoid using this path in CPAN modules.\n";return ''}my($dirs,$file)=($self->splitpath($path))[1,2];return '' if grep /^(?:RCS|CVS|SCCS|\.svn|_darcs)$/,$self->splitdir($dirs),$file;return$path}sub platform_constants {return ''}sub post_constants {""}sub post_initialize {""}sub postamble {""}sub _PREREQ_PRINT {my$self=shift;require Data::Dumper;my@what=('PREREQ_PM');push@what,'MIN_PERL_VERSION' if$self->{MIN_PERL_VERSION};push@what,'BUILD_REQUIRES' if$self->{BUILD_REQUIRES};print Data::Dumper->Dump([@{$self}{@what}],\@what);exit 0}sub _PRINT_PREREQ {my$self=shift;my$prereqs=$self->{PREREQ_PM};my@prereq=map {[$_,$prereqs->{$_}]}keys %$prereqs;if ($self->{MIN_PERL_VERSION}){push@prereq,['perl'=>$self->{MIN_PERL_VERSION}]}print join(" ",map {"perl($_->[0])>=$_->[1] "}sort {$a->[0]cmp $b->[0]}@prereq),"\n";exit 0}sub _perl_header_files {my$self=shift;my$header_dir=$self->{PERL_SRC}|| $ENV{PERL_SRC}|| $self->catdir($Config{archlibexp},'CORE');opendir my$dh,$header_dir or die "Failed to opendir '$header_dir' to find header files: $!";my@perl_headers=sort grep {/\.h\z/}readdir($dh);closedir$dh;return@perl_headers}sub _perl_header_files_fragment {my ($self,$separator)=@_;$separator ||= "";return join("\\\n","PERL_HDRS = ",map {sprintf("        \$(PERL_INCDEP)%s%s            ",$separator,$_)}$self->_perl_header_files())."\n\n" ."\$(OBJECT) : \$(PERL_HDRS)\n"}1;
  makemakerdflt : all
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  manifypods : pure_all config $dependencies
  END
  	$(NOECHO) $(POD2MAN) --section=%s --perm_rw=$(PERM_RW)%s
  CMD
  metafile :
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  metafile : create_distdir
  	$(NOECHO) $(ECHO) Generating META.yml
  	%s
  	-$(NOECHO) $(MV) META_new.yml $(DISTVNAME)/META.yml
  	$(NOECHO) $(ECHO) Generating META.json
  	%s
  	-$(NOECHO) $(MV) META_new.json $(DISTVNAME)/META.json
  MAKE_FRAG
  exit unless -e q{META.yml};
  eval { maniadd({q{META.yml} => q{Module YAML meta-data (added by MakeMaker)}}) }
      or die "Could not add META.yml to MANIFEST: ${'@'}"
  CODE
  exit unless -f q{META.json};
  eval { maniadd({q{META.json} => q{Module JSON meta-data (added by MakeMaker)}}) }
      or die "Could not add META.json to MANIFEST: ${'@'}"
  CODE
  distmeta : create_distdir metafile
  	$(NOECHO) %s
  	$(NOECHO) %s
  
  MAKE
  # Delete temporary files (via clean) and also delete dist files
  realclean purge :: realclean_subdirs
  	%s
  	%s
  MAKE
  # so clean is forced to complete before realclean_subdirs runs
  realclean_subdirs : clean
  EOF
  chdir '%1$s';  system '$(MAKE) $(USEMAKEFILE) %2$s realclean' if -f '%2$s';
  CODE
  signature :
  	cpansign -s
  MAKE_FRAG
  eval { maniadd({q{SIGNATURE} => q{Public-key signature (added by MakeMaker)}}) }
      or die "Could not add SIGNATURE to MANIFEST: ${'@'}"
  CODE
  distsignature : distmeta
  	$(NOECHO) %s
  	$(NOECHO) %s
  	%s
  
  MAKE
  .SUFFIXES : .xs .c .C .cpp .i .s .cxx .cc $(OBJ_EXT)
  
  .PHONY: all config static dynamic test linkext manifest blibdirs clean realclean disttest distdir pure_all subdirs clean_subdirs makemakerdflt manifypods realclean_subdirs subdirs_dynamic subdirs_pure_nolink subdirs_static subdirs-test_dynamic subdirs-test_static test_dynamic test_static
  
  MAKE_FRAG
  .NO_CONFIG_REC: Makefile
  
  MAKE_FRAG
  install([ from_to => {@ARGV}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  
  $POD2MAN_macro
  
  $manifypods_target
  
  END_OF_TARGET
  POD2MAN_EXE = $(PERLRUN) "-MExtUtils::Command::MM" -e pod2man "--"
  POD2MAN = $(POD2MAN_EXE)
  END_OF_DEF
  use AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1)
  PERL_CODE
  # Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
  AUTOSPLITFILE = %s
  
  MAKE_FRAG
  Your perl and your Config.pm seem to have different ideas about the
  architecture they are running on.
  Perl thinks: [$arch]
  Config says: [$Config{archname}]
  This may or may not cause problems. Please check your installation of perl
  if you have problems building this extension.
  END
EXTUTILS_MM_ANY

$fatpacked{"ExtUtils/MM_BeOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_BEOS';
  package ExtUtils::MM_BeOS;use strict;use warnings;use ExtUtils::MakeMaker::Config;use File::Spec;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);our$VERSION='7.60';$VERSION =~ tr/_//d;sub os_flavor {return('BeOS')}sub init_linker {my($self)=shift;$self->{PERL_ARCHIVE}||= File::Spec->catdir('$(PERL_INC)',$Config{libperl});$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}1;
EXTUTILS_MM_BEOS

$fatpacked{"ExtUtils/MM_Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_CYGWIN';
  package ExtUtils::MM_Cygwin;use strict;use warnings;use ExtUtils::MakeMaker::Config;use File::Spec;require ExtUtils::MM_Unix;require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Unix);our$VERSION='7.60';$VERSION =~ tr/_//d;sub os_flavor {return('Unix','Cygwin')}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my$base=$self->SUPER::cflags($libperl);for (split /\n/,$base){/^(\S*)\s*=\s*(\S*)$/ and $self->{$1}=$2};$self->{CCFLAGS}.= " -DUSEIMPORTLIB" if ($Config{useshrplib}eq 'true');return$self->{CFLAGS}=qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s{/+}{.}g;return$man}sub init_linker {my$self=shift;if ($Config{useshrplib}eq 'true'){my$libperl='$(PERL_INC)' .'/'."$Config{libperl}";if("$]" >= 5.006002){$libperl =~ s/(dll\.)?a$/dll.a/}$self->{PERL_ARCHIVE}=$libperl}else {$self->{PERL_ARCHIVE}='$(PERL_INC)' .'/'.("$Config{libperl}" or "libperl.a")}$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}sub init_others {my$self=shift;$self->SUPER::init_others;$self->{LDLOADLIBS}||= $Config{perllibs};return}sub maybe_command {my ($self,$file)=@_;my$cygpath=Cygwin::posix_to_win_path('/',1);my$filepath=Cygwin::posix_to_win_path($file,1);return (substr($filepath,0,length($cygpath))eq $cygpath)? $self->SUPER::maybe_command($file): ExtUtils::MM_Win32->maybe_command($file)}sub dynamic_lib {my($self,%attribs)=@_;my$s=ExtUtils::MM_Unix::dynamic_lib($self,%attribs);return '' unless$s;return$s unless %{$self->{XS}};$s .= "\t/bin/find \$\(INST_ARCHLIB\)/auto -xdev -name \\*.$self->{DLEXT} | /bin/rebase -sOT -" if (($Config{myarchname}eq 'i686-cygwin')and not (exists$ENV{CYGPORT_PACKAGE_VERSION}));$s}sub install {my($self,%attribs)=@_;my$s=ExtUtils::MM_Unix::install($self,%attribs);return '' unless$s;return$s unless %{$self->{XS}};my$INSTALLDIRS=$self->{INSTALLDIRS};my$INSTALLLIB=$self->{"INSTALL".($INSTALLDIRS eq 'perl' ? 'ARCHLIB' : uc($INSTALLDIRS)."ARCH")};my$dop="\$\(DESTDIR\)$INSTALLLIB/auto/";my$dll="$dop/$self->{FULLEXT}/$self->{BASEEXT}.$self->{DLEXT}";$s =~ s|^(pure_install :: pure_\$\(INSTALLDIRS\)_install\n\t)\$\(NOECHO\) \$\(NOOP\)\n|$1\$(CHMOD) \$(PERM_RWX) $dll\n\t/bin/find $dop -xdev -name \\*.$self->{DLEXT} \| /bin/rebase -sOT -\n|m if (($Config{myarchname}eq 'i686-cygwin')and not (exists$ENV{CYGPORT_PACKAGE_VERSION}));$s}1;
EXTUTILS_MM_CYGWIN

$fatpacked{"ExtUtils/MM_DOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DOS';
  package ExtUtils::MM_DOS;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);sub os_flavor {return('DOS')}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,__,g;return$man}sub xs_static_lib_is_xs {return 1}1;
EXTUTILS_MM_DOS

$fatpacked{"ExtUtils/MM_Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DARWIN';
  package ExtUtils::MM_Darwin;use strict;use warnings;BEGIN {require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix)}our$VERSION='7.60';$VERSION =~ tr/_//d;sub init_dist {my$self=shift;$self->{TAR}||= 'COPY_EXTENDED_ATTRIBUTES_DISABLE=1 COPYFILE_DISABLE=1 tar';$self->SUPER::init_dist(@_)}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my$base=$self->SUPER::cflags($libperl);for (split /\n/,$base){/^(\S*)\s*=\s*(\S*)$/ and $self->{$1}=$2};$self->{CCFLAGS}.= " -Wno-error=implicit-function-declaration";return$self->{CFLAGS}=qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}1;
EXTUTILS_MM_DARWIN

$fatpacked{"ExtUtils/MM_MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_MACOS';
  package ExtUtils::MM_MacOS;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;sub new {die 'MacOS Classic (MacPerl) is no longer supported by MakeMaker'}1;
EXTUTILS_MM_MACOS

$fatpacked{"ExtUtils/MM_NW5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_NW5';
  package ExtUtils::MM_NW5;use strict;use warnings;use ExtUtils::MakeMaker::Config;use File::Basename;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Win32);use ExtUtils::MakeMaker qw(&neatvalue &_sprintf562);$ENV{EMXSHELL}='sh';my$BORLAND=$Config{'cc'}=~ /\bbcc/i;my$GCC=$Config{'cc'}=~ /\bgcc/i;sub os_flavor {my$self=shift;return ($self->SUPER::os_flavor,'Netware')}sub init_platform {my($self)=shift;$self->SUPER::init_platform;my$libpth=$Config{'libpth'};$libpth =~ s( )(;);$self->{'LIBPTH'}=$libpth;$self->{'BASE_IMPORT'}=$Config{'base_import'};if($self->{'base_import'}){$self->{'BASE_IMPORT'}.= ', ' .$self->{'base_import'}}$self->{'NLM_VERSION'}=$Config{'nlm_version'};$self->{'MPKTOOL'}=$Config{'mpktool'};$self->{'TOOLPATH'}=$Config{'toolpath'};(my$boot=$self->{'NAME'})=~ s/:/_/g;$self->{'BOOT_SYMBOL'}=$boot;if(length($self->{'BASEEXT'})> 8){$self->{'NLM_SHORT_NAME'}=substr($self->{'BASEEXT'},0,8)}($self->{INCLUDE}=$Config{'incpath'})=~ s/([ ]*)-I/;/g;$self->{PATH}='$(PATH);$(TOOLPATH)';$self->{MM_NW5_VERSION}=$VERSION}sub platform_constants {my($self)=shift;my$make_frag='';$make_frag .= $self->SUPER::platform_constants;for my$macro (qw(LIBPTH BASE_IMPORT NLM_VERSION MPKTOOL TOOLPATH BOOT_SYMBOL NLM_SHORT_NAME INCLUDE PATH MM_NW5_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub static_lib_pure_cmd {my ($self,$src)=@_;$src =~ s/(\$\(\w+)(\))/$1:^"+"$2/g if$BORLAND;sprintf qq{\t\$(AR) %s\n},($BORLAND ? '$@ ' .$src : ($GCC ? '-ru $@ ' .$src : '-type library -o $@ ' .$src))}sub xs_static_lib_is_xs {return 1}sub xs_make_dynamic_lib {my ($self,$attribs,$from,$to,$todir,$ldfrom,$exportlist)=@_;my@m;if ($to =~ /^\$/){if ($self->{NLM_SHORT_NAME}){my$newto=q{$(INST_AUTODIR)\\$(NLM_SHORT_NAME).$(DLEXT)};push@m,"$to: $newto\n\n";$to=$newto}}else {my ($v,$d,$f)=File::Spec->splitpath($to);if ($f =~ /[^\.]{9}\./){$f=substr$f,0,8}my$newto=File::Spec->catpath($v,$d,$f);push@m,"$to: $newto\n\n";$to=$newto}push@m,_sprintf562 <<'MAKE_FRAG',$to,$from,$todir,$exportlist;if ($self->{CCFLAGS}=~ m/ -DMPK_ON /){(my$xdc=$exportlist)=~ s#def\z#xdc#;$xdc='$(BASEEXT).xdc';push@m,sprintf <<'MAKE_FRAG',$xdc,$exportlist}my$version=join '.',map {sprintf "%d",$_}"$]" =~ /(\d)\.(\d{3})(\d{2})/;push@m,sprintf <<'EOF',$from,$version,$to,$exportlist;join '',@m}1;
  # Create xdc data for an MT safe NLM in case of mpk build
  %1$s: %2$s $(MYEXTLIB) $(BOOTSTRAP) %3$s$(DFSEP).exists
  	$(NOECHO) $(ECHO) Export boot_$(BOOT_SYMBOL) > %4$s
  	$(NOECHO) $(ECHO) $(BASE_IMPORT) >> %4$s
  	$(NOECHO) $(ECHO) Import @$(PERL_INC)\perl.imp >> %4$s
  MAKE_FRAG
  	$(MPKTOOL) $(XDCFLAGS) %s
  	$(NOECHO) $(ECHO) xdcdata $(BASEEXT).xdc >> %s
  MAKE_FRAG
  	$(LD) $(LDFLAGS) %s -desc "Perl %s Extension ($(BASEEXT))  XS_VERSION: $(XS_VERSION)" -nlmversion $(NLM_VERSION) -o %s $(MYEXTLIB) $(PERL_INC)\Main.lib -commandfile %s
  	$(CHMOD) 755 $@
  EOF
EXTUTILS_MM_NW5

$fatpacked{"ExtUtils/MM_OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_OS2';
  package ExtUtils::MM_OS2;use strict;use warnings;use ExtUtils::MakeMaker qw(neatvalue);use File::Spec;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);sub init_dist {my($self)=@_;$self->{TO_UNIX}||= <<'MAKE_TEXT';$self->SUPER::init_dist}sub dlsyms {my($self,%attribs)=@_;if ($self->{IMPORTS}&& %{$self->{IMPORTS}}){-d 'tmp_imp' or mkdir 'tmp_imp',0777 or die "Can't mkdir tmp_imp";open my$imp,'>','tmpimp.imp' or die "Can't open tmpimp.imp";for my$name (sort keys %{$self->{IMPORTS}}){my$exp=$self->{IMPORTS}->{$name};my ($lib,$id)=($exp =~ /(.*)\.(.*)/)or die "Malformed IMPORT `$exp'";print$imp "$name $lib $id ?\n"}close$imp or die "Can't close tmpimp.imp";system "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp" and die "Cannot make import library: $!, \$?=$?";eval {unlink <tmp_imp/*>;1}or system "rm tmp_imp/*";system "cd tmp_imp; $Config::Config{ar} x ../tmpimp$Config::Config{lib_ext}" and die "Cannot extract import objects: $!, \$?=$?"}return '' if$self->{SKIPHASH}{'dynamic'};$self->xs_dlsyms_iterator(\%attribs)}sub xs_dlsyms_ext {'.def'}sub xs_dlsyms_extra {join '',map {qq{, "$_" => "\$($_)"}}qw(VERSION DISTNAME INSTALLDIRS)}sub static_lib_pure_cmd {my($self)=@_;my$old=$self->SUPER::static_lib_pure_cmd;return$old unless$self->{IMPORTS}&& %{$self->{IMPORTS}};$old .<<'EOC'}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,.,g;$man}sub maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}sub init_linker {my$self=shift;$self->{PERL_ARCHIVE}="\$(PERL_INC)/libperl\$(LIB_EXT)";$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}=$OS2::is_aout ? '' : '$(PERL_INC)/libperl_override$(LIB_EXT)';$self->{EXPORT_LIST}='$(BASEEXT).def'}sub os_flavor {return('OS/2')}sub xs_static_lib_is_xs {return 1}1;
  $(NOECHO) $(TEST_F) tmp.zip && $(RM_F) tmp.zip; $(ZIP) -ll -mr tmp.zip $(DISTVNAME) && unzip -o tmp.zip && $(RM_F) tmp.zip
  MAKE_TEXT
  	$(AR) $(AR_STATIC_ARGS) "$@" tmp_imp/*
  	$(RANLIB) "$@"
  EOC
EXTUTILS_MM_OS2

$fatpacked{"ExtUtils/MM_OS390.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_OS390';
  package ExtUtils::MM_OS390;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;use ExtUtils::MakeMaker::Config;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub xs_make_dynamic_lib {my ($self,$attribs,$object,$to,$todir,$ldfrom,$exportlist,$dlsyms)=@_;$exportlist='' if$exportlist ne '$(EXPORT_LIST)';my$armaybe=$self->_xs_armaybe($attribs);my@m=sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP) %s'."\n",$to,$object,$todir,$exportlist,($dlsyms || '');my$dlsyms_arg=$self->xs_dlsyms_arg($dlsyms);if ($armaybe ne ':'){$ldfrom='tmp$(LIB_EXT)';push(@m,"	\$(ARMAYBE) cr $ldfrom $object\n");push(@m,"	\$(RANLIB) $ldfrom\n")}push(@m,"	\$(RM_F) \$\@\n");my$libs='$(LDLOADLIBS)';my$ld_run_path_shell="";if ($self->{LD_RUN_PATH}ne ""){$ld_run_path_shell='LD_RUN_PATH="$(LD_RUN_PATH)" '}push@m,sprintf <<'MAKE',$ld_run_path_shell,$dlsyms_arg,$self->xs_obj_opt('$@'),$ldfrom,$libs,$exportlist;join '',@m}1;
  	%s$(LD) $(LDDLFLAGS) %s $(OTHERLDFLAGS) %s $(MYEXTLIB) %s \
  	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) %s \
  	  $(INST_DYNAMIC_FIX)
  	$(CHMOD) $(PERM_RWX) $@
  MAKE
EXTUTILS_MM_OS390

$fatpacked{"ExtUtils/MM_QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_QNX';
  package ExtUtils::MM_QNX;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub extra_clean_files {my$self=shift;my@errfiles=@{$self->{C}};for (@errfiles){s/.c$/.err/}return(@errfiles,'perlmain.err')}1;
EXTUTILS_MM_QNX

$fatpacked{"ExtUtils/MM_UWIN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UWIN';
  package ExtUtils::MM_UWIN;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub os_flavor {return('Unix','U/WIN')}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,.,g;return$man}1;
EXTUTILS_MM_UWIN

$fatpacked{"ExtUtils/MM_Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UNIX';
  package ExtUtils::MM_Unix;require 5.006;use strict;use warnings;use Carp;use ExtUtils::MakeMaker::Config;use File::Basename qw(basename dirname);our%Config_Override;use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);use vars qw($VERSION);$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Any;our@ISA=qw(ExtUtils::MM_Any);my%Is;BEGIN {$Is{OS2}=$^O eq 'os2';$Is{Win32}=$^O eq 'MSWin32' || $Config{osname}eq 'NetWare';$Is{Dos}=$^O eq 'dos';$Is{VMS}=$^O eq 'VMS';$Is{OSF}=$^O eq 'dec_osf';$Is{IRIX}=$^O eq 'irix';$Is{NetBSD}=$^O eq 'netbsd';$Is{Interix}=$^O eq 'interix';$Is{SunOS4}=$^O eq 'sunos';$Is{Solaris}=$^O eq 'solaris';$Is{SunOS}=$Is{SunOS4}|| $Is{Solaris};$Is{BSD}=($^O =~ /^(?:free|net|open)bsd$/ or grep($^O eq $_,qw(bsdos interix dragonfly)));$Is{Android}=$^O =~ /android/;if ($^O eq 'darwin' && $^X eq '/usr/bin/perl'){my@osvers=split /\./,$Config{osvers};$Is{ApplCor}=($osvers[0]>= 18)}}BEGIN {if($Is{VMS}){require VMS::Filespec;VMS::Filespec->import}}my$Curdir=__PACKAGE__->curdir;my$Updir=__PACKAGE__->updir;sub os_flavor {return('Unix')}sub c_o {my($self)=shift;return '' unless$self->needs_linking();my(@m);my$command='$(CCCMD)';my$flags='$(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE)';if ($Is{ApplCor}){$flags =~ s/"-I(\$\(PERL_INC\))"/-iwithsysroot "$1"/}if (my$cpp=$Config{cpprun}){my$cpp_cmd=$self->const_cccmd;$cpp_cmd =~ s/^CCCMD\s*=\s*\$\(CC\)/$cpp/;push@m,qq{
  .c.i:
  	$cpp_cmd $flags \$*.c > \$*.i
  }}my$m_o=$self->{XSMULTI}? $self->xs_obj_opt('$*.s'): '';push@m,sprintf <<'EOF',$command,$flags,$m_o;my@exts=qw(c cpp cxx cc);push@exts,'C' if!$Is{OS2}and!$Is{Win32}and!$Is{Dos};$m_o=$self->{XSMULTI}? $self->xs_obj_opt('$*$(OBJ_EXT)'): '';my$dbgout=$self->dbgoutflag;for my$ext (@exts){push@m,"\n.$ext\$(OBJ_EXT) :\n\t$command $flags " .($dbgout?"$dbgout ":'')."\$*.$ext" .($m_o ? " $m_o" : '')."\n"}return join "",@m}sub xs_obj_opt {my ($self,$output_file)=@_;"-o $output_file"}sub dbgoutflag {''}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my($prog,$uc,$perltype,%cflags);$libperl ||= $self->{LIBPERL_A}|| "libperl$self->{LIB_EXT}" ;$libperl =~ s/\.\$\(A\)$/$self->{LIB_EXT}/;@cflags{qw(cc ccflags optimize shellflags)}=@Config{qw(cc ccflags optimize shellflags)};my@ccextraflags=qw(ccwarnflags);if ($ENV{PERL_CORE}){for my$x (@ccextraflags){if (exists$Config{$x}){$cflags{$x}=$Config{$x}}}}my($optdebug)="";$cflags{shellflags}||= '';my(%map)=(D=>'-DDEBUGGING',E=>'-DEMBED',DE=>'-DDEBUGGING -DEMBED',M=>'-DEMBED -DMULTIPLICITY',DM=>'-DDEBUGGING -DEMBED -DMULTIPLICITY',);if ($libperl =~ /libperl(\w*)\Q$self->{LIB_EXT}/){$uc=uc($1)}else {$uc=""}$perltype=$map{$uc}? $map{$uc}: "";if ($uc =~ /^D/){$optdebug="-g"}my($name);($name=$self->{NAME}."_cflags")=~ s/:/_/g ;if ($prog=$Config{$name}){print "Processing $name hint:\n" if$Verbose;my(@o)=`cc=\"$cflags{cc}\"
  
  .c.s :
  	%s -S %s $*.c %s
  EOF
  	  ccflags=\"$cflags{ccflags}\"
  	  optimize=\"$cflags{optimize}\"
  	  perltype=\"$cflags{perltype}\"
  	  optdebug=\"$cflags{optdebug}\"
  	  eval '$prog'
  	  echo cc=\$cc
  	  echo ccflags=\$ccflags
  	  echo optimize=\$optimize
  	  echo perltype=\$perltype
  	  echo optdebug=\$optdebug
  	  `;for my$line (@o){chomp$line;if ($line =~ /(.*?)=\s*(.*)\s*$/){$cflags{$1}=$2;print "	$1 = $2\n" if$Verbose}else {print "Unrecognised result from hint: '$line'\n"}}}if ($optdebug){$cflags{optimize}=$optdebug}for (qw(ccflags optimize perltype)){$cflags{$_}||= '';$cflags{$_}=~ s/^\s+//;$cflags{$_}=~ s/\s+/ /g;$cflags{$_}=~ s/\s+$//;$self->{uc $_}||= $cflags{$_}}if ($self->{POLLUTE}){$self->{CCFLAGS}.= ' -DPERL_POLLUTE '}for my$x (@ccextraflags){next unless exists$cflags{$x};$self->{CCFLAGS}.= $cflags{$x}=~ m!^\s! ? $cflags{$x}: ' ' .$cflags{$x}}my$pollute='';if ($Config{usemymalloc}and not $Config{bincompat5005}and not $Config{ccflags}=~ /-DPERL_POLLUTE_MALLOC\b/ and $self->{PERL_MALLOC_OK}){$pollute='$(PERL_MALLOC_DEF)'}return$self->{CFLAGS}=qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  MPOLLUTE = $pollute
  }}sub const_cccmd {my($self,$libperl)=@_;return$self->{CONST_CCCMD}if$self->{CONST_CCCMD};return '' unless$self->needs_linking();return$self->{CONST_CCCMD}=q{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\
  	$(CCFLAGS) $(OPTIMIZE) \\
  	$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\
  	$(XS_DEFINE_VERSION)}}sub const_config {my($self)=shift;my@m=$self->specify_shell();push@m,<<"END";my(%once_only);for my$key (@{$self->{CONFIG}}){next if$once_only{$key};push@m,uc($key),' = ',$self->{uc$key},"\n";$once_only{$key}=1}join('',@m)}sub const_loadlibs {my($self)=shift;return "" unless$self->needs_linking;my@m;push@m,qq{
  
  # These definitions are from config.sh (via $INC{'Config.pm'}).
  # They may have been overridden via Makefile.PL or on the command line.
  END
  # $self->{NAME} might depend on some other libraries:
  # See ExtUtils::Liblist for details
  #
  };for my$tmp (qw/EXTRALIBS LDLOADLIBS BSLOADLIBS/){next unless defined$self->{$tmp};push@m,"$tmp = $self->{$tmp}\n"}for my$tmp (qw/LD_RUN_PATH/){next unless$self->{$tmp};push@m,"$tmp = $self->{$tmp}\n"}return join "",@m}sub constants {my($self)=@_;my@m=();$self->{DFSEP}='$(DIRFILESEP)';for my$macro (qw(AR_STATIC_ARGS DIRFILESEP DFSEP NAME NAME_SYM VERSION VERSION_MACRO VERSION_SYM DEFINE_VERSION XS_VERSION XS_VERSION_MACRO XS_DEFINE_VERSION INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR MAN1EXT MAN3EXT MAN1SECTION MAN3SECTION INSTALLDIRS INSTALL_BASE DESTDIR PREFIX PERLPREFIX SITEPREFIX VENDORPREFIX),(map {("INSTALL".$_,"DESTINSTALL".$_)}$self->installvars),qw(PERL_LIB PERL_ARCHLIB PERL_ARCHLIBDEP LIBPERL_A MYEXTLIB FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE PERLMAINCC PERL_SRC PERL_INC PERL_INCDEP PERL FULLPERL ABSPERL PERLRUN FULLPERLRUN ABSPERLRUN PERLRUNINST FULLPERLRUNINST ABSPERLRUNINST PERL_CORE PERM_DIR PERM_RW PERM_RWX)){next unless defined$self->{$macro};$self->{$macro}=~ s/#/\\#/g;$self->{$macro}=$self->quote_dep($self->{$macro})if$ExtUtils::MakeMaker::macro_dep{$macro};push@m,"$macro = $self->{$macro}\n"}push@m,qq{
  MAKEMAKER   = $self->{MAKEMAKER}
  MM_VERSION  = $self->{MM_VERSION}
  MM_REVISION = $self->{MM_REVISION}
  };push@m,q{
  # FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
  # BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
  # PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
  # DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
  };for my$macro (qw/MAKE FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT LDFROM LINKTYPE BOOTDEP/){next unless defined$self->{$macro};push@m,"$macro = $self->{$macro}\n"}push@m,"
  # Handy lists of source code files:
  XS_FILES = ".$self->wraplist(sort keys %{$self->{XS}})."
  C_FILES  = ".$self->wraplist(sort @{$self->{C}})."
  O_FILES  = ".$self->wraplist(sort @{$self->{O_FILES}})."
  H_FILES  = ".$self->wraplist(sort @{$self->{H}})."
  MAN1PODS = ".$self->wraplist(sort keys %{$self->{MAN1PODS}})."
  MAN3PODS = ".$self->wraplist(sort keys %{$self->{MAN3PODS}})."
  ";push@m,q{
  SDKROOT := $(shell xcrun --show-sdk-path)
  PERL_SYSROOT = $(SDKROOT)
  } if$Is{ApplCor}&& $self->{'PERL_INC'}=~ m!^/System/Library/Perl/!;push@m,q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIBDEP)$(DFSEP)Config.pm $(PERL_SYSROOT)$(PERL_INCDEP)$(DFSEP)config.h
  } if$Is{ApplCor};push@m,q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIBDEP)$(DFSEP)Config.pm $(PERL_INCDEP)$(DFSEP)config.h
  } if -e $self->catfile($self->{PERL_INC},'config.h')&&!$Is{ApplCor};push@m,qq{
  # Where to build things
  INST_LIBDIR      = $self->{INST_LIBDIR}
  INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}
  
  INST_AUTODIR     = $self->{INST_AUTODIR}
  INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}
  
  INST_STATIC      = $self->{INST_STATIC}
  INST_DYNAMIC     = $self->{INST_DYNAMIC}
  INST_BOOT        = $self->{INST_BOOT}
  };push@m,qq{
  # Extra linker info
  EXPORT_LIST        = $self->{EXPORT_LIST}
  PERL_ARCHIVE       = $self->{PERL_ARCHIVE}
  PERL_ARCHIVEDEP    = $self->{PERL_ARCHIVEDEP}
  PERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}
  };push@m,"
  
  TO_INST_PM = ".$self->wraplist(map$self->quote_dep($_),sort keys %{$self->{PM}})."\n";join('',@m)}sub depend {my($self,%attribs)=@_;my(@m,$key,$val);for my$key (sort keys%attribs){my$val=$attribs{$key};next unless defined$key and defined$val;push@m,"$key : $val\n"}join "",@m}sub init_DEST {my$self=shift;$self->{DESTDIR}||= '';for my$var ($self->installvars){my$destvar='DESTINSTALL'.$var;$self->{$destvar}||= '$(DESTDIR)$(INSTALL'.$var.')'}}sub init_dist {my$self=shift;$self->{TAR}||= 'tar';$self->{TARFLAGS}||= 'cvf';$self->{ZIP}||= 'zip';$self->{ZIPFLAGS}||= '-r';$self->{COMPRESS}||= 'gzip --best';$self->{SUFFIX}||= '.gz';$self->{SHAR}||= 'shar';$self->{PREOP}||= '$(NOECHO) $(NOOP)';$self->{POSTOP}||= '$(NOECHO) $(NOOP)';$self->{TO_UNIX}||= '$(NOECHO) $(NOOP)';$self->{CI}||= 'ci -u';$self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';$self->{DIST_CP}||= 'best';$self->{DIST_DEFAULT}||= 'tardist';($self->{DISTNAME}=$self->{NAME})=~ s{::}{-}g unless$self->{DISTNAME};$self->{DISTVNAME}||= $self->{DISTNAME}.'-'.$self->{VERSION}}sub dist {my($self,%attribs)=@_;my$make='';if ($attribs{SUFFIX}&& $attribs{SUFFIX}!~ m!^\.!){$attribs{SUFFIX}='.' .$attribs{SUFFIX}}for my$key (qw(TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR PREOP POSTOP TO_UNIX CI RCS_LABEL DIST_CP DIST_DEFAULT DISTNAME DISTVNAME)){my$value=$attribs{$key}|| $self->{$key};$make .= "$key = $value\n"}return$make}sub dist_basics {my($self)=shift;return <<'MAKE_FRAG'}sub dist_ci {my($self)=shift;return sprintf "ci :\n\t%s\n",$self->oneliner(<<'EOF',[qw(-MExtUtils::Manifest=maniread)])}sub dist_core {my($self)=shift;my$make_frag='';for my$target (qw(dist tardist uutardist tarfile zipdist zipfile shdist)){my$method=$target.'_target';$make_frag .= "\n";$make_frag .= $self->$method()}return$make_frag}sub dist_target {my($self)=shift;my$date_check=$self->oneliner(<<'CODE',['-l']);return sprintf <<'MAKE_FRAG',$date_check}sub tardist_target {my($self)=shift;return <<'MAKE_FRAG'}sub zipdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub tarfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub zipfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub uutardist_target {my($self)=shift;return <<'MAKE_FRAG'}sub shdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub dlsyms {return ''}sub dynamic_bs {my($self,%attribs)=@_;return "\nBOOTSTRAP =\n" unless$self->has_link_code();my@exts;if ($self->{XSMULTI}){@exts=$self->_xs_list_basenames}else {@exts='$(BASEEXT)'}return join "\n","BOOTSTRAP = @{[map { qq{$_.bs} } @exts]}\n",map {$self->_xs_make_bs($_)}@exts}sub _xs_make_bs {my ($self,$basename)=@_;my ($v,$d,$f)=File::Spec->splitpath($basename);my@d=File::Spec->splitdir($d);shift@d if$self->{XSMULTI}and $d[0]eq 'lib';my$instdir=$self->catdir('$(INST_ARCHLIB)','auto',@d,$f);$instdir='$(INST_ARCHAUTODIR)' if$basename eq '$(BASEEXT)';my$instfile=$self->catfile($instdir,"$f.bs");my$exists="$instdir\$(DFSEP).exists";return _sprintf562 <<'MAKE_FRAG',$basename,$instfile,$exists}sub dynamic_lib {my($self,%attribs)=@_;return '' unless$self->needs_linking();return '' unless$self->has_link_code;my@m=$self->xs_dynamic_lib_macros(\%attribs);my@libs;my$dlsyms_ext=eval {$self->xs_dlsyms_ext};if ($self->{XSMULTI}){my@exts=$self->_xs_list_basenames;for my$ext (@exts){my ($v,$d,$f)=File::Spec->splitpath($ext);my@d=File::Spec->splitdir($d);shift@d if$d[0]eq 'lib';pop@d if$d[$#d]eq '';my$instdir=$self->catdir('$(INST_ARCHLIB)','auto',@d,$f);eval {require DynaLoader};if (defined&DynaLoader::mod2fname){$f=&DynaLoader::mod2fname([@d,$f])}my$instfile=$self->catfile($instdir,"$f.\$(DLEXT)");my$objfile=$self->_xsbuild_value('xs',$ext,'OBJECT');$objfile="$ext\$(OBJ_EXT)" unless defined$objfile;my$ldfrom=$self->_xsbuild_value('xs',$ext,'LDFROM');$ldfrom=$objfile unless defined$ldfrom;my$exportlist="$ext.def";my@libchunk=($objfile,$instfile,$instdir,$ldfrom,$exportlist);push@libchunk,$dlsyms_ext ? $ext.$dlsyms_ext : undef;push@libs,\@libchunk}}else {my@libchunk=qw($(OBJECT) $(INST_DYNAMIC) $(INST_ARCHAUTODIR) $(LDFROM) $(EXPORT_LIST));push@libchunk,$dlsyms_ext ? '$(BASEEXT)'.$dlsyms_ext : undef;@libs=(\@libchunk)}push@m,map {$self->xs_make_dynamic_lib(\%attribs,@$_)}@libs;return join("\n",@m)}sub xs_dynamic_lib_macros {my ($self,$attribs)=@_;my$otherldflags=$attribs->{OTHERLDFLAGS}|| "";my$inst_dynamic_dep=$attribs->{INST_DYNAMIC_DEP}|| "";my$armaybe=$self->_xs_armaybe($attribs);my$ld_opt=$Is{OS2}? '$(OPTIMIZE) ' : '';my$ld_fix=$Is{OS2}? '|| ( $(RM_F) $@ && sh -c false )' : '';sprintf <<'EOF',$armaybe,$ld_opt.$otherldflags,$inst_dynamic_dep,$ld_fix}sub _xs_armaybe {my ($self,$attribs)=@_;my$armaybe=$attribs->{ARMAYBE}|| $self->{ARMAYBE}|| ":";$armaybe='ar' if ($Is{OSF}and $armaybe eq ':');$armaybe}sub xs_make_dynamic_lib {my ($self,$attribs,$object,$to,$todir,$ldfrom,$exportlist,$dlsyms)=@_;$exportlist='' if$exportlist ne '$(EXPORT_LIST)';my$armaybe=$self->_xs_armaybe($attribs);my@m=sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP) %s'."\n",$to,$object,$todir,$exportlist,($dlsyms || '');my$dlsyms_arg=$self->xs_dlsyms_arg($dlsyms);if ($armaybe ne ':'){$ldfrom='tmp$(LIB_EXT)';push(@m,"	\$(ARMAYBE) cr $ldfrom $object\n");push(@m,"	\$(RANLIB) $ldfrom\n")}$ldfrom="-all $ldfrom -none" if$Is{OSF};my$ldrun=$Is{IRIX}&& $self->{LD_RUN_PATH}? qq{-rpath "$self->{LD_RUN_PATH}"} : '';push(@m,"	\$(RM_F) \$\@\n");my$libs='$(LDLOADLIBS)';if (($Is{NetBSD}|| $Is{Interix}|| $Is{Android})&& $Config{'useshrplib'}eq 'true'){if ($Config{'lddlflags'}=~ /-Wl,-R/){$libs .= ' "-L$(PERL_INC)" "-Wl,-R$(INSTALLARCHLIB)/CORE" "-Wl,-R$(PERL_ARCHLIB)/CORE" -lperl'}elsif ($Config{'lddlflags'}=~ /-R/){$libs .= ' "-L$(PERL_INC)" "-R$(INSTALLARCHLIB)/CORE" "-R$(PERL_ARCHLIB)/CORE" -lperl'}elsif ($Is{Android}){$libs .= ' "-L$(PERL_INC)" -lperl'}}my$ld_run_path_shell="";if ($self->{LD_RUN_PATH}ne ""){$ld_run_path_shell='LD_RUN_PATH="$(LD_RUN_PATH)" '}push@m,sprintf <<'MAKE',$ld_run_path_shell,$ldrun,$dlsyms_arg,$ldfrom,$self->xs_obj_opt('$@'),$libs,$exportlist;join '',@m}sub exescan {my($self,$path)=@_;$path}sub extliblist {my($self,$libs)=@_;require ExtUtils::Liblist;$self->ext($libs,$Verbose)}sub find_perl {my($self,$ver,$names,$dirs,$trace)=@_;if ($trace >= 2){print "Looking for perl $ver by these names:
  distclean :: realclean distcheck
  	$(NOECHO) $(NOOP)
  
  distcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
  
  skipcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
  
  manifest :
  	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
  
  veryclean : realclean
  	$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old
  
  MAKE_FRAG
  @all = sort keys %{ maniread() };
  print(qq{Executing $(CI) @all\n});
  system(qq{$(CI) @all}) == 0 or die $!;
  print(qq{Executing $(RCS_LABEL) ...\n});
  system(qq{$(RCS_LABEL) @all}) == 0 or die $!;
  EOF
  print 'Warning: Makefile possibly out of date with $(VERSION_FROM)'
      if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';
  CODE
  dist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)
  	$(NOECHO) %s
  MAKE_FRAG
  tardist : $(DISTVNAME).tar$(SUFFIX)
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  zipdist : $(DISTVNAME).zip
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)'
  	$(POSTOP)
  MAKE_FRAG
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).zip'
  	$(POSTOP)
  MAKE_FRAG
  uutardist : $(DISTVNAME).tar$(SUFFIX)
  	uuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)_uu'
  MAKE_FRAG
  shdist : distdir
  	$(PREOP)
  	$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).shar'
  	$(POSTOP)
  MAKE_FRAG
  # As Mkbootstrap might not write a file (if none is required)
  # we use touch to prevent make continually trying to remake it.
  # The DynaLoader only reads a non-empty file.
  %1$s.bs : $(FIRST_MAKEFILE) $(BOOTDEP)
  	$(NOECHO) $(ECHO) "Running Mkbootstrap for %1$s ($(BSLOADLIBS))"
  	$(NOECHO) $(PERLRUN) \
  		"-MExtUtils::Mkbootstrap" \
  		-e "Mkbootstrap('%1$s','$(BSLOADLIBS)');"
  	$(NOECHO) $(TOUCH) "%1$s.bs"
  	$(CHMOD) $(PERM_RW) "%1$s.bs"
  
  %2$s : %1$s.bs %3$s
  	$(NOECHO) $(RM_RF) %2$s
  	- $(CP_NONEMPTY) %1$s.bs %2$s $(PERM_RW)
  MAKE_FRAG
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  ARMAYBE = %s
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  INST_DYNAMIC_FIX = %s
  EOF
  	%s$(LD) %s $(LDDLFLAGS) %s %s $(OTHERLDFLAGS) %s $(MYEXTLIB) \
  	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) %s \
  	  $(INST_DYNAMIC_FIX)
  	$(CHMOD) $(PERM_RWX) $@
  MAKE
  @$names
  in these dirs:
  @$dirs
  "}my$stderr_duped=0;local*STDERR_COPY;unless ($Is{BSD}){if(open(STDERR_COPY,'>&STDERR')){$stderr_duped=1}else {warn <<WARNING}}for my$name (@$names){my ($abs,$use_dir);if ($self->file_name_is_absolute($name)){$abs=$name}elsif ($self->canonpath($name)eq $self->canonpath(basename($name))){$use_dir=1}else {$abs=$self->catfile($Curdir,$name)}for my$dir ($use_dir ? @$dirs : 1){next unless defined$dir;$abs=$self->catfile($dir,$name)if$use_dir;print "Checking $abs\n" if ($trace >= 2);next unless$self->maybe_command($abs);print "Executing $abs\n" if ($trace >= 2);my$val;my$version_check=qq{"$abs" -le "require $ver; print qq{VER_OK}"};if ($Is{BSD}){$val=`$version_check 2>&1`}else {close STDERR if$stderr_duped;$val=`$version_check`;open STDERR,">&STDERR_COPY" if$stderr_duped}if ($val =~ /^VER_OK/m){print "Using PERL=$abs\n" if$trace;return$abs}elsif ($trace >= 2){print "Result: '$val' ".($? >> 8)."\n"}}}print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";0}sub fixin {my ($self,@files)=@_;for my$file (@files){my$file_new="$file.new";my$file_bak="$file.bak";open(my$fixin,'<',$file)or croak "Can't process '$file': $!";local $/="\n";chomp(my$line=<$fixin>);next unless$line =~ s/^\s*\#!\s*//;my$shb=$self->_fixin_replace_shebang($file,$line);next unless defined$shb;open(my$fixout,">","$file_new")or do {warn "Can't create new $file: $!\n";next};local $\;local $/;print$fixout $shb,<$fixin>;close$fixin;close$fixout;chmod 0666,$file_bak;unlink$file_bak;unless (_rename($file,$file_bak)){warn "Can't rename $file to $file_bak: $!";next}unless (_rename($file_new,$file)){warn "Can't rename $file_new to $file: $!";unless (_rename($file_bak,$file)){warn "Can't rename $file_bak back to $file either: $!";warn "Leaving $file renamed as $file_bak\n"}next}unlink$file_bak}continue {system("$Config{'eunicefix'} $file")if$Config{'eunicefix'}ne ':'}}sub _rename {my($old,$new)=@_;for my$file ($old,$new){if($Is{VMS}and basename($file)!~ /\./){$file="$file."}}return rename($old,$new)}sub _fixin_replace_shebang {my ($self,$file,$line)=@_;my ($origcmd,$arg)=split ' ',$line,2;(my$cmd=$origcmd)=~ s!^.*/!!;my$interpreter;if (defined$ENV{PERL_MM_SHEBANG}&& $ENV{PERL_MM_SHEBANG}eq "relocatable"){$interpreter="/usr/bin/env perl"}elsif ($cmd =~ m{^perl(?:\z|[^a-z])}){if ($Config{startperl}=~ m,^\#!.*/perl,){$interpreter=$Config{startperl};$interpreter =~ s,^\#!,,}else {$interpreter=$Config{perlpath}}}else {my (@absdirs)=reverse grep {$self->file_name_is_absolute($_)}$self->path;$interpreter='';for my$dir (@absdirs){my$maybefile=$self->catfile($dir,$cmd);if ($self->maybe_command($maybefile)){warn "Ignoring $interpreter in $file\n" if$Verbose && $interpreter;$interpreter=$maybefile}}if ($origcmd ne $interpreter and $self->file_name_is_absolute($origcmd)){my$origdir=dirname($origcmd);if ($self->maybe_command($origcmd)&& grep {$_ eq $origdir}@absdirs){my ($odev,$oino)=stat$origcmd;my ($idev,$iino)=stat$interpreter;if ($odev==$idev && $oino==$iino){warn "$origcmd is the same as $interpreter, leaving alone" if$Verbose;$interpreter=$origcmd}}}}my ($does_shbang)=$Config{'sharpbang'}=~ /^\s*\#\!/;my ($shb)="";if ($interpreter){print "Changing sharpbang in $file to $interpreter" if$Verbose;if ($does_shbang){$shb .= "$Config{'sharpbang'}$interpreter";$shb .= ' ' .$arg if defined$arg;$shb .= "\n"}}else {warn "Can't find $cmd in PATH, $file unchanged" if$Verbose;return}return$shb}sub force {my($self)=shift;'# Phony target to force checking subdirectories.
  find_perl() can't dup STDERR: $!
  You might see some garbage while we search for Perl
  WARNING
  FORCE :
  	$(NOECHO) $(NOOP)
  '}sub guess_name {my($self)=@_;use Cwd 'cwd';my$name=basename(cwd());$name =~ s|[\-_][\d\.\-]+\z||;print "Warning: Guessing NAME [$name] from current directory name.\n";$name}sub has_link_code {my($self)=shift;return$self->{HAS_LINK_CODE}if defined$self->{HAS_LINK_CODE};if ($self->{OBJECT}or @{$self->{C}|| []}or $self->{MYEXTLIB}){$self->{HAS_LINK_CODE}=1;return 1}return$self->{HAS_LINK_CODE}=0}sub init_dirscan {my($self)=@_;my(%dir,%xs,%c,%o,%h,%pl_files,%pm);my%ignore=map {($_=>1)}qw(Makefile.PL Build.PL test.pl t);$Is{VMS}? $ignore{"$self->{DISTVNAME}.dir"}=1 : $ignore{$self->{DISTVNAME}}=1;my$distprefix=$Is{VMS}? qr/^\Q$self->{DISTNAME}\E-v?[\d\.]+\.dir$/i : qr/^\Q$self->{DISTNAME}\E-v?[\d\.]+$/;@ignore{map lc,keys%ignore}=values%ignore if$Is{VMS};if (defined$self->{XS}and!defined$self->{C}){my@c_files=grep {m/\.c(pp|xx)?\z/i}values %{$self->{XS}};my@o_files=grep {m/(?:.(?:o(?:bj)?)|\$\(OBJ_EXT\))\z/i}values %{$self->{XS}};%c=map {$_=>1}@c_files;%o=map {$_=>1}@o_files}for my$name ($self->lsdir($Curdir)){next if$name =~ /\#/;next if$name =~ $distprefix && -d $name;$name=lc($name)if$Is{VMS};next if$name eq $Curdir or $name eq $Updir or $ignore{$name};next unless$self->libscan($name);if (-d $name){next if -l $name;next if$self->{NORECURS};$dir{$name}=$name if (-f $self->catfile($name,"Makefile.PL"))}elsif ($name =~ /\.xs\z/){my($c);($c=$name)=~ s/\.xs\z/.c/;$xs{$name}=$c;$c{$c}=1}elsif ($name =~ /\.c(pp|xx|c)?\z/i){$c{$name}=1 unless$name =~ m/perlmain\.c/}elsif ($name =~ /\.h\z/i){$h{$name}=1}elsif ($name =~ /\.PL\z/){($pl_files{$name}=$name)=~ s/\.PL\z// }elsif (($Is{VMS}|| $Is{Dos})&& $name =~ /[._]pl$/i){local($/);open(my$pl,'<',$name);my$txt=<$pl>;close$pl;if ($txt =~ /Extracting \S+ \(with variable substitutions/){($pl_files{$name}=$name)=~ s/[._]pl\z//i }else {$pm{$name}=$self->catfile($self->{INST_LIBDIR},$name)}}elsif ($name =~ /\.(p[ml]|pod)\z/){$pm{$name}=$self->catfile($self->{INST_LIBDIR},$name)}}$self->{PL_FILES}||= \%pl_files;$self->{DIR}||= [sort keys%dir];$self->{XS}||= \%xs;$self->{C}||= [sort keys%c];$self->{H}||= [sort keys%h];$self->{PM}||= \%pm;my@o_files=@{$self->{C}};%o=(%o,map {$_=>1}grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i,@o_files);$self->{O_FILES}=[sort keys%o]}sub init_MANPODS {my$self=shift;for my$man (qw(MAN1 MAN3)){if ($self->{"${man}PODS"}or $self->{"INSTALL${man}DIR"}=~ /^(none|\s*)$/){$self->{"${man}PODS"}||= {}}else {my$init_method="init_${man}PODS";$self->$init_method()}}for my$num (1,3){my$installdirs=uc$self->{INSTALLDIRS};$installdirs='' if$installdirs eq 'PERL';my@mandirs=File::Spec->splitdir($self->_expand_macros($self->{"INSTALL${installdirs}MAN${num}DIR" }));my$mandir=pop@mandirs;my$section=$num;for ($num,"${num}p","${num}pm",qw<l n o C L>,"L$num"){if ($mandir =~ /^(?:man|cat)$_$/){$section=$_;last}}$self->{"MAN${num}SECTION"}=$section}}sub _has_pod {my($self,$file)=@_;my($ispod)=0;if (open(my$fh,'<',$file)){while (<$fh>){if (/^=(?:head\d+|item|pod)\b/){$ispod=1;last}}close$fh}else {$ispod=1}return$ispod}sub init_MAN1PODS {my($self)=@_;if (exists$self->{EXE_FILES}){for my$name (@{$self->{EXE_FILES}}){next unless$self->_has_pod($name);$self->{MAN1PODS}->{$name}=$self->catfile("\$(INST_MAN1DIR)",basename($name).".\$(MAN1EXT)")}}}sub init_MAN3PODS {my$self=shift;my%manifypods=();for my$name (keys %{$self->{PM}}){if ($name =~ /\.pod\z/){$manifypods{$name}=$self->{PM}{$name}}elsif ($name =~ /\.p[ml]\z/){if($self->_has_pod($name)){$manifypods{$name}=$self->{PM}{$name}}}}my$parentlibs_re=join '|',@{$self->{PMLIBPARENTDIRS}};for my$name (keys%manifypods){if (($self->{PERL_CORE}and $name =~ /(config|setup).*\.pm/is)or ($name =~ m/^README\.pod$/i)){delete$manifypods{$name};next}my($manpagename)=$name;$manpagename =~ s/\.p(od|m|l)\z//;unless($manpagename =~ s!^\W*($parentlibs_re)\W+!!s){$manpagename=$self->catfile(split(/::/,$self->{PARENT_NAME}),$manpagename)}$manpagename=$self->replace_manpage_separator($manpagename);$self->{MAN3PODS}->{$name}=$self->catfile("\$(INST_MAN3DIR)","$manpagename.\$(MAN3EXT)")}}sub init_PM {my$self=shift;unless($self->{PMLIBDIRS}){if($Is{VMS}){$self->{PMLIBDIRS}=['./lib',"./$self->{BASEEXT}"]}else {$self->{PMLIBDIRS}=['lib',$self->{BASEEXT}]}}my (@pmlibdirs)=@{$self->{PMLIBDIRS}};@{$self->{PMLIBDIRS}}=();my%dir=map {($_=>$_)}@{$self->{DIR}};for my$pmlibdir (@pmlibdirs){-d $pmlibdir &&!$dir{$pmlibdir}&& push @{$self->{PMLIBDIRS}},$pmlibdir}unless($self->{PMLIBPARENTDIRS}){@{$self->{PMLIBPARENTDIRS}}=('lib')}return if$self->{PM}and $self->{ARGS}{PM};if (@{$self->{PMLIBDIRS}}){print "Searching PMLIBDIRS: @{$self->{PMLIBDIRS}}\n" if ($Verbose >= 2);require File::Find;File::Find::find(sub {if (-d $_){unless ($self->libscan($_)){$File::Find::prune=1}return}return if /\#/;return if /~$/;return if /,v$/;return if m{\.swp$};my$path=$File::Find::name;my$prefix=$self->{INST_LIBDIR};my$striplibpath;my$parentlibs_re=join '|',@{$self->{PMLIBPARENTDIRS}};$prefix=$self->{INST_LIB}if ($striplibpath=$path)=~ s{^(\W*)($parentlibs_re)\W}
  	                                       {$1}i;my($inst)=$self->catfile($prefix,$striplibpath);local($_)=$inst;$inst=$self->libscan($inst);print "libscan($path) => '$inst'\n" if ($Verbose >= 2);return unless$inst;if ($self->{XSMULTI}and $inst =~ /\.xs\z/){my($base);($base=$path)=~ s/\.xs\z//;$self->{XS}{$path}="$base.c";push @{$self->{C}},"$base.c";push @{$self->{O_FILES}},"$base$self->{OBJ_EXT}"}else {$self->{PM}{$path}=$inst}},@{$self->{PMLIBDIRS}})}}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}='/'}sub init_main {my($self)=@_;$self->{FULLEXT}=$self->catdir(split /::/,$self->{NAME});my(@modparts)=split(/::/,$self->{NAME});my($modfname)=$modparts[-1];eval {require DynaLoader};if (defined&DynaLoader::mod2fname){$modfname=&DynaLoader::mod2fname(\@modparts)}($self->{PARENT_NAME},$self->{BASEEXT})=$self->{NAME}=~ m!(?:([\w:]+)::)?(\w+)\z! ;$self->{PARENT_NAME}||= '';if (defined&DynaLoader::mod2fname){$self->{DLBASE}=$modfname}else {$self->{DLBASE}='$(BASEEXT)'}my$inc_config_dir=dirname($INC{'Config.pm'});my$inc_carp_dir=dirname($INC{'Carp.pm'});unless ($self->{PERL_SRC}){for my$dir_count (1..8){my$dir=$self->catdir(($Updir)x $dir_count);if (-f $self->catfile($dir,"config_h.SH")&& -f $self->catfile($dir,"perl.h")&& -f $self->catfile($dir,"lib","strict.pm")){$self->{PERL_SRC}=$dir ;last}}}warn "PERL_CORE is set but I can't find your PERL_SRC!\n" if $self->{PERL_CORE}and!$self->{PERL_SRC};if ($self->{PERL_SRC}){$self->{PERL_LIB}||= $self->catdir("$self->{PERL_SRC}","lib");$self->{PERL_ARCHLIB}=$self->{PERL_LIB};$self->{PERL_INC}=($Is{Win32})? $self->catdir($self->{PERL_LIB},"CORE"): $self->{PERL_SRC};unless (-s $self->catfile($self->{PERL_SRC},'cflags')or $Is{VMS}&& -s $self->catfile($self->{PERL_SRC},'vmsish.h')or $Is{Win32}){warn qq{
  You cannot build extensions below the perl source tree after executing
  a 'make clean' in the perl source tree.
  
  To rebuild extensions distributed with the perl source you should
  simply Configure (to include those extensions) and then build perl as
  normal. After installing perl the source tree can be deleted. It is
  not needed for building extensions by running 'perl Makefile.PL'
  usually without extra arguments.
  
  It is recommended that you unpack and build additional extensions away
  from the perl source tree.
  }}}else {my$old=$self->{PERL_LIB}|| $self->{PERL_ARCHLIB}|| $self->{PERL_INC};$self->{PERL_LIB}||= $Config{privlibexp};$self->{PERL_ARCHLIB}||= $Config{archlibexp};$self->{PERL_INC}=$self->catdir("$self->{PERL_ARCHLIB}","CORE");my$perl_h;if (not -f ($perl_h=$self->catfile($self->{PERL_INC},"perl.h"))and not $old){my$lib;for my$dir (@INC){$lib=$dir,last if -e $self->catfile($dir,"Config.pm")}if ($lib){my$inc=$Is{Win32}? $self->catdir($lib,"CORE"): dirname$lib;if (-e $self->catfile($inc,"perl.h")){$self->{PERL_LIB}=$lib;$self->{PERL_ARCHLIB}=$lib;$self->{PERL_INC}=$inc;$self->{UNINSTALLED_PERL}=1;print <<EOP}}}}if ($Is{Android}){$self->{PERL_LIB}=File::Spec->rel2abs($self->{PERL_LIB});$self->{PERL_ARCHLIB}=File::Spec->rel2abs($self->{PERL_ARCHLIB})}$self->{PERL_INCDEP}=$self->{PERL_INC};$self->{PERL_ARCHLIBDEP}=$self->{PERL_ARCHLIB};$self->{INSTALLDIRS}||= "site";$self->{MAN1EXT}||= $Config{man1ext};$self->{MAN3EXT}||= $Config{man3ext};print "CONFIG must be an array ref\n" if ($self->{CONFIG}and ref$self->{CONFIG}ne 'ARRAY');$self->{CONFIG}=[]unless (ref$self->{CONFIG});push(@{$self->{CONFIG}},@ExtUtils::MakeMaker::Get_from_Config);push(@{$self->{CONFIG}},'shellflags')if$Config{shellflags};my(%once_only);for my$m (@{$self->{CONFIG}}){next if$once_only{$m};print "CONFIG key '$m' does not exist in Config.pm\n" unless exists$Config{$m};$self->{uc$m}||= $Config{$m};$once_only{$m}=1}$self->{AR_STATIC_ARGS}||= "cr";$self->{OBJ_EXT}||= '.o';$self->{LIB_EXT}||= '.a';$self->{MAP_TARGET}||= "perl";$self->{LIBPERL_A}||= "libperl$self->{LIB_EXT}";warn "Warning: PERL_LIB ($self->{PERL_LIB}) seems not to be a perl library directory
  ... Detected uninstalled Perl.  Trying to continue.
  EOP
          (strict.pm not found)" unless -f $self->catfile("$self->{PERL_LIB}","strict.pm")|| $self->{NAME}eq "ExtUtils::MakeMaker"}sub init_tools {my$self=shift;$self->{ECHO}||= 'echo';$self->{ECHO_N}||= 'echo -n';$self->{RM_F}||= "rm -f";$self->{RM_RF}||= "rm -rf";$self->{TOUCH}||= "touch";$self->{TEST_F}||= "test -f";$self->{TEST_S}||= "test -s";$self->{CP}||= "cp";$self->{MV}||= "mv";$self->{CHMOD}||= "chmod";$self->{FALSE}||= 'false';$self->{TRUE}||= 'true';$self->{LD}||= 'ld';return$self->SUPER::init_tools(@_);$self->{SHELL}||= '/bin/sh';return}sub init_linker {my($self)=shift;$self->{PERL_ARCHIVE}||= '';$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}sub init_lib2arch {my($self)=shift;for my$libpair ({l=>"privlib",a=>"archlib"},{l=>"sitelib",a=>"sitearch"},{l=>"vendorlib",a=>"vendorarch"},){my$lib="install$libpair->{l}";my$Lib=uc$lib;my$Arch=uc "install$libpair->{a}";if($self->{$Lib}&&!$self->{$Arch}){my($ilib)=$Config{$lib};$self->prefixify($Arch,$ilib,$self->{$Lib});unless (-d $self->{$Arch}){print "Directory $self->{$Arch} not found\n" if$Verbose;$self->{$Arch}=$self->{$Lib}}print "Defaulting $Arch to $self->{$Arch}\n" if$Verbose}}}sub init_PERL {my($self)=shift;my@defpath=();for my$component ($self->{PERL_SRC},$self->path(),$Config{binexp}){push@defpath,$component if defined$component}my$thisperl=$self->canonpath($^X);$thisperl .= $Config{exe_ext}unless $Is{VMS}? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i : $thisperl =~ m/$Config{exe_ext}$/i;$thisperl=$self->abs2rel($thisperl)if$self->{PERL_CORE};my@perls=($thisperl);push@perls,map {"$_$Config{exe_ext}"}("perl$Config{version}",'perl5','perl');my$miniperl="miniperl$Config{exe_ext}";if($self->{PERL_CORE}){splice@perls,1,0,$miniperl}else {push@perls,$miniperl}$self->{PERL}||= $self->find_perl(5.0,\@perls,\@defpath,$Verbose);my$perl=$self->{PERL};$perl =~ s/^"//;my$has_mcr=$perl =~ s/^MCR\s*//;my$perlflags='';my$stripped_perl;while ($perl){($stripped_perl=$perl)=~ s/"$//;last if -x $stripped_perl;last unless$perl =~ s/(\s+\S+)$//;$perlflags=$1.$perlflags}$self->{PERL}=$stripped_perl;$self->{PERL}='MCR '.$self->{PERL}if$has_mcr || $Is{VMS};my$perl_name='perl';$perl_name='ndbgperl' if$Is{VMS}&& defined$Config{usevmsdebug}&& $Config{usevmsdebug}eq 'define';unless ($self->{FULLPERL}){($self->{FULLPERL}=$self->{PERL})=~ s/\Q$miniperl\E$/$perl_name$Config{exe_ext}/i;$self->{FULLPERL}=qq{"$self->{FULLPERL}"}.$perlflags}$self->{FULLPERL}=~ tr/"//d if$Is{VMS};$self->{FULLPERL}=~ s/^"(\S(:\\|:)?)/$1"/ if$self->is_make_type('dmake');$self->{ABSPERL}=$self->{PERL};$has_mcr=$self->{ABSPERL}=~ s/^MCR\s*//;if($self->file_name_is_absolute($self->{ABSPERL})){$self->{ABSPERL}='$(PERL)'}else {$self->{ABSPERL}=$self->rel2abs($self->{ABSPERL});$self->{ABSPERL}=$self->quote_literal($self->{ABSPERL})if$self->{ABSPERL}=~ /\s/;$self->{ABSPERL}='MCR '.$self->{ABSPERL}if$has_mcr}$self->{PERL}=qq{"$self->{PERL}"}.$perlflags;$self->{PERL}=~ tr/"//d if$Is{VMS};$self->{PERL}=~ s/^"(\S(:\\|:)?)/$1"/ if$self->is_make_type('dmake');$self->{PERL_CORE}=$ENV{PERL_CORE}unless exists$self->{PERL_CORE};$self->{PERL_CORE}=0 unless defined$self->{PERL_CORE};my$lib_paths=$self->{UNINSTALLED_PERL}|| $self->{PERL_CORE}? ($self->{PERL_ARCHLIB}&& $self->{PERL_LIB}&& $self->{PERL_ARCHLIB}ne $self->{PERL_LIB})? q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"} : q{ "-I$(PERL_LIB)"} : undef;my$inst_lib_paths=$self->{INST_ARCHLIB}ne $self->{INST_LIB}? 'RUN)'.$perlflags.' "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"' : 'RUN)'.$perlflags.' "-I$(INST_LIB)"';for my$perl (qw(PERL FULLPERL ABSPERL)){my$run=$perl.'RUN';$self->{$run}=qq{\$($perl)};$self->{$run}.= $lib_paths if$lib_paths;$self->{$perl.'RUNINST'}='$('.$perl.$inst_lib_paths}return 1}sub init_platform {my($self)=shift;$self->{MM_Unix_VERSION}=$VERSION;$self->{PERL_MALLOC_DEF}='-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.'-Dfree=Perl_mfree -Drealloc=Perl_realloc '.'-Dcalloc=Perl_calloc'}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub init_PERM {my($self)=shift;$self->{PERM_DIR}=755 unless defined$self->{PERM_DIR};$self->{PERM_RW}=644 unless defined$self->{PERM_RW};$self->{PERM_RWX}=755 unless defined$self->{PERM_RWX};return 1}sub init_xs {my$self=shift;if ($self->has_link_code()){$self->{INST_STATIC}=$self->catfile('$(INST_ARCHAUTODIR)','$(BASEEXT)$(LIB_EXT)');$self->{INST_DYNAMIC}=$self->catfile('$(INST_ARCHAUTODIR)','$(DLBASE).$(DLEXT)');$self->{INST_BOOT}=$self->catfile('$(INST_ARCHAUTODIR)','$(BASEEXT).bs');if ($self->{XSMULTI}){my@exts=$self->_xs_list_basenames;my (@statics,@dynamics,@boots);for my$ext (@exts){my ($v,$d,$f)=File::Spec->splitpath($ext);my@d=File::Spec->splitdir($d);shift@d if defined$d[0]and $d[0]eq 'lib';pop@d if$d[$#d]eq '';my$instdir=$self->catdir('$(INST_ARCHLIB)','auto',@d,$f);my$instfile=$self->catfile($instdir,$f);push@statics,"$instfile\$(LIB_EXT)";my$dynfile=$instfile;eval {require DynaLoader};if (defined&DynaLoader::mod2fname){$dynfile=$self->catfile($instdir,&DynaLoader::mod2fname([@d,$f]))}push@dynamics,"$dynfile.\$(DLEXT)";push@boots,"$instfile.bs"}$self->{INST_STATIC}=join ' ',@statics;$self->{INST_DYNAMIC}=join ' ',@dynamics;$self->{INST_BOOT}=join ' ',@boots}}else {$self->{INST_STATIC}='';$self->{INST_DYNAMIC}='';$self->{INST_BOOT}=''}}sub install {my($self,%attribs)=@_;my(@m);push@m,q{
  install :: pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  pure_perl_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };push@m,q{		read "}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{" \
  } unless$self->{NO_PACKLIST};push@m,q{		"$(INST_LIB)" "$(DESTINSTALLPRIVLIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLARCHLIB)" \
  		"$(INST_BIN)" "$(DESTINSTALLBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLSCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLMAN3DIR)"
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		"}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{"
  
  
  pure_site_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };push@m,q{		read "}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{" \
  } unless$self->{NO_PACKLIST};push@m,q{		"$(INST_LIB)" "$(DESTINSTALLSITELIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLSITEARCH)" \
  		"$(INST_BIN)" "$(DESTINSTALLSITEBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLSITESCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLSITEMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLSITEMAN3DIR)"
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		"}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{"
  
  pure_vendor_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };push@m,q{		read "}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{" \
  } unless$self->{NO_PACKLIST};push@m,q{		"$(INST_LIB)" "$(DESTINSTALLVENDORLIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLVENDORARCH)" \
  		"$(INST_BIN)" "$(DESTINSTALLVENDORBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLVENDORSCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLVENDORMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLVENDORMAN3DIR)"
  
  };push@m,q{
  doc_perl_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_site_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install :: all
  	$(NOECHO) $(NOOP)
  
  } if$self->{NO_PERLLOCAL};push@m,q{
  doc_perl_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLPRIVLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  doc_site_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLSITELIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  doc_vendor_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLVENDORLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  } unless$self->{NO_PERLLOCAL};push@m,q{
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{"
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{"
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{"
  };join("",@m)}sub installbin {my($self)=shift;return "" unless$self->{EXE_FILES}&& ref$self->{EXE_FILES}eq "ARRAY";my@exefiles=sort @{$self->{EXE_FILES}};return "" unless@exefiles;@exefiles=map vmsify($_),@exefiles if$Is{VMS};my%fromto;for my$from (@exefiles){my($path)=$self->catfile('$(INST_SCRIPT)',basename($from));local($_)=$path;my$to=$self->libscan($path);print "libscan($from) => '$to'\n" if ($Verbose >=2);$to=vmsify($to)if$Is{VMS};$fromto{$from}=$to}my@to=sort values%fromto;my@m;push(@m,qq{
  EXE_FILES = @exefiles
  
  pure_all :: @to
  	\$(NOECHO) \$(NOOP)
  
  realclean ::
  });push@m,map "\t$_\n",$self->split_command('$(RM_F)',@to);push@m,"\n";my@froms=sort keys%fromto;for my$from (@froms){push@m,_sprintf562 <<'MAKE',$from,$fromto{$from}}join "",@m}sub linkext {my($self,%attribs)=@_;my$linktype=$attribs{LINKTYPE};$linktype=$self->{LINKTYPE}unless defined$linktype;if (defined$linktype and $linktype eq ''){warn "Warning: LINKTYPE set to '', no longer necessary\n"}$linktype='$(LINKTYPE)' unless defined$linktype;"
  %2$s : %1$s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists
  	$(NOECHO) $(RM_F) %2$s
  	$(CP) %1$s %2$s
  	$(FIXIN) %2$s
  	-$(NOECHO) $(CHMOD) $(PERM_RWX) %2$s
  
  MAKE
  linkext :: $linktype
  	\$(NOECHO) \$(NOOP)
  "}sub lsdir {my(undef,$dir,$regex)=@_;opendir(my$dh,defined($dir)? $dir : ".")or return;my@ls=readdir$dh;closedir$dh;@ls=grep(/$regex/,@ls)if defined$regex;@ls}sub macro {my($self,%attribs)=@_;my@m;for my$key (sort keys%attribs){my$val=$attribs{$key};push@m,"$key = $val\n"}join "",@m}sub makeaperl {my($self,%attribs)=@_;my($makefilename,$searchdirs,$static,$extra,$perlinc,$target,$tmp,$libperl)=@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};s/^(.*)/"-I$1"/ for @{$perlinc || []};my(@m);push@m,"
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  FULLPERL      = $self->{FULLPERL}
  MAP_PERLINC   = @{$perlinc || []}
  ";return join '',@m if$self->{PARENT};my($dir)=join ":",@{$self->{DIR}};unless ($self->{MAKEAPERL}){push@m,q{
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@
  
  $(MAKE_APERL_FILE) : static $(FIRST_MAKEFILE) pm_to_blib
  	$(NOECHO) $(ECHO) Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR="},$dir,q{" \
  		MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 CCCDLFLAGS=};for (@ARGV){my$arg=$_;if ($arg =~ /(^.*?=)(.*['\s].*)/){$arg=$1 .$self->quote_literal($2)}push@m," \\\n\t\t$arg"}push@m,"\n";return join '',@m}my$cccmd=$self->const_cccmd($libperl);$cccmd =~ s/^CCCMD\s*=\s*//;$cccmd =~ s/\$\(INC\)/ "-I$self->{PERL_INC}" /;$cccmd .= " $Config{cccdlflags}" if ($Config{useshrplib}eq 'true');$cccmd =~ s/\(CC\)/\(PERLMAINCC\)/;my$linkcmd=join ' ',"\$(CC)",grep($_,@Config{qw(ldflags ccdlflags)});$linkcmd =~ s/\s+/ /g;$linkcmd =~ s,(perl\.exp),\$(PERL_INC)/$1,;my$staticlib21=$self->_find_static_libs($searchdirs);$static=[]unless$static;@$staticlib21{@{$static}}=(1)x @{$static};$extra=[]unless$extra && ref$extra eq 'ARRAY';for (sort keys %$staticlib21){next unless /\Q$self->{LIB_EXT}\E\z/;$_=dirname($_)."/extralibs.ld";push @$extra,$_}s/^(.*)/"-I$1"/ for @{$perlinc || []};$target ||= "perl";$tmp ||= ".";my@map_static=reverse sort keys %$staticlib21;push@m,"
  MAP_LINKCMD   = $linkcmd
  MAP_STATIC    = ",join(" \\\n\t",map {qq{"$_"}}@map_static),"
  MAP_STATICDEP = ",join(' ',map {$self->quote_dep($_)}@map_static),"
  
  MAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}
  ";my$lperl;if (defined$libperl){($lperl=$libperl)=~ s/\$\(A\)/$self->{LIB_EXT}/}unless ($libperl && -f $lperl){my$dir=$self->{PERL_SRC}|| "$self->{PERL_ARCHLIB}/CORE";$dir="$self->{PERL_ARCHLIB}/.." if$self->{UNINSTALLED_PERL};$libperl ||= "libperl$self->{LIB_EXT}";$libperl="$dir/$libperl";$lperl ||= "libperl$self->{LIB_EXT}";$lperl="$dir/$lperl";if (!-f $libperl and!-f $lperl){if ($Is{SunOS}){$lperl=$libperl="$dir/$Config{libperl}";$libperl='' if$Is{SunOS4}}}print <<EOF unless -f $lperl || defined($self->{PERL_SRC})}my$llibperl=$libperl ? '$(MAP_LIBPERL)' : '-lperl';my$libperl_dep=$self->quote_dep($libperl);push@m,"
  Warning: $libperl not found
  If you're going to build a static perl binary, make sure perl is installed
  otherwise ignore this warning
  EOF
  MAP_LIBPERL = $libperl
  MAP_LIBPERLDEP = $libperl_dep
  LLIBPERL    = $llibperl
  ";push@m,'
  $(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(" \\\n\t",@$extra).'
  	$(NOECHO) $(RM_F)  $@
  	$(NOECHO) $(TOUCH) $@
  ';for my$catfile (@$extra){push@m,"\tcat $catfile >> \$\@\n"}my$ldfrom=$self->{XSMULTI}? '' : '$(LDFROM)';push@m,_sprintf562 <<'EOF',$tmp,$ldfrom,$self->xs_obj_opt('$@'),$makefilename;push@m,"\t".$self->cd($tmp,qq[$cccmd "-I\$(PERL_INC)" perlmain.c])."\n";my$maybe_DynaLoader=$Config{usedl}? 'q(DynaLoader)' : '';push@m,_sprintf562 <<'EOF',$tmp,$makefilename,$maybe_DynaLoader;push@m,"\t",q{$(NOECHO) $(PERL) "$(INSTALLSCRIPT)/fixpmain"
  $(MAP_TARGET) :: %1$s/perlmain$(OBJ_EXT) $(MAP_LIBPERLDEP) $(MAP_STATICDEP) $(INST_ARCHAUTODIR)/extralibs.all
  	$(MAP_LINKCMD) %2$s $(OPTIMIZE) %1$s/perlmain$(OBJ_EXT) %3$s $(MAP_STATIC) "$(LLIBPERL)" `cat $(INST_ARCHAUTODIR)/extralibs.all` $(MAP_PRELIBS)
  	$(NOECHO) $(ECHO) "To install the new '$(MAP_TARGET)' binary, call"
  	$(NOECHO) $(ECHO) "    $(MAKE) $(USEMAKEFILE) %4$s inst_perl MAP_TARGET=$(MAP_TARGET)"
  	$(NOECHO) $(ECHO) "    $(MAKE) $(USEMAKEFILE) %4$s map_clean"
  
  %1$s/perlmain\$(OBJ_EXT): %1$s/perlmain.c
  EOF
  
  %1$s/perlmain.c: %2$s
  	$(NOECHO) $(ECHO) Writing $@
  	$(NOECHO) $(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \
  		-e "writemain(grep(s#.*/auto/##s, @ARGV), %3$s)" $(MAP_STATIC) > $@t
  	$(MV) $@t $@
  
  EOF
  } if (defined (&Dos::UseLFN)&& Dos::UseLFN()==0);push@m,q{
  doc_inst_perl :
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Perl binary" "$(MAP_TARGET)" \
  		MAP_STATIC "$(MAP_STATIC)" \
  		MAP_EXTRA "`cat $(INST_ARCHAUTODIR)/extralibs.all`" \
  		MAP_LIBPERL "$(MAP_LIBPERL)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  };push@m,q{
  inst_perl : pure_inst_perl doc_inst_perl
  
  pure_inst_perl : $(MAP_TARGET)
  	}.$self->{CP}.q{ $(MAP_TARGET) "}.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{"
  
  clean :: map_clean
  
  map_clean :
  	}.$self->{RM_F}.qq{ $tmp/perlmain\$(OBJ_EXT) $tmp/perlmain.c \$(MAP_TARGET) $makefilename \$(INST_ARCHAUTODIR)/extralibs.all
  };join '',@m}sub _find_static_libs {my ($self,$searchdirs)=@_;my$installed_version=join('/','auto',$self->{FULLEXT},"$self->{BASEEXT}$self->{LIB_EXT}");my%staticlib21;require File::Find;File::Find::find(sub {if ($File::Find::name =~ m{/auto/share\z}){$File::Find::prune=1;return}return unless m/\Q$self->{LIB_EXT}\E$/;return unless -f 'extralibs.ld';return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;return if m/_pure_\w+_\w+_\w+\.\w+$/ and -f "$File::Find::dir/.pure";if(exists$self->{INCLUDE_EXT}){my$found=0;(my$xx=$File::Find::name)=~ s,.*?/auto/,,s;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){if($xx eq $incl){$found++;last}}return unless$found}elsif(exists$self->{EXCLUDE_EXT}){(my$xx=$File::Find::name)=~ s,.*?/auto/,,s;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$excl (@{$self->{EXCLUDE_EXT}}){return if($xx eq $excl)}}return if$File::Find::name =~ m:\Q$installed_version\E\z:;return if!$self->xs_static_lib_is_xs($_);use Cwd 'cwd';$staticlib21{cwd()."/" .$_}++},grep(-d $_,map {$self->catdir($_,'auto')}@{$searchdirs || []}));return \%staticlib21}sub xs_static_lib_is_xs {my ($self,$libfile)=@_;my$devnull=File::Spec->devnull;return `nm $libfile 2>$devnull` =~ /\b_?boot_/}sub makefile {my($self)=shift;my$m;$m='
  $(OBJECT) : $(FIRST_MAKEFILE)
  
  ' if$self->{OBJECT};my$newer_than_target=$Is{VMS}? '$(MMS$SOURCE_LIST)' : '$?';my$mpl_args=join " ",map qq["$_"],@ARGV;my$cross='';if (defined$::Cross::platform){$cross="-MCross=$::Cross::platform "}$m .= sprintf <<'MAKE_FRAG',$newer_than_target,$cross,$mpl_args;return$m}sub maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub needs_linking {my($self)=shift;my$caller=(caller(0))[3];confess("needs_linking called too early")if $caller =~ /^ExtUtils::MakeMaker::/;return$self->{NEEDS_LINKING}if defined$self->{NEEDS_LINKING};if ($self->has_link_code or $self->{MAKEAPERL}){$self->{NEEDS_LINKING}=1;return 1}for my$child (keys %{$self->{CHILDREN}}){if ($self->{CHILDREN}->{$child}->needs_linking){$self->{NEEDS_LINKING}=1;return 1}}return$self->{NEEDS_LINKING}=0}sub parse_abstract {my($self,$parsefile)=@_;my$result;local $/="\n";open(my$fh,'<',$parsefile)or die "Could not open '$parsefile': $!";binmode$fh;my$inpod=0;my$pod_encoding;my$package=$self->{DISTNAME};$package =~ s/-/::/g;while (<$fh>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if!$inpod;s#\r*\n\z##;if (/^=encoding\s*(.*)$/i){$pod_encoding=$1}if (/^($package(?:\.pm)? \s+ -+ \s+)(.*)/x){$result=$2;next}next unless$result;if ($result && (/^\s*$/ || /^\=/)){last}$result=join ' ',$result,$_}close$fh;if ($pod_encoding and!("$]" < 5.008 or!$Config{useperlio})){eval {require Encode;$result=Encode::decode($pod_encoding,$result)}}return$result}sub parse_version {my($self,$parsefile)=@_;my$result;local $/="\n";local $_;open(my$fh,'<',$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<$fh>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;chop;next if /^\s*(if|unless|elsif)/;if (m{^ \s* package \s+ \w[\w\:\']* \s+ (v?[0-9._]+) \s* (;|\{)  }x){no warnings;$result=$1}elsif (m{(?<!\\) ([\$*]) (([\w\:\']*) \bVERSION)\b .* (?<![<>=!])\=[^=]}x){$result=$self->get_version($parsefile,$1,$2)}else {next}last if defined$result}close$fh;if (defined$result && $result !~ /^v?[\d_\.]+$/){require version;my$normal=eval {version->new($result)};$result=$normal if defined$normal}if (defined$result){$result="undef" unless$result =~ m!^v?[\d_\.]+$! or eval {version->parse($result)}}$result="undef" unless defined$result;return$result}sub get_version {my ($self,$parsefile,$sigil,$name)=@_;my$line=$_;{package ExtUtils::MakeMaker::_version;undef*version;eval {require version;version::->import};no strict;no warnings;local *{$name};$line=$1 if$line =~ m{^(.+)}s;eval($line);return ${$name}}}sub pasthru {my($self)=shift;my(@m);my(@pasthru);my($sep)=$Is{VMS}? ',' : '';$sep .= "\\\n\t";for my$key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE PREFIX INSTALL_BASE)){next unless defined$self->{$key};push@pasthru,"$key=\"\$($key)\""}for my$key (qw(DEFINE INC)){my$val=qq{\$($key)};chomp($val=$self->{$key})if defined$self->{$key};$val .= " \$(PASTHRU_$key)";my$quoted=$self->quote_literal($val);push@pasthru,qq{PASTHRU_$key=$quoted}}push@m,"\nPASTHRU = ",join ($sep,@pasthru),"\n";join "",@m}sub perl_script {my($self,$file)=@_;return$file if -r $file && -f _;return}sub perldepend {my($self)=shift;my(@m);my$make_config=$self->cd('$(PERL_SRC)','$(MAKE) lib/Config.pm');push@m,sprintf <<'MAKE_FRAG',$make_config if$self->{PERL_SRC};return join "",@m unless$self->needs_linking;if ($self->{OBJECT}){push@m,$self->_perl_header_files_fragment("/")}push@m,join(" ",sort values %{$self->{XS}})." : \$(XSUBPPDEPS)\n" if %{$self->{XS}};return join "\n",@m}sub pm_to_blib {my$self=shift;my($autodir)=$self->catdir('$(INST_LIB)','auto');my$r=q{
  # We take a very conservative approach here, but it's worth it.
  # We move Makefile to Makefile.old here to avoid gnu make looping.
  $(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
  	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to %s"
  	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding Makefile..."
  	-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
  	- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)
  	$(PERLRUN) %sMakefile.PL %s
  	$(NOECHO) $(ECHO) "==> Your Makefile has been rebuilt. <=="
  	$(NOECHO) $(ECHO) "==> Please rerun the $(MAKE) command.  <=="
  	$(FALSE)
  
  MAKE_FRAG
  # Check for unpropogated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INCDEP)/config.h: $(PERL_SRC)/config.sh
  	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; $(FALSE)
  
  $(PERL_ARCHLIB)/Config.pm: $(PERL_SRC)/config.sh
  	$(NOECHO) $(ECHO) "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
  	%s
  MAKE_FRAG
  pm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)
  };my$pm_to_blib=$self->oneliner(<<CODE,['-MExtUtils::Install']);my@cmds=$self->split_command($pm_to_blib,map {($self->quote_literal($_)=>$self->quote_literal($self->{PM}->{$_}))}sort keys %{$self->{PM}});$r .= join '',map {"\t\$(NOECHO) $_\n"}@cmds;$r .= qq{\t\$(NOECHO) \$(TOUCH) pm_to_blib\n};return$r}sub _ppd_version {my ($self,$string)=@_;return join ',',((split /\./,$string),(0)x 4)[0..3]}sub ppd {my($self)=@_;my$abstract=$self->{ABSTRACT}|| '';$abstract =~ s/\n/\\n/sg;$abstract =~ s/</&lt;/g;$abstract =~ s/>/&gt;/g;my$author=join(', ',@{ref$self->{AUTHOR}eq 'ARRAY' ? $self->{AUTHOR}: [$self->{AUTHOR}|| '']});$author =~ s/</&lt;/g;$author =~ s/>/&gt;/g;my$ppd_file="$self->{DISTNAME}.ppd";my@ppd_chunks=qq(<SOFTPKG NAME="$self->{DISTNAME}" VERSION="$self->{VERSION}">\n);push@ppd_chunks,sprintf <<'PPD_HTML',$abstract,$author;push@ppd_chunks,"    <IMPLEMENTATION>\n";if ($self->{MIN_PERL_VERSION}){my$min_perl_version=$self->_ppd_version($self->{MIN_PERL_VERSION});push@ppd_chunks,sprintf <<'PPD_PERLVERS',$min_perl_version}my%prereqs=%{$self->{PREREQ_PM}};delete$prereqs{perl};for my$prereq (sort keys%prereqs){my$name=$prereq;$name .= '::' unless$name =~ /::/;my$version=$prereqs{$prereq};my%attrs=(NAME=>$name);$attrs{VERSION}=$version if$version;my$attrs=join " ",map {qq[$_="$attrs{$_}"]}sort keys%attrs;push@ppd_chunks,qq(        <REQUIRE $attrs />\n)}my$archname=$Config{archname};if ("$]" >= 5.008){$archname .= "-$Config{api_revision}.$Config{api_version}"}push@ppd_chunks,sprintf <<'PPD_OUT',$archname;if ($self->{PPM_INSTALL_SCRIPT}){if ($self->{PPM_INSTALL_EXEC}){push@ppd_chunks,sprintf qq{        <INSTALL EXEC="%s">%s</INSTALL>\n},$self->{PPM_INSTALL_EXEC},$self->{PPM_INSTALL_SCRIPT}}else {push@ppd_chunks,sprintf qq{        <INSTALL>%s</INSTALL>\n},$self->{PPM_INSTALL_SCRIPT}}}if ($self->{PPM_UNINSTALL_SCRIPT}){if ($self->{PPM_UNINSTALL_EXEC}){push@ppd_chunks,sprintf qq{        <UNINSTALL EXEC="%s">%s</UNINSTALL>\n},$self->{PPM_UNINSTALL_EXEC},$self->{PPM_UNINSTALL_SCRIPT}}else {push@ppd_chunks,sprintf qq{        <UNINSTALL>%s</UNINSTALL>\n},$self->{PPM_UNINSTALL_SCRIPT}}}my ($bin_location)=$self->{BINARY_LOCATION}|| '';$bin_location =~ s/\\/\\\\/g;push@ppd_chunks,sprintf <<'PPD_XML',$bin_location;my@ppd_cmds=$self->stashmeta(join('',@ppd_chunks),$ppd_file);return sprintf <<'PPD_OUT',join "\n\t",@ppd_cmds}sub prefixify {my($self,$var,$sprefix,$rprefix,$default)=@_;my$path=$self->{uc$var}|| $Config_Override{lc$var}|| $Config{lc$var}|| '';$rprefix .= '/' if$sprefix =~ m|/$|;warn "  prefixify $var => $path\n" if$Verbose >= 2;warn "    from $sprefix to $rprefix\n" if$Verbose >= 2;if($self->{ARGS}{PREFIX}&& $path !~ s{^\Q$sprefix\E\b}{$rprefix}s){warn "    cannot prefix, using default.\n" if$Verbose >= 2;warn "    no default!\n" if!$default && $Verbose >= 2;$path=$self->catdir($rprefix,$default)if$default}print "    now $path\n" if$Verbose >= 2;return$self->{uc$var}=$path}sub processPL {my$self=shift;my$pl_files=$self->{PL_FILES};return "" unless$pl_files;my$m='';for my$plfile (sort keys %$pl_files){my$targets=$pl_files->{$plfile};my$list=ref($targets)eq 'HASH' ? [sort keys %$targets ]: ref($targets)eq 'ARRAY' ? $pl_files->{$plfile}: [$pl_files->{$plfile}];for my$target (@$list){if($Is{VMS}){$plfile=vmsify($self->eliminate_macros($plfile));$target=vmsify($self->eliminate_macros($target))}my$pm_dep;my$perlrun;if(defined$self->{PM}{$target}){$pm_dep='';$perlrun='PERLRUN'}else {$pm_dep='pm_to_blib';$perlrun='PERLRUNINST'}my$extra_inputs='';if(ref($targets)eq 'HASH'){my$inputs=ref($targets->{$target})? $targets->{$target}: [$targets->{$target}];for my$input (@$inputs){if($Is{VMS}){$input=vmsify($self->eliminate_macros($input))}$extra_inputs .= ' '.$input}}$m .= <<MAKE_FRAG}}return$m}sub specify_shell {return ''}sub quote_paren {my$arg=shift;$arg =~ s{\$\((.+?)\)}{\$\\\\($1\\\\)}g;$arg =~ s{(?<!\\)([()])}{\\$1}g;$arg =~ s{\$\\\\\((.+?)\\\\\)}{\$($1)}g;return$arg}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,::,g;return$man}sub cd {my($self,$dir,@cmds)=@_;my$make_frag=join "\n\t",map {"cd $dir && $_"}@cmds;return$make_frag}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my@cmds=split /\n/,$cmd;$cmd=join " \n\t  -e ",map$self->quote_literal($_),@cmds;$cmd=$self->escape_newlines($cmd);$switches=join ' ',@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd --}}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{'}{'\\''}g;$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return "'$text'"}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{\\\n}g;return$text}sub max_exec_len {my$self=shift;if (!defined$self->{_MAX_EXEC_LEN}){if (my$arg_max=eval {require POSIX;&POSIX::ARG_MAX}){$self->{_MAX_EXEC_LEN}=$arg_max}else {$self->{_MAX_EXEC_LEN}=4096}}return$self->{_MAX_EXEC_LEN}}sub static {my($self)=shift;'
  pm_to_blib({\@ARGV}, '$autodir', q[\$(PM_FILTER)], '\$(PERM_DIR)')
  CODE
      <ABSTRACT>%s</ABSTRACT>
      <AUTHOR>%s</AUTHOR>
  PPD_HTML
          <PERLCORE VERSION="%s" />
  PPD_PERLVERS
          <ARCHITECTURE NAME="%s" />
  PPD_OUT
          <CODEBASE HREF="%s" />
      </IMPLEMENTATION>
  </SOFTPKG>
  PPD_XML
  # Creates a PPD (Perl Package Description) for a binary distribution.
  ppd :
  	%s
  PPD_OUT
  
  pure_all :: $target
  	\$(NOECHO) \$(NOOP)
  
  $target :: $plfile $pm_dep $extra_inputs
  	\$($perlrun) $plfile $target $extra_inputs
  MAKE_FRAG
  ## $(INST_PM) has been moved to the all: target.
  ## It remains here for awhile to allow for old usage: "make static"
  static :: $(FIRST_MAKEFILE) $(INST_STATIC)
  	$(NOECHO) $(NOOP)
  '}sub static_lib {my($self)=@_;return '' unless$self->has_link_code;my(@m);my@libs;if ($self->{XSMULTI}){for my$ext ($self->_xs_list_basenames){my ($v,$d,$f)=File::Spec->splitpath($ext);my@d=File::Spec->splitdir($d);shift@d if$d[0]eq 'lib';my$instdir=$self->catdir('$(INST_ARCHLIB)','auto',@d,$f);my$instfile=$self->catfile($instdir,"$f\$(LIB_EXT)");my$objfile="$ext\$(OBJ_EXT)";push@libs,[$objfile,$instfile,$instdir ]}}else {@libs=([qw($(OBJECT) $(INST_STATIC) $(INST_ARCHAUTODIR)) ])}push@m,map {$self->xs_make_static_lib(@$_)}@libs;join "\n",@m}sub xs_make_static_lib {my ($self,$from,$to,$todir)=@_;my@m=sprintf '%s: %s $(MYEXTLIB) %s$(DFSEP).exists'."\n",$to,$from,$todir;push@m,"\t\$(RM_F) \"\$\@\"\n";push@m,$self->static_lib_fixtures;push@m,$self->static_lib_pure_cmd($from);push@m,"\t\$(CHMOD) \$(PERM_RWX) \$\@\n";push@m,$self->static_lib_closures($todir);join '',@m}sub static_lib_closures {my ($self,$todir)=@_;my@m=sprintf <<'MAKE_FRAG',$todir;push@m,<<'MAKE_FRAG' if$self->{PERL_SRC}&& $self->{EXTRALIBS};@m}sub static_lib_fixtures {my ($self)=@_;return unless$self->{MYEXTLIB};"\t\$(CP) \$(MYEXTLIB) \"\$\@\"\n"}sub static_lib_pure_cmd {my ($self,$from)=@_;my$ar;if (exists$self->{FULL_AR}&& -x $self->{FULL_AR}){$ar='FULL_AR'}else {$ar='AR'}sprintf <<'MAKE_FRAG',$ar,$from}sub staticmake {my($self,%attribs)=@_;my(@static);my(@searchdirs)=($self->{PERL_ARCHLIB},$self->{SITEARCHEXP},$self->{INST_ARCHLIB});if (@{$self->{C}}){@static=$self->catfile($self->{INST_ARCHLIB},"auto",$self->{FULLEXT},"$self->{BASEEXT}$self->{LIB_EXT}")}my(@perlinc)=($self->{INST_ARCHLIB},$self->{INST_LIB},$self->{PERL_ARCHLIB},$self->{PERL_LIB});$self->makeaperl(MAKE=>$self->{MAKEFILE},DIRS=>\@searchdirs,STAT=>\@static,INCL=>\@perlinc,TARGET=>$self->{MAP_TARGET},TMP=>"",LIBPERL=>$self->{LIBPERL_A})}sub subdir_x {my($self,$subdir)=@_;my$subdir_cmd=$self->cd($subdir,'$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)');return sprintf <<'EOT',$subdir_cmd}sub subdirs {my($self)=shift;my(@m);for my$dir (@{$self->{DIR}}){push@m,$self->subdir_x($dir)}if (@m){unshift@m,<<'EOF'}else {push(@m,"\n# none")}join('',@m)}sub test {my($self,%attribs)=@_;my$tests=$attribs{TESTS}|| '';if (!$tests && -d 't' && defined$attribs{RECURSIVE_TEST_FILES}){$tests=$self->find_tests_recursive}elsif (!$tests && -d 't'){$tests=$self->find_tests}$tests =~ s!/!\\!g if$self->is_make_type('nmake');my@m;my$default_testtype=$Config{usedl}? 'dynamic' : 'static';push@m,<<EOF;for my$linktype (qw(dynamic static)){my$directdeps=join ' ',grep!$self->{SKIPHASH}{$_},$linktype,"pure_all";push@m,"subdirs-test_$linktype :: $directdeps\n";for my$dir (@{$self->{DIR}}){my$test=$self->cd($dir,"\$(MAKE) test_$linktype \$(PASTHRU)");push@m,"\t\$(NOECHO) $test\n"}push@m,"\n";if ($tests or -f "test.pl"){for my$testspec (['','' ],['db',' $(TESTDB_SW)' ]){my ($db,$switch)=@$testspec;my ($command,$deps);$deps=$db eq 'db' ? $directdeps : "subdirs-test_$linktype";if ($linktype eq 'static' and $self->needs_linking){my$target=File::Spec->rel2abs('$(MAP_TARGET)');$command=qq{"$target" \$(MAP_PERLINC)};$deps .= ' $(MAP_TARGET)'}else {$command='$(FULLPERLRUN)' .$switch}push@m,"test${db}_$linktype :: $deps\n";if ($db eq 'db'){push@m,$self->test_via_script($command,'$(TEST_FILE)')}else {push@m,$self->test_via_script($command,'$(TEST_FILE)')if -f "test.pl";push@m,$self->test_via_harness($command,'$(TEST_FILES)')if$tests}push@m,"\n"}}else {push@m,_sprintf562 <<'EOF',$linktype}}join "",@m}sub test_via_harness {my($self,$perl,$tests)=@_;return$self->SUPER::test_via_harness("PERL_DL_NONLAZY=1 $perl",$tests)}sub test_via_script {my($self,$perl,$script)=@_;return$self->SUPER::test_via_script("PERL_DL_NONLAZY=1 $perl",$script)}sub tool_xsubpp {my($self)=shift;return "" unless$self->needs_linking;my$xsdir;my@xsubpp_dirs=@INC;unshift@xsubpp_dirs,$self->{PERL_LIB}if$self->{PERL_CORE};my$foundxsubpp=0;for my$dir (@xsubpp_dirs){$xsdir=$self->catdir($dir,'ExtUtils');if(-r $self->catfile($xsdir,"xsubpp")){$foundxsubpp=1;last}}die "ExtUtils::MM_Unix::tool_xsubpp : Can't find xsubpp" if!$foundxsubpp;my$tmdir=$self->catdir($self->{PERL_LIB},"ExtUtils");my(@tmdeps)=$self->catfile($tmdir,'typemap');if($self->{TYPEMAPS}){for my$typemap (@{$self->{TYPEMAPS}}){if(!-f $typemap){warn "Typemap $typemap not found.\n"}else {$typemap=vmsify($typemap)if$Is{VMS};push(@tmdeps,$typemap)}}}push(@tmdeps,"typemap")if -f "typemap";my@tmargs=map {'-typemap '.$self->quote_literal(File::Spec->rel2abs($_))}@tmdeps;$_=$self->quote_dep($_)for@tmdeps;if(exists$self->{XSOPT}){unshift(@tmargs,$self->{XSOPT})}if ($Is{VMS}&& $Config{'ldflags'}&& $Config{'ldflags'}=~ m!/Debug!i && (!exists($self->{XSOPT})|| $self->{XSOPT}!~ /linenumbers/)){unshift(@tmargs,'-nolinenumbers')}$self->{XSPROTOARG}="" unless defined$self->{XSPROTOARG};my$xsdirdep=$self->quote_dep($xsdir);return qq{
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > %s$(DFSEP)extralibs.ld
  MAKE_FRAG
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)$(DFSEP)ext.libs
  MAKE_FRAG
  	$(%s) $(AR_STATIC_ARGS) "$@" %s
  	$(RANLIB) "$@"
  MAKE_FRAG
  
  subdirs ::
  	$(NOECHO) %s
  EOT
  
  # The default clean, realclean and test targets in this Makefile
  # have automatically been given entries for each subdir.
  
  EOF
  TEST_VERBOSE=0
  TEST_TYPE=test_\$(LINKTYPE)
  TEST_FILE = test.pl
  TEST_FILES = $tests
  TESTDB_SW = -d
  
  testdb :: testdb_\$(LINKTYPE)
  	\$(NOECHO) \$(NOOP)
  
  test :: \$(TEST_TYPE)
  	\$(NOECHO) \$(NOOP)
  
  # Occasionally we may face this degenerate target:
  test_ : test_$default_testtype
  	\$(NOECHO) \$(NOOP)
  
  EOF
  testdb_%1$s test_%1$s :: subdirs-test_%1$s
  	$(NOECHO) $(ECHO) 'No tests defined for $(NAME) extension.'
  
  EOF
  XSUBPPDIR = $xsdir
  XSUBPP = "\$(XSUBPPDIR)\$(DFSEP)xsubpp"
  XSUBPPRUN = \$(PERLRUN) \$(XSUBPP)
  XSPROTOARG = $self->{XSPROTOARG}
  XSUBPPDEPS = @tmdeps $xsdirdep\$(DFSEP)xsubpp
  XSUBPPARGS = @tmargs
  XSUBPP_EXTRA_ARGS =
  }}sub all_target {my$self=shift;return <<'MAKE_EXT'}sub top_targets {my($self)=shift;my(@m);push@m,$self->all_target,"\n" unless$self->{SKIPHASH}{'all'};push@m,sprintf <<'EOF';push@m,'
  all :: pure_all manifypods
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  pure_all :: config pm_to_blib subdirs linkext
  	$(NOECHO) $(NOOP)
  
  subdirs :: $(MYEXTLIB)
  	$(NOECHO) $(NOOP)
  
  config :: $(FIRST_MAKEFILE) blibdirs
  	$(NOECHO) $(NOOP)
  EOF
  $(O_FILES) : $(H_FILES)
  ' if @{$self->{O_FILES}|| []}&& @{$self->{H}|| []};push@m,q{
  help :
  	perldoc ExtUtils::MakeMaker
  };join('',@m)}sub writedoc {my($self,$what,$name,@attribs)=@_;my$time=gmtime($ENV{SOURCE_DATE_EPOCH}|| time);print "=head2 $time: $what C<$name>\n\n=over 4\n\n=item *\n\n";print join "\n\n=item *\n\n",map("C<$_>",@attribs);print "\n\n=back\n\n"}sub xs_c {my($self)=shift;return '' unless$self->needs_linking();'
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  '}sub xs_cpp {my($self)=shift;return '' unless$self->needs_linking();'
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.cpp
  '}sub xs_o {my ($self)=@_;return '' unless$self->needs_linking();my$m_o=$self->{XSMULTI}? $self->xs_obj_opt('$*$(OBJ_EXT)'): '';my$dbgout=$self->dbgoutflag;$dbgout=$dbgout ? "$dbgout " : '';my$frag='';$frag .= sprintf <<'EOF',$dbgout,$m_o unless$self->is_make_type('dmake');if ($self->{XSMULTI}){for my$ext ($self->_xs_list_basenames){my$pmfile="$ext.pm";croak "$ext.xs has no matching $pmfile: $!" unless -f $pmfile;my$version=$self->parse_version($pmfile);my$cccmd=$self->{CONST_CCCMD};$cccmd =~ s/^\s*CCCMD\s*=\s*//;$cccmd =~ s/\$\(DEFINE_VERSION\)/-DVERSION=\\"$version\\"/;$cccmd =~ s/\$\(XS_DEFINE_VERSION\)/-DXS_VERSION=\\"$version\\"/;$self->_xsbuild_replace_macro($cccmd,'xs',$ext,'INC');my$define='$(DEFINE)';$self->_xsbuild_replace_macro($define,'xs',$ext,'DEFINE');$frag .= _sprintf562 <<'EOF',$ext,$cccmd,$m_o,$define,$dbgout}}$frag =~ s/"-I(\$\(PERL_INC\))"/-iwithsysroot "$1"/sg if$Is{ApplCor};$frag}sub _xsbuild_replace_macro {my ($self,undef,$xstype,$ext,$varname)=@_;my$value=$self->_xsbuild_value($xstype,$ext,$varname);return unless defined$value;$_[1]=~ s/\$\($varname\)/$value/}sub _xsbuild_value {my ($self,$xstype,$ext,$varname)=@_;return$self->{XSBUILD}{$xstype}{$ext}{$varname}if$self->{XSBUILD}{$xstype}{$ext}{$varname};return$self->{XSBUILD}{$xstype}{all}{$varname}if$self->{XSBUILD}{$xstype}{all}{$varname};()}1;
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) %s$*.c %s
  EOF
  
  %1$s$(OBJ_EXT): %1$s.xs
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  	%2$s $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) %4$s %5$s$*.c %3$s
  EOF
EXTUTILS_MM_UNIX

$fatpacked{"ExtUtils/MM_VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VMS';
  package ExtUtils::MM_VMS;use strict;use warnings;use ExtUtils::MakeMaker::Config;require Exporter;BEGIN {if($^O eq 'VMS'){require VMS::Filespec;VMS::Filespec->import}}use File::Basename;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);our$Revision=$ExtUtils::MakeMaker::Revision;sub wraplist {my($self)=shift;my($line,$hlen)=('',0);for my$word (@_){next unless$word =~ /\w/;$line .= ' ' if length($line);if ($hlen > 80){$line .= "\\\n\t";$hlen=0}$line .= $word;$hlen += length($word)+ 2}$line}sub ext {require ExtUtils::Liblist::Kid;goto&ExtUtils::Liblist::Kid::ext}sub guess_name {my($self)=@_;my($defname,$defpm,@pm,%xs);local*PM;$defname=basename(fileify($ENV{'DEFAULT'}));$defname =~ s![\d\-_]*\.dir.*$!!;$defpm=$defname;if (not -e "${defpm}.pm"){@pm=glob('*.pm');s/.pm$// for@pm;if (@pm==1){($defpm=$pm[0])=~ s/.pm$//}elsif (@pm){%xs=map {s/.xs$//;($_,1)}glob('*.xs');if (keys%xs){for my$pm (@pm){$defpm=$pm,last if exists$xs{$pm}}}}}if (open(my$pm,'<',"${defpm}.pm")){while (<$pm>){if (/^\s*package\s+([^;]+)/i){$defname=$1;last}}print "Warning (non-fatal): Couldn't find package name in ${defpm}.pm;\n\t","defaulting package name to $defname\n" if eof($pm);close$pm}else {print "Warning (non-fatal): Couldn't find ${defpm}.pm;\n\t","defaulting package name to $defname\n"}$defname =~ s#[\d.\-_]+$##;$defname}sub find_perl {my($self,$ver,$names,$dirs,$trace)=@_;my($vmsfile,@sdirs,@snames,@cand);my($rslt);my($inabs)=0;local*TCF;if($self->{PERL_CORE}){@sdirs=sort {my($absa)=$self->file_name_is_absolute($a);my($absb)=$self->file_name_is_absolute($b);if ($absa && $absb){return$a cmp $b}else {return$absa ? 1 : ($absb ? -1 : ($a cmp $b))}}@$dirs;@snames=sort {my($ba)=$a =~ m!([^:>\]/]+)$!;my($bb)=$b =~ m!([^:>\]/]+)$!;my($ahasdir)=(length($a)- length($ba)> 0);my($bhasdir)=(length($b)- length($bb)> 0);if ($ahasdir and not $bhasdir){return 1}elsif ($bhasdir and not $ahasdir){return -1}else {$bb =~ /\d/ <=> $ba =~ /\d/ or substr($ba,0,1)cmp substr($bb,0,1)or length($bb)<=> length($ba)}}@$names}else {@sdirs=@$dirs;@snames=@$names}s/\.(\d+)$/_$1/ for@snames;if ($trace >= 2){print "Looking for perl $ver by these names:\n";print "\t@snames,\n";print "in these dirs:\n";print "\t@sdirs\n"}for my$dir (@sdirs){next unless defined$dir;$inabs++ if$self->file_name_is_absolute($dir);if ($inabs==1){for my$name (@snames){push(@cand,$name)if$name =~ /^[\w\-\$]+$/}$inabs++}for my$name (@snames){push@cand,($name !~ m![/:>\]]!)? $self->catfile($dir,$name): $self->fixpath($name,0)}}for my$name (@cand){print "Checking $name\n" if$trace >= 2;if ($name =~ /^[\w\-\$]+$/){open(my$tcf,">","temp_mmvms.com")or die('unable to open temp file');print$tcf "\$ set message/nofacil/nosever/noident/notext\n";print$tcf "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";close$tcf;$rslt=`\@temp_mmvms.com` ;unlink('temp_mmvms.com');if ($rslt =~ /VER_OK/){print "Using PERL=$name\n" if$trace;return$name}}next unless$vmsfile=$self->maybe_command($name);$vmsfile =~ s/;[\d\-]*$//;print "Executing $vmsfile\n" if ($trace >= 2);open(my$tcf,'>',"temp_mmvms.com")or die('unable to open temp file');print$tcf "\$ set message/nofacil/nosever/noident/notext\n";print$tcf "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";close$tcf;$rslt=`\@temp_mmvms.com`;unlink('temp_mmvms.com');if ($rslt =~ /VER_OK/){print "Using PERL=MCR $vmsfile\n" if$trace;return "MCR $vmsfile"}}print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";0}sub _fixin_replace_shebang {my ($self,$file,$line)=@_;my (undef,$arg)=split ' ',$line,2;return$Config{startperl}."\n" .$Config{sharpbang}."perl $arg\n"}sub maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return 0}sub pasthru {my($self)=shift;my$pasthru=$self->SUPER::pasthru;$pasthru =~ s|(PASTHRU\s*=\s*)|$1/MACRO=(|;$pasthru =~ s|\n\z|)\n|m;$pasthru =~ s|/defi?n?e?=\(?([^\),]+)\)?|,$1|ig;return$pasthru}sub pm_to_blib {my$self=shift;my$make=$self->SUPER::pm_to_blib;$make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;$make =~ s{\$\(TOUCH\) pm_to_blib}{\$(TOUCH) pm_to_blib.ts};$make=<<'MAKE' .$make;return$make}sub perl_script {my($self,$file)=@_;return$file if -r $file &&!-d _;return "$file.com" if -r "$file.com";return "$file.pl" if -r "$file.pl";return ''}sub replace_manpage_separator {my($self,$man)=@_;$man=unixify($man);$man =~ s#/+#__#g;$man}sub init_DEST {my$self=shift;$self->SUPER::init_DEST;for my$var ($self->installvars){my$destvar='DESTINSTALL'.$var;$self->{$destvar}=$self->eliminate_macros($self->{$destvar})}}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}='';return 1}sub init_main {my($self)=shift;$self->SUPER::init_main;$self->{DEFINE}||= '';if ($self->{DEFINE}ne ''){my(@terms)=split(/\s+/,$self->{DEFINE});my(@defs,@udefs);for my$def (@terms){next unless$def;my$targ=\@defs;if ($def =~ s/^-([DU])//){$targ=\@udefs if $1 eq 'U';$def =~ s/='(.*)'$/=$1/;$def =~ s/^'(.*)'$/$1/}if ($def =~ /=/){$def =~ s/"/""/g;$def=qq["$def"]}push @$targ,$def}$self->{DEFINE}='';if (@defs){$self->{DEFINE}='/Define=(' .join(',',@defs).')'}if (@udefs){$self->{DEFINE}.= '/Undef=(' .join(',',@udefs).')'}}}sub init_tools {my($self)=@_;$self->{NOOP}='Continue';$self->{NOECHO}||= '@ ';$self->{MAKEFILE}||= $self->{FIRST_MAKEFILE}|| 'Descrip.MMS';$self->{FIRST_MAKEFILE}||= $self->{MAKEFILE};$self->{MAKE_APERL_FILE}||= 'Makeaperl.MMS';$self->{MAKEFILE_OLD}||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');$self->{MAKEFILE}.= '.' unless$self->{MAKEFILE}=~ m/\./;$self->{FIRST_MAKEFILE}.= '.' unless$self->{FIRST_MAKEFILE}=~ m/\./;$self->{MAKE_APERL_FILE}.= '.' unless$self->{MAKE_APERL_FILE}=~ m/\./;$self->{MAKEFILE_OLD}.= '.' unless$self->{MAKEFILE_OLD}=~ m/\./;$self->{MACROSTART}||= '/Macro=(';$self->{MACROEND}||= ')';$self->{USEMAKEFILE}||= '/Descrip=';$self->{EQUALIZE_TIMESTAMP}||= '$(ABSPERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';$self->{MOD_INSTALL}||= $self->oneliner(<<'CODE',['-MExtUtils::Install']);$self->{UMASK_NULL}='! ';$self->SUPER::init_tools;$self->{SHELL}||= 'Posix';$self->{DEV_NULL}='';return}sub init_platform {my($self)=shift;$self->{MM_VMS_REVISION}=$Revision;$self->{MM_VMS_VERSION}=$VERSION;$self->{PERL_VMS}=$self->catdir($self->{PERL_SRC},'VMS')if$self->{PERL_SRC}}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub init_VERSION {my$self=shift;$self->SUPER::init_VERSION;$self->{DEFINE_VERSION}='"$(VERSION_MACRO)=""$(VERSION)"""';$self->{XS_DEFINE_VERSION}='"$(XS_VERSION_MACRO)=""$(XS_VERSION)"""';$self->{MAKEMAKER}=vmsify($INC{'ExtUtils/MakeMaker.pm'})}sub constants {my($self)=@_;for (@ARGV){$_=uc($_)if /POLLUTE/i}for my$macro (qw [ INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB PERL_LIB PERL_ARCHLIB PERL_ARCHLIBDEP PERL_INC PERL_SRC],(map {'INSTALL'.$_}$self->installvars),(map {'DESTINSTALL'.$_}$self->installvars)){next unless defined$self->{$macro};next if$macro =~ /MAN/ && $self->{$macro}eq 'none';$self->{$macro}=$self->fixpath($self->{$macro},1)}for my$macro (qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE MYEXTLIB]){next unless defined$self->{$macro};$self->{$macro}=$self->fixpath($self->{$macro},0)}for my$macro (qw/FULLEXT VERSION_FROM/){next unless defined$self->{$macro};$self->{$macro}=$self->fixpath($self->{$macro},0)}for my$macro (qw/OBJECT LDFROM/){next unless defined$self->{$macro};$self->{$macro}=$self->eliminate_macros($self->{$macro});if ($self->{$macro}=~ /(?<!\^)\s/){$self->{$macro}=~ s/(\\)?\n+\s+/ /g;$self->{$macro}=$self->wraplist(map$self->fixpath($_,0),split /,?(?<!\^)\s+/,$self->{$macro})}else {$self->{$macro}=$self->fixpath($self->{$macro},0)}}for my$macro (qw/XS MAN1PODS MAN3PODS PM/){next unless$self ne " " && defined$self->{$macro};my%tmp=();for my$key (keys %{$self->{$macro}}){$tmp{$self->fixpath($key,0)}=$self->fixpath($self->{$macro}{$key},0)}$self->{$macro}=\%tmp}for my$macro (qw/C O_FILES H/){next unless defined$self->{$macro};my@tmp=();for my$val (@{$self->{$macro}}){push(@tmp,$self->fixpath($val,0))}$self->{$macro}=\@tmp}$self->{MAKE}='$(MMS)$(MMSQUALIFIERS)';return$self->SUPER::constants}sub special_targets {my$self=shift;my$make_frag .= <<'MAKE_FRAG';return$make_frag}sub cflags {my($self,$libperl)=@_;my($quals)=$self->{CCFLAGS}|| $Config{'ccflags'};my($definestr,$undefstr,$flagoptstr)=('','','');my($incstr)='/Include=($(PERL_INC)';my($name,$sys,@m);($name=$self->{NAME}."_cflags")=~ s/:/_/g ;print "Unix shell script ".$Config{"$self->{'BASEEXT'}_cflags"}." required to modify CC command for $self->{'BASEEXT'}\n" if ($Config{$name});if ($quals =~ / -[DIUOg]/){while ($quals =~ / -([Og])(\d*)\b/){my($type,$lvl)=($1,$2);$quals =~ s/ -$type$lvl\b\s*//;if ($type eq 'g'){$flagoptstr='/NoOptimize'}else {$flagoptstr='/Optimize' .(defined($lvl)? "=$lvl" : '')}}while ($quals =~ / -([DIU])(\S+)/){my($type,$def)=($1,$2);$quals =~ s/ -$type$def\s*//;$def =~ s/"/""/g;if ($type eq 'D'){$definestr .= qq["$def",]}elsif ($type eq 'I'){$incstr .= ',' .$self->fixpath($def,1)}else {$undefstr .= qq["$def",]}}}if (length$quals and $quals !~ m!/!){warn "MM_VMS: Ignoring unrecognized CCFLAGS elements \"$quals\"\n";$quals=''}$definestr .= q["PERL_POLLUTE",] if$self->{POLLUTE};if (length$definestr){chop($definestr);$quals .= "/Define=($definestr)"}if (length$undefstr){chop($undefstr);$quals .= "/Undef=($undefstr)"}if ($self->{DEFINE}){$quals .= $self->{DEFINE}}for my$type (qw(Def Undef)){my(@terms);while ($quals =~ m:/${type}i?n?e?=([^/]+):ig){my$term=$1;$term =~ s:^\((.+)\)$:$1:;push@terms,$term}if ($type eq 'Def'){push@terms,qw[$(DEFINE_VERSION) $(XS_DEFINE_VERSION)]}if (@terms){$quals =~ s:/${type}i?n?e?=[^/]+::ig;$quals .= "/${type}ine=(" .join(',',@terms).($type eq 'Def' ? '$(PASTHRU_DEFINE)' : '').')'}}$libperl or $libperl=$self->{LIBPERL_A}|| "libperl.olb";if ($self->{'INC'}){my(@includes)=split(/\s+/,$self->{INC});for (@includes){s/^-I//;$incstr .= ','.$self->fixpath($_,1)}}$quals .= "$incstr)";$self->{CCFLAGS}=$quals;$self->{PERLTYPE}||= '';$self->{OPTIMIZE}||= $flagoptstr || $Config{'optimize'};if ($self->{OPTIMIZE}!~ m!/!){if ($self->{OPTIMIZE}=~ m!-g!){$self->{OPTIMIZE}='/Debug/NoOptimize'}elsif ($self->{OPTIMIZE}=~ /-O(\d*)/){$self->{OPTIMIZE}='/Optimize' .(defined($1)? "=$1" : '')}else {warn "MM_VMS: Can't parse OPTIMIZE \"$self->{OPTIMIZE}\"; using default\n" if length$self->{OPTIMIZE};$self->{OPTIMIZE}='/Optimize'}}return$self->{CFLAGS}=qq{
  # Dummy target to match Unix target name; we use pm_to_blib.ts as
  # timestamp file to avoid repeated invocations under VMS
  pm_to_blib : pm_to_blib.ts
  	$(NOECHO) $(NOOP)
  
  MAKE
  install([ from_to => {split('\|', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  .SUFFIXES :
  .SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs
  
  MAKE_FRAG
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub const_cccmd {my($self,$libperl)=@_;my(@m);return$self->{CONST_CCCMD}if$self->{CONST_CCCMD};return '' unless$self->needs_linking();if ($Config{'vms_cc_type'}eq 'gcc'){push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" Then Define/NoLog SYS GNU_CC_Include:[VMS]'}elsif ($Config{'vms_cc_type'}eq 'vaxc'){push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").eqs."" Then Define/NoLog SYS Sys$Library
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").nes."" Then Define/NoLog SYS VAXC$Include'}else {push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").eqs."" Then Define/NoLog SYS ',($Config{'archname'}eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").nes."" Then Define/NoLog SYS DECC$System_Include'}push(@m,"\n\nCCCMD = $Config{'cc'} \$(CCFLAGS)\$(OPTIMIZE)\n");$self->{CONST_CCCMD}=join('',@m)}sub tools_other {my($self)=@_;my$extra_tools=<<'EXTRA_TOOLS';return$self->SUPER::tools_other .$extra_tools}sub init_dist {my($self)=@_;$self->{ZIPFLAGS}||= '-Vu';$self->{COMPRESS}||= 'gzip';$self->{SUFFIX}||= '-gz';$self->{SHAR}||= 'vms_share';$self->{DIST_DEFAULT}||= 'zipdist';$self->SUPER::init_dist;$self->{DISTVNAME}="$self->{DISTNAME}-$self->{VERSION_SYM}" unless$self->{ARGS}{DISTVNAME};return}sub c_o {my($self)=@_;return '' unless$self->needs_linking();'
  
  # Just in case anyone is using the old macro.
  USEMACROS = $(MACROSTART)
  SAY = $(ECHO)
  
  EXTRA_TOOLS
  .c$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  .cpp$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cpp /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  .cxx$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cxx /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  '}sub xs_c {my($self)=@_;return '' unless$self->needs_linking();'
  .xs.c :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  '}sub xs_o {my ($self)=@_;return '' unless$self->needs_linking();my$frag='
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  ';if ($self->{XSMULTI}){for my$ext ($self->_xs_list_basenames){my$version=$self->parse_version("$ext.pm");my$ccflags=$self->{CCFLAGS};$ccflags =~ s/\$\(DEFINE_VERSION\)/\"VERSION_MACRO=\\"\"$version\\"\"/;$ccflags =~ s/\$\(XS_DEFINE_VERSION\)/\"XS_VERSION_MACRO=\\"\"$version\\"\"/;$self->_xsbuild_replace_macro($ccflags,'xs',$ext,'INC');$self->_xsbuild_replace_macro($ccflags,'xs',$ext,'DEFINE');$frag .= _sprintf562 <<'EOF',$ext,$ccflags}}$frag}sub _xsbuild_replace_macro {my ($self,undef,$xstype,$ext,$varname)=@_;my$value=$self->_xsbuild_value($xstype,$ext,$varname);return unless defined$value;$_[1]=_vms_replace_qualifier($self,$_[1],$value,$varname)}sub _xsbuild_value {my ($self,$xstype,$ext,$varname)=@_;$ext=unixify($ext);return$self->SUPER::_xsbuild_value($xstype,$ext,$varname)}sub _vms_replace_qualifier {my ($self,$flags,$newflag,$macro)=@_;my$qual_type;my$type_suffix;my$quote_subquals=0;my@subquals_new=split /\s+/,$newflag;if ($macro eq 'DEFINE'){$qual_type='Def';$type_suffix='ine';map {$_ =~ s/^-D//}@subquals_new;$quote_subquals=1}elsif ($macro eq 'INC'){$qual_type='Inc';$type_suffix='lude';map {$_ =~ s/^-I//;$_=$self->fixpath($_)}@subquals_new}my@subquals=();while ($flags =~ m:/${qual_type}\S{0,4}=([^/]+):ig){my$term=$1;$term =~ s/\"//g;$term =~ s:^\((.+)\)$:$1:;push@subquals,split /,/,$term}for my$new (@subquals_new){my ($sq_new,$sqval_new)=split /=/,$new;my$replaced_old=0;for my$old (@subquals){my ($sq,$sqval)=split /=/,$old;if ($sq_new eq $sq){$old=$sq_new;$old .= '=' .$sqval_new if defined($sqval_new)and length($sqval_new);$replaced_old=1;last}}push@subquals,$new unless$replaced_old}if (@subquals){$flags =~ s:/${qual_type}\S{0,4}=[^/]+::ig;map {$_=qq/"$_"/ if $_ !~ m/^\$\(/}@subquals if$quote_subquals;$flags .= "/${qual_type}$type_suffix=(" .join(',',@subquals).')'}return$flags}sub xs_dlsyms_ext {'.opt'}sub dlsyms {my ($self,%attribs)=@_;return '' unless$self->needs_linking;$self->xs_dlsyms_iterator}sub xs_make_dlsyms {my ($self,$attribs,$target,$dep,$name,$dlbase,$funcs,$funclist,$imports,$vars,$extra)=@_;my@m;my$instloc;if ($self->{XSMULTI}){my ($v,$d,$f)=File::Spec->splitpath($target);my@d=File::Spec->splitdir($d);shift@d if$d[0]eq 'lib';$instloc=$self->catfile('$(INST_ARCHLIB)','auto',@d,$f);push@m,"\ndynamic :: $instloc\n\t\$(NOECHO) \$(NOOP)\n" unless$self->{SKIPHASH}{'dynamic'};push@m,"\nstatic :: $instloc\n\t\$(NOECHO) \$(NOOP)\n" unless$self->{SKIPHASH}{'static'};push@m,"\n",sprintf <<'EOF',$instloc,$target}else {push@m,"\ndynamic :: \$(INST_ARCHAUTODIR)$self->{BASEEXT}.opt\n\t\$(NOECHO) \$(NOOP)\n" unless$self->{SKIPHASH}{'dynamic'};push@m,"\nstatic :: \$(INST_ARCHAUTODIR)$self->{BASEEXT}.opt\n\t\$(NOECHO) \$(NOOP)\n" unless$self->{SKIPHASH}{'static'};push@m,"\n",sprintf <<'EOF',$target}push@m,"\n$target : $dep\n\t",q!$(PERLRUN) -MExtUtils::Mksymlists -e "Mksymlists('NAME'=>'!,$name,q!', 'DLBASE' => '!,$dlbase,q!', 'DL_FUNCS' => !,neatvalue($funcs),q!, 'FUNCLIST' => !,neatvalue($funclist),q!, 'IMPORTS' => !,neatvalue($imports),q!, 'DL_VARS' => !,neatvalue($vars);push@m,$extra if defined$extra;push@m,qq!);"\n\t!;my$olb_base=basename($target,'.opt');if ($self->{XSMULTI}){my$olb_dir=$self->catdir(dirname($instloc),$olb_base);push@m,qq!\$(PERL) -e "print ""${olb_dir}${olb_base}\$(LIB_EXT)/Include=!;push@m,($Config{d_vms_case_sensitive_symbols}? uc($olb_base): $olb_base);push@m,'\n' .$olb_dir .$olb_base .'$(LIB_EXT)/Library\n"";" >>$(MMS$TARGET)',"\n"}else {push@m,qq!\$(PERL) -e "print ""\$(INST_ARCHAUTODIR)${olb_base}\$(LIB_EXT)/Include=!;if ($self->{OBJECT}=~ /\bBASEEXT\b/ or $self->{OBJECT}=~ /\b$self->{BASEEXT}\b/i){push@m,($Config{d_vms_case_sensitive_symbols}? uc($self->{BASEEXT}):'$(BASEEXT)')}else {my($upcase)=$Config{d_vms_case_sensitive_symbols};my(@omods)=split ' ',$self->eliminate_macros($self->{OBJECT});for (@omods){s/\.[^.]*$//;s[\$\(\w+_EXT\)][];s/.*[:>\/\]]//;$_=uc if$upcase};my(@lines);my$tmp=shift@omods;for my$elt (@omods){$tmp .= ",$elt";if (length($tmp)> 80){push@lines,$tmp;$tmp=''}}push@lines,$tmp;push@m,'(',join(qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""],@lines),')'}push@m,'\n$(INST_ARCHAUTODIR)' .$olb_base .'$(LIB_EXT)/Library\n"";" >>$(MMS$TARGET)',"\n"}if (length$self->{LDLOADLIBS}){my($line)='';for my$lib (split ' ',$self->{LDLOADLIBS}){$lib =~ s%\$%\\\$%g;if (length($line)+ length($lib)> 160){push@m,"\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";$line=$lib .'\n'}else {$line .= $lib .'\n'}}push@m,"\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if$line}join '',@m}sub xs_obj_opt {my ($self,$output_file)=@_;"/OBJECT=$output_file"}sub xs_dynamic_lib_macros {my ($self,$attribs)=@_;my$otherldflags=$attribs->{OTHERLDFLAGS}|| "";my$inst_dynamic_dep=$attribs->{INST_DYNAMIC_DEP}|| "";sprintf <<'EOF',$otherldflags,$inst_dynamic_dep}sub xs_make_dynamic_lib {my ($self,$attribs,$from,$to,$todir,$ldfrom,$exportlist)=@_;my$shr=$Config{'dbgprefix'}.'PerlShr';$exportlist =~ s/.def$/.opt/;_sprintf562 <<'EOF',$to,$todir,$exportlist,$shr,"$shr Sys\$Share:$shr.$Config{'dlext'}"}sub xs_make_static_lib {my ($self,$object,$to,$todir)=@_;my@objects;if ($self->{XSMULTI}){my$lib=$object;$lib =~ s/\$\(OBJ_EXT\)\z//;my$override=$self->_xsbuild_value('xs',$lib,'OBJECT');$object=$override if defined$override;@objects=map {$self->fixpath($_,0)}split /(?<!\^)\s+/,$object}else {push@objects,$object}my@m;for my$obj (@objects){push(@m,sprintf "\n%s : %s\$(DFSEP).exists",$obj,$todir)}push(@m,sprintf "\n\n%s : %s \$(MYEXTLIB)\n",$to,(join ' ',@objects));push(@m,"\t",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n")if$self->{MYEXTLIB};push(@m,"\t",'If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)',"\n");if ($self->{MYEXTLIB}){for my$obj (@objects){push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) ' .$obj,"\n")}}else {push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',"\n")}push@m,"\t\$(NOECHO) \$(PERL) -e 1 >\$(INST_ARCHAUTODIR)extralibs.ld\n";for my$lib (split ' ',$self->{EXTRALIBS}){push(@m,"\t",'$(NOECHO) $(PERL) -e "print qq{',$lib,'\n}" >>$(INST_ARCHAUTODIR)extralibs.ld',"\n")}join('',@m)}sub static_lib_pure_cmd {my ($self,$from)=@_;sprintf <<'MAKE_FRAG',$from}sub xs_static_lib_is_xs {return 1}sub extra_clean_files {return qw(*.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso .MM_Tmp cxx_repository)}sub zipfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub tarfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub shdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub install {my($self,%attribs)=@_;my(@m);push@m,q[
  
  %1$s$(OBJ_EXT) : %1$s.xs
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs > $(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  	$(CC)%2$s$(OPTIMIZE) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  EOF
  %s : %s
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  EOF
  $(INST_ARCHAUTODIR)$(BASEEXT).opt : %s
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  EOF
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  EOF
  %1$s : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt %2$s$(DFSEP).exists %3$s $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
  	If F$TrnLNm("%4$s").eqs."" Then Define/NoLog/User %5$s
  	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) %3$s/Option,$(PERL_INC)perlshr_attr.opt/Option
  EOF
  	If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)
  	Library/Object/Replace $(MMS$TARGET) %s
  MAKE_FRAG
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)...]
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(POSTOP)
  MAKE_FRAG
  shdist : distdir
  	$(PREOP)
  	$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  install :: all pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: all pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: all pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: all pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  # This hack brought to you by DCL's 255-character command line limit
  pure_perl_install ::
  ];push@m,q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless$self->{NO_PACKLIST};push@m,q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLPRIVLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLARCHLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) "].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q["
  
  # Likewise
  pure_site_install ::
  ];push@m,q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless$self->{NO_PACKLIST};push@m,q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLSITELIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLSITEARCH)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLSITEBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR)|$(DESTINSTALLSITEMAN1DIR)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLSITEMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) "].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q["
  
  pure_vendor_install ::
  ];push@m,q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless$self->{NO_PACKLIST};push@m,q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLVENDORLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLVENDORARCH)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLVENDORBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR)|$(DESTINSTALLVENDORMAN1DIR)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLVENDORMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ];push@m,q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(NOOP)
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install ::
  	$(NOECHO) $(NOOP)
  
  ] if$self->{NO_PERLLOCAL};push@m,q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLPRIVLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLSITELIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  doc_vendor_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLVENDORLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ] unless$self->{NO_PERLLOCAL};push@m,q[
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{VENDORARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  ];join('',@m)}sub perldepend {my($self)=@_;my(@m);if ($self->{OBJECT}){push@m,$self->_perl_header_files_fragment("")}if ($self->{PERL_SRC}){my(@macros);my($mmsquals)='$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';push(@macros,'__AXP__=1')if$Config{'archname'}eq 'VMS_AXP';push(@macros,'DECC=1')if$Config{'vms_cc_type'}eq 'decc';push(@macros,'GNUC=1')if$Config{'vms_cc_type'}eq 'gcc';push(@macros,'SOCKET=1')if$Config{'d_has_sockets'};push(@macros,qq["CC=$Config{'cc'}"])if$Config{'cc'}=~ m!/!;$mmsquals .= '$(USEMACROS)' .join(',',@macros).'$(MACROEND)' if@macros;push(@m,q[
  # Check for unpropagated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INC)config.h : $(PERL_SRC)config.sh
  	$(NOOP)
  
  $(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
  	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl"
  	olddef = F$Environment("Default")
  	Set Default $(PERL_SRC)
  	$(MMS)],$mmsquals,);if ($self->{PERL_ARCHLIB}=~ m|\[-| && $self->{PERL_SRC}=~ m|(\[-+)|){my($prefix,$target)=($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));$target =~ s/\Q$prefix/[/;push(@m," $target")}else {push(@m,' $(MMS$TARGET)')}push(@m,q[
  	Set Default 'olddef'
  ])}push(@m,join(" ",map($self->fixpath($_,0),sort values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")if %{$self->{XS}};join('',@m)}our%olbs;sub makeaperl {my($self,%attribs)=@_;my($makefilename,$searchdirs,$static,$extra,$perlinc,$target,$tmpdir,$libperl)=@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};my(@m);push@m,"
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  ";return join '',@m if$self->{PARENT};my($dir)=join ":",@{$self->{DIR}};unless ($self->{MAKEAPERL}){push@m,q{
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)
  	$(NOECHO) $(ECHO) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR=},$dir,q{ \
  		FIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 };push@m,map(q[ \\\n\t\t"$_"],@ARGV),q{
  
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
  };push@m,"\n";return join '',@m}my($linkcmd,@optlibs,@staticpkgs,$extralist,$targdir,$libperldir,%libseen);local($_);$linkcmd=join ' ',$Config{'ld'},grep($_,@Config{qw(large split ldflags ccdlflags)});$linkcmd =~ s/\s+/ /g;local(%olbs);$olbs{$self->{INST_ARCHAUTODIR}}="$self->{BASEEXT}\$(LIB_EXT)";require File::Find;File::Find::find(sub {return unless m/\Q$self->{LIB_EXT}\E$/;return if m/^libperl/;if(exists$self->{INCLUDE_EXT}){my$found=0;(my$xx=$File::Find::name)=~ s,.*?/auto/,,;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){if($xx eq $incl){$found++;last}}return unless$found}elsif(exists$self->{EXCLUDE_EXT}){(my$xx=$File::Find::name)=~ s,.*?/auto/,,;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$excl (@{$self->{EXCLUDE_EXT}}){return if($xx eq $excl)}}$olbs{$ENV{DEFAULT}}=$_},grep(-d $_,@{$searchdirs || []}));$static=[]unless$static;@olbs{@{$static}}=(1)x @{$static};$extra=[]unless$extra && ref$extra eq 'ARRAY';for (sort {length($a)<=> length($b)|| $a cmp $b}keys%olbs){next unless$olbs{$_}=~ /\Q$self->{LIB_EXT}\E$/;my($dir)=$self->fixpath($_,1);my($extralibs)=$dir ."extralibs.ld";my($extopt)=$dir .$olbs{$_};$extopt =~ s/$self->{LIB_EXT}$/.opt/;push@optlibs,"$dir$olbs{$_}";if (-f $extralibs){my%seenthis;open my$list,"<",$extralibs or warn $!,next;while (<$list>){chomp;my$skip=exists($libseen{$_})&&!exists($seenthis{$_});$libseen{$_}++;$seenthis{$_}++;next if$skip;push @$extra,$_}}if (-f $extopt){open my$opt,'<',$extopt or die $!;while (<$opt>){next unless /(?:UNIVERSAL|VECTOR)=boot_([\w_]+)/;my$pkg=$1;$pkg =~ s#__*#::#g;push@staticpkgs,$pkg}}}push@optlibs,@$extra;$target="Perl$Config{'exe_ext'}" unless$target;my$shrtarget;($shrtarget,$targdir)=fileparse($target);$shrtarget =~ s/^([^.]*)/$1Shr/;$shrtarget=$targdir .$shrtarget;$target="Perlshr.$Config{'dlext'}" unless$target;$tmpdir="[]" unless$tmpdir;$tmpdir=$self->fixpath($tmpdir,1);if (@optlibs){$extralist=join(' ',@optlibs)}else {$extralist=''}push@optlibs,grep {!/PerlShr/i}split ' ',+($self->ext())[2];if ($libperl){unless (-f $libperl || -f ($libperl=$self->catfile($Config{'installarchlib'},'CORE',$libperl))){print "Warning: $libperl not found\n";undef$libperl}}unless ($libperl){if (defined$self->{PERL_SRC}){$libperl=$self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}")}elsif (-f ($libperl=$self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}"))){}else {print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n"}}$libperldir=$self->fixpath((fileparse($libperl))[1],1);push@m,'
  # Fill in the target you want to produce if it\'s not perl
  MAP_TARGET    = ',$self->fixpath($target,0),'
  MAP_SHRTARGET = ',$self->fixpath($shrtarget,0),"
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = ",$perlinc ? map('"$_" ',@{$perlinc}): '',"
  MAP_EXTRA     = $extralist
  MAP_LIBPERL = ",$self->fixpath($libperl,0),'
  ';push@m,"\n${tmpdir}Makeaperl.Opt : \$(MAP_EXTRA)\n";for (@optlibs){push@m,'	$(NOECHO) $(PERL) -e "print q{',$_,'}" >>$(MMS$TARGET)',"\n"}push@m,"\n${tmpdir}PerlShr.Opt :\n\t";push@m,'$(NOECHO) $(PERL) -e "print q{$(MAP_SHRTARGET)}" >$(MMS$TARGET)',"\n";push@m,'
  $(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',"${libperldir}Perlshr_Attr.Opt",'
  	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',"${libperldir}Perlshr_Attr.Opt/Option",'
  $(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}PerlShr.Opt",'
  	$(MAP_LINKCMD) ',"${tmpdir}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
  	$(NOECHO) $(ECHO) "To install the new ""$(MAP_TARGET)"" binary, say"
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
  	$(NOECHO) $(ECHO) "To remove the intermediate files, say
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
  ';push@m,"\n${tmpdir}perlmain.c : \$(FIRST_MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmpdir}Writemain.tmp\n";push@m,"# More from the 255-char line length limit\n";for (@staticpkgs){push@m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmpdir}Writemain.tmp\n]}push@m,sprintf <<'MAKE_FRAG',$tmpdir,$tmpdir;push@m,q[
  	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@F)" %sWritemain.tmp >$(MMS$TARGET)
  	$(NOECHO) $(RM_F) %sWritemain.tmp
  MAKE_FRAG
  # Still more from the 255-char line length limit
  doc_inst_perl :
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO) "Perl binary $(MAP_TARGET)|" >.MM_tmp
  	$(NOECHO) $(ECHO) "MAP_STATIC|$(MAP_STATIC)|" >>.MM_tmp
  	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
  	$(NOECHO) $(ECHO) -e "MAP_LIBPERL|$(MAP_LIBPERL)|" >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  ];push@m,"
  inst_perl : pure_inst_perl doc_inst_perl
  	\$(NOECHO) \$(NOOP)
  
  pure_inst_perl : \$(MAP_TARGET)
  	$self->{CP} \$(MAP_SHRTARGET) ",$self->fixpath($Config{'installbin'},1),"
  	$self->{CP} \$(MAP_TARGET) ",$self->fixpath($Config{'installbin'},1),"
  
  clean :: map_clean
  	\$(NOECHO) \$(NOOP)
  
  map_clean :
  	\$(RM_F) ${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}perlmain.c \$(FIRST_MAKEFILE)
  	\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \$(MAP_TARGET)
  ";join '',@m}sub maketext_filter {my($self,$text)=@_;$text =~ s/^([^\s:=]+)(:+\s)/$1 $2/mg;return$text}sub prefixify {my($self,$var,$sprefix,$rprefix,$default)=@_;$rprefix=$self->eliminate_macros($rprefix);$rprefix=vmspath($rprefix)if$rprefix;$sprefix=vmspath($sprefix)if$sprefix;$default=vmsify($default)unless$default =~ /\[.*\]/;(my$var_no_install=$var)=~ s/^install//;my$path=$self->{uc$var}|| $ExtUtils::MM_Unix::Config_Override{lc$var}|| $Config{lc$var}|| $Config{lc$var_no_install};if(!$path){warn "  no Config found for $var.\n" if$Verbose >= 2;$path=$self->_prefixify_default($rprefix,$default)}elsif(!$self->{ARGS}{PREFIX}||!$self->file_name_is_absolute($path)){}elsif($sprefix eq $rprefix){warn "  no new prefix.\n" if$Verbose >= 2}else {warn "  prefixify $var => $path\n" if$Verbose >= 2;warn "    from $sprefix to $rprefix\n" if$Verbose >= 2;my($path_vol,$path_dirs)=$self->splitpath($path);if($path_vol eq $Config{vms_prefix}.':'){warn "  $Config{vms_prefix}: seen\n" if$Verbose >= 2;$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$path=$self->_prefixify_default($rprefix,$default)}}print "    now $path\n" if$Verbose >= 2;return$self->{uc$var}=$path}sub _prefixify_default {my($self,$rprefix,$default)=@_;warn "  cannot prefix, using default.\n" if$Verbose >= 2;if(!$default){warn "No default!\n" if$Verbose >= 1;return}if(!$rprefix){warn "No replacement prefix!\n" if$Verbose >= 1;return ''}return$self->_catprefix($rprefix,$default)}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=$self->splitpath($rprefix);if($rvol){return$self->catpath($rvol,$self->catdir($rdirs,$default),'')}else {return$self->catdir($rdirs,$default)}}sub cd {my($self,$dir,@cmds)=@_;$dir=vmspath($dir);my$cmd=join "\n\t",map "$_",@cmds;my$make_frag=sprintf <<'MAKE_FRAG',$dir,$cmd;chomp$make_frag;return$make_frag}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my@cmds=split /\n/,$cmd;$cmd=join " \n\t  -e ",map$self->quote_literal($_),@cmds;$cmd=$self->escape_newlines($cmd);$switches=join ' ',map {qq{"$_"}}@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd "--"}}sub echo {my($self,$text,$file,$opts)=@_;if(!ref$opts){my$append=$opts;$opts={append=>$append || 0 }}my$opencmd=$opts->{append}? 'Open/Append' : 'Open/Write';$opts->{allow_variables}=0 unless defined$opts->{allow_variables};my$ql_opts={allow_variables=>$opts->{allow_variables}};my@cmds=("\$(NOECHO) $opencmd MMECHOFILE $file ");push@cmds,map {'$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_,$ql_opts)}split /\n/,$text;push@cmds,'$(NOECHO) Close MMECHOFILE';return@cmds}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{"}{""}g;$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return qq{"$text"}}sub escape_dollarsigns {my($self,$text)=@_;$text =~ s{\$ (?!\() }{"\$"}gx;return$text}sub escape_all_dollarsigns {my($self,$text)=@_;$text =~ s{\$}{"\$\"}gx;return$text}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{-\n}g;return$text}sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 256}sub init_linker {my$self=shift;$self->{EXPORT_LIST}||= '$(BASEEXT).opt';my$shr=$Config{dbgprefix}.'PERLSHR';if ($self->{PERL_SRC}){$self->{PERL_ARCHIVE}||= $self->catfile($self->{PERL_SRC},"$shr.$Config{'dlext'}")}else {$self->{PERL_ARCHIVE}||= $ENV{$shr}? $ENV{$shr}: "Sys\$Share:$shr.$Config{'dlext'}"}$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}||= ''}sub catdir {my$self=shift;my@args=map {m{\$\(} ? $self->eliminate_macros($_): $_}@_;my$dir=$self->SUPER::catdir(@args);$dir=$self->fixpath($dir,1);return$dir}sub catfile {my$self=shift;my@args=map {m{\$\(} ? $self->eliminate_macros($_): $_}@_;my$file=$self->SUPER::catfile(@args);$file=vmsify($file);return$file}sub eliminate_macros {my($self,$path)=@_;return '' unless$path;$self={}unless ref$self;my($npath)=unixify($path);$npath =~ s{\0$}{};my($complex)=0;my($head,$macro,$tail);while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs){if (defined$self->{$2}){($head,$macro,$tail)=($1,$2,$3);if (ref$self->{$macro}){if (ref$self->{$macro}eq 'ARRAY'){$macro=join ' ',@{$self->{$macro}}}else {print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),"\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";$macro="\cB$macro\cB";$complex=1}}else {$macro=$self->{$macro};$macro=unixify($macro)unless ($macro =~ /(?<!\^)\s/);$macro =~ s#/\Z(?!\n)##}$npath="$head$macro$tail"}}if ($complex){$npath =~ s#\cB(.*?)\cB#\${$1}#gs}$npath}sub fixpath {my($self,$path,$force_path)=@_;return '' unless$path;$self=bless {},$self unless ref$self;my($fixedpath,$prefix,$name);if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#){if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/){$fixedpath=vmspath($self->eliminate_macros($path))}else {$fixedpath=vmsify($self->eliminate_macros($path))}}elsif ((($prefix,$name)=($path =~ m#^\$\(([^\)]+)\)(.+)#s))&& $self->{$prefix}){my($vmspre)=$self->eliminate_macros("\$($prefix)");$vmspre=($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/)? vmspath($vmspre): '';$fixedpath=($vmspre ? $vmspre : $self->{$prefix}).$name;$fixedpath=vmspath($fixedpath)if$force_path}else {$fixedpath=$path;$fixedpath=vmspath($fixedpath)if$force_path}if (!defined($force_path)and $fixedpath !~ /[:>(.\]]/){$fixedpath=vmspath($fixedpath)if -d $fixedpath}$fixedpath =~ s/\.000000([\]>])/$1/;if ($path =~ /^[\[>][^.\-]/){$fixedpath =~ s/^[^\[<]+//}return$fixedpath}sub os_flavor {return('VMS')}sub is_make_type {my($self,$type)=@_;return 0}sub make_type {"$Config{make}-style"}1;
  startdir = F$Environment("Default")
  	Set Default %s
  	%s
  	Set Default 'startdir'
  MAKE_FRAG
EXTUTILS_MM_VMS

$fatpacked{"ExtUtils/MM_VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VOS';
  package ExtUtils::MM_VOS;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub extra_clean_files {return qw(*.kp)}1;
EXTUTILS_MM_VOS

$fatpacked{"ExtUtils/MM_Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN32';
  package ExtUtils::MM_Win32;use strict;use warnings;use ExtUtils::MakeMaker::Config;use File::Basename;use File::Spec;use ExtUtils::MakeMaker qw(neatvalue _sprintf562);require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);our$VERSION='7.60';$VERSION =~ tr/_//d;$ENV{EMXSHELL}='sh';my ($BORLAND,$GCC,$MSVC)=_identify_compiler_environment(\%Config);sub _identify_compiler_environment {my ($config)=@_;my$BORLAND=$config->{cc}=~ /\bbcc/i ? 1 : 0;my$GCC=$config->{cc}=~ /\bgcc\b/i ? 1 : 0;my$MSVC=$config->{cc}=~ /\b(?:cl|icl)/i ? 1 : 0;return ($BORLAND,$GCC,$MSVC)}sub dlsyms {my($self,%attribs)=@_;return '' if$self->{SKIPHASH}{'dynamic'};$self->xs_dlsyms_iterator(\%attribs)}sub xs_dlsyms_ext {'.def'}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,[/\\]+,.,g;$man}sub maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}=$self->is_make_type('nmake')? '^\\' : $self->is_make_type('dmake')? '\\\\' : $self->is_make_type('gmake')? '/' : '\\'}sub init_tools {my ($self)=@_;$self->{NOOP}||= 'rem';$self->{DEV_NULL}||= '> NUL';$self->{FIXIN}||= $self->{PERL_CORE}? "\$(PERLRUN) -I$self->{PERL_SRC}\\cpan\\ExtUtils-PL2Bat\\lib $self->{PERL_SRC}\\win32\\bin\\pl2bat.pl" : 'pl2bat.bat';$self->SUPER::init_tools;delete$self->{SHELL};return}sub init_others {my$self=shift;$self->{LD}||= 'link';$self->{AR}||= 'lib';$self->SUPER::init_others;$self->{LDLOADLIBS}||= $Config{libs};if ($BORLAND){my$libs=$self->{LDLOADLIBS};my$libpath='';while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /){$libpath .= ' ' if length$libpath;$libpath .= $1}$self->{LDLOADLIBS}=$libs;$self->{LDDLFLAGS}||= $Config{lddlflags};$self->{LDDLFLAGS}.= " $libpath"}return}sub init_platform {my($self)=shift;$self->{MM_Win32_VERSION}=$VERSION;return}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(MM_Win32_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub specify_shell {my$self=shift;return '' unless$self->is_make_type('gmake');"\nSHELL = $ENV{COMSPEC}\n"}sub constants {my$self=shift;my$make_text=$self->SUPER::constants;return$make_text unless$self->is_make_type('dmake');my$size=$self->{MAXLINELENGTH}|| 800000;my$prefix=qq{
  # Get dmake to read long commands like PM_TO_BLIB
  MAXLINELENGTH = $size
  
  };return$prefix .$make_text}sub special_targets {my($self)=@_;my$make_frag=$self->SUPER::special_targets;$make_frag .= <<'MAKE_FRAG' if$self->is_make_type('dmake');return$make_frag}sub static_lib_pure_cmd {my ($self,$from)=@_;$from =~ s/(\$\(\w+)(\))/$1:^"+"$2/g if$BORLAND;sprintf qq{\t\$(AR) %s\n},($BORLAND ? '$@ ' .$from : ($GCC ? '-ru $@ ' .$from : '-out:$@ ' .$from))}sub xs_make_dynamic_lib {my ($self,$attribs,$from,$to,$todir,$ldfrom,$exportlist)=@_;my@m=sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(INST_DYNAMIC_DEP)'."\n",$to,$from,$todir,$exportlist;if ($GCC){push@m,_sprintf562 <<'EOF',$exportlist,$ldfrom}elsif ($BORLAND){my$ldargs=$self->is_make_type('dmake')? q{"$(PERL_ARCHIVE:s,/,\,)" $(LDLOADLIBS:s,/,\,) $(MYEXTLIB:s,/,\,),} : q{"$(subst /,\,$(PERL_ARCHIVE))" $(subst /,\,$(LDLOADLIBS)) $(subst /,\,$(MYEXTLIB)),};my$subbed;if ($exportlist eq '$(EXPORT_LIST)'){$subbed=$self->is_make_type('dmake')? q{$(EXPORT_LIST:s,/,\,)} : q{$(subst /,\,$(EXPORT_LIST))}}else {($subbed=$exportlist)=~ s#/#\\#g}push@m,sprintf <<'EOF',$ldfrom,$ldargs .$subbed}else {push@m,sprintf <<'EOF',$ldfrom,$exportlist;push(@m,q{	if exist $@.manifest mt -nologo -manifest $@.manifest -outputresource:$@;2
  .USESHELL :
  MAKE_FRAG
  	$(LD) %1$s -o $@ $(LDDLFLAGS) %2$s $(OTHERLDFLAGS) $(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) -Wl,--enable-auto-image-base
  EOF
          $(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) %s,$@,,%s,$(RESFILES)
  EOF
  	$(LD) -out:$@ $(LDDLFLAGS) %s $(OTHERLDFLAGS) $(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) -def:%s
  EOF
  	if exist $@.manifest del $@.manifest})}push@m,"\n\t\$(CHMOD) \$(PERM_RWX) \$\@\n";join '',@m}sub xs_dynamic_lib_macros {my ($self,$attribs)=@_;my$otherldflags=$attribs->{OTHERLDFLAGS}|| ($BORLAND ? 'c0d32.obj': '');my$inst_dynamic_dep=$attribs->{INST_DYNAMIC_DEP}|| "";sprintf <<'EOF',$otherldflags,$inst_dynamic_dep}sub extra_clean_files {my$self=shift;return$GCC ? (qw(dll.base dll.exp)): ('*.pdb')}sub init_linker {my$self=shift;$self->{PERL_ARCHIVE}="\$(PERL_INC)\\$Config{libperl}";$self->{PERL_ARCHIVEDEP}="\$(PERL_INCDEP)\\$Config{libperl}";$self->{PERL_ARCHIVE_AFTER}='';$self->{EXPORT_LIST}='$(BASEEXT).def'}sub perl_script {my($self,$file)=@_;return$file if -r $file && -f _;return "$file.pl" if -r "$file.pl" && -f _;return "$file.plx" if -r "$file.plx" && -f _;return "$file.bat" if -r "$file.bat" && -f _;return}sub can_dep_space {my ($self)=@_;return 0 unless$self->can_load_xs;require Win32;require File::Spec;my ($vol,$dir)=File::Spec->splitpath($INC{'ExtUtils/MakeMaker.pm'});my$canary=Win32::GetShortPathName(File::Spec->catpath($vol,$dir,'MakeMaker.pm'));(undef,undef,my$file)=File::Spec->splitpath($canary);return (length$file > 11)? 0 : 1}sub quote_dep {my ($self,$arg)=@_;if ($arg =~ / / and not $self->is_make_type('gmake')){require Win32;$arg=Win32::GetShortPathName($arg);die <<EOF if not defined$arg or $arg =~ / /;return$arg}return$self->SUPER::quote_dep($arg)}sub xs_obj_opt {my ($self,$output_file)=@_;($MSVC ? "/Fo" : "-o ").$output_file}sub pasthru {my($self)=shift;my$old=$self->SUPER::pasthru;return$old unless$self->is_make_type('nmake');$old =~ s/(PASTHRU\s*=\s*)/$1 -nologo /;$old}sub arch_check {my$self=shift;return 1 unless$self->can_load_xs;return$self->SUPER::arch_check(map {$self->_normalize_path_name($_)}@_)}sub _normalize_path_name {my$self=shift;my$file=shift;require Win32;my$short=Win32::GetShortPathName($file);return defined$short ? lc$short : lc$file}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};$cmd=$self->quote_literal($cmd);$cmd=$self->escape_newlines($cmd);$switches=join ' ',@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd --}}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{\\\\"}{\\\\\\\\\\"}g;$text =~ s{(?<!\\)\\"}{\\\\\\"}g;$text =~ s{(?<!\\)"}{\\"}g;$text=qq{"$text"} if$text =~ /[ \t#]/;my@text=split /("[^"]*")/,$text;s{([<>|&^@!])}{^$1}g foreach grep {!/^"[^"]*"$/}@text;$text=join('',@text);if($self->is_make_type('dmake')){$text =~ s/{/{{/g;$text =~ s/}/}}/g}$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return$text}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{\\\n}g;return$text}sub cd {my($self,$dir,@cmds)=@_;return$self->SUPER::cd($dir,@cmds)unless$self->is_make_type('nmake');my$cmd=join "\n\t",map "$_",@cmds;my$updirs=$self->catdir(map {$self->updir}$self->splitdir($dir));my$make_frag=sprintf <<'MAKE_FRAG',$dir,$cmd,$updirs;chomp$make_frag;return$make_frag}sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 2 * 1024}sub os_flavor {return('Win32')}sub dbgoutflag {$MSVC ? '-Fd$(*).pdb' : ''}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my$base=$self->SUPER::cflags($libperl);for (split /\n/,$base){/^(\S*)\s*=\s*(\S*)$/ and $self->{$1}=$2};$self->{CCFLAGS}.= " -DPERLDLL" if ($self->{LINKTYPE}eq 'static');return$self->{CFLAGS}=qq{
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  EOF
  Tried to use make dependency with space for non-GNU make:
    '$arg'
  Fallback to short pathname failed.
  EOF
  cd %s
  	%s
  	cd %s
  MAKE_FRAG
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub make_type {my ($self)=@_;my$make=$self->make;$make=+(File::Spec->splitpath($make))[-1];$make =~ s!\.exe$!!i;if ($make =~ m![^A-Z0-9]!i){($make)=grep {m!make!i}split m![^A-Z0-9]!i,$make}return "$make-style"}1;
EXTUTILS_MM_WIN32

$fatpacked{"ExtUtils/MM_Win95.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN95';
  package ExtUtils::MM_Win95;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Win32);use ExtUtils::MakeMaker::Config;sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 1024}sub os_flavor {my$self=shift;return ($self->SUPER::os_flavor,'Win9x')}1;
EXTUTILS_MM_WIN95

$fatpacked{"ExtUtils/MY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MY';
  package ExtUtils::MY;use strict;require ExtUtils::MM;our$VERSION='7.60';$VERSION =~ tr/_//d;our@ISA=qw(ExtUtils::MM);{package MY;our@ISA=qw(ExtUtils::MY)}sub DESTROY {}
EXTUTILS_MY

$fatpacked{"ExtUtils/MakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER';
  package ExtUtils::MakeMaker;use strict;use warnings;BEGIN {require 5.006}require Exporter;use ExtUtils::MakeMaker::Config;use ExtUtils::MakeMaker::version;use Carp;use File::Path;my$CAN_DECODE=eval {require ExtUtils::MakeMaker::Locale};eval {ExtUtils::MakeMaker::Locale::reinit('UTF-8')}if$CAN_DECODE and Encode::find_encoding('locale')->name eq 'ascii';our$Verbose=0;our@Parent;our@Get_from_Config;our@MM_Sections;our@Overridable;my@Prepend_parent;my%Recognized_Att_Keys;our%macro_fsentity;our%macro_dep;our$VERSION='7.60';$VERSION =~ tr/_//d;(our$Revision=$VERSION)=~ s{_}{};$Revision=int$Revision * 10000;our$Filename=__FILE__;our@ISA=qw(Exporter);our@EXPORT=qw(&WriteMakefile $Verbose &prompt &os_unsupported);our@EXPORT_OK=qw($VERSION &neatvalue &mkbootstrap &mksymlists &WriteEmptyMakefile &open_for_writing &write_file_via_tmp &_sprintf562);my$Is_VMS=$^O eq 'VMS';my$Is_Win32=$^O eq 'MSWin32';our$UNDER_CORE=$ENV{PERL_CORE};full_setup();require ExtUtils::MM;require ExtUtils::MY;sub _sprintf562 {my ($format,@args)=@_;for (my$i=1;$i <= @args;$i++){$format =~ s#%$i\$s#$args[$i-1]#g}$format}sub WriteMakefile {croak "WriteMakefile: Need even number of args" if @_ % 2;require ExtUtils::MY;my%att=@_;_convert_compat_attrs(\%att);_verify_att(\%att);my$mm=MM->new(\%att);$mm->flush;return$mm}my%Att_Sigs;my%Special_Sigs=(AUTHOR=>'ARRAY',C=>'ARRAY',CONFIG=>'ARRAY',CONFIGURE=>'CODE',DIR=>'ARRAY',DL_FUNCS=>'HASH',DL_VARS=>'ARRAY',EXCLUDE_EXT=>'ARRAY',EXE_FILES=>'ARRAY',FUNCLIST=>'ARRAY',H=>'ARRAY',IMPORTS=>'HASH',INCLUDE_EXT=>'ARRAY',LIBS=>['ARRAY',''],MAN1PODS=>'HASH',MAN3PODS=>'HASH',META_ADD=>'HASH',META_MERGE=>'HASH',OBJECT=>['ARRAY',''],PL_FILES=>'HASH',PM=>'HASH',PMLIBDIRS=>'ARRAY',PMLIBPARENTDIRS=>'ARRAY',PREREQ_PM=>'HASH',BUILD_REQUIRES=>'HASH',CONFIGURE_REQUIRES=>'HASH',TEST_REQUIRES=>'HASH',SKIP=>'ARRAY',TYPEMAPS=>'ARRAY',XS=>'HASH',XSBUILD=>'HASH',VERSION=>['version',''],_KEEP_AFTER_FLUSH=>'',clean=>'HASH',depend=>'HASH',dist=>'HASH',dynamic_lib=>'HASH',linkext=>'HASH',macro=>'HASH',postamble=>'HASH',realclean=>'HASH',test=>'HASH',tool_autosplit=>'HASH',);@Att_Sigs{keys%Recognized_Att_Keys}=('')x keys%Recognized_Att_Keys;@Att_Sigs{keys%Special_Sigs}=values%Special_Sigs;sub _convert_compat_attrs {my($att)=@_;if (exists$att->{AUTHOR}){if ($att->{AUTHOR}){if (!ref($att->{AUTHOR})){my$t=$att->{AUTHOR};$att->{AUTHOR}=[$t]}}else {$att->{AUTHOR}=[]}}}sub _verify_att {my($att)=@_;for my$key (sort keys %$att){my$val=$att->{$key};my$sig=$Att_Sigs{$key};unless(defined$sig){warn "WARNING: $key is not a known parameter.\n";next}my@sigs=ref$sig ? @$sig : $sig;my$given=ref$val;unless(grep {_is_of_type($val,$_)}@sigs){my$takes=join " or ",map {_format_att($_)}@sigs;my$has=_format_att($given);warn "WARNING: $key takes a $takes not a $has.\n"."         Please inform the author.\n"}}}sub _is_of_type {my($thing,$type)=@_;return 1 if ref$thing eq $type;local$SIG{__DIE__};return 1 if eval{$thing->isa($type)};return 0}sub _format_att {my$given=shift;return$given eq '' ? "string/number" : uc$given eq $given ? "$given reference" : "$given object" }sub prompt ($;$) {my($mess,$def)=@_;confess("prompt function called without an argument")unless defined$mess;my$isa_tty=-t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT));my$dispdef=defined$def ? "[$def] " : " ";$def=defined$def ? $def : "";local $|=1;local $\;print "$mess $dispdef";my$ans;if ($ENV{PERL_MM_USE_DEFAULT}|| (!$isa_tty && eof STDIN)){print "$def\n"}else {$ans=<STDIN>;if(defined$ans){$ans =~ s{\015?\012$}{}}else {print "\n"}}return (!defined$ans || $ans eq '')? $def : $ans}sub os_unsupported {die "OS unsupported\n"}sub eval_in_subdirs {my($self)=@_;use Cwd qw(cwd abs_path);my$pwd=cwd()|| die "Can't figure out your cwd!";local@INC=map eval {abs_path($_)if -e}|| $_,@INC;push@INC,'.';for my$dir (@{$self->{DIR}}){my($abs)=$self->catdir($pwd,$dir);eval {$self->eval_in_x($abs)};last if $@}chdir$pwd;die $@ if $@}sub eval_in_x {my($self,$dir)=@_;chdir$dir or carp("Couldn't change to directory $dir: $!");{package main;do './Makefile.PL'};if ($@){die "ERROR from evaluation of $dir/Makefile.PL: $@"}}my$PACKNAME='PACK000';sub full_setup {$Verbose ||= 0;my@dep_macros=qw/PERL_INCDEP PERL_ARCHLIBDEP PERL_ARCHIVEDEP/;my@fs_macros=qw/FULLPERL XSUBPPDIR INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR INSTALLDIRS DESTDIR PREFIX INSTALL_BASE PERLPREFIX SITEPREFIX VENDORPREFIX INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN1DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN1DIR INSTALLVENDORMAN3DIR INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT PERL_LIB PERL_ARCHLIB SITELIBEXP SITEARCHEXP MAKE LIBPERL_A LIB PERL_SRC PERL_INC PPM_INSTALL_EXEC PPM_UNINSTALL_EXEC PPM_INSTALL_SCRIPT PPM_UNINSTALL_SCRIPT/;my@attrib_help=qw/AUTHOR ABSTRACT ABSTRACT_FROM BINARY_LOCATION C CAPI CCFLAGS CONFIG CONFIGURE DEFINE DIR DISTNAME DISTVNAME DL_FUNCS DL_VARS EXCLUDE_EXT EXE_FILES FIRST_MAKEFILE FULLPERLRUN FULLPERLRUNINST FUNCLIST H IMPORTS INC INCLUDE_EXT LDFROM LIBS LICENSE LINKTYPE MAKEAPERL MAKEFILE MAKEFILE_OLD MAN1PODS MAN3PODS MAP_TARGET META_ADD META_MERGE MIN_PERL_VERSION BUILD_REQUIRES CONFIGURE_REQUIRES MYEXTLIB NAME NEEDS_LINKING NOECHO NO_META NO_MYMETA NO_PACKLIST NO_PERLLOCAL NORECURS NO_VC OBJECT OPTIMIZE PERL_MALLOC_OK PERL PERLMAINCC PERLRUN PERLRUNINST PERL_CORE PERM_DIR PERM_RW PERM_RWX MAGICXS PL_FILES PM PM_FILTER PMLIBDIRS PMLIBPARENTDIRS POLLUTE PREREQ_FATAL PREREQ_PM PREREQ_PRINT PRINT_PREREQ PUREPERL_ONLY SIGN SKIP TEST_REQUIRES TYPEMAPS UNINST VERSION VERSION_FROM XS XSBUILD XSMULTI XSOPT XSPROTOARG XS_VERSION clean depend dist dynamic_lib linkext macro realclean tool_autosplit MAN1EXT MAN3EXT MACPERL_SRC MACPERL_LIB MACLIBS_68K MACLIBS_PPC MACLIBS_SC MACLIBS_MRC MACLIBS_ALL_68K MACLIBS_ALL_PPC MACLIBS_SHARED/;push@attrib_help,@fs_macros;@macro_fsentity{@fs_macros,@dep_macros}=(1)x (@fs_macros+@dep_macros);@macro_dep{@dep_macros}=(1)x @dep_macros;@MM_Sections=qw(post_initialize const_config constants platform_constants tool_autosplit tool_xsubpp tools_other makemakerdflt dist macro depend cflags const_loadlibs const_cccmd post_constants pasthru special_targets c_o xs_c xs_o top_targets blibdirs linkext dlsyms dynamic_bs dynamic dynamic_lib static static_lib manifypods processPL installbin subdirs clean_subdirs clean realclean_subdirs realclean metafile signature dist_basics dist_core distdir dist_test dist_ci distmeta distsignature install force perldepend makefile staticmake test ppd);@Overridable=@MM_Sections;push@Overridable,qw[libscan makeaperl needs_linking subdir_x test_via_harness test_via_script init_VERSION init_dist init_INST init_INSTALL init_DEST init_dirscan init_PM init_MANPODS init_xs init_PERL init_DIRFILESEP init_linker];push@MM_Sections,qw[pm_to_blib selfdocument];push@MM_Sections,"postamble";push@Overridable,"postamble";@Recognized_Att_Keys{@MM_Sections}=(1)x @MM_Sections;@Get_from_Config=qw(ar cc cccdlflags ccdlflags dlext dlsrc exe_ext full_ar ld lddlflags ldflags libc lib_ext obj_ext osname osvers ranlib sitelibexp sitearchexp so);push@Get_from_Config,qw(vendorarchexp vendorlibexp) if "$]" >= 5.006;for my$item (@attrib_help){$Recognized_Att_Keys{$item}=1}for my$item (@Get_from_Config){$Recognized_Att_Keys{uc$item}=$Config{$item};print "Attribute '\U$item\E' => '$Config{$item}'\n" if ($Verbose >= 2)}@Prepend_parent=qw(INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT MAP_TARGET INST_MAN1DIR INST_MAN3DIR PERL_SRC PERL FULLPERL)}sub _has_cpan_meta_requirements {return eval {require CPAN::Meta::Requirements;CPAN::Meta::Requirements->VERSION(2.130);CPAN::Meta::Requirements->new->add_string_requirement('Module'=>v1.2);1}}sub new {my($class,$self)=@_;my($key);_convert_compat_attrs($self)if defined$self && $self;for my$k (keys %$self){$self->{ARGS}{$k}=$self->{$k}}$self={}unless defined$self;bless$self,"MM";my%key2cmr;for my$key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)){$self->{$key}||= {};if (_has_cpan_meta_requirements){my$cmr=CPAN::Meta::Requirements->from_string_hash($self->{$key},{bad_version_hook=>sub {my$fallback;if ($_[0]=~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$!){$fallback=sprintf "%f",$_[0]}else {($fallback)=$_[0]? ($_[0]=~ /^([0-9.]+)/): 0;$fallback += 0;carp "Unparsable version '$_[0]' for prerequisite $_[1] treated as $fallback"}version->new($fallback)},},);$self->{$key}=$cmr->as_string_hash;$key2cmr{$key}=$cmr}else {for my$module (sort keys %{$self->{$key}}){my$version=$self->{$key}->{$module};my$fallback=0;if (!defined($version)or!length($version)){carp "Undefined requirement for $module treated as '0' (CPAN::Meta::Requirements not available)"}elsif ($version =~ /^\d+(?:\.\d+(?:_\d+)*)?$/){next}else {if ($version =~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$!){$fallback=sprintf "%f",$version}else {($fallback)=$version ? ($version =~ /^([0-9.]+)/): 0;$fallback += 0;carp "Unparsable version '$version' for prerequisite $module treated as $fallback (CPAN::Meta::Requirements not available)"}}$self->{$key}->{$module}=$fallback}}}if ("@ARGV" =~ /\bPREREQ_PRINT\b/){$self->_PREREQ_PRINT}if ("@ARGV" =~ /\bPRINT_PREREQ\b/){$self->_PRINT_PREREQ}print "MakeMaker (v$VERSION)\n" if$Verbose;if (-f "MANIFEST" &&!-f "Makefile" &&!$UNDER_CORE){check_manifest()}check_hints($self);if ($self->{MIN_PERL_VERSION}){my$perl_version=$self->{MIN_PERL_VERSION};if (ref$perl_version){}else {$perl_version=eval {local$SIG{__WARN__}=sub {die @_};version->new($perl_version)->numify};$perl_version =~ tr/_//d if defined$perl_version}if (!defined$perl_version){die sprintf <<'END',$self->{MIN_PERL_VERSION}}elsif ($perl_version > "$]"){my$message=sprintf <<'END',$perl_version,$];if ($self->{PREREQ_FATAL}){die "MakeMaker FATAL: $message"}else {warn "Warning: $message"}}$self->{MIN_PERL_VERSION}=$perl_version}my%configure_att;my(%initial_att)=%$self;my(%unsatisfied)=();my%prereq2version;my$cmr;if (_has_cpan_meta_requirements){$cmr=CPAN::Meta::Requirements->new;for my$key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)){$cmr->add_requirements($key2cmr{$key})if$key2cmr{$key}}for my$prereq ($cmr->required_modules){$prereq2version{$prereq}=$cmr->requirements_for_module($prereq)}}else {for my$key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)){next unless my$module2version=$self->{$key};$prereq2version{$_}=$module2version->{$_}for keys %$module2version}}for my$prereq (sort keys%prereq2version){my$required_version=$prereq2version{$prereq};my$pr_version=0;my$installed_file;if ($prereq eq 'perl'){if (defined$required_version && $required_version =~ /^v?[\d_\.]+$/ || $required_version !~ /^v?[\d_\.]+$/){require version;my$normal=eval {version->new($required_version)};$required_version=$normal if defined$normal}$installed_file=$prereq;$pr_version=$]}else {$installed_file=MM->_installed_file_for_module($prereq);$pr_version=MM->parse_version($installed_file)if$installed_file;$pr_version=0 if$pr_version eq 'undef';if (!eval {version->new($pr_version);1}){my$fallback;if ($pr_version =~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$!){$fallback=sprintf '%f',$pr_version}else {($fallback)=$pr_version ? ($pr_version =~ /^([0-9.]+)/): 0;$fallback += 0;carp "Unparsable version '$pr_version' for installed prerequisite $prereq treated as $fallback"}$pr_version=$fallback}}$pr_version =~ s/(\d+)\.(\d+)_(\d+)/$1.$2$3/;if (!$installed_file){warn sprintf "Warning: prerequisite %s %s not found.\n",$prereq,$required_version unless$self->{PREREQ_FATAL}or $UNDER_CORE;$unsatisfied{$prereq}='not installed'}elsif ($cmr ?!$cmr->accepts_module($prereq,$pr_version): $required_version > $pr_version){warn sprintf "Warning: prerequisite %s %s not found. We have %s.\n",$prereq,$required_version,($pr_version || 'unknown version')unless$self->{PREREQ_FATAL}or $UNDER_CORE;$unsatisfied{$prereq}=$required_version || 'unknown version' }}if (%unsatisfied && $self->{PREREQ_FATAL}){my$failedprereqs=join "\n",map {"    $_ $unsatisfied{$_}"}sort {$a cmp $b}keys%unsatisfied;die <<"END"}if (defined$self->{CONFIGURE}){if (ref$self->{CONFIGURE}eq 'CODE'){%configure_att=%{&{$self->{CONFIGURE}}};_convert_compat_attrs(\%configure_att);$self={%$self,%configure_att }}else {croak "Attribute 'CONFIGURE' to WriteMakefile() not a code reference\n"}}my$newclass=++$PACKNAME;local@Parent=@Parent;{print "Blessing Object into class [$newclass]\n" if$Verbose>=2;mv_all_methods("MY",$newclass);bless$self,$newclass;push@Parent,$self;require ExtUtils::MY;no strict 'refs';@{"$newclass\:\:ISA"}='MM'}if (defined$Parent[-2]){$self->{PARENT}=$Parent[-2];for my$key (@Prepend_parent){next unless defined$self->{PARENT}{$key};next if defined$self->{ARGS}{$key}and $self->{ARGS}{$key}eq $self->{$key};$self->{$key}=$self->{PARENT}{$key};if ($Is_VMS && $key =~ /PERL$/){my@cmd=split /\s+/,$self->{$key};$cmd[1]=$self->catfile('[-]',$cmd[1])unless (@cmd < 2)|| $self->file_name_is_absolute($cmd[1]);$self->{$key}=join(' ',@cmd)}else {my$value=$self->{$key};$value =~ s/"// if$key =~ /PERL$/ and $self->is_make_type('dmake');$value =~ s/^"// if$key =~ /PERL$/;$value=$self->catdir("..",$value)unless$self->file_name_is_absolute($value);$value=qq{"$value} if$key =~ /PERL$/;$self->{$key}=$value}}if ($self->{PARENT}){$self->{PARENT}->{CHILDREN}->{$newclass}=$self;for my$opt (qw(POLLUTE PERL_CORE LINKTYPE AR FULL_AR CC CCFLAGS OPTIMIZE LD LDDLFLAGS LDFLAGS PERL_ARCHLIB DESTDIR)){if (exists$self->{PARENT}->{$opt}and not exists$self->{$opt}){$self->{$opt}=$self->{PARENT}->{$opt}}}}my@fm=grep /^FIRST_MAKEFILE=/,@ARGV;parse_args($self,@fm)if@fm}else {parse_args($self,_shellwords($ENV{PERL_MM_OPT}|| ''),@ARGV)}if (%unsatisfied && $self->{PREREQ_FATAL}){my$failedprereqs=join "\n",map {"    $_ $unsatisfied{$_}"}sort {$a cmp $b}keys%unsatisfied;die <<"END"}$self->{NAME}||= $self->guess_name;warn "Warning: NAME must be a package name\n" unless$self->{NAME}=~ m!^[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*$!;($self->{NAME_SYM}=$self->{NAME})=~ s/\W+/_/g;$self->init_MAKE;$self->init_main;$self->init_VERSION;$self->init_dist;$self->init_INST;$self->init_INSTALL;$self->init_DEST;$self->init_dirscan;$self->init_PM;$self->init_MANPODS;$self->init_xs;$self->init_PERL;$self->init_DIRFILESEP;$self->init_linker;$self->init_ABSTRACT;$self->arch_check($INC{'Config.pm'},$self->catfile($Config{'archlibexp'},"Config.pm"));$self->init_tools();$self->init_others();$self->init_platform();$self->init_PERM();my@args=@ARGV;@args=map {Encode::decode(locale=>$_)}@args if$CAN_DECODE;my($argv)=neatvalue(\@args);$argv =~ s/^\[/(/;$argv =~ s/\]$/)/;push @{$self->{RESULT}},<<END;push @{$self->{RESULT}},$self->_MakeMaker_Parameters_section(\%initial_att);if (defined$self->{CONFIGURE}){push @{$self->{RESULT}},<<END;if (scalar(keys%configure_att)> 0){for my$key (sort keys%configure_att){next if$key eq 'ARGS';my($v)=neatvalue($configure_att{$key});$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push @{$self->{RESULT}},"#     $key => $v"}}else {push @{$self->{RESULT}},"# no values returned"}undef%configure_att}for my$skip (@{$self->{SKIP}|| []}){$self->{SKIPHASH}{$skip}=1}delete$self->{SKIP};if ($self->{PARENT}){for (qw/install dist dist_basics dist_core distdir dist_test dist_ci/){$self->{SKIPHASH}{$_}=1}}unless ($self->{NORECURS}){$self->eval_in_subdirs if @{$self->{DIR}}}for my$section (@MM_Sections){my$method=$section;$method .= '_target' unless$self->can($method);print "Processing Makefile '$section' section\n" if ($Verbose >= 2);my($skipit)=$self->skipcheck($section);if ($skipit){push @{$self->{RESULT}},"\n# --- MakeMaker $section section $skipit."}else {my(%a)=%{$self->{$section}|| {}};push @{$self->{RESULT}},"\n# --- MakeMaker $section section:";push @{$self->{RESULT}},"# " .join ", ",%a if$Verbose && %a;push @{$self->{RESULT}},$self->maketext_filter($self->$method(%a))}}push @{$self->{RESULT}},"\n# End.";$self}sub WriteEmptyMakefile {croak "WriteEmptyMakefile: Need an even number of args" if @_ % 2;my%att=@_;$att{DIR}=[]unless$att{DIR};my$self=MM->new(\%att);my$new=$self->{MAKEFILE};my$old=$self->{MAKEFILE_OLD};if (-f $old){_unlink($old)or warn "unlink $old: $!"}if (-f $new){_rename($new,$old)or warn "rename $new => $old: $!"}open my$mfh,'>',$new or die "open $new for write: $!";print$mfh <<'EOP';close$mfh or die "close $new for write: $!"}sub _installed_file_for_module {my$class=shift;my$prereq=shift;my$file="$prereq.pm";$file =~ s{::}{/}g;my$path;for my$dir (@INC){my$tmp=File::Spec->catfile($dir,$file);if (-r $tmp){$path=$tmp;last}}return$path}sub _MakeMaker_Parameters_section {my$self=shift;my$att=shift;my@result=<<'END';for my$key (sort keys %$att){next if$key eq 'ARGS';my$v;if ($key eq 'PREREQ_PM'){$v=neatvalue({%{$att->{PREREQ_PM}|| {}},%{$att->{BUILD_REQUIRES}|| {}},%{$att->{TEST_REQUIRES}|| {}},})}else {$v=neatvalue($att->{$key})}$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push@result,"#     $key => $v"}return@result}sub _shellwords {my (@lines)=@_;my@allwords;for my$line (@lines){$line =~ s/^\s+//;my@words=_parse_line('\s+',0,$line);pop@words if (@words and!defined$words[-1]);return()unless (@words ||!length($line));push(@allwords,@words)}return(@allwords)}sub _parse_line {my($delimiter,$keep,$line)=@_;my($word,@pieces);no warnings 'uninitialized';while (length($line)){$line =~ s/^
  MakeMaker FATAL: MIN_PERL_VERSION (%s) is not in a recognized format.
  Recommended is a quoted numerical value like '5.005' or '5.008001'.
  END
  Perl version %s or higher required. We run %s.
  END
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
  # This Makefile is for the $self->{NAME} extension to perl.
  #
  # It was generated automatically by MakeMaker version
  # $VERSION (Revision: $Revision) from the contents of
  # Makefile.PL. Don't edit this file, edit Makefile.PL instead.
  #
  #       ANY CHANGES MADE HERE WILL BE LOST!
  #
  #   MakeMaker ARGV: $argv
  #
  END
  
  #   MakeMaker 'CONFIGURE' Parameters:
  END
  all :
  
  manifypods :
  
  subdirs :
  
  dynamic :
  
  static :
  
  clean :
  
  install :
  
  makemakerdflt :
  
  test :
  
  test_dynamic :
  
  test_static :
  
  EOP
  #   MakeMaker Parameters:
  END
                      (?:
                          # double quoted string
                          (")                             # $quote
                          ((?>[^\\"]*(?:\\.[^\\"]*)*))"   # $quoted
          | # --OR--
                          # singe quoted string
                          (')                             # $quote
                          ((?>[^\\']*(?:\\.[^\\']*)*))'   # $quoted
                      |   # --OR--
                          # unquoted string
              (                               # $unquoted
                              (?:\\.|[^\\"'])*?
                          )
                          # followed by
              (                               # $delim
                              \Z(?!\n)                    # EOL
                          |   # --OR--
                              (?-x:$delimiter)            # delimiter
                          |   # --OR--
                              (?!^)(?=["'])               # a quote
                          )
          )//xs or return;my ($quote,$quoted,$unquoted,$delim)=(($1 ? ($1,$2): ($3,$4)),$5,$6);return()unless(defined($quote)|| length($unquoted)|| length($delim));if ($keep){$quoted="$quote$quoted$quote"}else {$unquoted =~ s/\\(.)/$1/sg;if (defined$quote){$quoted =~ s/\\(.)/$1/sg if ($quote eq '"')}}$word .= substr($line,0,0);$word .= defined$quote ? $quoted : $unquoted;if (length($delim)){push(@pieces,$word);push(@pieces,$delim)if ($keep eq 'delimiters');undef$word}if (!length($line)){push(@pieces,$word)}}return(@pieces)}sub check_manifest {print STDOUT "Checking if your kit is complete...\n";require ExtUtils::Manifest;$ExtUtils::Manifest::Quiet=$ExtUtils::Manifest::Quiet=1;my(@missed)=ExtUtils::Manifest::manicheck();if (@missed){print "Warning: the following files are missing in your kit:\n";print "\t",join "\n\t",@missed;print "\n";print "Please inform the author.\n"}else {print "Looks good\n"}}sub parse_args{my($self,@args)=@_;@args=map {Encode::decode(locale=>$_)}@args if$CAN_DECODE;for (@args){unless (m/(.*?)=(.*)/){++$Verbose if m/^verb/;next}my($name,$value)=($1,$2);if ($value =~ m/^~(\w+)?/){$value =~ s [^~(\w*)]
                  [$1 ?
                   ((getpwnam($1))[7] || "~$1") :
                   (getpwuid($>))[7]
                   ]ex}$self->{ARGS}{uc$name}=$self->{uc$name}=$value}if (defined$self->{potential_libs}){my($msg)="'potential_libs' => '$self->{potential_libs}' should be";if ($self->{potential_libs}){print "$msg changed to:\n\t'LIBS' => ['$self->{potential_libs}']\n"}else {print "$msg deleted.\n"}$self->{LIBS}=[$self->{potential_libs}];delete$self->{potential_libs}}if (defined$self->{ARMAYBE}){my($armaybe)=$self->{ARMAYBE};print "ARMAYBE => '$armaybe' should be changed to:\n","\t'dynamic_lib' => {ARMAYBE => '$armaybe'}\n";my(%dl)=%{$self->{dynamic_lib}|| {}};$self->{dynamic_lib}={%dl,ARMAYBE=>$armaybe};delete$self->{ARMAYBE}}if (defined$self->{LDTARGET}){print "LDTARGET should be changed to LDFROM\n";$self->{LDFROM}=$self->{LDTARGET};delete$self->{LDTARGET}}if (defined$self->{DIR}&& ref \$self->{DIR}eq 'SCALAR'){$self->{DIR}=[grep $_,split ":",$self->{DIR}]}if (defined$self->{INCLUDE_EXT}&& ref \$self->{INCLUDE_EXT}eq 'SCALAR'){$self->{INCLUDE_EXT}=[grep $_,split '\s+',$self->{INCLUDE_EXT}]}if (defined$self->{EXCLUDE_EXT}&& ref \$self->{EXCLUDE_EXT}eq 'SCALAR'){$self->{EXCLUDE_EXT}=[grep $_,split '\s+',$self->{EXCLUDE_EXT}]}for my$mmkey (sort keys %$self){next if$mmkey eq 'ARGS';print "  $mmkey => ",neatvalue($self->{$mmkey}),"\n" if$Verbose;print "'$mmkey' is not a known MakeMaker parameter name.\n" unless exists$Recognized_Att_Keys{$mmkey}}$|=1 if$Verbose}sub check_hints {my($self)=@_;require File::Spec;my$curdir=File::Spec->curdir;my$hint_dir=File::Spec->catdir($curdir,"hints");return unless -d $hint_dir;my($hint)="${^O}_$Config{osvers}";$hint =~ s/\./_/g;$hint =~ s/_$//;return unless$hint;while (1){last if -f File::Spec->catfile($hint_dir,"$hint.pl")}continue {last unless$hint =~ s/_[^_]*$//}my$hint_file=File::Spec->catfile($hint_dir,"$hint.pl");return unless -f $hint_file;_run_hintfile($self,$hint_file)}sub _run_hintfile {my ($self,$hint_file)=@_;local($@,$!);print "Processing hints file $hint_file\n" if$Verbose;if(open(my$fh,'<',$hint_file)){my$hints_content=do {local $/;<$fh>};no strict;eval$hints_content;warn "Failed to run hint file $hint_file: $@" if $@}else {warn "Could not open $hint_file for read: $!"}}sub mv_all_methods {my($from,$to)=@_;local$SIG{__WARN__}=sub {warn @_ unless $_[0]=~ /^Subroutine .* redefined/};for my$method (@Overridable){next unless defined &{"${from}::$method"};no strict 'refs';*{"${to}::$method"}=\&{"${from}::$method"};{package MY;my$super="SUPER::".$method;*{$method}=sub {shift->$super(@_)}}}}sub skipcheck {my($self)=shift;my($section)=@_;return 'skipped' if$section eq 'metafile' && $UNDER_CORE;if ($section eq 'dynamic'){print "Warning (non-fatal): Target 'dynamic' depends on targets ","in skipped section 'dynamic_bs'\n" if$self->{SKIPHASH}{dynamic_bs}&& $Verbose;print "Warning (non-fatal): Target 'dynamic' depends on targets ","in skipped section 'dynamic_lib'\n" if$self->{SKIPHASH}{dynamic_lib}&& $Verbose}if ($section eq 'dynamic_lib'){print "Warning (non-fatal): Target '\$(INST_DYNAMIC)' depends on ","targets in skipped section 'dynamic_bs'\n" if$self->{SKIPHASH}{dynamic_bs}&& $Verbose}if ($section eq 'static'){print "Warning (non-fatal): Target 'static' depends on targets ","in skipped section 'static_lib'\n" if$self->{SKIPHASH}{static_lib}&& $Verbose}return 'skipped' if$self->{SKIPHASH}{$section};return ''}sub open_for_writing {my ($file)=@_;open my$fh,">",$file or die "Unable to open $file: $!";my@layers=':raw';push@layers,join ' ',':encoding(locale)' if$CAN_DECODE;binmode$fh,join ' ',@layers;$fh}sub flush {my$self=shift;my$finalname=$self->{MAKEFILE};printf STDOUT "Generating a %s %s\n",$self->make_type,$finalname if$Verbose ||!$self->{PARENT};print STDOUT "Writing $finalname for $self->{NAME}\n" if$Verbose ||!$self->{PARENT};unlink($finalname,"MakeMaker.tmp",$Is_VMS ? 'Descrip.MMS' : ());write_file_via_tmp($finalname,$self->{RESULT});print STDOUT "Writing MYMETA.yml and MYMETA.json\n" if!$self->{NO_MYMETA}and $self->write_mymeta($self->mymeta);if ($self->{PARENT}&&!$self->{_KEEP_AFTER_FLUSH}){my%keep=map {($_=>1)}qw(NEEDS_LINKING HAS_LINK_CODE);delete$self->{$_}for grep!$keep{$_},keys %$self}system("$Config::Config{eunicefix} $finalname")if$Config::Config{eunicefix}ne ":";return}sub write_file_via_tmp {my ($finalname,$contents)=@_;my$fh=open_for_writing("MakeMaker.tmp");die "write_file_via_tmp: 2nd arg must be ref" unless ref$contents;for my$chunk (@$contents){my$to_write=$chunk;utf8::encode$to_write if!$CAN_DECODE && "$]" > 5.008;print$fh "$to_write\n" or die "Can't write to MakeMaker.tmp: $!"}close$fh or die "Can't write to MakeMaker.tmp: $!";_rename("MakeMaker.tmp",$finalname)or warn "rename MakeMaker.tmp => $finalname: $!";chmod 0644,$finalname if!$Is_VMS;return}sub _rename {my($src,$dest)=@_;_unlink($dest);return rename$src,$dest}sub _unlink {my@files=@_;chmod 0666,@files;return unlink@files}sub mkbootstrap {die <<END}sub mksymlists {die <<END}sub neatvalue {my($v)=@_;return "undef" unless defined$v;my($t)=ref$v;return "q[$v]" unless$t;if ($t eq 'ARRAY'){my(@m,@neat);push@m,"[";for my$elem (@$v){push@neat,"q[$elem]"}push@m,join ", ",@neat;push@m,"]";return join "",@m}return$v unless$t eq 'HASH';my(@m,$key,$val);for my$key (sort keys %$v){last unless defined$key;push@m,"$key=>".neatvalue($v->{$key})}return "{ ".join(', ',@m)." }"}sub _find_magic_vstring {my$value=shift;return$value if$UNDER_CORE;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub selfdocument {my($self)=@_;my(@m);if ($Verbose){push@m,"\n# Full list of MakeMaker attribute values:";for my$key (sort keys %$self){next if$key eq 'RESULT' || $key =~ /^[A-Z][a-z]/;my($v)=neatvalue($self->{$key});$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push@m,"# $key => $v"}}push@m,<<'EOF';push@m,join "\n",map "$_ ::\n\t\$(NOECHO) \$(NOOP)\n",grep!$self->{SKIPHASH}{$_},qw(static dynamic config);join "\n",@m}1;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  
  # here so even if top_targets is overridden, these will still be defined
  # gmake will silently still work if any are .PHONY-ed but nmake won't
  EOF
EXTUTILS_MAKEMAKER

$fatpacked{"ExtUtils/MakeMaker/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_CONFIG';
  package ExtUtils::MakeMaker::Config;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;use Config ();our%Config=%Config::Config;sub import {my$caller=caller;no strict 'refs';*{$caller.'::Config'}=\%Config}1;
EXTUTILS_MAKEMAKER_CONFIG

$fatpacked{"ExtUtils/MakeMaker/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_LOCALE';
  package ExtUtils::MakeMaker::Locale;use strict;use warnings;our$VERSION="7.60";$VERSION =~ tr/_//d;use base 'Exporter';our@EXPORT_OK=qw(decode_argv env $ENCODING_LOCALE $ENCODING_LOCALE_FS $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT);use Encode ();use Encode::Alias ();our$ENCODING_LOCALE;our$ENCODING_LOCALE_FS;our$ENCODING_CONSOLE_IN;our$ENCODING_CONSOLE_OUT;sub DEBUG () {0}sub _init {if ($^O eq "MSWin32"){unless ($ENCODING_LOCALE){eval {unless (defined&GetConsoleCP){require Win32;*GetConsoleCP=sub {&Win32::GetConsoleCP}if defined&Win32::GetConsoleCP}unless (defined&GetConsoleCP){require Win32::API;Win32::API->Import('kernel32','int GetConsoleCP()')}if (defined&GetConsoleCP){my$cp=GetConsoleCP();$ENCODING_LOCALE="cp$cp" if$cp}}}unless ($ENCODING_CONSOLE_IN){unless (defined&GetInputCP){eval {require Win32;eval {local$SIG{__WARN__}=sub {}if ("$]" < 5.014);Win32::GetConsoleCP()};*GetInputCP=sub {&Win32::GetConsoleCP}if defined&Win32::GetConsoleCP;*GetOutputCP=sub {&Win32::GetConsoleOutputCP}if defined&Win32::GetConsoleOutputCP};unless (defined&GetInputCP){eval {require Win32::Console;*GetInputCP=sub {&Win32::Console::InputCP}if defined&Win32::Console::InputCP;*GetOutputCP=sub {&Win32::Console::OutputCP}if defined&Win32::Console::OutputCP}}unless (defined&GetInputCP){*GetInputCP=*GetOutputCP=sub {((qx(chcp) || '')=~ /^Active code page: (\d+)/)? $1 : ()}}}my$cp=GetInputCP();$ENCODING_CONSOLE_IN="cp$cp" if$cp;$cp=GetOutputCP();$ENCODING_CONSOLE_OUT="cp$cp" if$cp}}unless ($ENCODING_LOCALE){eval {require I18N::Langinfo;$ENCODING_LOCALE=I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());$ENCODING_LOCALE="ascii" if$ENCODING_LOCALE eq "646";$ENCODING_LOCALE="hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8"};$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN}$ENCODING_LOCALE='UTF-7' if$ENCODING_LOCALE && lc($ENCODING_LOCALE)eq "cp65000";$ENCODING_LOCALE='utf-8-strict' if$ENCODING_LOCALE && lc($ENCODING_LOCALE)eq "cp65001";if ($^O eq "darwin"){$ENCODING_LOCALE_FS ||= "UTF-8"}$ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";$ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;$ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;$ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;unless (Encode::find_encoding($ENCODING_LOCALE)){my$foundit;if (lc($ENCODING_LOCALE)eq "gb18030"){eval {require Encode::HanExtra};if ($@){die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped"}$foundit++ if Encode::find_encoding($ENCODING_LOCALE)}die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped" unless$foundit}}_init();Encode::Alias::define_alias(sub {no strict 'refs';no warnings 'once';return ${"ENCODING_" .uc(shift)}},"locale");sub _flush_aliases {no strict 'refs';for my$a (sort keys%Encode::Alias::Alias){if (defined ${"ENCODING_" .uc($a)}){delete$Encode::Alias::Alias{$a};warn "Flushed alias cache for $a" if DEBUG}}}sub reinit {$ENCODING_LOCALE=shift;$ENCODING_LOCALE_FS=shift;$ENCODING_CONSOLE_IN=$ENCODING_LOCALE;$ENCODING_CONSOLE_OUT=$ENCODING_LOCALE;_init();_flush_aliases()}sub decode_argv {die if defined wantarray;for (@ARGV){$_=Encode::decode(locale=>$_,@_)}}sub env {my$k=Encode::encode(locale=>shift);my$old=$ENV{$k};if (@_){my$v=shift;if (defined$v){$ENV{$k}=Encode::encode(locale=>$v)}else {delete$ENV{$k}}}return Encode::decode(locale=>$old)if defined wantarray}1;
EXTUTILS_MAKEMAKER_LOCALE

$fatpacked{"ExtUtils/MakeMaker/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION';
  package ExtUtils::MakeMaker::version;use 5.006001;use strict;use warnings;use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);$VERSION='7.60';$VERSION =~ tr/_//d;$CLASS='version';{local$SIG{'__DIE__'};eval "use version";if ($@){eval "use ExtUtils::MakeMaker::version::vpp";die "$@" if ($@);no warnings;delete$INC{'version.pm'};$INC{'version.pm'}=$INC{'ExtUtils/MakeMaker/version.pm'};push@version::ISA,"ExtUtils::MakeMaker::version::vpp";$version::VERSION=$VERSION;*version::qv=\&ExtUtils::MakeMaker::version::vpp::qv;*version::declare=\&ExtUtils::MakeMaker::version::vpp::declare;*version::_VERSION=\&ExtUtils::MakeMaker::version::vpp::_VERSION;*version::vcmp=\&ExtUtils::MakeMaker::version::vpp::vcmp;*version::new=\&ExtUtils::MakeMaker::version::vpp::new;if ("$]" >= 5.009000){no strict 'refs';*version::stringify=\&ExtUtils::MakeMaker::version::vpp::stringify;*{'version::(""'}=\&ExtUtils::MakeMaker::version::vpp::stringify;*{'version::(<=>'}=\&ExtUtils::MakeMaker::version::vpp::vcmp;*version::parse=\&ExtUtils::MakeMaker::version::vpp::parse}require ExtUtils::MakeMaker::version::regex;*version::is_lax=\&ExtUtils::MakeMaker::version::regex::is_lax;*version::is_strict=\&ExtUtils::MakeMaker::version::regex::is_strict;*LAX=\$ExtUtils::MakeMaker::version::regex::LAX;*STRICT=\$ExtUtils::MakeMaker::version::regex::STRICT}elsif (!version->can('is_qv')){*version::is_qv=sub {exists $_[0]->{qv}}}}1;
EXTUTILS_MAKEMAKER_VERSION

$fatpacked{"ExtUtils/MakeMaker/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION_REGEX';
  package ExtUtils::MakeMaker::version::regex;use strict;use warnings;use vars qw($VERSION $CLASS $STRICT $LAX);$VERSION='7.60';$VERSION =~ tr/_//d;my$FRACTION_PART=qr/\.[0-9]+/;my$STRICT_INTEGER_PART=qr/0|[1-9][0-9]*/;my$LAX_INTEGER_PART=qr/[0-9]+/;my$STRICT_DOTTED_DECIMAL_PART=qr/\.[0-9]{1,3}/;my$LAX_DOTTED_DECIMAL_PART=qr/\.[0-9]+/;my$LAX_ALPHA_PART=qr/_[0-9]+/;my$STRICT_DECIMAL_VERSION=qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;my$STRICT_DOTTED_DECIMAL_VERSION=qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;$STRICT=qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;my$LAX_DECIMAL_VERSION=qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;my$LAX_DOTTED_DECIMAL_VERSION=qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;$LAX=qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;sub is_strict {defined $_[0]&& $_[0]=~ qr/ \A $STRICT \z /x}sub is_lax {defined $_[0]&& $_[0]=~ qr/ \A $LAX \z /x}1;
EXTUTILS_MAKEMAKER_VERSION_REGEX

$fatpacked{"ExtUtils/MakeMaker/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION_VPP';
  package ExtUtils::MakeMaker::charstar;use overload ('""'=>\&thischar,'0+'=>\&thischar,'++'=>\&increment,'--'=>\&decrement,'+'=>\&plus,'-'=>\&minus,'*'=>\&multiply,'cmp'=>\&cmp,'<=>'=>\&spaceship,'bool'=>\&thischar,'='=>\&clone,);sub new {my ($self,$string)=@_;my$class=ref($self)|| $self;my$obj={string=>[split(//,$string)],current=>0,};return bless$obj,$class}sub thischar {my ($self)=@_;my$last=$#{$self->{string}};my$curr=$self->{current};if ($curr >= 0 && $curr <= $last){return$self->{string}->[$curr]}else {return ''}}sub increment {my ($self)=@_;$self->{current}++}sub decrement {my ($self)=@_;$self->{current}--}sub plus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}+= $offset;return$rself}sub minus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}-= $offset;return$rself}sub multiply {my ($left,$right,$swapped)=@_;my$char=$left->thischar();return$char * $right}sub spaceship {my ($left,$right,$swapped)=@_;unless (ref($right)){$right=$left->new($right)}return$left->{current}<=> $right->{current}}sub cmp {my ($left,$right,$swapped)=@_;unless (ref($right)){if (length($right)==1){return$left->thischar cmp $right}$right=$left->new($right)}return$left->currstr cmp $right->currstr}sub bool {my ($self)=@_;my$char=$self->thischar;return ($char ne '')}sub clone {my ($left,$right,$swapped)=@_;$right={string=>[@{$left->{string}}],current=>$left->{current},};return bless$right,ref($left)}sub currstr {my ($self,$s)=@_;my$curr=$self->{current};my$last=$#{$self->{string}};if (defined($s)&& $s->{current}< $last){$last=$s->{current}}my$string=join('',@{$self->{string}}[$curr..$last]);return$string}package ExtUtils::MakeMaker::version::vpp;use 5.006001;use strict;use warnings;use Config;use vars qw($VERSION $CLASS @ISA $LAX $STRICT);$VERSION='7.60';$VERSION =~ tr/_//d;$CLASS='ExtUtils::MakeMaker::version::vpp';require ExtUtils::MakeMaker::version::regex;*ExtUtils::MakeMaker::version::vpp::is_strict=\&ExtUtils::MakeMaker::version::regex::is_strict;*ExtUtils::MakeMaker::version::vpp::is_lax=\&ExtUtils::MakeMaker::version::regex::is_lax;*LAX=\$ExtUtils::MakeMaker::version::regex::LAX;*STRICT=\$ExtUtils::MakeMaker::version::regex::STRICT;use overload ('""'=>\&stringify,'0+'=>\&numify,'cmp'=>\&vcmp,'<=>'=>\&vcmp,'bool'=>\&vbool,'+'=>\&vnoop,'-'=>\&vnoop,'*'=>\&vnoop,'/'=>\&vnoop,'+='=>\&vnoop,'-='=>\&vnoop,'*='=>\&vnoop,'/='=>\&vnoop,'abs'=>\&vnoop,);eval "use warnings";if ($@){eval '
  	package
  	warnings;
  	sub enabled {return $^W;}
  	1;
      '}sub import {no strict 'refs';my ($class)=shift;unless ($class eq $CLASS){no warnings;*{$class.'::declare'}=\&{$CLASS.'::declare'};*{$class.'::qv'}=\&{$CLASS.'::qv'}}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){no warnings;*UNIVERSAL::VERSION =\&{$CLASS.'::_VERSION'}}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&{$CLASS.'::_VERSION'}}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&{$CLASS.'::is_strict'}unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&{$CLASS.'::is_lax'}unless defined(&{$callpkg.'::is_lax'})}}my$VERSION_MAX=0x7FFFFFFF;use constant TRUE=>1;use constant FALSE=>0;sub isDIGIT {my ($char)=shift->thischar();return ($char =~ /\d/)}sub isALPHA {my ($char)=shift->thischar();return ($char =~ /[a-zA-Z]/)}sub isSPACE {my ($char)=shift->thischar();return ($char =~ /\s/)}sub BADVERSION {my ($s,$errstr,$error)=@_;if ($errstr){$$errstr=$error}return$s}sub prescan_version {my ($s,$strict,$errstr,$sqv,$ssaw_decimal,$swidth,$salpha)=@_;my$qv=defined$sqv ? $$sqv : FALSE;my$saw_decimal=defined$ssaw_decimal ? $$ssaw_decimal : 0;my$width=defined$swidth ? $$swidth : 3;my$alpha=defined$salpha ? $$salpha : FALSE;my$d=$s;if ($qv && isDIGIT($d)){goto dotted_decimal_version}if ($d eq 'v'){$d++;if (isDIGIT($d)){$qv=TRUE}else {return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}dotted_decimal_version: if ($strict && $d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}else {if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}else {goto version_prescan_finish}}{my$i=0;my$j=0;while (isDIGIT($d)){$i++;while (isDIGIT($d)){$d++;$j++;if ($strict && $j > 3){return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)")}}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}$d++;$alpha=TRUE}elsif ($d eq '.'){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}$saw_decimal++;$d++}elsif (!isDIGIT($d)){last}$j=0}if ($strict && $i < 2){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}}}else {my$j=0;if ($strict){if ($d eq '.'){return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)")}if ($d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}}if ($d eq '-'){return BADVERSION($s,$errstr,"Invalid version format (negative version number)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}elsif (!$d || $d eq ';' || isSPACE($d)|| $d eq '}'){if ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (version required)")}goto version_prescan_finish}elsif ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}elsif ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}elsif (isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)")}else {return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}}elsif ($d){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($d &&!isDIGIT($d)&& ($strict ||!($d eq ';' || isSPACE($d)|| $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (fractional part required)")}while (isDIGIT($d)){$d++;$j++;if ($d eq '.' && isDIGIT($d-1)){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')")}$d=$s;$qv=TRUE;goto dotted_decimal_version}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}if (!isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}$width=$j;$d++;$alpha=TRUE}}}version_prescan_finish: while (isSPACE($d)){$d++}if ($d &&!isDIGIT($d)&& (!($d eq ';' || $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if (defined$sqv){$$sqv=$qv}if (defined$swidth){$$swidth=$width}if (defined$ssaw_decimal){$$ssaw_decimal=$saw_decimal}if (defined$salpha){$$salpha=$alpha}return$d}sub scan_version {my ($s,$rv,$qv)=@_;my$start;my$pos;my$last;my$errstr;my$saw_decimal=0;my$width=3;my$alpha=FALSE;my$vinf=FALSE;my@av;$s=new ExtUtils::MakeMaker::charstar$s;while (isSPACE($s)){$s++}$last=prescan_version($s,FALSE,\$errstr,\$qv,\$saw_decimal,\$width,\$alpha);if ($errstr){if ($s ne 'undef'){require Carp;Carp::croak($errstr)}}$start=$s;if ($s eq 'v'){$s++}$pos=$s;if ($qv){$$rv->{qv}=$qv}if ($alpha){$$rv->{alpha}=$alpha}if (!$qv && $width < 3){$$rv->{width}=$width}while (isDIGIT($pos)){$pos++}if (!isALPHA($pos)){my$rev;for (;;){$rev=0;{my$end=$pos;my$mult=1;my$orev;if (!$qv && $s > $start && $saw_decimal==1){$mult *= 100;while ($s < $end){$orev=$rev;$rev += $s * $mult;$mult /= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version %d",$VERSION_MAX);$s=$end - 1;$rev=$VERSION_MAX;$vinf=1}$s++;if ($s eq '_'){$s++}}}else {while (--$end >= $s){$orev=$rev;$rev += $end * $mult;$mult *= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version");$end=$s - 1;$rev=$VERSION_MAX;$vinf=1}}}}push@av,$rev;if ($vinf){$s=$last;last}elsif ($pos eq '.'){$s=++$pos}elsif ($pos eq '_' && isDIGIT($pos+1)){$s=++$pos}elsif ($pos eq ',' && isDIGIT($pos+1)){$s=++$pos}elsif (isDIGIT($pos)){$s=$pos}else {$s=$pos;last}if ($qv){while (isDIGIT($pos)){$pos++}}else {my$digits=0;while ((isDIGIT($pos)|| $pos eq '_')&& $digits < 3){if ($pos ne '_'){$digits++}$pos++}}}}if ($qv){my$len=$#av;$len=2 - $len;while ($len-- > 0){push@av,0}}if ($vinf){$$rv->{original}="v.Inf";$$rv->{vinf}=1}elsif ($s > $start){$$rv->{original}=$start->currstr($s);if ($qv && $saw_decimal==1 && $start ne 'v'){$$rv->{original}='v' .$$rv->{original}}}else {$$rv->{original}='0';push(@av,0)}$$rv->{version}=\@av;if ($s eq 'undef'){$s += 5}return$s}sub new {my$class=shift;unless (defined$class or $#_ > 1){require Carp;Carp::croak('Usage: version::new(class, version)')}my$self=bless ({},ref ($class)|| $class);my$qv=FALSE;if ($#_==1){$qv=TRUE}my$value=pop;if (ref($value)&& eval('$value->isa("version")')){$self->{version}=[@{$value->{version}}];$self->{qv}=1 if$value->{qv};$self->{alpha}=1 if$value->{alpha};$self->{original}=''.$value->{original};return$self}if (not defined$value or $value =~ /^undef$/){push @{$self->{version}},0;$self->{original}="0";return ($self)}if (ref($value)=~ m/ARRAY|HASH/){require Carp;Carp::croak("Invalid version format (non-numeric data)")}$value=_un_vstring($value);if ($Config{d_setlocale}&& eval {require POSIX}){require locale;my$currlocale=POSIX::setlocale(&POSIX::LC_ALL);if (POSIX::localeconv()->{decimal_point}eq ','){$value =~ tr/,/./}}if ($value =~ /\d+.?\d*e[-+]?\d+/){$value=sprintf("%.9f",$value);$value =~ s/(0+)$//}my$s=scan_version($value,\$self,$qv);if ($s){warn("Version string '%s' contains invalid data; " ."ignoring: '%s'",$value,$s)}return ($self)}*parse=\&new;sub numify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$width=$self->{width}|| 3;my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("%d.",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];if ($width < 3){my$denom=10**(3-$width);my$quot=int($digit/$denom);my$rem=$digit - ($quot * $denom);$string .= sprintf("%0".$width."d_%d",$quot,$rem)}else {$string .= sprintf("%03d",$digit)}}if ($len > 0){$digit=$self->{version}[$len];if ($alpha && $width==3){$string .= "_"}$string .= sprintf("%0".$width."d",$digit)}else {$string .= sprintf("000")}return$string}sub normal {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("v%d",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf(".%d",$digit)}if ($len > 0){$digit=$self->{version}[$len];if ($alpha){$string .= sprintf("_%0d",$digit)}else {$string .= sprintf(".%0d",$digit)}}if ($len <= 2){for ($len=2 - $len;$len!=0;$len-- ){$string .= sprintf(".%0d",0)}}return$string}sub stringify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}return exists$self->{original}? $self->{original}: exists$self->{qv}? $self->normal : $self->numify}sub vcmp {require UNIVERSAL;my ($left,$right,$swap)=@_;my$class=ref($left);unless (UNIVERSAL::isa($right,$class)){$right=$class->new($right)}if ($swap){($left,$right)=($right,$left)}unless (_verify($left)){require Carp;Carp::croak("Invalid version object")}unless (_verify($right)){require Carp;Carp::croak("Invalid version format")}my$l=$#{$left->{version}};my$r=$#{$right->{version}};my$m=$l < $r ? $l : $r;my$lalpha=$left->is_alpha;my$ralpha=$right->is_alpha;my$retval=0;my$i=0;while ($i <= $m && $retval==0){$retval=$left->{version}[$i]<=> $right->{version}[$i];$i++}if ($retval==0 && $l==$r && $left->{version}[$m]==$right->{version}[$m]&& ($lalpha || $ralpha)){if ($lalpha &&!$ralpha){$retval=-1}elsif ($ralpha &&!$lalpha){$retval=+1}}if ($retval==0 && $l!=$r){if ($l < $r){while ($i <= $r && $retval==0){if ($right->{version}[$i]!=0){$retval=-1}$i++}}else {while ($i <= $l && $retval==0){if ($left->{version}[$i]!=0){$retval=+1}$i++}}}return$retval}sub vbool {my ($self)=@_;return vcmp($self,$self->new("0"),1)}sub vnoop {require Carp;Carp::croak("operation not supported with version object")}sub is_alpha {my ($self)=@_;return (exists$self->{alpha})}sub qv {my$value=shift;my$class=$CLASS;if (@_){$class=ref($value)|| $value;$value=shift}$value=_un_vstring($value);$value='v'.$value unless$value =~ /(^v|\d+\.\d+\.\d)/;my$obj=$CLASS->new($value);return bless$obj,$class}*declare=\&qv;sub is_qv {my ($self)=@_;return (exists$self->{qv})}sub _verify {my ($self)=@_;if (ref($self)&& eval {exists$self->{version}}&& ref($self->{version})eq 'ARRAY'){return 1}else {return 0}}sub _is_non_alphanumeric {my$s=shift;$s=new ExtUtils::MakeMaker::charstar$s;while ($s){return 0 if isSPACE($s);return 1 unless (isALPHA($s)|| isDIGIT($s)|| $s =~ /[.-]/);$s++}return 0}sub _un_vstring {my$value=shift;if (length($value)>= 3 && $value !~ /[._]/ && _is_non_alphanumeric($value)){my$tvalue;if ("$]" >= 5.008_001){$tvalue=_find_magic_vstring($value);$value=$tvalue if length$tvalue}elsif ("$]" >= 5.006_000){$tvalue=sprintf("v%vd",$value);if ($tvalue =~ /^v\d+(\.\d+){2,}$/){$value=$tvalue}}}return$value}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _VERSION {my ($obj,$req)=@_;my$class=ref($obj)|| $obj;no strict 'refs';if (exists$INC{"$class.pm"}and not %{"$class\::"}and "$]" >= 5.008){require Carp;Carp::croak("$class defines neither package nor VERSION" ."--version check failed")}my$version=eval "\$$class\::VERSION";if (defined$version){local $^W if "$]" <= 5.008;$version=ExtUtils::MakeMaker::version::vpp->new($version)}if (defined$req){unless (defined$version){require Carp;my$msg="$]" < 5.006 ? "$class version $req required--this is only version " : "$class does not define \$$class\::VERSION" ."--version check failed";if ($ENV{VERSION_DEBUG}){Carp::confess($msg)}else {Carp::croak($msg)}}$req=ExtUtils::MakeMaker::version::vpp->new($req);if ($req > $version){require Carp;if ($req->is_qv){Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->normal,$version->normal))}else {Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->stringify,$version->stringify))}}}return defined$version ? $version->stringify : undef}1;
EXTUTILS_MAKEMAKER_VERSION_VPP

$fatpacked{"ExtUtils/Mkbootstrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKBOOTSTRAP';
  package ExtUtils::Mkbootstrap;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;require Exporter;our@ISA=('Exporter');our@EXPORT=('&Mkbootstrap');use Config;our$Verbose=0;sub Mkbootstrap {my($baseext,@bsloadlibs)=@_;@bsloadlibs=grep($_,@bsloadlibs);print "	bsloadlibs=@bsloadlibs\n" if$Verbose;require DynaLoader;rename "$baseext.bs","$baseext.bso" if -s "$baseext.bs";if (-f "${baseext}_BS"){$_="${baseext}_BS";package DynaLoader;no strict 'vars';local($osname,$dlsrc)=();($osname,$dlsrc)=@Config::Config{qw(osname dlsrc)};$bscode="";unshift@INC,".";require $_;shift@INC}if ($Config{'dlsrc'}=~ /^dl_dld/){package DynaLoader;no strict 'vars';push(@dl_resolve_using,dl_findfile('-lc'))}my(@all)=(@bsloadlibs,@DynaLoader::dl_resolve_using);my($method)='';if (@all || (defined$DynaLoader::bscode && length$DynaLoader::bscode)){open my$bs,">","$baseext.bs" or die "Unable to open $baseext.bs: $!";print "Writing $baseext.bs\n";print "	containing: @all" if$Verbose;print$bs "# $baseext DynaLoader bootstrap file for $^O architecture.\n";print$bs "# Do not edit this file, changes will be lost.\n";print$bs "# This file was automatically generated by the\n";print$bs "# Mkbootstrap routine in ExtUtils::Mkbootstrap (v$VERSION).\n";if (@all){print$bs "\@DynaLoader::dl_resolve_using = ";if (" @all" =~ m/ -[lLR]/){print$bs "  dl_findfile(qw(\n  @all\n  ));\n"}else {print$bs "  qw(@all);\n"}}print$bs $DynaLoader::bscode if$DynaLoader::bscode;print$bs "\n1;\n";close$bs}}1;
EXTUTILS_MKBOOTSTRAP

$fatpacked{"ExtUtils/Mksymlists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKSYMLISTS';
  package ExtUtils::Mksymlists;use 5.006;use strict qw[subs refs];use warnings;use Carp;use Exporter;use Config;our@ISA=qw(Exporter);our@EXPORT=qw(&Mksymlists);our$VERSION='7.60';$VERSION =~ tr/_//d;sub Mksymlists {my(%spec)=@_;my($osname)=$^O;croak("Insufficient information specified to Mksymlists")unless ($spec{NAME}or ($spec{FILE}and ($spec{DL_FUNCS}or $spec{FUNCLIST})));$spec{DL_VARS}=[]unless$spec{DL_VARS};($spec{FILE}=$spec{NAME})=~ s/.*::// unless$spec{FILE};$spec{FUNCLIST}=[]unless$spec{FUNCLIST};$spec{DL_FUNCS}={$spec{NAME}=>[]}unless (($spec{DL_FUNCS}and keys %{$spec{DL_FUNCS}})or @{$spec{FUNCLIST}});if (defined$spec{DL_FUNCS}){for my$package (sort keys %{$spec{DL_FUNCS}}){my($packprefix,$bootseen);($packprefix=$package)=~ s/\W/_/g;for my$sym (@{$spec{DL_FUNCS}->{$package}}){if ($sym =~ /^boot_/){push(@{$spec{FUNCLIST}},$sym);$bootseen++}else {push(@{$spec{FUNCLIST}},"XS_${packprefix}_$sym")}}push(@{$spec{FUNCLIST}},"boot_$packprefix")unless$bootseen}}if (defined&DynaLoader::mod2fname and not $spec{DLBASE}){$spec{DLBASE}=DynaLoader::mod2fname([split(/::/,$spec{NAME})])}if ($osname eq 'aix'){_write_aix(\%spec)}elsif ($osname eq 'MacOS'){_write_aix(\%spec)}elsif ($osname eq 'VMS'){_write_vms(\%spec)}elsif ($osname eq 'os2'){_write_os2(\%spec)}elsif ($osname eq 'MSWin32'){_write_win32(\%spec)}else {croak("Don't know how to create linker option file for $osname\n")}}sub _write_aix {my($data)=@_;rename "$data->{FILE}.exp","$data->{FILE}.exp_old";open(my$exp,">","$data->{FILE}.exp")or croak("Can't create $data->{FILE}.exp: $!\n");print$exp join("\n",@{$data->{DL_VARS}},"\n")if @{$data->{DL_VARS}};print$exp join("\n",@{$data->{FUNCLIST}},"\n")if @{$data->{FUNCLIST}};close$exp}sub _write_os2 {my($data)=@_;require Config;my$threaded=($Config::Config{archname}=~ /-thread/ ? " threaded" : "");if (not $data->{DLBASE}){($data->{DLBASE}=$data->{NAME})=~ s/.*:://;$data->{DLBASE}=substr($data->{DLBASE},0,7).'_'}my$distname=$data->{DISTNAME}|| $data->{NAME};$distname="Distribution $distname";my$patchlevel=" pl$Config{perl_patchlevel}" || '';my$comment=sprintf "Perl (v%s%s%s) module %s",$Config::Config{version},$threaded,$patchlevel,$data->{NAME};chomp$comment;if ($data->{INSTALLDIRS}and $data->{INSTALLDIRS}eq 'perl'){$distname='perl5-porters@perl.org';$comment="Core $comment"}$comment="$comment (Perl-config: $Config{config_args})";$comment=substr($comment,0,200)."...)" if length$comment > 203;rename "$data->{FILE}.def","$data->{FILE}_def.old";open(my$def,">","$data->{FILE}.def")or croak("Can't create $data->{FILE}.def: $!\n");print$def "LIBRARY '$data->{DLBASE}' INITINSTANCE TERMINSTANCE\n";print$def "DESCRIPTION '\@#$distname:$data->{VERSION}#\@ $comment'\n";print$def "CODE LOADONCALL\n";print$def "DATA LOADONCALL NONSHARED MULTIPLE\n";print$def "EXPORTS\n  ";print$def join("\n  ",@{$data->{DL_VARS}},"\n")if @{$data->{DL_VARS}};print$def join("\n  ",@{$data->{FUNCLIST}},"\n")if @{$data->{FUNCLIST}};_print_imports($def,$data);close$def}sub _print_imports {my ($def,$data)=@_;my$imports=$data->{IMPORTS}or return;if (keys %$imports){print$def "IMPORTS\n";for my$name (sort keys %$imports){print$def "  $name=$imports->{$name}\n"}}}sub _write_win32 {my($data)=@_;require Config;if (not $data->{DLBASE}){($data->{DLBASE}=$data->{NAME})=~ s/.*:://;$data->{DLBASE}=substr($data->{DLBASE},0,7).'_'}rename "$data->{FILE}.def","$data->{FILE}_def.old";open(my$def,">","$data->{FILE}.def")or croak("Can't create $data->{FILE}.def: $!\n");if ($Config::Config{'cc'}!~ /\bgcc/i){print$def "LIBRARY \"$data->{DLBASE}\"\n"}print$def "EXPORTS\n  ";my@syms;unless("$]" >= 5.016){if ($Config::Config{'cc'}=~ /^bcc/i){push@syms,"_$_","$_ = _$_" for (@{$data->{DL_VARS}},@{$data->{FUNCLIST}})}else {push@syms,"$_","_$_ = $_" for (@{$data->{DL_VARS}},@{$data->{FUNCLIST}})}}else {push@syms,"$_" for (@{$data->{DL_VARS}},@{$data->{FUNCLIST}})}print$def join("\n  ",@syms,"\n")if@syms;_print_imports($def,$data);close$def}sub _write_vms {my($data)=@_;require Config;require ExtUtils::XSSymSet;my($isvax)=$Config::Config{'archname'}=~ /VAX/i;my($set)=new ExtUtils::XSSymSet;rename "$data->{FILE}.opt","$data->{FILE}.opt_old";open(my$opt,">","$data->{FILE}.opt")or croak("Can't create $data->{FILE}.opt: $!\n");print$opt "case_sensitive=yes\n" if$Config::Config{d_vms_case_sensitive_symbols};for my$sym (@{$data->{FUNCLIST}}){my$safe=$set->addsym($sym);if ($isvax){print$opt "UNIVERSAL=$safe\n"}else {print$opt "SYMBOL_VECTOR=($safe=PROCEDURE)\n"}}for my$sym (@{$data->{DL_VARS}}){my$safe=$set->addsym($sym);print$opt "PSECT_ATTR=${sym},PIC,OVR,RD,NOEXE,WRT,NOSHR\n";if ($isvax){print$opt "UNIVERSAL=$safe\n"}else {print$opt "SYMBOL_VECTOR=($safe=DATA)\n"}}close$opt}1;
EXTUTILS_MKSYMLISTS

$fatpacked{"ExtUtils/testlib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TESTLIB';
  package ExtUtils::testlib;use strict;use warnings;our$VERSION='7.60';$VERSION =~ tr/_//d;use Cwd;use File::Spec;my$cwd;BEGIN {($cwd)=getcwd()=~ /(.*)/}use lib map {File::Spec->rel2abs($_,$cwd)}qw(blib/arch blib/lib);1;
EXTUTILS_TESTLIB

$fatpacked{"File/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PATH';
  package File::Path;use 5.005_04;use strict;use Cwd 'getcwd';use File::Basename ();use File::Spec ();BEGIN {if ($] < 5.006){eval 'use Symbol'}}use Exporter ();use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);$VERSION='2.18';$VERSION=eval$VERSION;@ISA=qw(Exporter);@EXPORT=qw(mkpath rmtree);@EXPORT_OK=qw(make_path remove_tree);BEGIN {for (qw(VMS MacOS MSWin32 os2)){no strict 'refs';*{"_IS_\U$_"}=$^O eq $_ ? sub () {1}: sub () {0}}*_FORCE_WRITABLE=(grep {$^O eq $_}qw(amigaos dos epoc MSWin32 MacOS os2))? sub () {1}: sub () {0};*_NEED_STAT_CHECK=!(_IS_MSWIN32())? sub () {1}: sub () {0}}sub _carp {require Carp;goto&Carp::carp}sub _croak {require Carp;goto&Carp::croak}sub _error {my$arg=shift;my$message=shift;my$object=shift;if ($arg->{error}){$object='' unless defined$object;$message .= ": $!" if $!;push @{${$arg->{error}}},{$object=>$message }}else {_carp(defined($object)? "$message for $object: $!" : "$message: $!")}}sub __is_arg {my ($arg)=@_;return (ref$arg eq 'HASH')}sub make_path {push @_,{}unless @_ and __is_arg($_[-1]);goto&mkpath}sub mkpath {my$old_style=!(@_ and __is_arg($_[-1]));my$data;my$paths;if ($old_style){my ($verbose,$mode);($paths,$verbose,$mode)=@_;$paths=[$paths]unless UNIVERSAL::isa($paths,'ARRAY');$data->{verbose}=$verbose;$data->{mode}=defined$mode ? $mode : oct '777'}else {my%args_permitted=map {$_=>1}(qw|chmod error group mask mode owner uid user verbose|);my%not_on_win32_args=map {$_=>1}(qw|group owner uid user|);my@bad_args=();my@win32_implausible_args=();my$arg=pop @_;for my$k (sort keys %{$arg}){if (!$args_permitted{$k}){push@bad_args,$k}elsif ($not_on_win32_args{$k}and _IS_MSWIN32){push@win32_implausible_args,$k}else {$data->{$k}=$arg->{$k}}}_carp("Unrecognized option(s) passed to mkpath() or make_path(): @bad_args")if@bad_args;_carp("Option(s) implausible on Win32 passed to mkpath() or make_path(): @win32_implausible_args")if@win32_implausible_args;$data->{mode}=delete$data->{mask}if exists$data->{mask};$data->{mode}=oct '777' unless exists$data->{mode};${$data->{error}}=[]if exists$data->{error};unless (@win32_implausible_args){$data->{owner}=delete$data->{user}if exists$data->{user};$data->{owner}=delete$data->{uid}if exists$data->{uid};if (exists$data->{owner}and $data->{owner}=~ /\D/){my$uid=(getpwnam$data->{owner})[2];if (defined$uid){$data->{owner}=$uid}else {_error($data,"unable to map $data->{owner} to a uid, ownership not changed");delete$data->{owner}}}if (exists$data->{group}and $data->{group}=~ /\D/){my$gid=(getgrnam$data->{group})[2];if (defined$gid){$data->{group}=$gid}else {_error($data,"unable to map $data->{group} to a gid, group ownership not changed");delete$data->{group}}}if (exists$data->{owner}and not exists$data->{group}){$data->{group}=-1}if (exists$data->{group}and not exists$data->{owner}){$data->{owner}=-1}}$paths=[@_]}return _mkpath($data,$paths)}sub _mkpath {my$data=shift;my$paths=shift;my (@created);for my$path (@{$paths}){next unless defined($path)and length($path);$path .= '/' if _IS_OS2 and $path =~ /^\w:\z/s;if (_IS_VMS){next if$path eq '/';$path=VMS::Filespec::unixify($path)}next if -d $path;my$parent=File::Basename::dirname($path);unless (-d $parent or $path eq $parent){push(@created,_mkpath($data,[$parent]))}print "mkdir $path\n" if$data->{verbose};if (mkdir($path,$data->{mode})){push(@created,$path);if (exists$data->{owner}){if (!chown$data->{owner},$data->{group},$path){_error($data,"Cannot change ownership of $path to $data->{owner}:$data->{group}")}}if (exists$data->{chmod}){if (!chmod$data->{chmod},$path){_error($data,"Cannot change permissions of $path to $data->{chmod}")}}}else {my$save_bang=$!;my ($e,$e1)=($save_bang,$^E);$e .= "; $e1" if$e ne $e1;if (!-d $path){$!=$save_bang;if ($data->{error}){push @{${$data->{error}}},{$path=>$e }}else {_croak("mkdir $path: $e")}}}}return@created}sub remove_tree {push @_,{}unless @_ and __is_arg($_[-1]);goto&rmtree}sub _is_subdir {my ($dir,$test)=@_;my ($dv,$dd)=File::Spec->splitpath($dir,1);my ($tv,$td)=File::Spec->splitpath($test,1);return 0 if$dv ne $tv;my@d=File::Spec->splitdir($dd);my@t=File::Spec->splitdir($td);return 0 if@t < @d;return join('/',@d)eq join('/',splice@t,0,+@d)}sub rmtree {my$old_style=!(@_ and __is_arg($_[-1]));my ($arg,$data,$paths);if ($old_style){my ($verbose,$safe);($paths,$verbose,$safe)=@_;$data->{verbose}=$verbose;$data->{safe}=defined$safe ? $safe : 0;if (defined($paths)and length($paths)){$paths=[$paths]unless UNIVERSAL::isa($paths,'ARRAY')}else {_carp("No root path(s) specified\n");return 0}}else {my%args_permitted=map {$_=>1}(qw|error keep_root result safe verbose|);my@bad_args=();my$arg=pop @_;for my$k (sort keys %{$arg}){if (!$args_permitted{$k}){push@bad_args,$k}else {$data->{$k}=$arg->{$k}}}_carp("Unrecognized option(s) passed to remove_tree(): @bad_args")if@bad_args;${$data->{error}}=[]if exists$data->{error};${$data->{result}}=[]if exists$data->{result};$paths=[@_]}$data->{prefix}='';$data->{depth}=0;my@clean_path;$data->{cwd}=getcwd()or do {_error($data,"cannot fetch initial working directory");return 0};for ($data->{cwd}){/\A(.*)\Z/s;$_=$1}for my$p (@$paths){my$ortho_root=_IS_MSWIN32 ? _slash_lc($p): $p;my$ortho_cwd=_IS_MSWIN32 ? _slash_lc($data->{cwd}): $data->{cwd};my$ortho_root_length=length($ortho_root);$ortho_root_length-- if _IS_VMS;if ($ortho_root_length && _is_subdir($ortho_root,$ortho_cwd)){local $!=0;_error($data,"cannot remove path when cwd is $data->{cwd}",$p);next}if (_IS_MACOS){$p=":$p" unless$p =~ /:/;$p .= ":" unless$p =~ /:\z/}elsif (_IS_MSWIN32){$p =~ s{[/\\]\z}{}}else {$p =~ s{/\z}{}}push@clean_path,$p}@{$data}{qw(device inode)}=(lstat$data->{cwd})[0,1 ]or do {_error($data,"cannot stat initial working directory",$data->{cwd});return 0};return _rmtree($data,\@clean_path)}sub _rmtree {my$data=shift;my$paths=shift;my$count=0;my$curdir=File::Spec->curdir();my$updir=File::Spec->updir();my (@files,$root);ROOT_DIR: foreach my$root (@$paths){my$canon=$data->{prefix}? File::Spec->catfile($data->{prefix},$root): $root;my ($ldev,$lino,$perm)=(lstat$root)[0,1,2 ]or next ROOT_DIR;if (-d _){$root=VMS::Filespec::vmspath(VMS::Filespec::pathify($root))if _IS_VMS;if (!chdir($root)){my$root_fh;if (open($root_fh,'<',$root)){my ($fh_dev,$fh_inode)=(stat$root_fh)[0,1];$perm &= oct '7777';my$nperm=$perm | oct '700';local $@;if (!($data->{safe}or $nperm==$perm or!-d _ or $fh_dev ne $ldev or $fh_inode ne $lino or eval {chmod($nperm,$root_fh)})){_error($data,"cannot make child directory read-write-exec",$canon);next ROOT_DIR}close$root_fh}if (!chdir($root)){_error($data,"cannot chdir to child",$canon);next ROOT_DIR}}my ($cur_dev,$cur_inode,$perm)=(stat$curdir)[0,1,2 ]or do {_error($data,"cannot stat current working directory",$canon);next ROOT_DIR};if (_NEED_STAT_CHECK){($ldev eq $cur_dev and $lino eq $cur_inode)or _croak("directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.")}$perm &= oct '7777';my$nperm=$perm | oct '700';if (!($data->{safe}or $nperm==$perm or chmod($nperm,$curdir))){_error($data,"cannot make directory read+writeable",$canon);$nperm=$perm}my$d;$d=gensym()if $] < 5.006;if (!opendir$d,$curdir){_error($data,"cannot opendir",$canon);@files=()}else {if (!defined ${^TAINT} or ${^TAINT}){@files=map {/\A(.*)\z/s;$1}readdir$d}else {@files=readdir$d}closedir$d}if (_IS_VMS){@files=map {$_ eq '.' ? '.;' : $_}reverse@files}@files=grep {$_ ne $updir and $_ ne $curdir}@files;if (@files){my$narg={%$data};@{$narg}{qw(device inode cwd prefix depth)}=($cur_dev,$cur_inode,$updir,$canon,$data->{depth}+ 1);$count += _rmtree($narg,\@files)}if ($nperm!=$perm and not chmod($perm,$curdir)){_error($data,"cannot reset chmod",$canon)}chdir($data->{cwd})or _croak("cannot chdir to $data->{cwd} from $canon: $!, aborting.");($cur_dev,$cur_inode)=(stat$curdir)[0,1 ]or _croak("cannot stat prior working directory $data->{cwd}: $!, aborting.");if (_NEED_STAT_CHECK){($data->{device}eq $cur_dev and $data->{inode}eq $cur_inode)or _croak("previous directory $data->{cwd} " ."changed before entering $canon, " ."expected dev=$ldev ino=$lino, " ."actual dev=$cur_dev ino=$cur_inode, aborting.")}if ($data->{depth}or!$data->{keep_root}){if ($data->{safe}&& (_IS_VMS ?!&VMS::Filespec::candelete($root):!-w $root)){print "skipped $root\n" if$data->{verbose};next ROOT_DIR}if (_FORCE_WRITABLE and!chmod$perm | oct '700',$root){_error($data,"cannot make directory writeable",$canon)}print "rmdir $root\n" if$data->{verbose};if (rmdir$root){push @{${$data->{result}}},$root if$data->{result};++$count}else {_error($data,"cannot remove directory",$canon);if (_FORCE_WRITABLE &&!chmod($perm,(_IS_VMS ? VMS::Filespec::fileify($root): $root))){_error($data,sprintf("cannot restore permissions to 0%o",$perm),$canon)}}}}else {$root=VMS::Filespec::vmsify("./$root")if _IS_VMS &&!File::Spec->file_name_is_absolute($root)&& ($root !~ m/(?<!\^)[\]>]+/);if ($data->{safe}&& (_IS_VMS ?!&VMS::Filespec::candelete($root):!(-l $root || -w $root))){print "skipped $root\n" if$data->{verbose};next ROOT_DIR}my$nperm=$perm & oct '7777' | oct '600';if (_FORCE_WRITABLE and $nperm!=$perm and not chmod$nperm,$root){_error($data,"cannot make file writeable",$canon)}print "unlink $canon\n" if$data->{verbose};for (;;){if (unlink$root){push @{${$data->{result}}},$root if$data->{result}}else {_error($data,"cannot unlink file",$canon);_FORCE_WRITABLE and chmod($perm,$root)or _error($data,sprintf("cannot restore permissions to 0%o",$perm),$canon);last}++$count;last unless _IS_VMS && lstat$root}}}return$count}sub _slash_lc {my$path=shift;$path =~ tr{\\}{/};return lc($path)}1;
FILE_PATH

$fatpacked{"File/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_TEMP';
  package File::Temp;our$VERSION='0.2311';use 5.006;use strict;use Carp;use File::Spec 0.8;use Cwd ();use File::Path 2.06 qw/rmtree/;use Fcntl 1.03;use IO::Seekable;use Errno;use Scalar::Util 'refaddr';require VMS::Stdio if $^O eq 'VMS';eval {require Carp::Heavy};require Symbol if $] < 5.006;use parent 0.221 qw/IO::Handle IO::Seekable/;use overload '""'=>"STRINGIFY",'0+'=>"NUMIFY",fallback=>1;our$DEBUG=0;our$KEEP_ALL=0;use Exporter 5.57 'import';our@EXPORT_OK=qw{tempfile tempdir tmpnam tmpfile mktemp mkstemp mkstemps mkdtemp unlink0 cleanup SEEK_SET SEEK_CUR SEEK_END};our%EXPORT_TAGS=('POSIX'=>[qw/tmpnam tmpfile/],'mktemp'=>[qw/mktemp mkstemp mkstemps mkdtemp/],'seekable'=>[qw/SEEK_SET SEEK_CUR SEEK_END/],);Exporter::export_tags('POSIX','mktemp','seekable');my@CHARS=(qw/A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 _/);use constant MAX_TRIES=>1000;use constant MINX=>4;use constant TEMPXXX=>'X' x 10;use constant STANDARD=>0;use constant MEDIUM=>1;use constant HIGH=>2;my$OPENFLAGS=O_CREAT | O_EXCL | O_RDWR;my$LOCKFLAG;unless ($^O eq 'MacOS'){for my$oflag (qw/NOFOLLOW BINARY LARGEFILE NOINHERIT/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);no strict 'refs';$OPENFLAGS |= $bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}$LOCKFLAG=eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};&Fcntl::O_EXLOCK()}}my$OPENTEMPFLAGS=$OPENFLAGS;unless ($^O eq 'MacOS'){for my$oflag (qw/TEMPORARY/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);local($@);no strict 'refs';$OPENTEMPFLAGS |= $bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}}my%FILES_CREATED_BY_OBJECT;sub _gettemp {croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);' unless scalar(@_)>= 1;my$tempErrStr;my%options=("open"=>0,"mkdir"=>0,"suffixlen"=>0,"unlink_on_close"=>0,"use_exlock"=>0,"ErrStr"=>\$tempErrStr,"file_permissions"=>undef,);my$template=shift;if (ref($template)){carp "File::Temp::_gettemp: template must not be a reference";return ()}if (scalar(@_)% 2!=0){carp "File::Temp::_gettemp: Must have even number of options";return ()}%options=(%options,@_)if @_;${$options{ErrStr}}=undef;if ($options{"open"}&& $options{"mkdir"}){${$options{ErrStr}}="doopen and domkdir can not both be true\n";return ()}my$start=length($template)- 1 - $options{"suffixlen"};if (substr($template,$start - MINX + 1,MINX)ne 'X' x MINX){${$options{ErrStr}}="The template must end with at least ".MINX ." 'X' characters\n";return ()}my$path=_replace_XX($template,$options{"suffixlen"});my ($volume,$directories,$file);my$parent;if ($options{"mkdir"}){($volume,$directories,$file)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);if ($#dirs==0){$parent=File::Spec->curdir}else {if ($^O eq 'VMS'){$parent=File::Spec->catdir($volume,@dirs[0..$#dirs-1]);$parent='sys$disk:[]' if$parent eq ''}else {$parent=File::Spec->catdir(@dirs[0..$#dirs-1]);$parent=File::Spec->catpath($volume,$parent,'')}}}else {($volume,$directories,$file)=File::Spec->splitpath($path);$parent=File::Spec->catpath($volume,$directories,'');$parent=File::Spec->curdir unless$directories ne ''}unless (-e $parent){${$options{ErrStr}}="Parent directory ($parent) does not exist";return ()}unless (-d $parent){${$options{ErrStr}}="Parent directory ($parent) is not a directory";return ()}if (File::Temp->safe_level==MEDIUM){my$safeerr;unless (_is_safe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}elsif (File::Temp->safe_level==HIGH){my$safeerr;unless (_is_verysafe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}my$perms=$options{file_permissions};my$has_perms=defined$perms;$perms=0600 unless$has_perms;for (my$i=0;$i < MAX_TRIES;$i++){if ($options{"open"}){my$fh;if ($] < 5.006){$fh=&Symbol::gensym}local $^F=2;my$open_success=undef;if ($^O eq 'VMS' and $options{"unlink_on_close"}&&!$KEEP_ALL){$fh=VMS::Stdio::vmssysopen($path,$OPENFLAGS,$perms,'fop=dlt');$open_success=$fh}else {my$flags=(($options{"unlink_on_close"}&&!$KEEP_ALL)? $OPENTEMPFLAGS : $OPENFLAGS);$flags |= $LOCKFLAG if (defined$LOCKFLAG && $options{use_exlock});$open_success=sysopen($fh,$path,$flags,$perms)}if ($open_success){chmod($perms,$path)unless$has_perms;return ($fh,$path)}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create temp file $path: $!";return ()}}}elsif ($options{"mkdir"}){if (mkdir($path,0700)){chmod(0700,$path);return undef,$path}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create directory $path: $!";return ()}}}else {return (undef,$path)unless -e $path}my$original=$path;my$counter=0;my$MAX_GUESS=50;do {$path=_replace_XX($template,$options{"suffixlen"});$counter++}until ($path ne $original || $counter > $MAX_GUESS);if ($counter > $MAX_GUESS){${$options{ErrStr}}="Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";return ()}}${$options{ErrStr}}="Have exceeded the maximum number of attempts (" .MAX_TRIES .") to open temp file/dir";return ()}sub _replace_XX {croak 'Usage: _replace_XX($template, $ignore)' unless scalar(@_)==2;my ($path,$ignore)=@_;my$end=($] >= 5.006 ? "\\z" : "\\Z");if ($ignore){substr($path,0,- $ignore)=~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}else {$path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}return$path}sub _force_writable {my$file=shift;chmod 0600,$file}sub _is_safe {my$path=shift;my$err_ref=shift;my@info=stat($path);unless (scalar(@info)){$$err_ref="stat(path) returned no values";return 0};return 1 if $^O eq 'VMS';if ($info[4]> File::Temp->top_system_uid()&& $info[4]!=$>){Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",File::Temp->top_system_uid());$$err_ref="Directory owned neither by root nor the current user" if ref($err_ref);return 0}if (($info[2]& &Fcntl::S_IWGRP)|| ($info[2]& &Fcntl::S_IWOTH)){unless (-d $path){$$err_ref="Path ($path) is not a directory" if ref($err_ref);return 0}unless (-k $path){$$err_ref="Sticky bit not set on $path when dir is group|world writable" if ref($err_ref);return 0}}return 1}sub _is_verysafe {require POSIX;my$path=shift;print "_is_verysafe testing $path\n" if$DEBUG;return 1 if $^O eq 'VMS';my$err_ref=shift;local($@);my$chown_restricted;$chown_restricted=&POSIX::_PC_CHOWN_RESTRICTED()if eval {&POSIX::_PC_CHOWN_RESTRICTED();1};if (defined$chown_restricted){return _is_safe($path,$err_ref)if POSIX::sysconf($chown_restricted)}unless (File::Spec->file_name_is_absolute($path)){$path=File::Spec->rel2abs($path)}my ($volume,$directories,undef)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);for my$pos (0.. $#dirs){my$dir=File::Spec->catpath($volume,File::Spec->catdir(@dirs[0.. $#dirs - $pos]),'');print "TESTING DIR $dir\n" if$DEBUG;return 0 unless _is_safe($dir,$err_ref)}return 1}sub _can_unlink_opened_file {if (grep $^O eq $_,qw/MSWin32 os2 VMS dos MacOS haiku/){return 0}else {return 1}}sub _can_do_level {my$level=shift;return 1 if$level==STANDARD;if ($^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix'){return 0}else {return 1}}{my (%files_to_unlink,%dirs_to_unlink);END {local($.,$@,$!,$^E,$?);cleanup(at_exit=>1)}sub cleanup {my%h=@_;my$at_exit=delete$h{at_exit};$at_exit=0 if not defined$at_exit;{my@k=sort keys%h;die "unrecognized parameters: @k" if@k}if (!$KEEP_ALL){my@files=(exists$files_to_unlink{$$}? @{$files_to_unlink{$$}}: ());for my$file (@files){close($file->[0]);if (-f $file->[1]){_force_writable($file->[1]);unlink$file->[1]or warn "Error removing ".$file->[1]}}my@dirs=(exists$dirs_to_unlink{$$}? @{$dirs_to_unlink{$$}}: ());my ($cwd,$cwd_to_remove);for my$dir (@dirs){if (-d $dir){if ($at_exit){$cwd=Cwd::abs_path(File::Spec->curdir)if not defined$cwd;my$abs=Cwd::abs_path($dir);if ($abs eq $cwd){$cwd_to_remove=$dir;next}}eval {rmtree($dir,$DEBUG,0)};warn $@ if ($@ && $^W)}}if (defined$cwd_to_remove){chdir$cwd_to_remove or die "cannot chdir to $cwd_to_remove: $!";my$updir=File::Spec->updir;chdir$updir or die "cannot chdir to $updir: $!";eval {rmtree($cwd_to_remove,$DEBUG,0)};warn $@ if ($@ && $^W)}@{$files_to_unlink{$$}}=()if exists$files_to_unlink{$$};@{$dirs_to_unlink{$$}}=()if exists$dirs_to_unlink{$$}}}sub _deferred_unlink {croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)' unless scalar(@_)==3;my ($fh,$fname,$isdir)=@_;warn "Setting up deferred removal of $fname\n" if$DEBUG;$fname=Cwd::abs_path($fname);($fname)=$fname =~ /^(.*)$/;if ($isdir){if (-d $fname){$fname=VMS::Filespec::vmspath($fname)if $^O eq 'VMS';$dirs_to_unlink{$$}=[]unless exists$dirs_to_unlink{$$};push (@{$dirs_to_unlink{$$}},$fname)}else {carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W}}else {if (-f $fname){$files_to_unlink{$$}=[]unless exists$files_to_unlink{$$};push(@{$files_to_unlink{$$}},[$fh,$fname])}else {carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W}}}}sub _parse_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map +(uc($_)=>$args{$_}),keys%args;my@template=(exists$args{TEMPLATE}? $args{TEMPLATE}: $leading_template ? $leading_template : ());delete$args{TEMPLATE};return(\@template,\%args)}sub new {my$proto=shift;my$class=ref($proto)|| $proto;my ($maybe_template,$args)=_parse_args(@_);my$unlink=(exists$args->{UNLINK}? $args->{UNLINK}: 1);delete$args->{UNLINK};delete$args->{OPEN};my ($fh,$path)=tempfile(@$maybe_template,%$args);print "Tmp: $fh - $path\n" if$DEBUG;${*$fh}=$path;$FILES_CREATED_BY_OBJECT{$$}{$path}=1;%{*$fh}=%$args;bless$fh,$class;$fh->unlink_on_destroy($unlink);return$fh}sub newdir {my$self=shift;my ($maybe_template,$args)=_parse_args(@_);my$cleanup=(exists$args->{CLEANUP}? $args->{CLEANUP}: 1);delete$args->{CLEANUP};my$tempdir=tempdir(@$maybe_template,%$args);my$real_dir=Cwd::abs_path($tempdir);($real_dir)=$real_dir =~ /^(.*)$/;return bless {DIRNAME=>$tempdir,REALNAME=>$real_dir,CLEANUP=>$cleanup,LAUNCHPID=>$$,},"File::Temp::Dir"}sub filename {my$self=shift;return ${*$self}}sub STRINGIFY {my$self=shift;return$self->filename}sub NUMIFY {return refaddr($_[0])}sub unlink_on_destroy {my$self=shift;if (@_){${*$self}{UNLINK}=shift}return ${*$self}{UNLINK}}sub DESTROY {local($.,$@,$!,$^E,$?);my$self=shift;my$file=$self->filename;my$was_created_by_proc;if (exists$FILES_CREATED_BY_OBJECT{$$}{$file}){$was_created_by_proc=1;delete$FILES_CREATED_BY_OBJECT{$$}{$file}}if (${*$self}{UNLINK}&&!$KEEP_ALL){print "# --------->   Unlinking $self\n" if$DEBUG;return unless$was_created_by_proc;_force_writable($file);unlink1($self,$file)or unlink($file)}}sub tempfile {if (@_ && $_[0]eq 'File::Temp'){croak "'tempfile' can't be called as a method"}my%options=("DIR"=>undef,"SUFFIX"=>'',"UNLINK"=>0,"OPEN"=>1,"TMPDIR"=>0,"EXLOCK"=>0,"PERMS"=>undef,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (!$options{"OPEN"}){warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n" if $^W}if ($options{"DIR"}and $^O eq 'VMS'){$options{"DIR"}=VMS::Filespec::vmspath($options{"DIR"})}if (defined$template){if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catfile(_wrap_file_spec_tmpdir(),$template)}}else {if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catfile(_wrap_file_spec_tmpdir(),TEMPXXX)}}$template .= $options{"SUFFIX"};my$unlink_on_close=(wantarray ? 0 : 1);my ($fh,$path,$errstr);croak "Error in tempfile() using template $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>$options{OPEN},"mkdir"=>0,"unlink_on_close"=>$unlink_on_close,"suffixlen"=>length($options{SUFFIX}),"ErrStr"=>\$errstr,"use_exlock"=>$options{EXLOCK},"file_permissions"=>$options{PERMS},));_deferred_unlink($fh,$path,0)if$options{"UNLINK"};if (wantarray()){if ($options{'OPEN'}){return ($fh,$path)}else {return (undef,$path)}}else {unlink0($fh,$path)or croak "Error unlinking file $path using unlink0";return$fh}}{my ($alt_tmpdir,$checked);sub _wrap_file_spec_tmpdir {return File::Spec->tmpdir unless $^O eq "MSWin32" && ${^TAINT};if ($checked){return$alt_tmpdir ? $alt_tmpdir : File::Spec->tmpdir}my$xxpath=_replace_XX("X" x 10,0);my$tmpdir=File::Spec->tmpdir;my$testpath=File::Spec->catdir($tmpdir,$xxpath);if (mkdir($testpath,0700)){$checked=1;rmdir$testpath;return$tmpdir}require Win32;my$local_app=File::Spec->catdir(Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA()),'Temp');$testpath=File::Spec->catdir($local_app,$xxpath);if (-e $local_app or mkdir($local_app,0700)){if (mkdir($testpath,0700)){$checked=1;rmdir$testpath;return$alt_tmpdir=$local_app}}croak << "HERE"}}sub tempdir {if (@_ && $_[0]eq 'File::Temp'){croak "'tempdir' can't be called as a method"}my%options=("CLEANUP"=>0,"DIR"=>'',"TMPDIR"=>0,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (defined$template){if ($options{'TMPDIR'}|| $options{'DIR'}){$template=VMS::Filespec::vmspath($template)if $^O eq 'VMS';my ($volume,$directories,undef)=File::Spec->splitpath($template,1);$template=(File::Spec->splitdir($directories))[-1];if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catdir(_wrap_file_spec_tmpdir(),$template)}}}else {if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catdir(_wrap_file_spec_tmpdir(),TEMPXXX)}}my$tempdir;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my$errstr;croak "Error in tempdir() using $template: $errstr" unless ((undef,$tempdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));if ($options{'CLEANUP'}&& -d $tempdir){_deferred_unlink(undef,$tempdir,1)}return$tempdir}sub mkstemp {croak "Usage: mkstemp(template)" if scalar(@_)!=1;my$template=shift;my ($fh,$path,$errstr);croak "Error in mkstemp using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkstemps {croak "Usage: mkstemps(template, suffix)" if scalar(@_)!=2;my$template=shift;my$suffix=shift;$template .= $suffix;my ($fh,$path,$errstr);croak "Error in mkstemps using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>length($suffix),"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkdtemp {croak "Usage: mkdtemp(template)" if scalar(@_)!=1;my$template=shift;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my ($junk,$tmpdir,$errstr);croak "Error creating temp directory from template $template\: $errstr" unless (($junk,$tmpdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));return$tmpdir}sub mktemp {croak "Usage: mktemp(template)" if scalar(@_)!=1;my$template=shift;my ($tmpname,$junk,$errstr);croak "Error getting name to temp file from template $template: $errstr" unless (($junk,$tmpname)=_gettemp($template,"open"=>0,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));return$tmpname}sub tmpnam {my$tmpdir=_wrap_file_spec_tmpdir();croak "Error temporary directory is not writable" if$tmpdir eq '';my$template=File::Spec->catfile($tmpdir,TEMPXXX);if (wantarray()){return mkstemp($template)}else {return mktemp($template)}}sub tmpfile {my ($fh,$file)=tmpnam();unlink0($fh,$file)or return undef;return$fh}sub tempnam {croak 'Usage tempnam($dir, $prefix)' unless scalar(@_)==2;my ($dir,$prefix)=@_;$prefix .= 'XXXXXXXX';my$template=File::Spec->catfile($dir,$prefix);return mktemp($template)}sub unlink0 {croak 'Usage: unlink0(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;if (_can_unlink_opened_file()){return 1 if$KEEP_ALL;croak "unlink0: $path has become a directory!" if -d $path;unlink($path)or return 0;my@fh=stat$fh;print "Link count = $fh[3] \n" if$DEBUG;return 1 if$fh[3]==0 || $^O eq 'cygwin'}_deferred_unlink($fh,$path,0);return 1}sub cmpstat {croak 'Usage: cmpstat(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;warn "Comparing stat\n" if$DEBUG;my@fh;{local ($^W)=0;@fh=stat$fh}return unless@fh;if ($fh[3]> 1 && $^W){carp "unlink0: fstat found too many links; SB=@fh" if $^W}my@path=stat$path;unless (@path){carp "unlink0: $path is gone already" if $^W;return}unless (-f $path){confess "panic: $path is no longer a file: SB=@fh"}my@okstat=(0..$#fh);if ($^O eq 'MSWin32'){@okstat=(1,2,3,4,5,7,8,9,10)}elsif ($^O eq 'os2'){@okstat=(0,2..$#fh)}elsif ($^O eq 'VMS'){@okstat=(0,1)}elsif ($^O eq 'dos'){@okstat=(0,2..7,11..$#fh)}elsif ($^O eq 'mpeix'){@okstat=(0..4,8..10)}for (@okstat){print "Comparing: $_ : $fh[$_] and $path[$_]\n" if$DEBUG;unless ($fh[$_]eq $path[$_]){warn "Did not match $_ element of stat\n" if$DEBUG;return 0}}return 1}sub unlink1 {croak 'Usage: unlink1(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;close($fh)or return 0;_force_writable($path);return 1 if$KEEP_ALL;return unlink($path)}{my$LEVEL=STANDARD;sub safe_level {my$self=shift;if (@_){my$level=shift;if (($level!=STANDARD)&& ($level!=MEDIUM)&& ($level!=HIGH)){carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W}else {if ($] < 5.006 && $level!=STANDARD){croak "Currently requires perl 5.006 or newer to do the safe checks"}$LEVEL=$level if _can_do_level($level)}}return$LEVEL}}{my$TopSystemUID=10;$TopSystemUID=197108 if $^O eq 'interix';sub top_system_uid {my$self=shift;if (@_){my$newuid=shift;croak "top_system_uid: UIDs should be numeric" unless$newuid =~ /^\d+$/s;$TopSystemUID=$newuid}return$TopSystemUID}}package File::Temp::Dir;our$VERSION='0.2311';use File::Path qw/rmtree/;use strict;use overload '""'=>"STRINGIFY",'0+'=>\&File::Temp::NUMIFY,fallback=>1;sub dirname {my$self=shift;return$self->{DIRNAME}}sub STRINGIFY {my$self=shift;return$self->dirname}sub unlink_on_destroy {my$self=shift;if (@_){$self->{CLEANUP}=shift}return$self->{CLEANUP}}sub DESTROY {my$self=shift;local($.,$@,$!,$^E,$?);if ($self->unlink_on_destroy && $$==$self->{LAUNCHPID}&&!$File::Temp::KEEP_ALL){if (-d $self->{REALNAME}){eval {rmtree($self->{REALNAME},$File::Temp::DEBUG,0)};warn $@ if ($@ && $^W)}}}1;
  Couldn't find a writable temp directory in taint mode. Tried:
    $tmpdir
    $local_app
  
  Try setting and untainting the TMPDIR environment variable.
  HERE
FILE_TEMP

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='1.23';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if($^O eq 'MSWin32'){@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;use strict;use warnings;our$VERSION='0.076';sub _croak {require Carp;Carp::croak(@_)}my@attributes;BEGIN {@attributes=qw(cookie_jar default_headers http_proxy https_proxy keep_alive local_address max_redirect max_size proxy no_proxy SSL_options verify_SSL);my%persist_ok=map {;$_=>1}qw(cookie_jar default_headers max_redirect max_size);no strict 'refs';no warnings 'uninitialized';for my$accessor (@attributes){*{$accessor}=sub {@_ > 1 ? do {delete $_[0]->{handle}if!$persist_ok{$accessor}&& $_[1]ne $_[0]->{$accessor};$_[0]->{$accessor}=$_[1]}: $_[0]->{$accessor}}}}sub agent {my($self,$agent)=@_;if(@_ > 1){$self->{agent}=(defined$agent && $agent =~ / $/)? $agent .$self->_agent : $agent}return$self->{agent}}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{handle}){$self->{handle}->timeout($timeout)}}return$self->{timeout}}sub new {my($class,%args)=@_;my$self={max_redirect=>5,timeout=>defined$args{timeout}? $args{timeout}: 60,keep_alive=>1,verify_SSL=>$args{verify_SSL}|| $args{verify_ssl}|| 0,no_proxy=>$ENV{no_proxy},};bless$self,$class;$class->_validate_cookie_jar($args{cookie_jar})if$args{cookie_jar};for my$key (@attributes){$self->{$key}=$args{$key}if exists$args{$key}}$self->agent(exists$args{agent}? $args{agent}: $class->_agent);$self->_set_proxies;return$self}sub _set_proxies {my ($self)=@_;if (!exists$self->{proxy}){$self->{proxy}=$ENV{all_proxy}|| $ENV{ALL_PROXY}}if (defined$self->{proxy}){$self->_split_proxy('generic proxy'=>$self->{proxy})}else {delete$self->{proxy}}if (!exists$self->{http_proxy}){local$ENV{HTTP_PROXY}if$ENV{REQUEST_METHOD};$self->{http_proxy}=$ENV{http_proxy}|| $ENV{HTTP_PROXY}|| $self->{proxy}}if (defined$self->{http_proxy}){$self->_split_proxy(http_proxy=>$self->{http_proxy});$self->{_has_proxy}{http}=1}else {delete$self->{http_proxy}}if (!exists$self->{https_proxy}){$self->{https_proxy}=$ENV{https_proxy}|| $ENV{HTTPS_PROXY}|| $self->{proxy}}if ($self->{https_proxy}){$self->_split_proxy(https_proxy=>$self->{https_proxy});$self->{_has_proxy}{https}=1}else {delete$self->{https_proxy}}unless (ref$self->{no_proxy}eq 'ARRAY'){$self->{no_proxy}=(defined$self->{no_proxy})? [split /\s*,\s*/,$self->{no_proxy}]: []}return}for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;no strict 'refs';eval <<"HERE"}sub post_form {my ($self,$url,$data,$args)=@_;(@_==3 || @_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ ."\n");my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}delete$args->{headers};return$self->request('POST',$url,{%$args,content=>$self->www_form_urlencode($data),headers=>{%$headers,'content-type'=>'application/x-www-form-urlencoded' },})}sub mirror {my ($self,$url,$file,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ ."\n");if (exists$args->{headers}){my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}$args->{headers}=$headers}if (-e $file and my$mtime=(stat($file))[9]){$args->{headers}{'if-modified-since'}||= $self->_http_date($mtime)}my$tempfile=$file .int(rand(2**31));require Fcntl;sysopen my$fh,$tempfile,Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);binmode$fh;$args->{data_callback}=sub {print {$fh}$_[0]};my$response=$self->request('GET',$url,$args);close$fh or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);if ($response->{success}){rename$tempfile,$file or _croak(qq/Error replacing $file with $tempfile: $!\n/);my$lm=$response->{headers}{'last-modified'};if ($lm and my$mtime=$self->_parse_http_date($lm)){utime$mtime,$mtime,$file}}$response->{success}||= $response->{status}eq '304';unlink$tempfile;return$response}my%idempotent=map {$_=>1}qw/GET HEAD PUT DELETE OPTIONS TRACE/;sub request {my ($self,$method,$url,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ ."\n");$args ||= {};my$response;for (0 .. 1){$response=eval {$self->_request($method,$url,$args)};last unless $@ && $idempotent{$method}&& $@ =~ m{^(?:Socket closed|Unexpected end)}}if (my$e=$@){if (ref$e eq 'HASH' && exists$e->{status}){$e->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}|| []};return$e}$e="$e";$response={url=>$url,success=>q{},status=>599,reason=>'Internal Exception',content=>$e,headers=>{'content-type'=>'text/plain','content-length'=>length$e,},(@{$args->{_redirects}|| []}? (redirects=>delete$args->{_redirects}): ()),}}return$response}sub www_form_urlencode {my ($self,$data)=@_;(@_==2 && ref$data)or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ ."\n");(ref$data eq 'HASH' || ref$data eq 'ARRAY')or _croak("form data must be a hash or array reference\n");my@params=ref$data eq 'HASH' ? %$data : @$data;@params % 2==0 or _croak("form data reference must have an even number of terms\n");my@terms;while(@params){my ($key,$value)=splice(@params,0,2);if (ref$value eq 'ARRAY'){unshift@params,map {$key=>$_}@$value}else {push@terms,join("=",map {$self->_uri_escape($_)}$key,$value)}}return join("&",(ref$data eq 'ARRAY')? (@terms): (sort@terms))}sub can_ssl {my ($self)=@_;my($ok,$reason)=(1,'');local@INC=@INC;pop@INC if$INC[-1]eq '.';unless (eval {require IO::Socket::SSL;IO::Socket::SSL->VERSION(1.42)}){$ok=0;$reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/}unless (eval {require Net::SSLeay;Net::SSLeay->VERSION(1.49)}){$ok=0;$reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/}if (ref($self)&& ($self->{verify_SSL}|| $self->{SSL_options}{SSL_verify_mode})){my$handle=HTTP::Tiny::Handle->new(SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},);unless (eval {$handle->_find_CA_file;1}){$ok=0;$reason .= "$@"}}wantarray ? ($ok,$reason): $ok}sub connected {my ($self)=@_;if ($self->{handle}&& $self->{handle}{fh}){my$socket=$self->{handle}{fh};if ($socket->connected){return wantarray ? ($socket->peerhost,$socket->peerport): join(':',$socket->peerhost,$socket->peerport)}}return}my%DefaultPort=(http=>80,https=>443,);sub _agent {my$class=ref($_[0])|| $_[0];(my$default_agent=$class)=~ s{::}{-}g;return$default_agent ."/" .$class->VERSION}sub _request {my ($self,$method,$url,$args)=@_;my ($scheme,$host,$port,$path_query,$auth)=$self->_split_url($url);my$request={method=>$method,scheme=>$scheme,host=>$host,port=>$port,host_port=>($port==$DefaultPort{$scheme}? $host : "$host:$port"),uri=>$path_query,headers=>{},};my$peer=$args->{peer}|| $host;if ('CODE' eq ref$peer){$peer=$peer->($host)}my$handle=delete$self->{handle};if ($handle){unless ($handle->can_reuse($scheme,$host,$port,$peer)){$handle->close;undef$handle}}$handle ||= $self->_open_handle($request,$scheme,$host,$port,$peer);$self->_prepare_headers_and_cb($request,$args,$url,$auth);$handle->write_request($request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');$self->_update_cookie_jar($url,$response)if$self->{cookie_jar};my@redir_args=$self->_maybe_redirect($request,$response,$args);my$known_message_length;if ($method eq 'HEAD' || $response->{status}=~ /^[23]04/){$known_message_length=1}else {my$cb_args=@redir_args ? +{}: $args;my$data_cb=$self->_prepare_data_cb($response,$cb_args);$known_message_length=$handle->read_body($data_cb,$response)}if ($self->{keep_alive}&& $known_message_length && $response->{protocol}eq 'HTTP/1.1' && ($response->{headers}{connection}|| '')ne 'close'){$self->{handle}=$handle}else {$handle->close}$response->{success}=substr($response->{status},0,1)eq '2';$response->{url}=$url;if (@redir_args){push @{$args->{_redirects}},$response;return$self->_request(@redir_args,$args)}$response->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}};return$response}sub _open_handle {my ($self,$request,$scheme,$host,$port,$peer)=@_;my$handle=HTTP::Tiny::Handle->new(timeout=>$self->{timeout},SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},local_address=>$self->{local_address},keep_alive=>$self->{keep_alive});if ($self->{_has_proxy}{$scheme}&&!grep {$host =~ /\Q$_\E$/}@{$self->{no_proxy}}){return$self->_proxy_connect($request,$handle)}else {return$handle->connect($scheme,$host,$port,$peer)}}sub _proxy_connect {my ($self,$request,$handle)=@_;my@proxy_vars;if ($request->{scheme}eq 'https'){_croak(qq{No https_proxy defined})unless$self->{https_proxy};@proxy_vars=$self->_split_proxy(https_proxy=>$self->{https_proxy});if ($proxy_vars[0]eq 'https'){_croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}})}}else {_croak(qq{No http_proxy defined})unless$self->{http_proxy};@proxy_vars=$self->_split_proxy(http_proxy=>$self->{http_proxy})}my ($p_scheme,$p_host,$p_port,$p_auth)=@proxy_vars;if (length$p_auth &&!defined$request->{headers}{'proxy-authorization'}){$self->_add_basic_auth_header($request,'proxy-authorization'=>$p_auth)}$handle->connect($p_scheme,$p_host,$p_port,$p_host);if ($request->{scheme}eq 'https'){$self->_create_proxy_tunnel($request,$handle)}else {$request->{uri}="$request->{scheme}://$request->{host_port}$request->{uri}"}return$handle}sub _split_proxy {my ($self,$type,$proxy)=@_;my ($scheme,$host,$port,$path_query,$auth)=eval {$self->_split_url($proxy)};unless(defined($scheme)&& length($scheme)&& length($host)&& length($port)&& $path_query eq '/'){_croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n})}return ($scheme,$host,$port,$auth)}sub _create_proxy_tunnel {my ($self,$request,$handle)=@_;$handle->_assert_ssl;my$agent=exists($request->{headers}{'user-agent'})? $request->{headers}{'user-agent'}: $self->{agent};my$connect_request={method=>'CONNECT',uri=>"$request->{host}:$request->{port}",headers=>{host=>"$request->{host}:$request->{port}",'user-agent'=>$agent,}};if ($request->{headers}{'proxy-authorization'}){$connect_request->{headers}{'proxy-authorization'}=delete$request->{headers}{'proxy-authorization'}}$handle->write_request($connect_request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');unless (substr($response->{status},0,1)eq '2'){die$response}$handle->start_ssl($request->{host});return}sub _prepare_headers_and_cb {my ($self,$request,$args,$url,$auth)=@_;for ($self->{default_headers},$args->{headers}){next unless defined;while (my ($k,$v)=each %$_){$request->{headers}{lc$k}=$v;$request->{header_case}{lc$k}=$k}}if (exists$request->{headers}{'host'}){die(qq/The 'Host' header must not be provided as header option\n/)}$request->{headers}{'host'}=$request->{host_port};$request->{headers}{'user-agent'}||= $self->{agent};$request->{headers}{'connection'}="close" unless$self->{keep_alive};if (defined$args->{content}){if (ref$args->{content}eq 'CODE'){$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'transfer-encoding'}='chunked' unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=$args->{content}}elsif (length$args->{content}){my$content=$args->{content};if ($] ge '5.008'){utf8::downgrade($content,1)or die(qq/Wide character in request message body\n/)}$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'content-length'}=length$content unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=sub {substr$content,0,length$content,''}}$request->{trailer_cb}=$args->{trailer_callback}if ref$args->{trailer_callback}eq 'CODE'}if ($self->{cookie_jar}){my$cookies=$self->cookie_jar->cookie_header($url);$request->{headers}{cookie}=$cookies if length$cookies}if (length$auth &&!defined$request->{headers}{authorization}){$self->_add_basic_auth_header($request,'authorization'=>$auth)}return}sub _add_basic_auth_header {my ($self,$request,$header,$auth)=@_;require MIME::Base64;$request->{headers}{$header}="Basic " .MIME::Base64::encode_base64($auth,"");return}sub _prepare_data_cb {my ($self,$response,$args)=@_;my$data_cb=$args->{data_callback};$response->{content}='';if (!$data_cb || $response->{status}!~ /^2/){if (defined$self->{max_size}){$data_cb=sub {$_[1]->{content}.= $_[0];die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)if length $_[1]->{content}> $self->{max_size}}}else {$data_cb=sub {$_[1]->{content}.= $_[0]}}}return$data_cb}sub _update_cookie_jar {my ($self,$url,$response)=@_;my$cookies=$response->{headers}->{'set-cookie'};return unless defined$cookies;my@cookies=ref$cookies ? @$cookies : $cookies;$self->cookie_jar->add($url,$_)for@cookies;return}sub _validate_cookie_jar {my ($class,$jar)=@_;for my$method (qw/add cookie_header/){_croak(qq/Cookie jar must provide the '$method' method\n/)unless ref($jar)&& ref($jar)->can($method)}return}sub _maybe_redirect {my ($self,$request,$response,$args)=@_;my$headers=$response->{headers};my ($status,$method)=($response->{status},$request->{method});$args->{_redirects}||= [];if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))and $headers->{location}and @{$args->{_redirects}}< $self->{max_redirect}){my$location=($headers->{location}=~ /^\//)? "$request->{scheme}://$request->{host_port}$headers->{location}" : $headers->{location};return (($status eq '303' ? 'GET' : $method),$location)}return}sub _split_url {my$url=pop;my ($scheme,$host,$path_query)=$url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)> or die(qq/Cannot parse URL: '$url'\n/);$scheme=lc$scheme;$path_query="/$path_query" unless$path_query =~ m<\A/>;my$auth='';if ((my$i=index$host,'@')!=-1){$auth=substr$host,0,$i,'';substr$host,0,1,'';$auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}my$port=$host =~ s/:(\d*)\z// && length $1 ? $1 : $scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef;return ($scheme,(length$host ? lc$host : "localhost"),$port,$path_query,$auth)}my$DoW="Sun|Mon|Tue|Wed|Thu|Fri|Sat";my$MoY="Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";sub _http_date {my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($_[1]);return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",substr($DoW,$wday*4,3),$mday,substr($MoY,$mon*4,3),$year+1900,$hour,$min,$sec)}sub _parse_http_date {my ($self,$str)=@_;require Time::Local;my@tl_parts;if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/){@tl_parts=($5,$4,$3,$2,(index($MoY,$1)/4),$6)}return eval {my$t=@tl_parts ? Time::Local::timegm(@tl_parts): -1;$t < 0 ? undef : $t}}my%escapes=map {chr($_)=>sprintf("%%%02X",$_)}0..255;$escapes{' '}="+";my$unsafe_char=qr/[^A-Za-z0-9\-\._~]/;sub _uri_escape {my ($self,$str)=@_;if ($] ge '5.008'){utf8::encode($str)}else {$str=pack("U*",unpack("C*",$str))if (length$str==do {use bytes;length$str});$str=pack("C*",unpack("C*",$str))}$str =~ s/($unsafe_char)/$escapes{$1}/g;return$str}package HTTP::Tiny::Handle;use strict;use warnings;use Errno qw[EINTR EPIPE];use IO::Socket qw[SOCK_STREAM];use Socket qw[SOL_SOCKET SO_KEEPALIVE];my$SOCKET_CLASS=$ENV{PERL_HTTP_TINY_IPV4_ONLY}? 'IO::Socket::INET' : eval {require IO::Socket::IP;IO::Socket::IP->VERSION(0.25)}? 'IO::Socket::IP' : 'IO::Socket::INET';sub BUFSIZE () {32768}my$Printable=sub {local $_=shift;s/\r/\\r/g;s/\n/\\n/g;s/\t/\\t/g;s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;$_};my$Token=qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;my$Field_Content=qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;sub new {my ($class,%args)=@_;return bless {rbuf=>'',timeout=>60,max_line_size=>16384,max_header_lines=>64,verify_SSL=>0,SSL_options=>{},%args },$class}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{fh}&& $self->{fh}->can('timeout')){$self->{fh}->timeout($timeout)}}return$self->{timeout}}sub connect {@_==5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ ."\n");my ($self,$scheme,$host,$port,$peer)=@_;if ($scheme eq 'https'){$self->_assert_ssl}elsif ($scheme ne 'http'){die(qq/Unsupported URL scheme '$scheme'\n/)}$self->{fh}=$SOCKET_CLASS->new(PeerHost=>$peer,PeerPort=>$port,$self->{local_address}? (LocalAddr=>$self->{local_address}): (),Proto=>'tcp',Type=>SOCK_STREAM,Timeout=>$self->{timeout},)or die(qq/Could not connect to '$host:$port': $@\n/);binmode($self->{fh})or die(qq/Could not binmode() socket: '$!'\n/);if ($self->{keep_alive}){unless (defined($self->{fh}->setsockopt(SOL_SOCKET,SO_KEEPALIVE,1))){CORE::close($self->{fh});die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/)}}$self->start_ssl($host)if$scheme eq 'https';$self->{scheme}=$scheme;$self->{host}=$host;$self->{peer}=$peer;$self->{port}=$port;$self->{pid}=$$;$self->{tid}=_get_tid();return$self}sub start_ssl {my ($self,$host)=@_;if (ref($self->{fh})eq 'IO::Socket::SSL'){unless ($self->{fh}->stop_SSL){my$ssl_err=IO::Socket::SSL->errstr;die(qq/Error halting prior SSL connection: $ssl_err/)}}my$ssl_args=$self->_ssl_args($host);IO::Socket::SSL->start_SSL($self->{fh},%$ssl_args,SSL_create_ctx_callback=>sub {my$ctx=shift;Net::SSLeay::CTX_set_mode($ctx,Net::SSLeay::MODE_AUTO_RETRY())},);unless (ref($self->{fh})eq 'IO::Socket::SSL'){my$ssl_err=IO::Socket::SSL->errstr;die(qq/SSL connection failed for $host: $ssl_err\n/)}}sub close {@_==1 || die(q/Usage: $handle->close()/ ."\n");my ($self)=@_;CORE::close($self->{fh})or die(qq/Could not close socket: '$!'\n/)}sub write {@_==2 || die(q/Usage: $handle->write(buf)/ ."\n");my ($self,$buf)=@_;if ($] ge '5.008'){utf8::downgrade($buf,1)or die(qq/Wide character in write()\n/)}my$len=length$buf;my$off=0;local$SIG{PIPE}='IGNORE';while (){$self->can_write or die(qq/Timed out while waiting for socket to become ready for writing\n/);my$r=syswrite($self->{fh},$buf,$len,$off);if (defined$r){$len -= $r;$off += $r;last unless$len > 0}elsif ($!==EPIPE){die(qq/Socket closed by remote server: $!\n/)}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not write to SSL socket: '$err'\n /)}else {die(qq/Could not write to socket: '$!'\n/)}}}return$off}sub read {@_==2 || @_==3 || die(q/Usage: $handle->read(len [, allow_partial])/ ."\n");my ($self,$len,$allow_partial)=@_;my$buf='';my$got=length$self->{rbuf};if ($got){my$take=($got < $len)? $got : $len;$buf=substr($self->{rbuf},0,$take,'');$len -= $take}while ($len > 0){$self->can_read or die(q/Timed out while waiting for socket to become ready for reading/ ."\n");my$r=sysread($self->{fh},$buf,$len,length$buf);if (defined$r){last unless$r;$len -= $r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}if ($len &&!$allow_partial){die(qq/Unexpected end of stream\n/)}return$buf}sub readline {@_==1 || die(q/Usage: $handle->readline()/ ."\n");my ($self)=@_;while (){if ($self->{rbuf}=~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x){return $1}if (length$self->{rbuf}>= $self->{max_line_size}){die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/)}$self->can_read or die(qq/Timed out while waiting for socket to become ready for reading\n/);my$r=sysread($self->{fh},$self->{rbuf},BUFSIZE,length$self->{rbuf});if (defined$r){last unless$r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}die(qq/Unexpected end of stream while looking for line\n/)}sub read_header_lines {@_==1 || @_==2 || die(q/Usage: $handle->read_header_lines([headers])/ ."\n");my ($self,$headers)=@_;$headers ||= {};my$lines=0;my$val;while (){my$line=$self->readline;if (++$lines >= $self->{max_header_lines}){die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/)}elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x){my ($field_name)=lc $1;if (exists$headers->{$field_name}){for ($headers->{$field_name}){$_=[$_]unless ref $_ eq "ARRAY";push @$_,$2;$val=\$_->[-1]}}else {$val=\($headers->{$field_name}=$2)}}elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x){$val or die(qq/Unexpected header continuation line\n/);next unless length $1;$$val .= ' ' if length $$val;$$val .= $1}elsif ($line =~ /\A \x0D?\x0A \z/x){last}else {die(q/Malformed header line: / .$Printable->($line)."\n")}}return$headers}sub write_request {@_==2 || die(q/Usage: $handle->write_request(request)/ ."\n");my($self,$request)=@_;$self->write_request_header(@{$request}{qw/method uri headers header_case/});$self->write_body($request)if$request->{cb};return}my@rfc_request_headers=qw(Accept Accept-Charset Accept-Encoding Accept-Language Authorization Cache-Control Connection Content-Length Expect From Host If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer Transfer-Encoding Upgrade User-Agent Via);my@other_request_headers=qw(Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin X-XSS-Protection);my%HeaderCase=map {lc($_)=>$_}@rfc_request_headers,@other_request_headers;sub write_header_lines {(@_ >= 2 && @_ <= 4 && ref $_[1]eq 'HASH')|| die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ ."\n");my($self,$headers,$header_case,$prefix_data)=@_;$header_case ||= {};my$buf=(defined$prefix_data ? $prefix_data : '');my%seen;for my$k (qw/host cache-control expect max-forwards pragma range te/){next unless exists$headers->{$k};$seen{$k}++;my$field_name=$HeaderCase{$k};my$v=$headers->{$k};for (ref$v eq 'ARRAY' ? @$v : $v){$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}while (my ($k,$v)=each %$headers){my$field_name=lc$k;next if$seen{$field_name};if (exists$HeaderCase{$field_name}){$field_name=$HeaderCase{$field_name}}else {if (exists$header_case->{$field_name}){$field_name=$header_case->{$field_name}}else {$field_name =~ s/\b(\w)/\u$1/g}$field_name =~ /\A $Token+ \z/xo or die(q/Invalid HTTP header field name: / .$Printable->($field_name)."\n");$HeaderCase{lc$field_name}=$field_name}for (ref$v eq 'ARRAY' ? @$v : $v){s/\x0D?\x0A\s+/ /g;die(qq/Invalid HTTP header field value ($field_name): / .$Printable->($_)."\n")unless $_ eq '' || /\A $Field_Content \z/xo;$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}$buf .= "\x0D\x0A";return$self->write($buf)}sub read_body {@_==3 || die(q/Usage: $handle->read_body(callback, response)/ ."\n");my ($self,$cb,$response)=@_;my$te=$response->{headers}{'transfer-encoding'}|| '';my$chunked=grep {/chunked/i}(ref$te eq 'ARRAY' ? @$te : $te);return$chunked ? $self->read_chunked_body($cb,$response): $self->read_content_body($cb,$response)}sub write_body {@_==2 || die(q/Usage: $handle->write_body(request)/ ."\n");my ($self,$request)=@_;if ($request->{headers}{'content-length'}){return$self->write_content_body($request)}else {return$self->write_chunked_body($request)}}sub read_content_body {@_==3 || @_==4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ ."\n");my ($self,$cb,$response,$content_length)=@_;$content_length ||= $response->{headers}{'content-length'};if (defined$content_length){my$len=$content_length;while ($len > 0){my$read=($len > BUFSIZE)? BUFSIZE : $len;$cb->($self->read($read,0),$response);$len -= $read}return length($self->{rbuf})==0}my$chunk;$cb->($chunk,$response)while length($chunk=$self->read(BUFSIZE,1));return}sub write_content_body {@_==2 || die(q/Usage: $handle->write_content_body(request)/ ."\n");my ($self,$request)=@_;my ($len,$content_length)=(0,$request->{headers}{'content-length'});while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_content()\n/)}$len += $self->write($data)}$len==$content_length or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);return$len}sub read_chunked_body {@_==3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ ."\n");my ($self,$cb,$response)=@_;while (){my$head=$self->readline;$head =~ /\A ([A-Fa-f0-9]+)/x or die(q/Malformed chunk head: / .$Printable->($head)."\n");my$len=hex($1)or last;$self->read_content_body($cb,$response,$len);$self->read(2)eq "\x0D\x0A" or die(qq/Malformed chunk: missing CRLF after chunk data\n/)}$self->read_header_lines($response->{headers});return 1}sub write_chunked_body {@_==2 || die(q/Usage: $handle->write_chunked_body(request)/ ."\n");my ($self,$request)=@_;my$len=0;while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_chunked_body()\n/)}$len += length$data;my$chunk=sprintf '%X',length$data;$chunk .= "\x0D\x0A";$chunk .= $data;$chunk .= "\x0D\x0A";$self->write($chunk)}$self->write("0\x0D\x0A");if (ref$request->{trailer_cb}eq 'CODE'){$self->write_header_lines($request->{trailer_cb}->())}else {$self->write("\x0D\x0A")}return$len}sub read_response_header {@_==1 || die(q/Usage: $handle->read_response_header()/ ."\n");my ($self)=@_;my$line=$self->readline;$line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x or die(q/Malformed Status-Line: / .$Printable->($line)."\n");my ($protocol,$version,$status,$reason)=($1,$2,$3,$4);die (qq/Unsupported HTTP protocol: $protocol\n/)unless$version =~ /0*1\.0*[01]/;return {status=>$status,reason=>$reason,headers=>$self->read_header_lines,protocol=>$protocol,}}sub write_request_header {@_==5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ ."\n");my ($self,$method,$request_uri,$headers,$header_case)=@_;return$self->write_header_lines($headers,$header_case,"$method $request_uri HTTP/1.1\x0D\x0A")}sub _do_timeout {my ($self,$type,$timeout)=@_;$timeout=$self->{timeout}unless defined$timeout && $timeout >= 0;my$fd=fileno$self->{fh};defined$fd && $fd >= 0 or die(qq/select(2): 'Bad file descriptor'\n/);my$initial=time;my$pending=$timeout;my$nfound;vec(my$fdset='',$fd,1)=1;while (){$nfound=($type eq 'read')? select($fdset,undef,undef,$pending): select(undef,$fdset,undef,$pending);if ($nfound==-1){$!==EINTR or die(qq/select(2): '$!'\n/);redo if!$timeout || ($pending=$timeout - (time - $initial))> 0;$nfound=0}last}$!=0;return$nfound}sub can_read {@_==1 || @_==2 || die(q/Usage: $handle->can_read([timeout])/ ."\n");my$self=shift;if (ref($self->{fh})eq 'IO::Socket::SSL'){return 1 if$self->{fh}->pending}return$self->_do_timeout('read',@_)}sub can_write {@_==1 || @_==2 || die(q/Usage: $handle->can_write([timeout])/ ."\n");my$self=shift;return$self->_do_timeout('write',@_)}sub _assert_ssl {my($ok,$reason)=HTTP::Tiny->can_ssl();die$reason unless$ok}sub can_reuse {my ($self,$scheme,$host,$port,$peer)=@_;return 0 if $self->{pid}!=$$ || $self->{tid}!=_get_tid()|| length($self->{rbuf})|| $scheme ne $self->{scheme}|| $host ne $self->{host}|| $port ne $self->{port}|| $peer ne $self->{peer}|| eval {$self->can_read(0)}|| $@ ;return 1}sub _find_CA_file {my$self=shift();my$ca_file=defined($self->{SSL_options}->{SSL_ca_file})? $self->{SSL_options}->{SSL_ca_file}: $ENV{SSL_CERT_FILE};if (defined$ca_file){unless (-r $ca_file){die qq/SSL_ca_file '$ca_file' not found or not readable\n/}return$ca_file}local@INC=@INC;pop@INC if$INC[-1]eq '.';return Mozilla::CA::SSL_ca_file()if eval {require Mozilla::CA;1};for my$ca_bundle ("/etc/ssl/certs/ca-certificates.crt","/etc/pki/tls/certs/ca-bundle.crt","/etc/ssl/ca-bundle.pem","/etc/openssl/certs/ca-certificates.crt","/etc/ssl/cert.pem","/usr/local/share/certs/ca-root-nss.crt","/etc/pki/tls/cacert.pem","/etc/certs/ca-certificates.crt",){return$ca_bundle if -e $ca_bundle}die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/ .qq/Try installing Mozilla::CA from CPAN\n/}sub _get_tid {no warnings 'reserved';return threads->can("tid")? threads->tid : 0}sub _ssl_args {my ($self,$host)=@_;my%ssl_args;if (Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x01000000){$ssl_args{SSL_hostname}=$host,}if ($self->{verify_SSL}){$ssl_args{SSL_verifycn_scheme}='http';$ssl_args{SSL_verifycn_name}=$host;$ssl_args{SSL_verify_mode}=0x01;$ssl_args{SSL_ca_file}=$self->_find_CA_file}else {$ssl_args{SSL_verifycn_scheme}='none';$ssl_args{SSL_verify_mode}=0x00}for my$k (keys %{$self->{SSL_options}}){$ssl_args{$k}=$self->{SSL_options}{$k}if$k =~ m/^SSL_/}return \%ssl_args}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
HTTP_TINY

$fatpacked{"HTTP/Tinyish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.17';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror patch/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my($self,$url)=@_;my($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

$fatpacked{"HTTP/Tinyish/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete patch/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if(/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

$fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version'],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my($self,$url,$opts)=@_;my@options=('--location','--silent','--show-error','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

$fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

$fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field}=$hdrs->header($field)}\%headers}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

$fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my(undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::PP::ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();$JSON::PP::VERSION='4.06';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true}else {delete$self->{false};delete$self->{true}}return$self}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){if (!$relaxed or $ch ne "\t"){$at--;decode_error('invalid character encountered while parsing JSON string')}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::PP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::PP::Boolean::VERSION='4.06';1;
JSON_PP_BOOLEAN

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;use strict;use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);use Module::Pluggable::Object;use if $] > 5.017,'deprecate';$VERSION='5.2';$FORCE_SEARCH_ALL_PATHS=0;sub import {my$class=shift;my%opts=@_;my ($pkg,$file)=caller;my$sub=$opts{'sub_name'}|| 'plugins';my ($package)=$opts{'package'}|| $pkg;$opts{filename}=$file;$opts{package}=$package;$opts{force_search_all_paths}=$FORCE_SEARCH_ALL_PATHS unless exists$opts{force_search_all_paths};my$finder=Module::Pluggable::Object->new(%opts);my$subroutine=sub {my$self=shift;return$finder->plugins(@_)};my$searchsub=sub {my$self=shift;my ($action,@paths)=@_;$finder->{'search_path'}=["${package}::Plugin"]if ($action eq 'add' and not $finder->{'search_path'});push @{$finder->{'search_path'}},@paths if ($action eq 'add');$finder->{'search_path'}=\@paths if ($action eq 'new');return$finder->{'search_path'}};my$onlysub=sub {my ($self,$only)=@_;if (defined$only){$finder->{'only'}=$only};return$finder->{'only'}};my$exceptsub=sub {my ($self,$except)=@_;if (defined$except){$finder->{'except'}=$except};return$finder->{'except'}};no strict 'refs';no warnings qw(redefine prototype);*{"$package\::$sub"}=$subroutine;*{"$package\::search_path"}=$searchsub;*{"$package\::only"}=$onlysub;*{"$package\::except"}=$exceptsub}1;
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;use strict;use File::Find ();use File::Basename;use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);use Carp qw(croak carp confess);use Devel::InnerPackage;use vars qw($VERSION $MR);use if $] > 5.017,'deprecate';$VERSION='5.2';BEGIN {eval {require Module::Runtime};unless ($@){Module::Runtime->import('require_module')}else {*require_module=sub {my$module=shift;my$path=$module .".pm";$path =~ s{::}{/}g;require$path}}}sub new {my$class=shift;my%opts=@_;return bless \%opts,$class}sub plugins {my$self=shift;my@args=@_;$self->{'require'}=1 if$self->{'inner'};my$filename=$self->{'filename'};my$pkg=$self->{'package'};$self->_setup_exceptions;for (qw(search_path search_dirs)){$self->{$_}=[$self->{$_}]if exists$self->{$_}&&!ref($self->{$_})}$self->{'search_path'}||= ["${pkg}::Plugin"];$self->{'on_require_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't require $plugin : $err";return 0};$self->{'on_instantiate_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't instantiate $plugin: $err";return 0};$self->{'follow_symlinks'}=1 unless exists$self->{'follow_symlinks'};my@SEARCHDIR=exists$INC{"blib.pm"}&& defined$filename && $filename =~ m!(^|/)blib/! &&!$self->{'force_search_all_paths'}? grep {/blib/}@INC : @INC;unshift@SEARCHDIR,@{$self->{'search_dirs'}}if defined$self->{'search_dirs'};my@tmp=@INC;unshift@tmp,@{$self->{'search_dirs'}|| []};local@INC=@tmp if defined$self->{'search_dirs'};my@plugins=$self->search_directories(@SEARCHDIR);push(@plugins,$self->handle_inc_hooks($_,@SEARCHDIR))for @{$self->{'search_path'}};push(@plugins,$self->handle_innerpackages($_))for @{$self->{'search_path'}};return ()unless@plugins;my%plugins;for(@plugins){next unless$self->_is_legit($_);$plugins{$_}=1}if (defined$self->{'instantiate'}){my$method=$self->{'instantiate'};my@objs=();for my$package (sort keys%plugins){next unless$package->can($method);my$obj=eval {$package->$method(@_)};$self->{'on_instantiate_error'}->($package,$@)if $@;push@objs,$obj if$obj}return@objs}else {my@objs=sort keys%plugins;return@objs}}sub _setup_exceptions {my$self=shift;my%only;my%except;my$only;my$except;if (defined$self->{'only'}){if (ref($self->{'only'})eq 'ARRAY'){%only=map {$_=>1}@{$self->{'only'}}}elsif (ref($self->{'only'})eq 'Regexp'){$only=$self->{'only'}}elsif (ref($self->{'only'})eq ''){$only{$self->{'only'}}=1}}if (defined$self->{'except'}){if (ref($self->{'except'})eq 'ARRAY'){%except=map {$_=>1}@{$self->{'except'}}}elsif (ref($self->{'except'})eq 'Regexp'){$except=$self->{'except'}}elsif (ref($self->{'except'})eq ''){$except{$self->{'except'}}=1}}$self->{_exceptions}->{only_hash}=\%only;$self->{_exceptions}->{only}=$only;$self->{_exceptions}->{except_hash}=\%except;$self->{_exceptions}->{except}=$except}sub _is_legit {my$self=shift;my$plugin=shift;my%only=%{$self->{_exceptions}->{only_hash}||{}};my%except=%{$self->{_exceptions}->{except_hash}||{}};my$only=$self->{_exceptions}->{only};my$except=$self->{_exceptions}->{except};my$depth=()=split '::',$plugin,-1;return 0 if (keys%only &&!$only{$plugin});return 0 unless (!defined$only || $plugin =~ m!$only!);return 0 if (keys%except && $except{$plugin});return 0 if (defined$except && $plugin =~ m!$except!);return 0 if defined$self->{max_depth}&& $depth>$self->{max_depth};return 0 if defined$self->{min_depth}&& $depth<$self->{min_depth};return 1}sub search_directories {my$self=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){push@plugins,$self->search_paths($dir)}return@plugins}sub search_paths {my$self=shift;my$dir=shift;my@plugins;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;for my$searchpath (@{$self->{'search_path'}}){my$sp=catdir($dir,(split /::/,$searchpath));next unless (-e $sp && -d _);my@files=$self->find_files($sp);for my$file (@files){next unless ($file)=($file =~ /(.*$file_regex)$/);my ($name,$directory,$suffix)=fileparse($file,$file_regex);next if (!$self->{include_editor_junk}&& $self->_is_editor_junk($name));$directory=abs2rel($directory,$sp);my@pkg_dirs=();if ($name eq lc($name)|| $name eq uc($name)){my$pkg_file=catfile($sp,$directory,"$name$suffix");open PKGFILE,"<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";my$in_pod=0;while (my$line=<PKGFILE>){$in_pod=1 if$line =~ m/^=\w/;$in_pod=0 if$line =~ /^=cut/;next if ($in_pod || $line =~ /^=cut/);next if$line =~ /^\s*#/;if ($line =~ m/^\s*package\s+(.*::)?($name)\s*;/i){@pkg_dirs=split /::/,$1 if defined $1;;$name=$2;last}}close PKGFILE}$directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);my@dirs=();if ($directory){($directory)=($directory =~ /(.*)/);@dirs=grep(length($_),splitdir($directory))unless$directory eq curdir();for my$d (reverse@dirs){my$pkg_dir=pop@pkg_dirs;last unless defined$pkg_dir;$d =~ s/\Q$pkg_dir\E/$pkg_dir/i}}else {$directory=""}my$plugin=join '::',$searchpath,@dirs,$name;next unless$plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;$self->handle_finding_plugin($plugin,\@plugins)}push@plugins,$self->handle_innerpackages($searchpath)}return@plugins}sub _is_editor_junk {my$self=shift;my$name=shift;return 1 if$name =~ /~$/;return 1 if$name =~ /^\.#/;return 1 if$name =~ /\.sw[po]$/;return 0}sub handle_finding_plugin {my$self=shift;my$plugin=shift;my$plugins=shift;my$no_req=shift || 0;return unless$self->_is_legit($plugin);unless (defined$self->{'instantiate'}|| $self->{'require'}){push @$plugins,$plugin;return}$self->{before_require}->($plugin)|| return if defined$self->{before_require};unless ($no_req){my$tmp=$@;my$res=eval {require_module($plugin)};my$err=$@;$@=$tmp;if ($err){if (defined$self->{on_require_error}){$self->{on_require_error}->($plugin,$err)|| return}else {return}}}$self->{after_require}->($plugin)|| return if defined$self->{after_require};push @$plugins,$plugin}sub find_files {my$self=shift;my$search_path=shift;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;my@files=();{local $_;File::Find::find({no_chdir=>1,follow=>$self->{'follow_symlinks'},wanted=>sub {return unless$File::Find::name =~ /$file_regex/;(my$path=$File::Find::name)=~ s#^\\./##;push@files,$path}},$search_path)}return@files}sub handle_inc_hooks {my$self=shift;my$path=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){next unless ref$dir && eval {$dir->can('files')};for my$plugin ($dir->files){$plugin =~ s/\.pm$//;$plugin =~ s{/}{::}g;next unless$plugin =~ m!^${path}::!;$self->handle_finding_plugin($plugin,\@plugins)}}return@plugins}sub handle_innerpackages {my$self=shift;return ()if (exists$self->{inner}&&!$self->{inner});my$path=shift;my@plugins;for my$plugin (Devel::InnerPackage::list_packages($path)){$self->handle_finding_plugin($plugin,\@plugins,1)}return@plugins}1;
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Perl/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_BUILD';
  package Perl::Build;use strict;use warnings;use utf8;use 5.008001;our$VERSION='1.32';use Carp ();use File::Basename;use File::Spec::Functions qw(catfile catdir rel2abs);use CPAN::Perl::Releases;use CPAN::Perl::Releases::MetaCPAN;use File::pushd qw(pushd);use File::Temp;use HTTP::Tinyish;use JSON::PP qw(decode_json);use Devel::PatchPerl 0.88;use Perl::Build::Built;use Time::Local;our$CPAN_MIRROR=$ENV{PERL_BUILD_CPAN_MIRROR}|| 'https://cpan.metacpan.org';sub available_perls {my$class=shift;my$releases=CPAN::Perl::Releases::MetaCPAN->new->get;my@available_versions;for my$release (@$releases){if ($release->{name}=~ /^perl-(5.(\d+).(\d+)(-\w+)?)$/){my ($version,$major,$minor,$rc)=($1,$2,$3,$4);my$sort_by=sprintf "%03d%03d%s",$major,$minor,$rc || "ZZZ";push@available_versions,{version=>$version,sort_by=>$sort_by }}}map {$_->{version}}sort {$b->{sort_by}cmp $a->{sort_by}}@available_versions}sub extract_tarball {my ($class,$dist_tarball,$destdir)=@_;my$tar=$^O eq 'solaris' ? 'gtar' : 'tar';my$type =$dist_tarball =~ m/bz2$/ ? 'j' : $dist_tarball =~ m/xz$/ ? 'J' : 'z';my$abs_tarball=File::Spec->rel2abs($dist_tarball);my@tar_files=`$tar t${type}f "$abs_tarball"`;$?==0 or die "Failed to extract $dist_tarball";chomp@tar_files;my%seen;my@prefixes=grep!$seen{$_}++,map m{\A(?:\./)?([^/]+)},@tar_files;die "$dist_tarball does not contain single directory : @prefixes" if@prefixes!=1;system(qq{cd "$destdir"; $tar x${type}f "$abs_tarball"})==0 or die "Failed to extract $dist_tarball";return catfile($destdir,$prefixes[0])}sub perl_release {my ($class,$version)=@_;my ($dist_tarball,$dist_tarball_url);my@err;for my$func (qw/cpan_perl_releases metacpan/){eval {($dist_tarball,$dist_tarball_url)=$class->can("perl_release_by_$func")->($class,$version)};push@err,"[$func] $@" if $@;last if$dist_tarball && $dist_tarball_url}if (!$dist_tarball and!$dist_tarball_url){push@err,"ERROR: Cannot find the tarball for perl-$version\n";die join "",@err}return ($dist_tarball,$dist_tarball_url)}sub perl_release_by_cpan_perl_releases {my ($class,$version)=@_;my$tarballs=CPAN::Perl::Releases::perl_tarballs($version);my$x=$tarballs->{'tar.gz'}|| $tarballs->{'tar.bz2'}|| $tarballs->{'tar.xz'};die "not found the tarball for perl-$version\n" unless$x;my$dist_tarball=(split("/",$x))[-1];my$dist_tarball_url=$CPAN_MIRROR ."/authors/id/$x";return ($dist_tarball,$dist_tarball_url)}sub perl_release_by_metacpan {my ($class,$version)=@_;my$releases=CPAN::Perl::Releases::MetaCPAN->new->get;for my$release (@$releases){if ($release->{name}eq "perl-$version"){my ($path)=$release->{download_url}=~ m{(/authors/id/.*)};my$dist_tarball=(split("/",$path))[-1];my$dist_tarball_url=$CPAN_MIRROR .$path;return ($dist_tarball,$dist_tarball_url)}}die "not found the tarball for perl-$version\n"}sub http_get {my ($url)=@_;my$http=HTTP::Tinyish->new(verify_SSL=>1);my$response=$http->get($url);if ($response->{success}){return$response->{content}}else {my$msg=$response->{status}==599 ? ", $response->{content}" : "";chomp$msg;die "Cannot get content from $url: $response->{status} $response->{reason}$msg\n"}}sub http_mirror {my ($url,$path)=@_;my$http=HTTP::Tinyish->new(verify_SSL=>1);my$response=$http->mirror($url,$path);if ($response->{success}){print "Downloaded $url to $path.\n"}else {my$msg=$response->{status}==599 ? ", $response->{content}" : "";chomp$msg;die "Cannot get file from $url: $response->{status} $response->{reason}$msg"}}sub install_from_cpan {my ($class,$version,%args)=@_;$args{patchperl}&& Carp::croak "The patchperl argument was deprected.";my$tarball_dir=$args{tarball_dir}|| File::Temp::tempdir(CLEANUP=>1);my$build_dir=$args{build_dir}|| File::Temp::tempdir(CLEANUP=>1);my$dst_path=$args{dst_path}or die "Missing mandatory parameter: dst_path";my$configure_options=$args{configure_options}|| ['-de'];my ($dist_tarball,$dist_tarball_url)=Perl::Build->perl_release($version);my$dist_tarball_path=catfile($tarball_dir,$dist_tarball);if (-f $dist_tarball_path){print "Use the previously fetched ${dist_tarball}\n"}else {print "Fetching $version as $dist_tarball_path ($dist_tarball_url)\n";http_mirror($dist_tarball_url,$dist_tarball_path)}my$dist_extracted_path=Perl::Build->extract_tarball($dist_tarball_path,$build_dir);Perl::Build->install(src_path=>$dist_extracted_path,dst_path=>$dst_path,configure_options=>$configure_options,test=>$args{test},jobs=>$args{jobs},)}sub install_from_url {my ($class,$dist_tarball_url,%args)=@_;$args{patchperl}&& Carp::croak "The patchperl argument was deprected.";my$build_dir=$args{build_dir}|| File::Temp::tempdir(CLEANUP=>1);my$tarball_dir=$args{tarball_dir}|| File::Temp::tempdir(CLEANUP=>1);my$dst_path=$args{dst_path}or die "Missing mandatory parameter: dst_path";my$configure_options=$args{configure_options}|| ['-de'];my$dist_tarball=basename($dist_tarball_url);my$dist_tarball_path=catfile($tarball_dir,$dist_tarball);if (-f $dist_tarball_path){print "Use the previously fetched ${dist_tarball}\n"}else {print "Fetching $dist_tarball_path ($dist_tarball_url)\n";http_mirror($dist_tarball_url,$dist_tarball_path)}my$dist_extracted_path=Perl::Build->extract_tarball($dist_tarball_path,$build_dir);Perl::Build->install(src_path=>$dist_extracted_path,dst_path=>$dst_path,configure_options=>$configure_options,test=>$args{test},jobs=>$args{jobs},)}sub install_from_tarball {my ($class,$dist_tarball_path,%args)=@_;$args{patchperl}&& Carp::croak "The patchperl argument was deprected.";my$build_dir=$args{build_dir}|| File::Temp::tempdir(CLEANUP=>1);my$dst_path=$args{dst_path}or die "Missing mandatory parameter: dst_path";my$configure_options=$args{configure_options}|| ['-de'];my$dist_extracted_path=Perl::Build->extract_tarball($dist_tarball_path,$build_dir);Perl::Build->install(src_path=>$dist_extracted_path,dst_path=>$dst_path,configure_options=>$configure_options,test=>$args{test},jobs=>$args{jobs},)}sub install {my ($class,%args)=@_;$args{patchperl}&& Carp::croak "The patchperl argument was deprected.";my$src_path=$args{src_path}or die "Missing mandatory parameter: src_path";my$dst_path=$args{dst_path}or die "Missing mandatory parameter: dst_path";my$configure_options=$args{configure_options}or die "Missing mandatory parameter: configure_options";my$jobs=$args{jobs};my$test=$args{test};unshift @$configure_options,qq(-Dprefix=$dst_path);unless (grep {/eval:scriptdir=/}@$configure_options){push @$configure_options,"-A'eval:scriptdir=${dst_path}/bin'"}delete$ENV{$_}for qw(PERL5LIB PERL5OPT);{my$dir=pushd($src_path);my$dist_version=Devel::PatchPerl->determine_version();print "Configuring perl '$dist_version'\n";$class->do_system("rm -f config.sh Policy.sh");Devel::PatchPerl->patch_source();$class->do_system(['sh','Configure',@$configure_options]);my@make=qw(make);if ($ENV{PERL_BUILD_COMPILE_OPTIONS}){push@make,$ENV{PERL_BUILD_COMPILE_OPTIONS}}if ($jobs){push@make,'-j',$jobs}$class->do_system(\@make);if ($test){local$ENV{TEST_JOBS}=$jobs if$jobs;my$test_target='test';if ($dist_version && $dist_version =~ /^5\.([0-9]+)\.([0-9]+)/ && ($1 >= 8 || $1==7 && $2==3)){$test_target="test_harness"}$class->do_system([@make,$test_target])}@make=qw(make install);if ($ENV{PERL_BUILD_INSTALL_OPTIONS}){push@make,$ENV{PERL_BUILD_INSTALL_OPTIONS}}$class->do_system(\@make)}return Perl::Build::Built->new({installed_path=>$dst_path,})}sub do_system {my ($class,$cmd)=@_;if (ref$cmd eq 'ARRAY'){$class->info(join(' ',@$cmd));system(@$cmd)==0 or die "Installation failure: @$cmd"}else {$class->info($cmd);system($cmd)==0 or die "Installation failure: $cmd"}}sub symlink_devel_executables {my ($class,$bin_dir)=@_;for my$executable (glob("$bin_dir/*")){my ($name,$version)=basename($executable)=~ m/(.+?)(5\.\d.*)?$/;if ($version){my$cmd="ln -fs $executable $bin_dir/$name";$class->info($cmd);system($cmd)}}}sub info {my ($class,@msg)=@_;print@msg,"\n"}1;
PERL_BUILD

$fatpacked{"Perl/Build/Built.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_BUILD_BUILT';
  package Perl::Build::Built;use strict;use warnings;use utf8;use 5.008001;our$VERSION='1.32';use Carp ();use File::Spec::Functions qw(catdir catfile);sub run_env {my ($self,@args)=@_;my$config={};if (ref$args[0]eq 'HASH'){$config=%{shift@args}}if ($args[0]and ref$args[0]eq 'CODE'){$config->{code}=shift@args}if (@args){Carp::croak('->run_env(\%config,\&code)' .' or ->run_env(\&code)' .' or ->run_env(\%config)')}local$ENV{PATH}=$self->combined_bin_path;my$combined_man_path=$self->combined_man_path;local$ENV{MANPATH}=$combined_man_path if$combined_man_path;delete local$ENV{PERL5LIB};return$config->{code}->()}sub new {my ($self,$args)=@_;$args={}unless defined$args;Carp::croak '->new(\%config) required' if not ref$args eq 'HASH';Carp::croak 'installed_path is a mandatory parameter' unless exists$args->{installed_path};return bless$args,$self}sub installed_path {return $_[0]->{installed_path}}sub bin_path {return catdir($_[0]->{installed_path},'bin')}sub man_path {return catdir($_[0]->{installed_path},'man')}sub combined_bin_path {return $_[0]->bin_path .':' .$ENV{PATH}}sub combined_man_path {if (-d $_[0]->man_path){return $_[0]->man_path .':' .$ENV{MANPATH}}return$ENV{MANPATH}}1;
PERL_BUILD_BUILT

$fatpacked{"Pod/Escapes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ESCAPES';
  package Pod::Escapes;use strict;use warnings;use 5.006;use vars qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback $FAR_CHAR $FAR_CHAR_NUMBER $NOT_ASCII @ISA $VERSION @EXPORT_OK %EXPORT_TAGS);require Exporter;@ISA=('Exporter');$VERSION='1.07';@EXPORT_OK=qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback e2char e2charnum);%EXPORT_TAGS=('ALL'=>\@EXPORT_OK);$FAR_CHAR="?" unless defined$FAR_CHAR;$FAR_CHAR_NUMBER=ord($FAR_CHAR)unless defined$FAR_CHAR_NUMBER;$NOT_ASCII='A' ne chr(65)unless defined$NOT_ASCII;sub e2char {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^\d+$/s){if($] < 5.007 and $in > 255){return$FAR_CHAR}elsif ($] >= 5.007003){return chr(utf8::unicode_to_native($in))}elsif ($NOT_ASCII){return$Code2USASCII{$in}|| $Latin1Code_to_fallback{$in}|| $FAR_CHAR}else {return chr($in)}}else {return$Name2character{$in}}}sub e2charnum {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^[0-9]+$/s){return 0 + $in}else {return$Name2character_number{$in}}}%Code2USASCII=(32,' ',33,'!',34,'"',35,'#',36,'$',37,'%',38,'&',39,"'",40,'(',41,')',42,'*',43,'+',44,',',45,'-',46,'.',47,'/',48,'0',49,'1',50,'2',51,'3',52,'4',53,'5',54,'6',55,'7',56,'8',57,'9',58,':',59,';',60,'<',61,'=',62,'>',63,'?',64,'@',65,'A',66,'B',67,'C',68,'D',69,'E',70,'F',71,'G',72,'H',73,'I',74,'J',75,'K',76,'L',77,'M',78,'N',79,'O',80,'P',81,'Q',82,'R',83,'S',84,'T',85,'U',86,'V',87,'W',88,'X',89,'Y',90,'Z',91,'[',92,"\\",93,']',94,'^',95,'_',96,'`',97,'a',98,'b',99,'c',100,'d',101,'e',102,'f',103,'g',104,'h',105,'i',106,'j',107,'k',108,'l',109,'m',110,'n',111,'o',112,'p',113,'q',114,'r',115,'s',116,'t',117,'u',118,'v',119,'w',120,'x',121,'y',122,'z',123,'{',124,'|',125,'}',126,'~',);%Latin1Code_to_fallback=();@Latin1Code_to_fallback{0xA0 .. 0xFF}=(' ',qq{!},qq{C/},'PS',qq{\$?},qq{Y=},qq{|},'SS',qq{"},qq{(c)},'a',qq{<<},qq{!},"",qq{(r)},qq{-},'deg',qq{+-},'2','3',qq{'},'u','P',qq{*},qq{,},'1','o',qq{>>},qq{1/4},qq{1/2},qq{3/4},qq{?},'A','A','A','A','A','A','AE','C','E','E','E','E','I','I','I','I','D','N','O','O','O','O','O','x','O','U','U','U','U','U','Th','ss','a','a','a','a','a','a','ae','c','e','e','e','e','i','i','i','i','d','n','o','o','o','o','o',qq{/},'o','u','u','u','u','y','th','y',);{%Latin1Char_to_fallback=();my($k,$v);while(($k,$v)=each%Latin1Code_to_fallback){$Latin1Char_to_fallback{chr$k}=$v}}%Name2character_number=('lt'=>60,'gt'=>62,'quot'=>34,'amp'=>38,'apos'=>39,'sol'=>47,'verbar'=>124,'lchevron'=>171,'rchevron'=>187,'nbsp',160,'iexcl',161,'cent',162,'pound',163,'curren',164,'yen',165,'brvbar',166,'sect',167,'uml',168,'copy',169,'ordf',170,'laquo',171,'not',172,'shy',173,'reg',174,'macr',175,'deg',176,'plusmn',177,'sup2',178,'sup3',179,'acute',180,'micro',181,'para',182,'middot',183,'cedil',184,'sup1',185,'ordm',186,'raquo',187,'frac14',188,'frac12',189,'frac34',190,'iquest',191,'Agrave',192,'Aacute',193,'Acirc',194,'Atilde',195,'Auml',196,'Aring',197,'AElig',198,'Ccedil',199,'Egrave',200,'Eacute',201,'Ecirc',202,'Euml',203,'Igrave',204,'Iacute',205,'Icirc',206,'Iuml',207,'ETH',208,'Ntilde',209,'Ograve',210,'Oacute',211,'Ocirc',212,'Otilde',213,'Ouml',214,'times',215,'Oslash',216,'Ugrave',217,'Uacute',218,'Ucirc',219,'Uuml',220,'Yacute',221,'THORN',222,'szlig',223,'agrave',224,'aacute',225,'acirc',226,'atilde',227,'auml',228,'aring',229,'aelig',230,'ccedil',231,'egrave',232,'eacute',233,'ecirc',234,'euml',235,'igrave',236,'iacute',237,'icirc',238,'iuml',239,'eth',240,'ntilde',241,'ograve',242,'oacute',243,'ocirc',244,'otilde',245,'ouml',246,'divide',247,'oslash',248,'ugrave',249,'uacute',250,'ucirc',251,'uuml',252,'yacute',253,'thorn',254,'yuml',255,'fnof',402,'Alpha',913,'Beta',914,'Gamma',915,'Delta',916,'Epsilon',917,'Zeta',918,'Eta',919,'Theta',920,'Iota',921,'Kappa',922,'Lambda',923,'Mu',924,'Nu',925,'Xi',926,'Omicron',927,'Pi',928,'Rho',929,'Sigma',931,'Tau',932,'Upsilon',933,'Phi',934,'Chi',935,'Psi',936,'Omega',937,'alpha',945,'beta',946,'gamma',947,'delta',948,'epsilon',949,'zeta',950,'eta',951,'theta',952,'iota',953,'kappa',954,'lambda',955,'mu',956,'nu',957,'xi',958,'omicron',959,'pi',960,'rho',961,'sigmaf',962,'sigma',963,'tau',964,'upsilon',965,'phi',966,'chi',967,'psi',968,'omega',969,'thetasym',977,'upsih',978,'piv',982,'bull',8226,'hellip',8230,'prime',8242,'Prime',8243,'oline',8254,'frasl',8260,'weierp',8472,'image',8465,'real',8476,'trade',8482,'alefsym',8501,'larr',8592,'uarr',8593,'rarr',8594,'darr',8595,'harr',8596,'crarr',8629,'lArr',8656,'uArr',8657,'rArr',8658,'dArr',8659,'hArr',8660,'forall',8704,'part',8706,'exist',8707,'empty',8709,'nabla',8711,'isin',8712,'notin',8713,'ni',8715,'prod',8719,'sum',8721,'minus',8722,'lowast',8727,'radic',8730,'prop',8733,'infin',8734,'ang',8736,'and',8743,'or',8744,'cap',8745,'cup',8746,'int',8747,'there4',8756,'sim',8764,'cong',8773,'asymp',8776,'ne',8800,'equiv',8801,'le',8804,'ge',8805,'sub',8834,'sup',8835,'nsub',8836,'sube',8838,'supe',8839,'oplus',8853,'otimes',8855,'perp',8869,'sdot',8901,'lceil',8968,'rceil',8969,'lfloor',8970,'rfloor',8971,'lang',9001,'rang',9002,'loz',9674,'spades',9824,'clubs',9827,'hearts',9829,'diams',9830,'OElig',338,'oelig',339,'Scaron',352,'scaron',353,'Yuml',376,'circ',710,'tilde',732,'ensp',8194,'emsp',8195,'thinsp',8201,'zwnj',8204,'zwj',8205,'lrm',8206,'rlm',8207,'ndash',8211,'mdash',8212,'lsquo',8216,'rsquo',8217,'sbquo',8218,'ldquo',8220,'rdquo',8221,'bdquo',8222,'dagger',8224,'Dagger',8225,'permil',8240,'lsaquo',8249,'rsaquo',8250,'euro',8364,);{%Name2character=();my($name,$number);while(($name,$number)=each%Name2character_number){if($] < 5.007 and $number > 255){$Name2character{$name}=$FAR_CHAR}elsif ($] >= 5.007003){$Name2character{$name}=chr utf8::unicode_to_native($number)}elsif (exists$Code2USASCII{$number}){$Name2character{$name}=$Code2USASCII{$number}}elsif ($NOT_ASCII && $number > 127 && $number < 256){if (exists$Latin1Code_to_fallback{$number}){$Name2character{$name}=$Latin1Code_to_fallback{$number}}else {$Name2character{$name}=$FAR_CHAR}}else {$Name2character{$name}=chr$number}}}1;
POD_ESCAPES

$fatpacked{"Pod/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MAN';
  package Pod::Man;use 5.008;use strict;use warnings;use subs qw(makespace);use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);use Carp qw(carp croak);use Pod::Simple ();our$HAS_ENCODE;BEGIN {$HAS_ENCODE=eval {require Encode}}@ISA=qw(Pod::Simple);$VERSION='4.14';BEGIN {my$parent=defined (&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : undef;unless (defined&DEBUG){*DEBUG=$parent || sub () {10}}}BEGIN {*ASCII=\&Pod::Simple::ASCII}BEGIN {*pretty=\&Pod::Simple::pretty}my%FORMATTING=(DEFAULT=>{cleanup=>1,convert=>1,guesswork=>1,literal=>0 },Data=>{cleanup=>0,convert=>0,guesswork=>0,literal=>0 },Verbatim=>{guesswork=>0,literal=>1 },C=>{guesswork=>0,literal=>1 },X=>{cleanup=>0,guesswork=>0 },);sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if (my$preserve_whitespace=$self->can ('preserve_whitespace')){$self->$preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/man MAN roff ROFF/);$self->merge_text (1);%$self=(%$self,@_);if ($$self{stderr}and not $$self{errors}){$$self{errors}='stderr'}delete $$self{stderr};if (not defined $$self{errors}){$$self{errors}='pod'}if ($$self{errors}eq 'stderr' || $$self{errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{errors}eq 'none'){$self->no_errata_section (1);$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};if ($$self{utf8}and!$HAS_ENCODE){if (!$ENV{PERL_CORE}){carp ('utf8 mode requested but Encode module not available,' .' falling back to non-utf8')}delete $$self{utf8}}$self->init_fonts;$self->init_quotes;$self->init_page;$$self{MAGIC_CPP}=1;$$self{MAGIC_EMDASH}=1;$$self{MAGIC_FUNC}=1;$$self{MAGIC_MANREF}=1;$$self{MAGIC_SMALLCAPS}=1;$$self{MAGIC_VARS}=1;return$self}sub toescape {(length ($_[0])> 1 ? '\f(' : '\f').$_[0]}sub init_fonts {my ($self)=@_;for (qw/fixed fixedbold fixeditalic fixedbolditalic/){my$font=$$self{$_};if (defined ($font)&& (length ($font)< 1 || length ($font)> 2)){croak qq(roff font should be 1 or 2 chars, not "$font")}}$$self{fixed}||= 'CW';$$self{fixedbold}||= 'CB';$$self{fixeditalic}||= 'CI';$$self{fixedbolditalic}||= 'CB';$$self{FONTS}={'000'=>'\fR','001'=>'\fI','010'=>'\fB','011'=>'\f(BI','100'=>toescape ($$self{fixed}),'101'=>toescape ($$self{fixeditalic}),'110'=>toescape ($$self{fixedbold}),'111'=>toescape ($$self{fixedbolditalic})}}sub init_quotes {my ($self)=(@_);$$self{quotes}||= '"';if ($$self{quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{quotes}}elsif (length ($$self{quotes})% 2==0){my$length=length ($$self{quotes})/ 2;$$self{LQUOTE}=substr ($$self{quotes},0,$length);$$self{RQUOTE}=substr ($$self{quotes},$length)}else {croak(qq(Invalid quote specification "$$self{quotes}"))}if (defined $$self{lquote}){$$self{LQUOTE}=$$self{lquote}eq 'none' ? q{} : $$self{lquote}}if (defined $$self{rquote}){$$self{RQUOTE}=$$self{rquote}eq 'none' ? q{} : $$self{rquote}}$$self{LQUOTE}=~ s/\"/\"\"/;$$self{RQUOTE}=~ s/\"/\"\"/}sub init_page {my ($self)=@_;my@version=($] =~ /^(\d+)\.(\d{3})(\d+)$/);for (@version){$_ += 0}my$version=join ('.',@version);$$self{center}='User Contributed Perl Documentation' unless defined $$self{center};$$self{release}='perl v' .$version unless defined $$self{release};$$self{indent}=4 unless defined $$self{indent};for (qw/center release/){$$self{$_}=~ s/\"/\"\"/g if $$self{$_}}}sub _handle_text {my ($self,$text)=@_;DEBUG > 3 and print "== $text\n";my$tag=$$self{PENDING}[-1];$$tag[2].= $self->format_text ($$tag[1],$text)}sub method_for_element {my ($self,$element)=@_;$element =~ tr/A-Z-/a-z_/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;DEBUG > 3 and print "++ $element (<",join ('> <',%$attrs),">)\n";my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){DEBUG > 2 and print "<$element> starts saving a tag\n";$$self{IN_NAME}=0 if ($element ne 'Para' && length ($element)> 1);my$formatting={%{$$self{PENDING}[-1][1]|| $FORMATTING{DEFAULT}},%{$FORMATTING{$element}|| {}},};push (@{$$self{PENDING}},[$attrs,$formatting,'' ]);DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n"}elsif (my$start_method=$self->can ("start_$method")){$self->$start_method ($attrs,'')}else {DEBUG > 2 and print "No $method start method, skipping\n"}}sub _handle_element_end {my ($self,$element)=@_;DEBUG > 3 and print "-- $element\n";my$method=$self->method_for_element ($element);if (my$cmd_method=$self->can ("cmd_$method")){DEBUG > 2 and print "</$element> stops saving a tag\n";my$tag=pop @{$$self{PENDING}};DEBUG > 4 and print "Popped: [",pretty ($tag),"]\n";DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n";my$text=$self->$cmd_method ($$tag[0],$$tag[2]);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][2].= $text}else {$self->output ($text)}}}elsif (my$end_method=$self->can ("end_$method")){$self->$end_method ()}else {DEBUG > 2 and print "No $method end method, skipping\n"}}sub format_text {my ($self,$options,$text)=@_;my$guesswork=$$options{guesswork}&&!$$self{IN_NAME};my$cleanup=$$options{cleanup};my$convert=$$options{convert};my$literal=$$options{literal};if ($cleanup){$text =~ s/\\/\\e/g;$text =~ s/-/\\-/g;$text =~ s/_(?=_)/_\\|/g}if ($convert &&!$$self{utf8}&& ASCII){$text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg}if ($literal){$text =~ s/(?<!\\\*)\'/\\*\(Aq/g;$text =~ s/(?<!\\\*)\`/\\\`/g}if ($guesswork){$text=$self->guesswork ($text)}return$text}sub quote_literal {my$self=shift;local $_=shift;my$index='(?: \[.*\] | \{.*\} )?';return qq{"$_"} if $$self{IN_NAME};m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
         | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xso and return '\f(FS' .$_ .'\f(FE';return '\f(FS\*(C`' .$_ ."\\*(C'\\f(FE"}sub guesswork {my$self=shift;local $_=shift;DEBUG > 5 and print "   Guesswork called on [$_]\n";s{
          ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
          ( (?: [a-zA-Z\']+ \\-)+ )
          ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
          \b
      } {
          my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
          $hyphen ||= '';
          $main =~ s/\\-/-/g;
          $prefix . $hyphen . $main . $suffix;
      }egx;if ($$self{MAGIC_EMDASH}){s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx}if ($$self{MAGIC_SMALLCAPS}){s{
              ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                           # (1)
              ( [A-Z] [A-Z] (?: \s? [/A-Z+:\d_\$&] | \\- | \s? [.,\"] )* )  # (2)
              (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )            # (3)
          } {
              $1 . '\s-1' . $2 . '\s0'
          }egx}if ($$self{MAGIC_FUNC}){s{
              ( \b | \\s-1 )
              ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
          } {
              $1 . '\f(BS' . $2 . '\f(BE'
          }egx}if ($$self{MAGIC_MANREF}){s{
              ( \b | \\s-1 )
              (?<! \\ )                                   # rule out \s0(1)
              ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
              ( \( \d [a-z]* \) )
          } {
              $1 . '\f(BS' . $2 . '\f(BE\|' . $3
          }egx}if ($$self{MAGIC_VARS}){s{
             ( ^ | \s+ )
             ( [\$\@%] [\w:]+ )
             (?! \( )
          } {
              $1 . '\f(FS' . $2 . '\f(FE'
          }egx}s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;if ($$self{MAGIC_CPP}){s{ \b C\+\+ } {\\*\(C+}gx}DEBUG > 5 and print "   Guesswork returning [$_]\n";return $_}sub mapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);my$last='\fR';$text =~ s<
          \\f\((.)(.)
      > <
          my $sequence = '';
          my $f;
          if ($last ne '\fR') { $sequence = '\fP' }
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
          if ($f eq $last) {
              '';
          } else {
              if ($f ne '\fR') { $sequence .= $f }
              $last = $f;
              $sequence;
          }
      >gxe;return$text}sub textmapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);$text =~ s<
          \\f\((.)(.)
      > <
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
      >gxe;return$text}sub switchquotes {my ($self,$command,$text,$extra)=@_;$text =~ s/\\\*\([LR]\"/\"/g;my$c_is_quote=($$self{LQUOTE}=~ /\"/)|| ($$self{RQUOTE}=~ /\"/);my$fixedpat=join '|',@{$$self{FONTS}}{'100','101','110','111'};$fixedpat =~ s/\\/\\\\/g;$fixedpat =~ s/\(/\\\(/g;if ($text =~ m/\"/ || $text =~ m/$fixedpat/){$text =~ s/\"/\"\"/g;my$nroff=$text;my$troff=$text;$troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/){$nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;$nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;$troff =~ s/\\\*\(C[\'\`]//g}$nroff=qq("$nroff") .($extra ? " $extra" : '');$troff=qq("$troff") .($extra ? " $extra" : '');my$font_end="(?:\\f[PR]|\Q$$self{FONTS}{100}\E)";$nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f([PR])/$1/g;$nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)$font_end/\\fI$1\\fP/g;$nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)$font_end/\\fB$1\\fP/g;$nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)$font_end/\\f\(BI$1\\fP/g;if ($nroff ne $troff){return ".ie n $command $nroff\n.el $command $troff\n"}else {return "$command $nroff\n"}}else {$text=qq("$text") .($extra ? " $extra" : '');return "$command $text\n"}}sub protect {my ($self,$text)=@_;$text =~ s/^([.\'\\])/\\&$1/mg;return$text}sub makespace {my ($self)=@_;$self->output (".PD\n")if $$self{ITEMS}> 1;$$self{ITEMS}=0;$self->output ($$self{INDENT}> 0 ? ".Sp\n" : ".PP\n")if $$self{NEEDSPACE}}sub outindex {my ($self,$section,$index)=@_;my@entries=map {split m%\s*/\s*%}@{$$self{INDEX}};return unless ($section || @entries);$$self{INDEX}=[];my@output;if (@entries){push@output,['Xref',join (' ',@entries)]}if ($section){$index =~ s/\\-/-/g;$index =~ s/\\(?:s-?\d|.\(..|.)//g;push@output,[$section,$index ]}for (@output){my ($type,$entry)=@$_;$entry =~ s/\s+/ /g;$entry =~ s/\"/\"\"/g;$entry =~ s/\\/\\\\/g;$self->output (".IX $type " .'"' .$entry .'"' ."\n")}}sub output {my ($self,@text)=@_;if ($$self{ENCODE}){print {$$self{output_fh}}Encode::encode ('UTF-8',join ('',@text))}else {print {$$self{output_fh}}@text}}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){DEBUG and print "Document is contentless\n";$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}$$self{ENCODE}=0;if ($$self{utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my@layers=PerlIO::get_layers (*{$$self{output_fh}},@options);if ($layers[-1]&& ($layers[-1]& PerlIO::F_UTF8 ())){$$self{ENCODE}=0}}}if (!$$self{CONTENTLESS}){my ($name,$section);if (defined $$self{name}){$name=$$self{name};$section=$$self{section}|| 1}else {($name,$section)=$self->devise_title}my$date=defined($$self{date})? $$self{date}: $self->devise_date;$self->preamble ($name,$section,$date)unless$self->bare_output or DEBUG > 9}$$self{INDENT}=0;$$self{INDENTS}=[];$$self{INDEX}=[];$$self{IN_NAME}=0;$$self{ITEMS}=0;$$self{ITEMTYPES}=[];$$self{SHIFTWAIT}=0;$$self{SHIFTS}=[];$$self{PENDING}=[[]]}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}return if$self->bare_output;return if ($$self{CONTENTLESS}&&!$$self{ALWAYS_EMIT_SOMETHING});$self->output (q(.\" [End document]) ."\n")if DEBUG}sub devise_title {my ($self)=@_;my$name=$self->source_filename || '';my$section=$$self{section}|| 1;$section=3 if (!$$self{section}&& $name =~ /\.pm\z/i);$name =~ s/\.p(od|[lm])\z//i;if ($name =~ /^IO::File(?:=\w+)\(0x[\da-f]+\)$/i){$name=''}if ($name eq ''){$name='STDIN'}if ($section !~ /^3/){require File::Basename;$name=uc File::Basename::basename ($name)}else {require File::Spec;my ($volume,$dirs,$file)=File::Spec->splitpath ($name);my@dirs=File::Spec->splitdir ($dirs);if (@dirs){my$cut=0;my$i;for ($i=0;$i < @dirs;$i++){if ($dirs[$i]=~ /perl/){$cut=$i + 1;$cut++ if ($dirs[$i + 1]&& $dirs[$i + 1]eq 'lib');last}}if ($cut > 0){splice (@dirs,0,$cut);shift@dirs if ($dirs[0]=~ /^(site|vendor)(_perl)?$/);shift@dirs if ($dirs[0]=~ /^[\d.]+$/);shift@dirs if ($dirs[0]=~ /^(.*-$^O|$^O-.*|$^O)$/)}shift@dirs if$dirs[0]eq 'lib';splice (@dirs,0,2)if ($dirs[0]eq 'blib' && $dirs[1]eq 'lib')}$name=join ('::',(grep {$_ ? $_ : ()}@dirs),$file)}return ($name,$section)}sub devise_date {my ($self)=@_;if (defined($ENV{POD_MAN_DATE})){return$ENV{POD_MAN_DATE}}my$time;if (defined($ENV{SOURCE_DATE_EPOCH})&& $ENV{SOURCE_DATE_EPOCH}!~ /\D/){$time=$ENV{SOURCE_DATE_EPOCH}}if (!defined$time){my$input=$self->source_filename;if ($input){$time=(stat($input))[9]|| time()}else {$time=time()}}my ($year,$month,$day)=(gmtime($time))[5,4,3];return sprintf("%04d-%02d-%02d",$year + 1900,$month + 1,$day)}sub preamble {my ($self,$name,$section,$date)=@_;my$preamble=$self->preamble_template (!$$self{utf8});my$index="$name $section";$index =~ s/\"/\"\"/g;for ($name,$section){if (/\s/){s/\"/\"\"/g;$_='"' .$_ .'"'}}$date =~ s/\"/\"\"/g;$preamble =~ s/\@CFONT\@/$$self{fixed}/;$preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;$preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;chomp$preamble;my$version=$self->version_report;$self->output (<<"----END OF HEADER----");$self->output (".\\\" [End of preamble]\n")if DEBUG}sub cmd_para {my ($self,$attrs,$text)=@_;my$line=$$attrs{start_line};$self->makespace;if ($$self{SHIFTWAIT}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT});$$self{SHIFTWAIT}=0}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG &&!$$self{IN_NAME};$text=reverse$text;$text =~ s/\A\s*?(?= \\|\S|\z)/\n/;$text=reverse$text;$self->output ($self->protect ($self->textmapfonts ($text)));$self->outindex;$$self{NEEDSPACE}=1;return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;return unless$text =~ /\S/;$text=reverse$text;$text =~ s/\A\s*/\n/;$text=reverse$text;my@lines=split (/\n/,$text);my$unbroken=0;for (@lines){last if /^\s*$/;$unbroken++}$unbroken=10 if ($unbroken > 12 &&!$$self{MAGIC_VNOPAGEBREAK_LIMIT});$text =~ s/^/\\&/gm;$self->makespace;$self->output (".Vb $unbroken\n$text.Ve\n");$$self{NEEDSPACE}=1;return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading_common {my ($self,$text,$line)=@_;$text =~ s/\s+$//;$text =~ s/\s*\n\s*/ /g;if ($$self{ITEMS}> 1){$$self{ITEMS}=0;$self->output (".PD\n")}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG;return$text}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\\s-?\d//g;$text=$self->heading_common ($text,$$attrs{start_line});my$isname=($text eq 'NAME' || $text =~ /\(NAME\)/);$self->output ($self->switchquotes ('.SH',$self->mapfonts ($text)));$self->outindex ('Header',$text)unless$isname;$$self{NEEDSPACE}=0;$$self{IN_NAME}=$isname;return ''}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->output ($self->switchquotes ('.SS',$self->mapfonts ($text)));$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=0;return ''}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ('\f(IS' .$text .'\f(IE')."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ($text)."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_b {return $_[0]->{IN_NAME}? $_[2]: '\f(BS' .$_[2].'\f(BE'}sub cmd_i {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_f {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_c {return $_[0]->quote_literal ($_[2])}sub cmd_x {my ($self,$attrs,$text)=@_;push (@{$$self{INDEX}},$text);return ''}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){my$to=$$attrs{to};if (defined$to){my$tag=$$self{PENDING}[-1];$to=$self->format_text ($$tag[1],$to)}if (not defined ($to)or $to eq $text){return "<$text>"}elsif ($$self{nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub over_common_start {my ($self,$type,$attrs)=@_;my$line=$$attrs{start_line};my$indent=$$attrs{indent};DEBUG > 3 and print " Starting =over $type (line $line, indent ",($indent || '?'),"\n";unless (defined ($indent)&& $indent =~ /^[-+]?\d{1,4}\s*$/){$indent=$$self{indent}}if (@{$$self{SHIFTS}}< @{$$self{INDENTS}}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT})}push (@{$$self{INDENTS}},$$self{INDENT});push (@{$$self{ITEMTYPES}},$type);$$self{INDENT}=$indent + 0;$$self{SHIFTWAIT}=1}sub over_common_end {my ($self)=@_;DEBUG > 3 and print " Ending =over\n";$$self{INDENT}=pop @{$$self{INDENTS}};pop @{$$self{ITEMTYPES}};if (@{$$self{SHIFTS}}> @{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}if (@{$$self{INDENTS}}> 0){$self->output (".RE\n");$self->output (".RS $$self{INDENT}\n")}$$self{NEEDSPACE}=1;$$self{SHIFTWAIT}=0}sub start_over_bullet {my$s=shift;$s->over_common_start ('bullet',@_)}sub start_over_number {my$s=shift;$s->over_common_start ('number',@_)}sub start_over_text {my$s=shift;$s->over_common_start ('text',@_)}sub start_over_block {my$s=shift;$s->over_common_start ('block',@_)}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;my$line=$$attrs{start_line};DEBUG > 3 and print "  $type item (line $line): $text\n";$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item="\\\(bu";$text =~ s/\n*$/\n/}elsif ($type eq 'number'){$item=$$attrs{number}.'.'}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text='';$index=$item if ($item =~ /\w/)}if (@{$$self{SHIFTS}}==@{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}$self->output (".PD 0\n")if ($$self{ITEMS}==1);$item=$self->textmapfonts ($item);$self->output ($self->switchquotes ('.IP',$item,$$self{INDENT}));$$self{NEEDSPACE}=0;$$self{ITEMS}++;$$self{SHIFTWAIT}=0;if ($text){$text =~ s/\s*$/\n/;$self->makespace;$self->output ($self->protect ($self->textmapfonts ($text)));$$self{NEEDSPACE}=1}$self->outindex ($index ? ('Item',$index): ())}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->SUPER::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;return$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}@ESCAPES{0xA0 .. 0xFF}=("\\ ",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"\\%",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"A\\*`","A\\*'","A\\*^","A\\*~","A\\*:","A\\*o","\\*(Ae","C\\*,","E\\*`","E\\*'","E\\*^","E\\*:","I\\*`","I\\*'","I\\*^","I\\*:","\\*(D-","N\\*~","O\\*`","O\\*'","O\\*^","O\\*~","O\\*:",undef,"O\\*/","U\\*`","U\\*'","U\\*^","U\\*:","Y\\*'","\\*(Th","\\*8","a\\*`","a\\*'","a\\*^","a\\*~","a\\*:","a\\*o","\\*(ae","c\\*,","e\\*`","e\\*'","e\\*^","e\\*:","i\\*`","i\\*'","i\\*^","i\\*:","\\*(d-","n\\*~","o\\*`","o\\*'","o\\*^","o\\*~","o\\*:",undef,"o\\*/","u\\*`","u\\*'","u\\*^","u\\*:","y\\*'","\\*(th","y\\*:",)if ASCII;sub preamble_template {my ($self,$accents)=@_;my$preamble=<<'----END OF PREAMBLE----';if ($accents){$preamble .= <<'----END OF PREAMBLE----'}return$preamble}1;
  .\\" Automatically generated by $version
  .\\"
  .\\" Standard preamble:
  .\\" ========================================================================
  $preamble
  .\\" ========================================================================
  .\\"
  .IX Title "$index"
  .TH $name $section "$date" "$$self{release}" "$$self{center}"
  .\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
  .\\" way too many mistakes in technical documents.
  .if n .ad l
  .nh
  ----END OF HEADER----
  .de Sp \" Vertical space (when we can't use .PP)
  .if t .sp .5v
  .if n .sp
  ..
  .de Vb \" Begin verbatim text
  .ft @CFONT@
  .nf
  .ne \\$1
  ..
  .de Ve \" End verbatim text
  .ft R
  .fi
  ..
  .\" Set up some character translations and predefined strings.  \*(-- will
  .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
  .\" double quote, and \*(R" will give a right double quote.  \*(C+ will
  .\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
  .\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
  .\" nothing in troff, for use with C<>.
  .tr \(*W-
  .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
  .ie n \{\
  .    ds -- \(*W-
  .    ds PI pi
  .    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
  .    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
  .    ds L" ""
  .    ds R" ""
  .    ds C` @LQUOTE@
  .    ds C' @RQUOTE@
  'br\}
  .el\{\
  .    ds -- \|\(em\|
  .    ds PI \(*p
  .    ds L" ``
  .    ds R" ''
  .    ds C`
  .    ds C'
  'br\}
  .\"
  .\" Escape single quotes in literal strings from groff's Unicode transform.
  .ie \n(.g .ds Aq \(aq
  .el       .ds Aq '
  .\"
  .\" If the F register is >0, we'll generate index entries on stderr for
  .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
  .\" entries marked with X<> in POD.  Of course, you'll have to process the
  .\" output yourself in some meaningful fashion.
  .\"
  .\" Avoid warning from groff about undefined register 'F'.
  .de IX
  ..
  .nr rF 0
  .if \n(.g .if rF .nr rF 1
  .if (\n(rF:(\n(.g==0)) \{\
  .    if \nF \{\
  .        de IX
  .        tm Index:\\$1\t\\n%\t"\\$2"
  ..
  .        if !\nF==2 \{\
  .            nr % 0
  .            nr F 2
  .        \}
  .    \}
  .\}
  .rr rF
  ----END OF PREAMBLE----
  .\"
  .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
  .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
  .    \" fudge factors for nroff and troff
  .if n \{\
  .    ds #H 0
  .    ds #V .8m
  .    ds #F .3m
  .    ds #[ \f1
  .    ds #] \fP
  .\}
  .if t \{\
  .    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
  .    ds #V .6m
  .    ds #F 0
  .    ds #[ \&
  .    ds #] \&
  .\}
  .    \" simple accents for nroff and troff
  .if n \{\
  .    ds ' \&
  .    ds ` \&
  .    ds ^ \&
  .    ds , \&
  .    ds ~ ~
  .    ds /
  .\}
  .if t \{\
  .    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
  .    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
  .    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
  .    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
  .    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
  .    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
  .\}
  .    \" troff and (daisy-wheel) nroff accents
  .ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
  .ds 8 \h'\*(#H'\(*b\h'-\*(#H'
  .ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
  .ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
  .ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
  .ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
  .ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
  .ds ae a\h'-(\w'a'u*4/10)'e
  .ds Ae A\h'-(\w'A'u*4/10)'E
  .    \" corrections for vroff
  .if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
  .if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
  .    \" for low resolution devices (crt and lpr)
  .if \n(.H>23 .if \n(.V>19 \
  \{\
  .    ds : e
  .    ds 8 ss
  .    ds o a
  .    ds d- d\h'-1'\(ga
  .    ds D- D\h'-1'\(hy
  .    ds th \o'bp'
  .    ds Th \o'LP'
  .    ds ae ae
  .    ds Ae AE
  .\}
  .rm #[ #] #H #V #F C
  ----END OF PREAMBLE----
POD_MAN

$fatpacked{"Pod/ParseLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSELINK';
  package Pod::ParseLink;use 5.008;use strict;use warnings;use vars qw(@EXPORT @ISA $VERSION);use Exporter;@ISA=qw(Exporter);@EXPORT=qw(parselink);$VERSION='4.14';sub _parse_section {my ($link)=@_;$link =~ s/^\s+//;$link =~ s/\s+$//;return (undef,$1)if ($link =~ /^"\s*(.*?)\s*"$/);my ($page,$section)=split (/\s*\/\s*/,$link,2);$section =~ s/^"\s*(.*?)\s*"$/$1/ if$section;if ($page && $page =~ / / &&!defined ($section)){$section=$page;$page=undef}else {$page=undef unless$page;$section=undef unless$section}return ($page,$section)}sub _infer_text {my ($page,$section)=@_;my$inferred;if ($page &&!$section){$inferred=$page}elsif (!$page && $section){$inferred='"' .$section .'"'}elsif ($page && $section){$inferred='"' .$section .'" in ' .$page}return$inferred}sub parselink {my ($link)=@_;$link =~ s/\s+/ /g;my$text;if ($link =~ /\|/){($text,$link)=split (/\|/,$link,2)}if ($link =~ /\A\w+:[^:\s]\S*\Z/){my$inferred;if (defined ($text)&& length ($text)> 0){return ($text,$text,$link,undef,'url')}else {return ($text,$link,$link,undef,'url')}}else {my ($name,$section)=_parse_section ($link);my$inferred;if (defined ($text)&& length ($text)> 0){$inferred=$text}else {$inferred=_infer_text ($name,$section)}my$type=($name && $name =~ /\(\S*\)/)? 'man' : 'pod';return ($text,$inferred,$name,$section,$type)}}1;
POD_PARSELINK

$fatpacked{"Pod/Perldoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC';
  use 5.006;package Pod::Perldoc;use strict;use warnings;use Config '%Config';use Fcntl;use File::Basename qw(basename);use File::Spec::Functions qw(catfile catdir splitdir);use vars qw($VERSION @Pagers $Bindir $Pod2man $Temp_Files_Created $Temp_File_Lifetime);$VERSION='3.28';BEGIN {unless(defined&DEBUG){if(($ENV{'PERLDOCDEBUG'}|| '')=~ m/^(\d+)/){eval("sub DEBUG () {$1}");die "WHAT? Couldn't eval-up a DEBUG constant!? $@" if $@}else {*DEBUG=sub () {0}}}}use Pod::Perldoc::GetOptsOO;use Carp qw(croak carp);sub debugging {my$self=shift;(defined(&Pod::Perldoc::DEBUG)and &Pod::Perldoc::DEBUG())}sub debug {my($self,@messages)=@_;return unless$self->debugging;print STDERR map {"DEBUG : $_"}@messages}sub warn {my($self,@messages)=@_;carp(join "\n",@messages,'')}sub die {my($self,@messages)=@_;croak(join "\n",@messages,'')}sub TRUE () {1}sub FALSE () {return}sub BE_LENIENT () {1}BEGIN {*is_vms=$^O eq 'VMS' ? \&TRUE : \&FALSE unless defined&is_vms;*is_mswin32=$^O eq 'MSWin32' ? \&TRUE : \&FALSE unless defined&is_mswin32;*is_dos=$^O eq 'dos' ? \&TRUE : \&FALSE unless defined&is_dos;*is_os2=$^O eq 'os2' ? \&TRUE : \&FALSE unless defined&is_os2;*is_cygwin=$^O eq 'cygwin' ? \&TRUE : \&FALSE unless defined&is_cygwin;*is_linux=$^O eq 'linux' ? \&TRUE : \&FALSE unless defined&is_linux;*is_hpux=$^O =~ m/hpux/ ? \&TRUE : \&FALSE unless defined&is_hpux;*is_amigaos=$^O eq 'amigaos' ? \&TRUE : \&FALSE unless defined&is_amigaos}$Temp_File_Lifetime ||= 60 * 60 * 24 * 5;{my$pager=$Config{'pager'};push@Pagers,$pager if -x (split /\s+/,$pager)[0]or __PACKAGE__->is_vms}$Bindir=$Config{'scriptdirexp'};$Pod2man="pod2man" .($Config{'versiononly'}? $Config{'version'}: '');for my$subname (map "opt_$_",split '',q{mhlDriFfXqnTdULva}){no strict 'refs';*$subname=do{use strict 'refs';sub () {shift->_elem($subname,@_)}}}sub opt_a_with {shift->_elem('opt_a',@_)}sub opt_f_with {shift->_elem('opt_f',@_)}sub opt_q_with {shift->_elem('opt_q',@_)}sub opt_d_with {shift->_elem('opt_d',@_)}sub opt_L_with {shift->_elem('opt_L',@_)}sub opt_v_with {shift->_elem('opt_v',@_)}sub opt_w_with {my($self,$value)=@_;if($value =~ m/^([-_a-zA-Z][-_a-zA-Z0-9]*)(?:[=\:](.*?))?$/s){my$option=$1;my$option_value=defined($2)? $2 : "TRUE";$option =~ tr/\-/_/s;$self->add_formatter_option($option,$option_value)}else {$self->warn(qq("$value" isn't a good formatter option name.  I'm ignoring it!\n ))}return}sub opt_M_with {my($self,$classes)=@_;return unless defined$classes and length$classes;DEBUG > 4 and print "Considering new formatter classes -M$classes\n";my@classes_to_add;for my$classname (split m/[,;]+/s,$classes){next unless$classname =~ m/\S/;if($classname =~ m/^(\w+(::\w+)+)$/s){push@classes_to_add,$1}else {$self->warn(qq("$classname" isn't a valid classname.  Ignoring.\n))}}unshift @{$self->{'formatter_classes'}},@classes_to_add;DEBUG > 3 and print("Adding @classes_to_add to the list of formatter classes, " ."making them @{ $self->{'formatter_classes'} }.\n");return}sub opt_V {print join '',"Perldoc v$VERSION, under perl v$] for $^O",(defined(&Win32::BuildNumber)and defined&Win32::BuildNumber())? (" (win32 build ",&Win32::BuildNumber(),")"): (),(chr(65)eq 'A')? (): " (non-ASCII)","\n",;exit}sub opt_t {my$self=shift;$self->opt_o_with('text')if @_ and $_[0];return$self->_elem('opt_t',@_)}sub opt_u {my$self=shift;$self->opt_o_with('pod')if @_ and $_[0];return$self->_elem('opt_u',@_)}sub opt_n_with {my$self=shift;$self->opt_o_with('man')if @_ and $_[0];$self->_elem('opt_n',@_)}sub opt_o_with {my($self,$rest)=@_;return unless defined$rest and length$rest;if($rest =~ m/^(\w+)$/s){$rest=$1}else {$self->warn(qq("$rest" isn't a valid output format.  Skipping.\n"));return}$self->aside("Noting \"$rest\" as desired output format...\n");my@classes;for my$prefix ("Pod::Perldoc::To","Pod::Simple::","Pod::"){for my$stem ($rest,"\L$rest","\L\u$rest","\U$rest"){$self->aside("Considering $prefix$stem\n");push@classes,$prefix .$stem}}$self->opt_M_with(join ";",@classes);return}sub run {my$class=shift;if(DEBUG > 3){print "Parameters to $class\->run:\n";my@x=@_;while(@x){$x[1]='<undef>' unless defined$x[1];$x[1]="@{$x[1]}" if ref($x[1])eq 'ARRAY';print "  [$x[0]] => [$x[1]]\n";splice@x,0,2}print "\n"}return$class -> new(@_)-> process()|| 0}sub new {my$class=shift;my$new=bless {@_},(ref($class)|| $class);DEBUG > 1 and print "New $class object $new\n";$new->init();$new}sub aside {my$self=shift;if(DEBUG or $self->opt_D){my$out=join('',DEBUG ? do {my$callsub=(caller(1))[3];my$package=quotemeta(__PACKAGE__ .'::');$callsub =~ s/^$package/'/os;$callsub .": "}: '',@_,);if(DEBUG){print$out}else {print STDERR$out}}return}sub usage {my$self=shift;$self->warn("@_\n")if @_;$!=0;CORE::die(<<EOF)}sub program_name {my($self)=@_;if(my$link=readlink($0)){$self->debug("The value in $0 is a symbolic link to $link\n")}my$basename=basename($0);$self->debug("\$0 is [$0]\nbasename is [$basename]\n");{my($untainted)=$basename =~ m/(
  perldoc [options] PageName|ModuleName|ProgramName|URL...
  perldoc [options] -f BuiltinFunction
  perldoc [options] -q FAQRegex
  perldoc [options] -v PerlVariable
  
  Options:
      -h   Display this help message
      -V   Report version
      -r   Recursive search (slow)
      -i   Ignore case
      -t   Display pod using pod2text instead of Pod::Man and groff
               (-t is the default on win32 unless -n is specified)
      -u   Display unformatted pod text
      -m   Display module's file in its entirety
      -n   Specify replacement for groff
      -l   Display the module's file name
      -U   Don't attempt to drop privs for security
      -F   Arguments are file names, not modules (implies -U)
      -D   Verbosely describe what's going on
      -T   Send output to STDOUT without any pager
      -d output_filename_to_send_to
      -o output_format_name
      -M FormatterModuleNameToUse
      -w formatter_option:option_value
      -L translation_code   Choose doc translation (if any)
      -X   Use index if present (looks for pod.idx at $Config{archlib})
      -q   Search the text of questions (not answers) in perlfaq[1-9]
      -f   Search Perl built-in functions
      -a   Search Perl API
      -v   Search predefined Perl variables
  
  PageName|ModuleName|ProgramName|URL...
           is the name of a piece of documentation that you want to look at. You
           may either give a descriptive name of the page (as in the case of
           `perlfunc') the name of a module, either like `Term::Info' or like
           `Term/Info', or the name of a program, like `perldoc', or a URL
           starting with http(s).
  
  BuiltinFunction
           is the name of a perl function.  Will extract documentation from
           `perlfunc' or `perlop'.
  
  FAQRegex
           is a regex. Will search perlfaq[1-9] for and extract any
           questions that match.
  
  Any switches in the PERLDOC environment variable will be used before the
  command line arguments.  The optional pod index file contains a list of
  filenames, one per line.
                                                         [Perldoc v$VERSION]
  EOF
      \A
      perl
        (?: doc | func | faq | help | op | toc | var # Camel 3
        ) 
      (?: -? v? \d+ \. \d+ (?:\. \d+)? )? # possible version
      (?: \. (?: bat | exe | com ) )?    # possible extension
      \z
      )
      /x;$self->debug($untainted);return$untainted if$untainted}$self->warn(<<"HERE");{my($untainted)=$basename =~ m/(
  You called the perldoc command with a name that I didn't recognize.
  This might mean that someone is tricking you into running a
  program you don't intend to use, but it also might mean that you
  created your own link to perldoc. I think your program name is
  [$basename].
  
  I'll allow this if the filename only has [a-zA-Z0-9._-].
  HERE
      \A [a-zA-Z0-9._-]+ \z
      )/x;$self->debug($untainted);return$untainted if$untainted}$self->die(<<"HERE")}sub usage_brief {my$self=shift;my$program_name=$self->program_name;CORE::die(<<"EOUSAGE")}sub pagers {@{shift->{'pagers'}}}sub _elem {if(@_ > 2){return $_[0]{$_[1]}=$_[2]}else {return $_[0]{$_[1]}}}sub init {my$self=shift;eval {umask(0077)};if ($] < 5.008){$self->aside("Your old perl doesn't have proper unicode support.")}else {use Encode qw(decode_utf8);@ARGV=map {decode_utf8($_,1)}@ARGV}$self->{'args'}||= \@ARGV;$self->{'found'}||= [];$self->{'temp_file_list'}||= [];$self->{'target'}=undef;$self->init_formatter_class_list;$self->{'pagers' }=[@Pagers]unless exists$self->{'pagers'};$self->{'bindir' }=$Bindir unless exists$self->{'bindir'};$self->{'pod2man'}=$Pod2man unless exists$self->{'pod2man'};$self->{'search_path'}=[]unless exists$self->{'search_path'};push @{$self->{'formatter_switches'}=[]},(['__bindir'=>$self->{'bindir' }],['__pod2man'=>$self->{'pod2man'}],);DEBUG > 3 and printf "Formatter switches now: [%s]\n",join ' ',map "[@$_]",@{$self->{'formatter_switches'}};$self->{'translators'}=[];$self->{'extra_search_dirs'}=[];return}sub init_formatter_class_list {my$self=shift;$self->{'formatter_classes'}||= [];$self->opt_M_with('Pod::Perldoc::ToPod');$self->opt_o_with('text');$self->opt_o_with('term')unless$self->is_mswin32 || $self->is_dos || $self->is_amigaos ||!($ENV{TERM}&& (($ENV{TERM}|| '')!~ /dumb|emacs|none|unknown/i));return}sub process {my$self=shift;DEBUG > 1 and print "  Beginning process.\n";DEBUG > 1 and print "  Args: @{$self->{'args'}}\n\n";if(DEBUG > 3){print "Object contents:\n";my@x=%$self;while(@x){$x[1]='<undef>' unless defined$x[1];$x[1]="@{$x[1]}" if ref($x[1])eq 'ARRAY';print "  [$x[0]] => [$x[1]]\n";splice@x,0,2}print "\n"}return$self->usage_brief unless @{$self->{'args'}};$self->options_reading;$self->pagers_guessing;$self->aside(sprintf "$0 => %s v%s\n",ref($self),$self->VERSION);$self->drop_privs_maybe unless ($self->opt_U || $self->opt_F);$self->options_processing;$self->aside("\n");my@pages;$self->{'pages'}=\@pages;if($self->opt_f){@pages=qw(perlfunc perlop)}elsif($self->opt_q){@pages=("perlfaq1" .. "perlfaq9")}elsif($self->opt_v){@pages=("perlvar")}elsif($self->opt_a){@pages=("perlapi")}else {@pages=@{$self->{'args'}}}return$self->usage_brief unless@pages;$self->find_good_formatter_class();$self->formatter_sanity_check();$self->maybe_extend_searchpath();my@found=$self->grand_search_init(\@pages);exit ($self->is_vms ? 98962 : 1)unless@found;if ($self->opt_l and not $self->opt_q){DEBUG and print "We're in -l mode, so byebye after this:\n";print join("\n",@found),"\n";return}$self->tweak_found_pathnames(\@found);$self->assert_closing_stdout;return$self->page_module_file(@found)if$self->opt_m;DEBUG > 2 and print "Found: [@found]\n";return$self->render_and_page(\@found)}{my(%class_seen,%class_loaded);sub find_good_formatter_class {my$self=$_[0];my@class_list=@{$self->{'formatter_classes'}|| []};$self->die("WHAT?  Nothing in the formatter class list!?")unless@class_list;local@INC=@INC;pop@INC if$INC[-1]eq '.';my$good_class_found;for my$c (@class_list){DEBUG > 4 and print "Trying to load $c...\n";if($class_loaded{$c}){DEBUG > 4 and print "OK, the already-loaded $c it is!\n";$good_class_found=$c;last}if($class_seen{$c}){DEBUG > 4 and print "I've tried $c before, and it's no good.  Skipping.\n";next}$class_seen{$c}=1;if($c->can('parse_from_file')){DEBUG > 4 and print "Interesting, the formatter class $c is already loaded!\n"}elsif(($self->is_os2 or $self->is_mswin32 or $self->is_dos or $self->is_os2)and $class_seen{lc("~$c")}++){DEBUG > 4 and print "We already used something quite like \"\L$c\E\", so no point using $c\n"}else {DEBUG > 4 and print "Trying to eval 'require $c'...\n";local $^W=$^W;if(DEBUG()or $self->opt_D){}else {$^W=0}eval "require $c";if($@){DEBUG > 4 and print "Couldn't load $c: $!\n";next}}if($c->can('parse_from_file')){DEBUG > 4 and print "Settling on $c\n";my$v=$c->VERSION;$v=(defined$v and length$v)? " version $v" : '';$self->aside("Formatter class $c$v successfully loaded!\n");$good_class_found=$c;last}else {DEBUG > 4 and print "Class $c isn't a formatter?!  Skipping.\n"}}$self->die("Can't find any loadable formatter class in @class_list?!\nAborting")unless$good_class_found;$self->{'formatter_class'}=$good_class_found;$self->aside("Will format with the class $good_class_found\n");return}}sub formatter_sanity_check {my$self=shift;my$formatter_class=$self->{'formatter_class'}|| $self->die("NO FORMATTER CLASS YET!?");if(!$self->opt_T and $formatter_class->can('is_pageable')and!$formatter_class->is_pageable and!$formatter_class->can('page_for_perldoc')){my$ext=($formatter_class->can('output_extension')&& $formatter_class->output_extension)|| '';$ext=".$ext" if length$ext;my$me=$self->program_name;$self->die("When using Perldoc to format with $formatter_class, you have to\n" ."specify -T or -dsomefile$ext\n" ."See `$me perldoc' for more information on those switches.\n")}}sub render_and_page {my($self,$found_list)=@_;$self->maybe_generate_dynamic_pod($found_list);my($out,$formatter)=$self->render_findings($found_list);if($self->opt_d){printf "Perldoc (%s) output saved to %s\n",$self->{'formatter_class'}|| ref($self),$out;print "But notice that it's 0 bytes long!\n" unless -s $out}elsif($formatter->can('page_for_perldoc')and do {$self->aside("Going to call $formatter\->page_for_perldoc(\"$out\")\n");if($formatter->page_for_perldoc($out,$self)){$self->aside("page_for_perldoc returned true, so NOT paging with $self.\n");1}else {$self->aside("page_for_perldoc returned false, so paging with $self instead.\n");''}}){}else {if(-s $out){$self->page($out,$self->{'output_to_stdout'},$self->pagers)}else {$self->aside("Skipping $out (from $$found_list[0] " ."via $$self{'formatter_class'}) as it is 0-length.\n");push @{$self->{'temp_file_list'}},$out;$self->unlink_if_temp_file($out)}}$self->after_rendering();return}sub options_reading {my$self=shift;if(defined$ENV{"PERLDOC"}and length$ENV{"PERLDOC"}){require Text::ParseWords;$self->aside("Noting env PERLDOC setting of $ENV{'PERLDOC'}\n");unshift @{$self->{'args'}},Text::ParseWords::shellwords($ENV{"PERLDOC"});DEBUG > 1 and print "  Args now: @{$self->{'args'}}\n\n"}else {DEBUG > 1 and print "  Okay, no PERLDOC setting in ENV.\n"}DEBUG > 1 and print "  Args right before switch processing: @{$self->{'args'}}\n";Pod::Perldoc::GetOptsOO::getopts($self,$self->{'args'},'YES')or return$self->usage;DEBUG > 1 and print "  Args after switch processing: @{$self->{'args'}}\n";return$self->usage if$self->opt_h;return}sub options_processing {my$self=shift;if ($self->opt_X){my$podidx="$Config{'archlib'}/pod.idx";$podidx="" unless -f $podidx && -r _ && -M _ <= 7;$self->{'podidx'}=$podidx}$self->{'output_to_stdout'}=1 if$self->opt_T or!-t STDOUT;$self->options_sanity;if($self->opt_n){$self->add_formatter_option('__nroffer'=>$self->opt_n)}if (!$self->opt_L && $ENV{PERLDOC_POD2}){if ($ENV{PERLDOC_POD2}eq '1'){$self->_elem('opt_L',(split(/\_/,$ENV{LC_ALL}|| $ENV{LC_LANG}|| $ENV{LANG}))[0])}else {$self->_elem('opt_L',$ENV{PERLDOC_POD2})}};$self->add_translator(split(/\s+/,$self->opt_L))if$self->opt_L;return}sub options_sanity {my$self=shift;if($self->opt_f or $self->opt_q or $self->opt_a){my$count;$count++ if$self->opt_f;$count++ if$self->opt_q;$count++ if$self->opt_a;$self->usage("Only one of -f or -q or -a")if$count > 1;$self->warn("Perldoc is meant for reading one file at a time.\n","So these parameters are being ignored: ",join(' ',@{$self->{'args'}}),"\n")if @{$self->{'args'}}}return}sub grand_search_init {my($self,$pages,@found)=@_;for (@$pages){if (/^http(s)?:\/\//){require HTTP::Tiny;require File::Temp;my$response=HTTP::Tiny->new->get($_);if ($response->{success}){my ($fh,$filename)=File::Temp::tempfile(UNLINK=>1);$fh->print($response->{content});push@found,$filename;($self->{podnames}{$filename}=m{.*/([^/#?]+)} ? uc $1 : "UNKNOWN")=~ s/\.P(?:[ML]|OD)\z//}else {print STDERR "No " .($self->opt_m ? "module" : "documentation")." found for \"$_\".\n";if (/^https/){print STDERR "You may need an SSL library (such as IO::Socket::SSL) for that URL.\n"}}next}if ($self->{'podidx'}&& open(PODIDX,$self->{'podidx'})){my$searchfor=catfile split '::',$_;$self->aside("Searching for '$searchfor' in $self->{'podidx'}\n");local $_;while (<PODIDX>){chomp;push(@found,$_)if m,/$searchfor(?:\.(?:pod|pm))?\z,i}close(PODIDX)or $self->die("Can't close $$self{'podidx'}: $!");next}$self->aside("Searching for $_\n");if ($self->opt_F){next unless -r;push@found,$_ if$self->opt_l or $self->opt_m or $self->containspod($_);next}my@searchdirs;push@searchdirs,@{$self->{'extra_search_dirs'}};push@searchdirs,($self->{'bindir'},@{$self->{search_path}},@INC);unless ($self->opt_m){if ($self->is_vms){my($i,$trn);for ($i=0;$trn=$ENV{'DCL$PATH;'.$i};$i++){push(@searchdirs,$trn)}push(@searchdirs,'perl_root:[lib.pods]')}else {push(@searchdirs,grep(-d,split($Config{path_sep},$ENV{'PATH'})))}}my@files=$self->searchfor(0,$_,@searchdirs);if (@files){$self->aside("Found as @files\n")}elsif (BE_LENIENT and!/\W/ and @files=$self->searchfor(0,"perl$_",@searchdirs)){$self->aside("Loosely found as @files\n")}else {@searchdirs=grep(!/^\.\z/s,@INC);@files=$self->searchfor(1,$_,@searchdirs)if$self->opt_r;if (@files){$self->aside("Loosely found as @files\n")}else {print STDERR "No " .($self->opt_m ? "module" : "documentation")." found for \"$_\".\n";if (@{$self->{'found'}}){print STDERR "However, try\n";my$me=$self->program_name;for my$dir (@{$self->{'found'}}){opendir(DIR,$dir)or $self->die("opendir $dir: $!");while (my$file=readdir(DIR)){next if ($file =~ /^\./s);$file =~ s/\.(pm|pod)\z//;print STDERR "\t$me $_\::$file\n"}closedir(DIR)or $self->die("closedir $dir: $!")}}}}push(@found,@files)}return@found}sub maybe_generate_dynamic_pod {my($self,$found_things)=@_;my@dynamic_pod;$self->search_perlapi($found_things,\@dynamic_pod)if$self->opt_a;$self->search_perlfunc($found_things,\@dynamic_pod)if$self->opt_f;$self->search_perlvar($found_things,\@dynamic_pod)if$self->opt_v;$self->search_perlfaqs($found_things,\@dynamic_pod)if$self->opt_q;if(!$self->opt_f and!$self->opt_q and!$self->opt_v and!$self->opt_a){DEBUG > 4 and print "That's a non-dynamic pod search.\n"}elsif (@dynamic_pod){$self->aside("Hm, I found some Pod from that search!\n");my ($buffd,$buffer)=$self->new_tempfile('pod','dyn');if ($] >= 5.008 && $self->opt_L){binmode($buffd,":encoding(UTF-8)");print$buffd "=encoding utf8\n\n"}push @{$self->{'temp_file_list'}},$buffer;my$in_list=!$self->not_dynamic && $self->opt_f || $self->opt_v || $self->opt_a;print$buffd "=over 8\n\n" if$in_list;print$buffd @dynamic_pod or $self->die("Can't print $buffer: $!");print$buffd "=back\n" if$in_list;close$buffd or $self->die("Can't close $buffer: $!");@$found_things=$buffer;$self->add_formatter_option('__filter_nroff'=>1)}else {@$found_things=();$self->aside("I found no Pod from that search!\n")}return}sub not_dynamic {my ($self,$value)=@_;$self->{__not_dynamic}=$value if @_==2;return$self->{__not_dynamic}}sub add_formatter_option {my$self=shift;push @{$self->{'formatter_switches'}},[@_ ]if @_;DEBUG > 3 and printf "Formatter switches now: [%s]\n",join ' ',map "[@$_]",@{$self->{'formatter_switches'}};return}sub new_translator {my$self=shift;my$lang=shift;local@INC=@INC;pop@INC if$INC[-1]eq '.';my$pack='POD2::' .uc($lang);eval "require $pack";if (!$@ && $pack->can('new')){return$pack->new()}eval {require POD2::Base};return if $@;return POD2::Base->new({lang=>$lang })}sub add_translator {my$self=shift;for my$lang (@_){my$tr=$self->new_translator($lang);if (defined$tr){push @{$self->{'translators'}},$tr;push @{$self->{'extra_search_dirs'}},$tr->pod_dirs;$self->aside("translator for '$lang' loaded\n")}else {$self->warn("Perldoc cannot load translator package for '$lang': ignored\n")}}return}sub open_fh {my ($self,$op,$path)=@_;open my$fh,$op,$path or $self->die("Couldn't open $path: $!");return$fh}sub set_encoding {my ($self,$fh,$encoding)=@_;if ($encoding =~ /utf-?8/i){$encoding=":encoding(UTF-8)"}else {$encoding=":encoding($encoding)"}if ($] < 5.008){$self->aside("Your old perl doesn't have proper unicode support.")}else {binmode($fh,$encoding)}return$fh}sub search_perlvar {my($self,$found_things,$pod)=@_;my$opt=$self->opt_v;if ($opt !~ /^ (?: [\@\%\$]\S+ | [A-Z]\w* ) $/x){CORE::die("'$opt' does not look like a Perl variable\n")}DEBUG > 2 and print "Search: @$found_things\n";my$perlvar=shift @$found_things;my$fh=$self->open_fh("<",$perlvar);if ($opt ne '$0' && $opt =~ /^\$\d+$/){$opt='$<I<digits>>'}my$search_re=quotemeta($opt);DEBUG > 2 and print "Going to perlvar-scan for $search_re in $perlvar\n";local $_;my$enc;while (<$fh>){$enc=$1 if /^=encoding\s+(\S+)/;last if /^=over 8/}$fh=$self->set_encoding($fh,$enc)if$enc;my$found=0;my$inheader=1;my$inlist=0;while (<$fh>){last if /^=head2 Error Indicators/;if (m/^=item\s+$search_re\s/){$found=1}elsif (/^=item/){last if$found &&!$inheader &&!$inlist}elsif (!/^\s+$/){if ($found){$inheader=0}else {@$pod=();$inheader=1;next}}if (/^=over/){++$inlist}elsif (/^=back/){last if$found &&!$inheader &&!$inlist;--$inlist}push @$pod,$_}@$pod=()unless$found;if (!@$pod){CORE::die("No documentation for perl variable '$opt' found\n")}close$fh or $self->die("Can't close $perlvar: $!");return}sub search_perlop {my ($self,$found_things,$pod)=@_;$self->not_dynamic(1);my$perlop=shift @$found_things;my$fh=$self->open_fh('<',$perlop);my$thing=$self->opt_f;my$previous_line;my$push=0;my$seen_item=0;my$skip=1;while(my$line=<$fh>){$line =~ /^=encoding\s+(\S+)/ && $self->set_encoding($fh,$1);if ($line =~ m!^X<operator, regexp>!){$skip=0}next if$skip;if ($line =~ m!X<+\s*\Q$thing\E\s*>+!){if ($previous_line){push @$pod,"=over 8\n\n",$previous_line;$previous_line=""}push @$pod,$line;$push=1}elsif ($push and $line =~ m!^=item\s*.*$!){$seen_item=1}elsif ($push and $seen_item and $line =~ m!^X<+\s*[ a-z,?-]+\s*>+!){$push=0;$seen_item=0;last}elsif ($push){push @$pod,$line}else {$previous_line=$line}}if (scalar @$pod){pop @$pod;push @$pod,"\n\n=back\n";DEBUG > 8 and print "PERLOP POD --->" .(join "",@$pod)."<---\n"}else {DEBUG > 4 and print "No pod from perlop\n"}close$fh;return}sub search_perlapi {my($self,$found_things,$pod)=@_;DEBUG > 2 and print "Search: @$found_things\n";my$perlapi=shift @$found_things;my$fh=$self->open_fh('<',$perlapi);my$search_re=quotemeta($self->opt_a);DEBUG > 2 and print "Going to perlapi-scan for $search_re in $perlapi\n";local $_;my$found=0;my$inlist=0;my@related;my$related_re;while (<$fh>){/^=encoding\s+(\S+)/ && $self->set_encoding($fh,$1);if (m/^=item\s+$search_re\b/){$found=1}elsif (@related > 1 and /^=item/){$related_re ||= join "|",@related;if (m/^=item\s+(?:$related_re)\b/){$found=1}else {last}}elsif (/^=item/){last if$found > 1 and not $inlist}elsif ($found and /^X<[^>]+>/){push@related,m/X<([^>]+)>/g}next unless$found;if (/^=over/){++$inlist}elsif (/^=back/){last if$found > 1 and not $inlist;--$inlist}push @$pod,$_;++$found if /^\w/}if (!@$pod){CORE::die(sprintf "No documentation for perl api function '%s' found\n",$self->opt_a)}close$fh or $self->die("Can't open $perlapi: $!");return}sub search_perlfunc {my($self,$found_things,$pod)=@_;DEBUG > 2 and print "Search: @$found_things\n";my$pfunc=shift @$found_things;my$fh=$self->open_fh("<",$pfunc);my$search_re=($self->opt_f =~ /^-[rwxoRWXOeszfdlpSbctugkTBMAC]$/)? '(?:I<)?-X' : quotemeta($self->opt_f);DEBUG > 2 and print "Going to perlfunc-scan for $search_re in $pfunc\n";my$re='Alphabetical Listing of Perl Functions';if ($self->opt_L && defined$self->{'translators'}->[0]){my$tr=$self->{'translators'}->[0];$re=$tr->search_perlfunc_re if$tr->can('search_perlfunc_re');if ($] < 5.008){$self->aside("Your old perl doesn't really have proper unicode support.")}}local $_;while (<$fh>){/^=encoding\s+(\S+)/ && $self->set_encoding($fh,$1);last if /^=head2 (?:$re|Alphabetical Listing of Perl Functions)/}my$found=0;my$inlist=0;my@perlops=qw(m q qq qr qx qw s tr y);my@related;my$related_re;while (<$fh>){last if(grep{$self->opt_f eq $_}@perlops);if (/^=over/ and not $found){++$inlist}elsif (/^=back/ and not $found and $inlist){--$inlist}if (m/^=item\s+$search_re\b/ and $inlist < 2){$found=1}elsif (@related > 1 and /^=item/){$related_re ||= join "|",@related;if (m/^=item\s+(?:$related_re)\b/){$found=1}else {last if$found > 1 and $inlist < 2}}elsif (/^=item|^=back/){last if$found > 1 and $inlist < 2}elsif ($found and /^X<[^>]+>/){push@related,m/X<([^>]+)>/g}next unless$found;if (/^=over/){++$inlist}elsif (/^=back/){--$inlist}push @$pod,$_;++$found if /^\w/}if(!@$pod){$self->search_perlop($found_things,$pod)}if (!@$pod){CORE::die(sprintf "No documentation for perl function '%s' found\n",$self->opt_f)}close$fh or $self->die("Can't close $pfunc: $!");return}sub search_perlfaqs {my($self,$found_things,$pod)=@_;my$found=0;my%found_in;my$search_key=$self->opt_q;my$rx=eval {qr/$search_key/}or $self->die(<<EOD);local $_;for my$file (@$found_things){$self->die("invalid file spec: $!")if$file =~ /[<>|]/;my$fh=$self->open_fh("<",$file);while (<$fh>){/^=encoding\s+(\S+)/ && $self->set_encoding($fh,$1);if (m/^=head2\s+.*(?:$search_key)/i){$found=1;push @$pod,"=head1 Found in $file\n\n" unless$found_in{$file}++}elsif (/^=head[12]/){$found=0}next unless$found;push @$pod,$_}close($fh)}CORE::die("No documentation for perl FAQ keyword '$search_key' found\n")unless @$pod;if ($self->opt_l){CORE::die((join "\n",keys%found_in)."\n")}return}sub render_findings {my($self,$found_things)=@_;my$formatter_class=$self->{'formatter_class'}|| $self->die("No formatter class set!?");my$formatter=$formatter_class->can('new')? $formatter_class->new : $formatter_class ;if(!@$found_things){$self->die("Nothing found?!")}elsif(@$found_things > 1){$self->warn("Perldoc is only really meant for reading one document at a time.\n","So these parameters are being ignored: ",join(' ',@$found_things[1 .. $#$found_things]),"\n")}my$file=$found_things->[0];DEBUG > 3 and printf "Formatter switches now: [%s]\n",join ' ',map "[@$_]",@{$self->{'formatter_switches'}};if(ref$formatter){for my$f (@{$self->{'formatter_switches'}|| []}){my($switch,$value,$silent_fail)=@$f;if($formatter->can($switch)){eval {$formatter->$switch(defined($value)? $value : ())};$self->warn("Got an error when setting $formatter_class\->$switch:\n$@\n")if $@}else {if($silent_fail or $switch =~ m/^__/s){DEBUG > 2 and print "Formatter $formatter_class doesn't support $switch\n"}else {$self->warn("$formatter_class doesn't recognize the $switch switch.\n")}}}}$self->{'output_is_binary'}=$formatter->can('write_with_binmode')&& $formatter->write_with_binmode;if($self->{podnames}and exists$self->{podnames}{$file}and $formatter->can('name')){$formatter->name($self->{podnames}{$file})}my ($out_fh,$out)=$self->new_output_file(($formatter->can('output_extension')&& $formatter->output_extension)|| undef,$self->useful_filename_bit,);{local $^W=$^W;if(DEBUG()or $self->opt_D){}else {$^W=0}eval {$formatter->parse_from_file($file,$out_fh)}}$self->warn("Error while formatting with $formatter_class:\n $@\n")if $@;DEBUG > 2 and print "Back from formatting with $formatter_class\n";close$out_fh or $self->warn("Can't close $out: $!\n(Did $formatter already close it?)");sleep 0;sleep 0;sleep 0;$self->unlink_if_temp_file($file);unless(-s $out){if($formatter->can('if_zero_length')){$formatter->if_zero_length($file,$out,$out_fh)}else {$self->warn("Got a 0-length file from $$found_things[0] via $formatter_class!?\n")}}DEBUG and print "Finished writing to $out.\n";return($out,$formatter)if wantarray;return$out}sub unlink_if_temp_file {my($self,$file)=@_;return unless defined$file and length$file;my$temp_file_list=$self->{'temp_file_list'}|| return;if(grep $_ eq $file,@$temp_file_list){$self->aside("Unlinking $file\n");unlink($file)or $self->warn("Odd, couldn't unlink $file: $!")}else {DEBUG > 1 and print "$file isn't a temp file, so not unlinking.\n"}return}sub after_rendering {my$self=$_[0];$self->after_rendering_VMS if$self->is_vms;$self->after_rendering_MSWin32 if$self->is_mswin32;$self->after_rendering_Dos if$self->is_dos;$self->after_rendering_OS2 if$self->is_os2;return}sub after_rendering_VMS {return}sub after_rendering_Dos {return}sub after_rendering_OS2 {return}sub after_rendering_MSWin32 {return}sub minus_f_nocase {my($self,$dir,$file)=@_;my$path=catfile($dir,$file);return$path if -f $path and -r _;if(!$self->opt_i or $self->is_vms or $self->is_mswin32 or $self->is_dos or $self->is_os2){$self->warn("Ignored $path: unreadable\n")if -f _;return ''}local*DIR;my@p=($dir);my($p,$cip);for$p (splitdir$file){my$try=catfile@p,$p;$self->aside("Scrutinizing $try...\n");stat$try;if (-d _){push@p,$p;if ($p eq $self->{'target'}){my$tmp_path=catfile@p;my$path_f=0;for (@{$self->{'found'}}){$path_f=1 if $_ eq $tmp_path}push (@{$self->{'found'}},$tmp_path)unless$path_f;$self->aside("Found as $tmp_path but directory\n")}}elsif (-f _ && -r _ && lc($try)eq lc($path)){return$try}elsif (-f _){$self->warn("Ignored $try: unreadable or file/dir mismatch\n")}elsif (-d catdir(@p)){my$found=0;my$lcp=lc$p;my$p_dirspec=catdir(@p);opendir DIR,$p_dirspec or $self->die("opendir $p_dirspec: $!");while(defined($cip=readdir(DIR))){if (lc$cip eq $lcp){$found++;last}}closedir DIR or $self->die("closedir $p_dirspec: $!");return "" unless$found;push@p,$cip;my$p_filespec=catfile(@p);return$p_filespec if -f $p_filespec and -r _;$self->warn("Ignored $p_filespec: unreadable\n")if -f _}}return ""}sub pagers_guessing {my$self=shift;my@pagers;push@pagers,$self->pagers;$self->{'pagers'}=\@pagers;if ($self->is_mswin32){push@pagers,qw(more< less notepad);unshift@pagers,$ENV{PAGER}if$ENV{PAGER}}elsif ($self->is_vms){push@pagers,qw(most more less type/page)}elsif ($self->is_dos){push@pagers,qw(less.exe more.com<);unshift@pagers,$ENV{PAGER}if$ENV{PAGER}}elsif ($self->is_amigaos){push@pagers,qw(/SYS/Utilities/MultiView /SYS/Utilities/More /C/TYPE);unshift@pagers,"$ENV{PAGER}" if$ENV{PAGER}}else {if ($self->is_os2){unshift@pagers,'less','cmd /c more <'}push@pagers,qw(more less pg view cat);unshift@pagers,"$ENV{PAGER} <" if$ENV{PAGER}}if ($self->is_cygwin){if (($pagers[0]eq 'less')|| ($pagers[0]eq '/usr/bin/less')){unshift@pagers,'/usr/bin/less -isrR';unshift@pagers,$ENV{PAGER}if$ENV{PAGER}}}if ($self->opt_m){unshift@pagers,"$ENV{PERLDOC_SRC_PAGER}" if$ENV{PERLDOC_SRC_PAGER}}else {unshift@pagers,"$ENV{MANPAGER} <" if$ENV{MANPAGER};unshift@pagers,"$ENV{PERLDOC_PAGER} <" if$ENV{PERLDOC_PAGER}}$self->aside("Pagers: ",(join ", ",@pagers));return}sub page_module_file {my($self,@found)=@_;if(@found > 1){$self->warn("Perldoc is only really meant for reading one document at a time.\n" ."So these files are being ignored: " .join(' ',@found[1 .. $#found])."\n")}return$self->page($found[0],$self->{'output_to_stdout'},$self->pagers)}sub check_file {my($self,$dir,$file)=@_;unless(ref$self){$Carp::Verbose=1;require Carp;Carp::croak(join '',"Crazy ",__PACKAGE__," error:\n","check_file must be an object_method!\n","Aborting")}if(length$dir and not -d $dir){DEBUG > 3 and print "  No dir $dir -- skipping.\n";return ""}my$path=$self->minus_f_nocase($dir,$file);if(length$path and ($self->opt_m ? $self->isprintable($path): $self->containspod($path))){DEBUG > 3 and print "  The file $path indeed looks promising!\n";return$path}DEBUG > 3 and print "  No good: $file in $dir\n";return ""}sub isprintable {my($self,$file,$readit)=@_;my$size=1024;my$maxunprintfrac=0.2;return 1 if!$readit && $file =~ /\.(?:pl|pm|pod|cmd|com|bat)\z/i;my$data;local($_);my$fh=$self->open_fh("<",$file);read$fh,$data,$size;close$fh;$size=length($data);$data =~ tr/\x09-\x0D\x20-\x7E//d;return length($data)<= $size*$maxunprintfrac}sub containspod {my($self,$file,$readit)=@_;return 1 if!$readit && $file =~ /\.pod\z/i;if ($self->is_cygwin and -x $file and -f "$file.exe"){$self->warn("Cygwin $file.exe search skipped\n")if DEBUG or $self->opt_D;return 0}local($_);my$fh=$self->open_fh("<",$file);while (<$fh>){if (/^=head/){close($fh)or $self->die("Can't close $file: $!");return 1}}close($fh)or $self->die("Can't close $file: $!");return 0}sub maybe_extend_searchpath {my$self=shift;if (-f "Makefile.PL" || -f "Build.PL"){push @{$self->{search_path}},'.','lib';if ($< && $> && -d "blib"){push @{$self->{search_path}},'blib';$self->warn($@)if $@ && $self->opt_D}}return}sub new_output_file {my$self=shift;my$outspec=$self->opt_d;return$self->new_tempfile(@_)unless defined$outspec and length$outspec;DEBUG > 3 and print "About to try writing to specified output file $outspec\n";my$fh=$self->open_fh(">",$outspec);DEBUG > 3 and print "Successfully opened $outspec\n";binmode($fh)if$self->{'output_is_binary'};return($fh,$outspec)}sub useful_filename_bit {my$self=shift;my$pages=$self->{'pages'}|| return undef;return undef unless @$pages;my$chunk=$pages->[0];return undef unless defined$chunk;$chunk =~ s/:://g;$chunk =~ s/\.\w+$//g;if($chunk =~ m/([^\#\\:\/\$]+)$/s){$chunk=$1}else {return undef}$chunk =~ s/[^a-zA-Z0-9]+//g;$chunk=substr($chunk,-10)if length($chunk)> 10;return$chunk}sub new_tempfile {my$self=shift;++$Temp_Files_Created;require File::Temp;return File::Temp::tempfile(UNLINK=>1)}sub page {my ($self,$output,$output_to_stdout,@pagers)=@_;if ($output_to_stdout){$self->aside("Sending unpaged output to STDOUT.\n");my$fh=$self->open_fh("<",$output);local $_;while (<$fh>){print or $self->die("Can't print to stdout: $!")}close$fh or $self->die("Can't close while $output: $!");$self->unlink_if_temp_file($output)}else {$output=VMS::Filespec::rmsexpand($output,'.')if$self->is_vms;$output =~ s{/}{\\}g if$self->is_mswin32 || $self->is_dos;$output =~ s/^\/(.*)\/(.*)/$1:$2/ if$self->is_amigaos;for my$pager (@pagers){$self->aside("About to try calling $pager $output\n");if ($self->is_vms){last if system("$pager $output")==0}elsif($self->is_amigaos){last if system($pager,$output)==0}else {my$formatter=$self->{'formatter_class'};if ($formatter->can('pager_configuration')){$self->aside("About to call $formatter" ."->pager_configuration(\"$pager\")\n");$formatter->pager_configuration($pager,$self)}last if system("$pager \"$output\"")==0}}}return}sub searchfor {my($self,$recurse,$s,@dirs)=@_;$s =~ s!::!/!g;$s=VMS::Filespec::unixify($s)if$self->is_vms;return$s if -f $s && $self->containspod($s);$self->aside("Looking for $s in @dirs\n");my$ret;my$i;my$dir;$self->{'target'}=(splitdir$s)[-1];for ($i=0;$i<@dirs;$i++){$dir=$dirs[$i];next unless -d $dir;($dir=VMS::Filespec::unixpath($dir))=~ s!/\z!! if$self->is_vms;if ((!$self->opt_m && ($ret=$self->check_file($dir,"$s.pod")))or ($ret=$self->check_file($dir,"$s.pm"))or ($ret=$self->check_file($dir,$s))or ($self->is_vms and $ret=$self->check_file($dir,"$s.com"))or ($self->is_os2 and $ret=$self->check_file($dir,"$s.cmd"))or (($self->is_mswin32 or $self->is_dos or $self->is_os2)and $ret=$self->check_file($dir,"$s.bat"))or ($ret=$self->check_file("$dir/pod","$s.pod"))or ($ret=$self->check_file("$dir/pod",$s))or ($ret=$self->check_file("$dir/pods","$s.pod"))or ($ret=$self->check_file("$dir/pods",$s))){DEBUG > 1 and print "  Found $ret\n";return$ret}if ($recurse){opendir(D,$dir)or $self->die("Can't opendir $dir: $!");my@newdirs=map catfile($dir,$_),grep {not /^\.\.?\z/s and not /^auto\z/s and -d catfile($dir,$_)}readdir D;closedir(D)or $self->die("Can't closedir $dir: $!");next unless@newdirs;@newdirs=map((s/\.dir\z//,$_)[1],@newdirs)if$self->is_vms;$self->aside("Also looking in @newdirs\n");push(@dirs,@newdirs)}}return ()}{my$already_asserted;sub assert_closing_stdout {my$self=shift;return if$already_asserted;eval q~ END { close(STDOUT) || CORE::die "Can't close STDOUT: $!" } ~;$self->die($@)if $@;$already_asserted=1;return}}sub tweak_found_pathnames {my($self,$found)=@_;if ($self->is_mswin32){for (@$found){s,/,\\,g}}for (@$found){s,',\\',g}return}sub am_taint_checking {my$self=shift;$self->die("NO ENVIRONMENT?!?!")unless keys%ENV;my($k,$v)=each%ENV;return is_tainted($v)}sub is_tainted {my$arg=shift;my$nada=substr($arg,0,0);local $@;eval {eval "# $nada"};return length($@)!=0}sub drop_privs_maybe {my$self=shift;DEBUG and print "Attempting to drop privs...\n";if (!($self->is_vms || $self->is_mswin32 || $self->is_dos || $self->is_os2)&& ($>==0 || $<==0)&&!$self->am_taint_checking()){my$id=eval {getpwnam("nobody")};$id=eval {getpwnam("nouser")}unless defined$id;$id=-2 unless defined$id;eval {$<=$id;$>=$id;$<=$id;$>=$id};if(!$@ && $< && $>){DEBUG and print "OK, I dropped privileges.\n"}elsif($self->opt_U){DEBUG and print "Couldn't drop privileges, but in -U mode, so feh."}else {DEBUG and print "Hm, couldn't drop privileges.  Ah well.\n"}}return}1;
  I think that your name for perldoc is potentially unsafe, so I'm
  going to disallow it. I'd rather you be safe than sorry. If you
  intended to use the name I'm disallowing, please tell the maintainers
  about it. Write to:
  
      Pod-Perldoc\@rt.cpan.org
  
  HERE
  Usage: $program_name [-hVriDtumUFXlT] [-n nroffer_program]
      [-d output_filename] [-o output_format] [-M FormatterModule]
      [-w formatter_option:option_value] [-L translation_code]
      PageName|ModuleName|ProgramName
  
  Examples:
  
      $program_name -f PerlFunc
      $program_name -q FAQKeywords
      $program_name -v PerlVar
      $program_name -a PerlAPI
  
  The -h option prints more help.  Also try "$program_name perldoc" to get
  acquainted with the system.                        [Perldoc v$VERSION]
  EOUSAGE
  Invalid regular expression '$search_key' given as -q pattern:
  $@
  Did you mean \\Q$search_key ?
  
  EOD
POD_PERLDOC

$fatpacked{"Pod/Perldoc/BaseTo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_BASETO';
  package Pod::Perldoc::BaseTo;use strict;use warnings;use vars qw($VERSION);$VERSION='3.28';use Carp qw(croak carp);use Config qw(%Config);use File::Spec::Functions qw(catfile);sub is_pageable {''}sub write_with_binmode {1}sub output_extension {'txt'}sub TRUE () {1}sub FALSE () {return}BEGIN {*is_vms=$^O eq 'VMS' ? \&TRUE : \&FALSE unless defined&is_vms;*is_mswin32=$^O eq 'MSWin32' ? \&TRUE : \&FALSE unless defined&is_mswin32;*is_dos=$^O eq 'dos' ? \&TRUE : \&FALSE unless defined&is_dos;*is_os2=$^O eq 'os2' ? \&TRUE : \&FALSE unless defined&is_os2;*is_cygwin=$^O eq 'cygwin' ? \&TRUE : \&FALSE unless defined&is_cygwin;*is_linux=$^O eq 'linux' ? \&TRUE : \&FALSE unless defined&is_linux;*is_hpux=$^O =~ m/hpux/ ? \&TRUE : \&FALSE unless defined&is_hpux;*is_openbsd=$^O =~ m/openbsd/ ? \&TRUE : \&FALSE unless defined&is_openbsd;*is_freebsd=$^O =~ m/freebsd/ ? \&TRUE : \&FALSE unless defined&is_freebsd;*is_bitrig=$^O =~ m/bitrig/ ? \&TRUE : \&FALSE unless defined&is_bitrig}sub _perldoc_elem {my($self,$name)=splice @_,0,2;if(@_){$self->{$name}=$_[0]}else {$self->{$name}}}sub debugging {my($self,@messages)=@_;(defined(&Pod::Perldoc::DEBUG)and &Pod::Perldoc::DEBUG())}sub debug {my($self,@messages)=@_;return unless$self->debugging;print STDERR map {"DEBUG $_"}@messages}sub warn {my($self,@messages)=@_;carp join "\n",@messages,''}sub die {my($self,@messages)=@_;croak join "\n",@messages,''}sub _get_path_components {my($self)=@_;my@paths=split /\Q$Config{path_sep}/,$ENV{PATH};return@paths}sub _find_executable_in_path {my($self,$program)=@_;my@found=();for my$dir ($self->_get_path_components){my$binary=catfile($dir,$program);$self->debug("Looking for $binary\n");next unless -e $binary;unless(-x $binary){$self->warn("Found $binary but it's not executable. Skipping.\n");next}$self->debug("Found $binary\n");push@found,$binary}return@found}1;
POD_PERLDOC_BASETO

$fatpacked{"Pod/Perldoc/GetOptsOO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_GETOPTSOO';
  package Pod::Perldoc::GetOptsOO;use strict;use vars qw($VERSION);$VERSION='3.28';BEGIN {*DEBUG=defined(&Pod::Perldoc::DEBUG)? \&Pod::Perldoc::DEBUG : sub(){10}}sub getopts {my($target,$args,$truth)=@_;$args ||= \@ARGV;$target->aside("Starting switch processing.  Scanning arguments [@$args]\n")if$target->can('aside');return unless @$args;$truth=1 unless @_ > 2;DEBUG > 3 and print "   Truth is $truth\n";my$error_count=0;while(@$args and ($_=$args->[0])=~ m/^-(.)(.*)/s){my($first,$rest)=($1,$2);if ($_ eq '--'){shift @$args;last}if ($first eq '-' and $rest){($first,$rest)=split '=',$rest,2}my$method="opt_${first}_with";if($target->can($method)){if($rest eq ''){shift @$args;$target->warn("Option $first needs a following argument!\n")unless @$args;$rest=shift @$args}else {shift @$args}DEBUG > 3 and print " $method => $rest\n";$target->$method($rest)}else {if($target->can($method="opt_$first")){DEBUG > 3 and print " $method is true ($truth)\n";$target->$method($truth)}elsif($target->can('handle_unknown_option')){DEBUG > 3 and print " calling handle_unknown_option('$first')\n";$error_count += ($target->handle_unknown_option($first)|| 0)}else {++$error_count;$target->warn("Unknown option: $first\n")}if($rest eq ''){shift @$args}else {DEBUG > 2 and print "   Setting args->[0] to \"-$rest\"\n";$args->[0]="-$rest"}}}$target->aside("Ending switch processing.  Args are [@$args] with $error_count errors.\n")if$target->can('aside');$error_count==0}1;
POD_PERLDOC_GETOPTSOO

$fatpacked{"Pod/Perldoc/ToANSI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOANSI';
  package Pod::Perldoc::ToANSI;use strict;use warnings;use parent qw(Pod::Perldoc::BaseTo);use vars qw($VERSION);$VERSION='3.28';sub is_pageable {1}sub write_with_binmode {0}sub output_extension {'txt'}use Pod::Text::Color ();sub alt {shift->_perldoc_elem('alt',@_)}sub indent {shift->_perldoc_elem('indent',@_)}sub loose {shift->_perldoc_elem('loose',@_)}sub quotes {shift->_perldoc_elem('quotes',@_)}sub sentence {shift->_perldoc_elem('sentence',@_)}sub width {shift->_perldoc_elem('width',@_)}sub new {return bless {},ref($_[0])|| $_[0]}sub parse_from_file {my$self=shift;my@options=map {;$_,$self->{$_}}grep!m/^_/s,keys %$self ;defined(&Pod::Perldoc::DEBUG)and Pod::Perldoc::DEBUG()and print "About to call new Pod::Text::Color ",$Pod::Text::VERSION ? "(v$Pod::Text::VERSION) " : '',"with options: ",@options ? "[@options]" : "(nil)","\n";;Pod::Text::Color->new(@options)->parse_from_file(@_)}1;
POD_PERLDOC_TOANSI

$fatpacked{"Pod/Perldoc/ToChecker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOCHECKER';
  package Pod::Perldoc::ToChecker;use strict;use warnings;use vars qw(@ISA);use vars qw($VERSION);$VERSION='3.28';eval 'require Pod::Simple::Checker';if($@){require Pod::Checker;@ISA=('Pod::Checker')}else {@ISA=('Pod::Simple::Checker')}sub is_pageable {1}sub write_with_binmode {0}sub output_extension {'txt'}sub if_zero_length {my($self,$file,$tmp,$tmpfd)=@_;print "No Pod errors in $file\n"}1;
POD_PERLDOC_TOCHECKER

$fatpacked{"Pod/Perldoc/ToMan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOMAN';
  require 5.006;package Pod::Perldoc::ToMan;use strict;use warnings;use parent qw(Pod::Perldoc::BaseTo);use vars qw($VERSION);$VERSION='3.28';use File::Spec::Functions qw(catfile);use Pod::Man 2.18;sub SUCCESS () {1}sub FAILED () {0}sub is_pageable {1}sub write_with_binmode {0}sub output_extension {'txt'}sub __filter_nroff {shift->_perldoc_elem('__filter_nroff',@_)}sub __nroffer {shift->_perldoc_elem('__nroffer',@_)}sub __bindir {shift->_perldoc_elem('__bindir',@_)}sub __pod2man {shift->_perldoc_elem('__pod2man',@_)}sub __output_file {shift->_perldoc_elem('__output_file',@_)}sub center {shift->_perldoc_elem('center',@_)}sub date {shift->_perldoc_elem('date',@_)}sub fixed {shift->_perldoc_elem('fixed',@_)}sub fixedbold {shift->_perldoc_elem('fixedbold',@_)}sub fixeditalic {shift->_perldoc_elem('fixeditalic',@_)}sub fixedbolditalic {shift->_perldoc_elem('fixedbolditalic',@_)}sub name {shift->_perldoc_elem('name',@_)}sub quotes {shift->_perldoc_elem('quotes',@_)}sub release {shift->_perldoc_elem('release',@_)}sub section {shift->_perldoc_elem('section',@_)}sub new {my($either)=shift;my$self=bless {},ref($either)|| $either;$self->init(@_);return$self}sub init {my($self,@args)=@_;unless($self->__nroffer){my$roffer=$self->_find_roffer($self->_roffer_candidates);$self->debug("Using $roffer\n");$self->__nroffer($roffer)}else {$self->debug("__nroffer is " .$self->__nroffer()."\n")}$self->_check_nroffer}sub _roffer_candidates {my($self)=@_;if($self->is_openbsd || $self->is_freebsd || $self->is_bitrig){qw(mandoc groff nroff)}else {qw(groff nroff mandoc)}}sub _find_roffer {my($self,@candidates)=@_;my@found=();for my$candidate (@candidates){push@found,$self->_find_executable_in_path($candidate)}return wantarray ? @found : $found[0]}sub _check_nroffer {return 1}sub _get_stty {`stty -a`}sub _get_columns_from_stty {my$output=$_[0]->_get_stty;if($output =~ /\bcolumns\s+(\d+)/){return $1}elsif($output =~ /;\s*(\d+)\s+columns;/){return $1}else {return 0}}sub _get_columns_from_manwidth {my($self)=@_;return 0 unless defined$ENV{MANWIDTH};unless($ENV{MANWIDTH}=~ m/\A\d+\z/){$self->warn("Ignoring non-numeric MANWIDTH ($ENV{MANWIDTH})\n");return 0}if($ENV{MANWIDTH}==0){$self->warn("Ignoring MANWIDTH of 0. Really? Why even run the program? :)\n");return 0}if($ENV{MANWIDTH}=~ m/\A(\d+)\z/){return $1}return 0}sub _get_default_width {73}sub _get_columns {$_[0]->_get_columns_from_manwidth || $_[0]->_get_columns_from_stty || $_[0]->_get_default_width}sub _get_podman_switches {my($self)=@_;my@switches=map {$_,$self->{$_}}grep!m/^_/s,keys %$self;$self->debug("Pod::Man switches are [@switches]\n");return@switches}sub _parse_with_pod_man {my($self,$file)=@_;local*STDOUT;open STDOUT,'>',$self->{_text_ref};my$parser=Pod::Man->new($self->_get_podman_switches);$self->debug("Parsing $file\n");$parser->parse_from_file($file);$self->debug("Done parsing $file\n");close STDOUT;$self->die("No output from Pod::Man!\n")unless length$self->{_text_ref};$self->_save_pod_man_output if$self->debugging;return SUCCESS}sub _save_pod_man_output {my($self,$fh)=@_;$fh=do {my$file="podman.out.$$.txt";$self->debug("Writing $file with Pod::Man output\n");open my$fh2,'>',$file;$fh2}unless$fh;print {$fh}${$self->{_text_ref}}}sub _have_groff_with_utf8 {my($self)=@_;return 0 unless$self->_is_groff;my$roffer=$self->__nroffer;my$minimum_groff_version='1.20.1';my$version_string=`$roffer -v`;my($version)=$version_string =~ /\(?groff\)? version (\d+\.\d+(?:\.\d+)?)/;$self->debug("Found groff $version\n");if($version lt $minimum_groff_version){$self->warn("You have an old groff." ." Update to version $minimum_groff_version for good Unicode support.\n" ."If you don't upgrade, wide characters may come out oddly.\n")}$version ge $minimum_groff_version}sub _have_mandoc_with_utf8 {my($self)=@_;$self->_is_mandoc and not system 'mandoc -Tlocale -V > /dev/null 2>&1'}sub _collect_nroff_switches {my($self)=shift;my@render_switches=('-man',$self->_get_device_switches);if($self->_is_roff and -t STDOUT and my ($cols)=$self->_get_columns){my$c=$cols * 39 / 40;$cols=$c > $cols - 2 ? $c : $cols -2;push@render_switches,'-rLL=' .(int$c).'n' if$cols > 80}push@render_switches,'-c' if($self->_is_roff and $self->is_cygwin);return@render_switches}sub _get_device_switches {my($self)=@_;if($self->_is_nroff){qw()}elsif($self->_have_groff_with_utf8){qw(-Kutf8 -Tutf8)}elsif($self->_is_ebcdic){qw(-Tcp1047)}elsif($self->_have_mandoc_with_utf8){qw(-Tlocale)}elsif($self->_is_mandoc){qw()}else {qw(-Tlatin1)}}sub _is_roff {my($self)=@_;$self->_is_nroff or $self->_is_groff}sub _is_nroff {my($self)=@_;$self->__nroffer =~ /\bnroff\b/}sub _is_groff {my($self)=@_;$self->__nroffer =~ /\bgroff\b/}sub _is_mandoc {my ($self)=@_;$self->__nroffer =~ /\bmandoc\b/}sub _is_ebcdic {my($self)=@_;return 0}sub _filter_through_nroff {my($self)=shift;$self->debug("Filtering through " .$self->__nroffer()."\n");my ($render,$switches)=$self->__nroffer()=~ /\A([\/a-zA-Z0-9_\.-]+)\b(.+)?\z/;$self->die("no nroffer!?")unless$render;my@render_switches=$self->_collect_nroff_switches;if ($switches){$switches =~ s/\s//g;push@render_switches,split(/(?=-)/,$switches)}$self->debug("render is $render\n");$self->debug("render options are @render_switches\n");require Symbol;require IPC::Open3;require IO::Handle;my$pid=IPC::Open3::open3(my$writer,my$reader,my$err=Symbol::gensym(),$render,@render_switches);$reader->autoflush(1);use IO::Select;my$selector=IO::Select->new($reader);$self->debug("Writing to pipe to $render\n");my$offset=0;my$chunk_size=4096;my$length=length(${$self->{_text_ref}});my$chunks=$length / $chunk_size;my$done;my$buffer;while($offset <= $length){$self->debug("Writing chunk $chunks\n");$chunks++;syswrite$writer,${$self->{_text_ref}},$chunk_size,$offset or $self->die($!);$offset += $chunk_size;$self->debug("Checking read\n");READ: {last READ unless$selector->can_read(0.01);$self->debug("Reading\n");my$bytes=sysread$reader,$buffer,4096;$self->debug("Read $bytes bytes\n");$done .= $buffer;$self->debug(sprintf "Output is %d bytes\n",length$done);next READ}}close$writer;$self->debug("Done writing\n");$done .= do {local $/;<$reader>};$self->debug(sprintf "Done reading. Output is %d bytes\n",length$done);if($?){$self->warn("Error from pipe to $render!\n");$self->debug('Error: ' .do {local $/;<$err>})}close$reader;if(my$err=$?){$self->debug("Nonzero exit ($?) while running `$render @render_switches`.\n" ."Falling back to Pod::Perldoc::ToPod\n");return$self->_fallback_to_pod(@_)}$self->debug("Output:\n----\n$done\n----\n");${$self->{_text_ref}}=$done;return length ${$self->{_text_ref}}? SUCCESS : FAILED}sub parse_from_file {my($self,$file,$outfh)=@_;$self->{_text_ref}=\my$output;$self->_parse_with_pod_man($file);my$result=$self->_filter_through_nroff;return$self->_fallback_to_pod(@_)unless$result==SUCCESS;$self->_post_nroff_processing;print {$outfh}$output or $self->die("Can't print to $$self{__output_file}: $!");return}sub _fallback_to_pod {my($self,@args)=@_;$self->warn("Falling back to Pod because there was a problem!\n");require Pod::Perldoc::ToPod;return Pod::Perldoc::ToPod->new->parse_from_file(@_)}sub _get_tab_width {4}sub _expand_tabs {my($self)=@_;my$tab_width=' ' x $self->_get_tab_width;${$self->{_text_ref}}=~ s/\t/$tab_width/g}sub _post_nroff_processing {my($self)=@_;if($self->is_hpux){$self->debug("On HP-UX, I'm going to expand tabs for you\n");$self->_expand_tabs}if($self->{'__filter_nroff'}){$self->debug("filter_nroff is set, so filtering\n");$self->_remove_nroff_header;$self->_remove_nroff_footer}else {$self->debug("filter_nroff is not set, so not filtering\n")}$self->_handle_unicode;return 1}sub _remove_nroff_header {my($self)=@_;$self->debug("_remove_nroff_header is still a stub!\n");return 1}sub _remove_nroff_footer {my($self)=@_;$self->debug("_remove_nroff_footer is still a stub!\n");return 1;${$self->{_text_ref}}=~ s/\n\n+.*\w.*\Z//m}sub _unicode_already_handled {my($self)=@_;$self->_have_groff_with_utf8 || 1 }sub _handle_unicode {my($self)=@_;return 1 if$self->_unicode_already_handled;require Encode;my$text=Encode::decode('UTF-8',${$self->{_text_ref}});$text =~ s/(\P{ASCII})/
  		sprintf '\\[u%04X]', ord $1
  	     /eg;${$self->{_text_ref}}=$text}1;
POD_PERLDOC_TOMAN

$fatpacked{"Pod/Perldoc/ToNroff.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TONROFF';
  package Pod::Perldoc::ToNroff;use strict;use warnings;use parent qw(Pod::Perldoc::BaseTo);use vars qw($VERSION);$VERSION='3.28';sub is_pageable {1}sub write_with_binmode {0}sub output_extension {'man'}use Pod::Man ();sub center {shift->_perldoc_elem('center',@_)}sub date {shift->_perldoc_elem('date',@_)}sub fixed {shift->_perldoc_elem('fixed',@_)}sub fixedbold {shift->_perldoc_elem('fixedbold',@_)}sub fixeditalic {shift->_perldoc_elem('fixeditalic',@_)}sub fixedbolditalic {shift->_perldoc_elem('fixedbolditalic',@_)}sub quotes {shift->_perldoc_elem('quotes',@_)}sub release {shift->_perldoc_elem('release',@_)}sub section {shift->_perldoc_elem('section',@_)}sub new {return bless {},ref($_[0])|| $_[0]}sub parse_from_file {my$self=shift;my$file=$_[0];my@options=map {;$_,$self->{$_}}grep!m/^_/s,keys %$self ;defined(&Pod::Perldoc::DEBUG)and Pod::Perldoc::DEBUG()and print "About to call new Pod::Man ",$Pod::Man::VERSION ? "(v$Pod::Man::VERSION) " : '',"with options: ",@options ? "[@options]" : "(nil)","\n";;Pod::Man->new(@options)->parse_from_file(@_)}1;
POD_PERLDOC_TONROFF

$fatpacked{"Pod/Perldoc/ToPod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOPOD';
  package Pod::Perldoc::ToPod;use strict;use warnings;use parent qw(Pod::Perldoc::BaseTo);use vars qw($VERSION);$VERSION='3.28';sub is_pageable {1}sub write_with_binmode {0}sub output_extension {'pod'}sub new {return bless {},ref($_[0])|| $_[0]}sub parse_from_file {my($self,$in,$outfh)=@_;open(IN,"<",$in)or $self->die("Can't read-open $in: $!\nAborting");my$cut_mode=1;local $_;while (<IN>){if(m/^=(\w+)/s){if($cut_mode=($1 eq 'cut')){print$outfh "\n=cut\n\n"}}next if$cut_mode;print$outfh $_ or $self->die("Can't print to $outfh: $!")}close IN or $self->die("Can't close $in: $!");return}1;
POD_PERLDOC_TOPOD

$fatpacked{"Pod/Perldoc/ToRtf.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TORTF';
  package Pod::Perldoc::ToRtf;use strict;use warnings;use parent qw(Pod::Simple::RTF);use vars qw($VERSION);$VERSION='3.28';sub is_pageable {0}sub write_with_binmode {0}sub output_extension {'rtf'}sub page_for_perldoc {my($self,$tempfile,$perldoc)=@_;return unless$perldoc->IS_MSWin32;my$rtf_pager=$ENV{'RTFREADER'}|| 'write.exe';$perldoc->aside("About to launch <\"$rtf_pager\" \"$tempfile\">\n");return 1 if system(qq{"$rtf_pager"},qq{"$tempfile"})==0;return 0}1;
POD_PERLDOC_TORTF

$fatpacked{"Pod/Perldoc/ToTerm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOTERM';
  package Pod::Perldoc::ToTerm;use strict;use warnings;use vars qw($VERSION);$VERSION='3.28';use parent qw(Pod::Perldoc::BaseTo);sub is_pageable {1}sub write_with_binmode {0}sub output_extension {'txt'}use Pod::Text::Termcap ();sub alt {shift->_perldoc_elem('alt',@_)}sub indent {shift->_perldoc_elem('indent',@_)}sub loose {shift->_perldoc_elem('loose',@_)}sub quotes {shift->_perldoc_elem('quotes',@_)}sub sentence {shift->_perldoc_elem('sentence',@_)}sub width {my$self=shift;$self->_perldoc_elem('width',@_)|| $self->_get_columns_from_manwidth || $self->_get_columns_from_stty || $self->_get_default_width}sub pager_configuration {my($self,$pager,$perldoc)=@_;return if ($perldoc->is_mswin32 || $perldoc->is_dos);if ($pager =~ /less/){$self->_maybe_modify_environment('LESS')}elsif ($pager =~ /more/){$self->_maybe_modify_environment('MORE')}return}sub _maybe_modify_environment {my($self,$name)=@_;if (!defined$ENV{$name}){$ENV{$name}="-R"}}sub _get_stty {`stty -a`}sub _get_columns_from_stty {my$output=$_[0]->_get_stty;if($output =~ /\bcolumns\s+(\d+)/){return $1}elsif($output =~ /;\s*(\d+)\s+columns;/){return $1}else {return 0}}sub _get_columns_from_manwidth {my($self)=@_;return 0 unless defined$ENV{MANWIDTH};unless($ENV{MANWIDTH}=~ m/\A\d+\z/){$self->warn("Ignoring non-numeric MANWIDTH ($ENV{MANWIDTH})\n");return 0}if($ENV{MANWIDTH}==0){$self->warn("Ignoring MANWIDTH of 0. Really? Why even run the program? :)\n");return 0}if($ENV{MANWIDTH}=~ m/\A(\d+)\z/){return $1}return 0}sub _get_default_width {76}sub new {return bless {},ref($_[0])|| $_[0]}sub parse_from_file {my$self=shift;$self->{width}=$self->width();my@options=map {;$_,$self->{$_}}grep!m/^_/s,keys %$self ;defined(&Pod::Perldoc::DEBUG)and Pod::Perldoc::DEBUG()and print "About to call new Pod::Text::Termcap ",$Pod::Text::VERSION ? "(v$Pod::Text::Termcap::VERSION) " : '',"with options: ",@options ? "[@options]" : "(nil)","\n";;Pod::Text::Termcap->new(@options)->parse_from_file(@_)}1;
POD_PERLDOC_TOTERM

$fatpacked{"Pod/Perldoc/ToText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOTEXT';
  package Pod::Perldoc::ToText;use strict;use warnings;use vars qw($VERSION);$VERSION='3.28';use parent qw(Pod::Perldoc::BaseTo);sub is_pageable {1}sub write_with_binmode {0}sub output_extension {'txt'}use Pod::Text ();sub alt {shift->_perldoc_elem('alt',@_)}sub indent {shift->_perldoc_elem('indent',@_)}sub loose {shift->_perldoc_elem('loose',@_)}sub quotes {shift->_perldoc_elem('quotes',@_)}sub sentence {shift->_perldoc_elem('sentence',@_)}sub width {shift->_perldoc_elem('width',@_)}sub new {return bless {},ref($_[0])|| $_[0]}sub parse_from_file {my$self=shift;my@options=map {;$_,$self->{$_}}grep!m/^_/s,keys %$self ;defined(&Pod::Perldoc::DEBUG)and Pod::Perldoc::DEBUG()and print "About to call new Pod::Text ",$Pod::Text::VERSION ? "(v$Pod::Text::VERSION) " : '',"with options: ",@options ? "[@options]" : "(nil)","\n";;Pod::Text->new(@options)->parse_from_file(@_)}1;
POD_PERLDOC_TOTEXT

$fatpacked{"Pod/Perldoc/ToTk.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOTK';
  package Pod::Perldoc::ToTk;use strict;use warnings;use vars qw($VERSION);$VERSION='3.28';use parent qw(Pod::Perldoc::BaseTo);sub is_pageable {1}sub write_with_binmode {0}sub output_extension {'txt'}sub if_zero_length {}sub new {return bless {},ref($_[0])|| $_[0]}sub tree {shift->_perldoc_elem('tree',@_)}sub tk_opt {shift->_perldoc_elem('tk_opt',@_)}sub forky {shift->_perldoc_elem('forky',@_)}use Pod::Perldoc ();use File::Spec::Functions qw(catfile);BEGIN{eval {require Tk}|| __PACKAGE__->die(<<"HERE");__PACKAGE__->die(__PACKAGE__," doesn't work nice with Tk.pm version $Tk::VERSION")if$Tk::VERSION eq '800.003'}BEGIN {eval {require Tk::FcyEntry}};BEGIN{eval {require Tk::Pod}|| __PACKAGE__->die(<<"HERE")}sub parse_from_file {my($self,$Input_File)=@_;if($self->{'forky'}){return if fork}$Input_File =~ s{\\}{/}g if$self->is_mswin32 or $self->is_dos ;my($tk_opt,$tree);$tree=$self->{'tree' };$tk_opt=$self->{'tk_opt'};if($tk_opt){push@INC,grep -d $_,map catfile($_,'Tk'),@INC}my$mw=MainWindow->new();$mw->withdraw;my$ufont=$mw->optionGet('userFont','UserFont');my$sfont=$mw->optionGet('systemFont','SystemFont');if (defined($ufont)and defined($sfont)){for ($ufont,$sfont){s/:$//};$mw->optionAdd('*Font',$sfont);$mw->optionAdd('*Entry.Font',$ufont);$mw->optionAdd('*Text.Font',$ufont)}$mw->optionAdd('*Menu.tearOff',$Tk::platform ne 'MSWin32' ? 1 : 0);$mw->Pod('-file'=>$Input_File,(($Tk::Pod::VERSION >= 4)? ('-tree'=>$tree): ()))->focusNext;if ($mw->children){$mw->repeat(1000,sub {for ($mw->children){return if "$_" =~ /^Tk::Pod/}$mw->destroy})}else {$mw->destroy}MainLoop();exit if$self->{'forky'};return}1;
  You must have the Tk module to use Pod::Perldoc::ToTk.
  If you have it installed, ensure it's in your Perl library
  path.
  HERE
  You must have the Tk::Pod module to use Pod::Perldoc::ToTk.
  If you have it installed, ensure it's in your Perl library
  path.
  HERE
POD_PERLDOC_TOTK

$fatpacked{"Pod/Perldoc/ToXml.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOXML';
  package Pod::Perldoc::ToXml;use strict;use warnings;use vars qw($VERSION);use parent qw(Pod::Simple::XMLOutStream);use vars qw($VERSION);$VERSION='3.28';sub is_pageable {0}sub write_with_binmode {0}sub output_extension {'xml'}1;
POD_PERLDOC_TOXML

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  require 5;package Pod::Simple;use strict;use Carp ();BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use integer;use Pod::Escapes 1.04 ();use Pod::Simple::LinkSection ();use Pod::Simple::BlackBox ();use vars qw($VERSION @ISA @Known_formatting_codes @Known_directives %Known_formatting_codes %Known_directives $NL);@ISA=('Pod::Simple::BlackBox');$VERSION='3.42';@Known_formatting_codes=qw(I B C L E F S X Z);%Known_formatting_codes=map(($_=>1),@Known_formatting_codes);@Known_directives=qw(head1 head2 head3 head4 head5 head6 item over back);%Known_directives=map(($_=>'Plain'),@Known_directives);$NL=$/ unless defined$NL;BEGIN {if(defined&ASCII){}elsif(chr(65)eq 'A'){*ASCII=sub () {1}}else {*ASCII=sub () {''}}unless(defined&MANY_LINES){*MANY_LINES=sub () {20}}DEBUG > 4 and print STDERR "MANY_LINES is ",MANY_LINES(),"\n";unless(MANY_LINES()>= 1){die "MANY_LINES is too small (",MANY_LINES(),")!\nAborting"}if(defined&UNICODE){}elsif($] >= 5.008){*UNICODE=sub() {1}}else {*UNICODE=sub() {''}}}if(DEBUG > 2){print STDERR "# We are ",ASCII ? '' : 'not ',"in ASCII-land\n";print STDERR "# We are under a Unicode-safe Perl.\n"}if ($] ge 5.007_003){$Pod::Simple::nbsp=chr utf8::unicode_to_native(0xA0);$Pod::Simple::shy=chr utf8::unicode_to_native(0xAD)}elsif (Pod::Simple::ASCII){$Pod::Simple::nbsp="\xA0";$Pod::Simple::shy="\xAD"}else {$Pod::Simple::nbsp="\x41";$Pod::Simple::shy="\xCA"}__PACKAGE__->_accessorize('_output_is_for_JustPod','nbsp_for_S','source_filename','source_dead','output_fh','hide_line_numbers','line_count','pod_para_count','no_whining','no_errata_section','complain_stderr','doc_has_started','bare_output','keep_encoding_directive','nix_X_codes','merge_text','preserve_whitespace','strip_verbatim_indent','expand_verbatim_tabs','parse_characters','content_seen','errors_seen','codes_in_verbatim','code_handler','cut_handler','pod_handler','whiteline_handler','parse_empty_lists','raw_mode',);sub any_errata_seen {return shift->{'errors_seen'}|| 0}sub errata_seen {return shift->{'all_errata'}|| {}}sub detected_encoding {return shift->{'detected_encoding'}}sub encoding {my$this=shift;return$this->{'encoding'}unless @_;$this->_handle_encoding_line("=encoding $_[0]");if ($this->{'_processed_encoding'}){delete$this->{'_processed_encoding'};if(!$this->{'encoding_command_statuses'}){DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n"}elsif($this->{'encoding_command_statuses'}[-1]){$this->scream("=encoding $_[0]",sprintf "Couldn't do %s: %s",$this->{'encoding_command_reqs' }[-1],$this->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print STDERR " (encoding successfully handled.)\n"}return$this->{'encoding'}}else {return undef}}BEGIN {*pretty=\&Pod::Simple::BlackBox::pretty;*stringify_lol=\&Pod::Simple::BlackBox::stringify_lol;*my_qr=\&Pod::Simple::BlackBox::my_qr}sub version_report {my$class=ref($_[0])|| $_[0];if($class eq __PACKAGE__){return "$class $VERSION"}else {my$v=$class->VERSION;return "$class $v (" .__PACKAGE__ ." $VERSION)"}}sub output_string {my$this=shift;return$this->{'output_string'}unless @_;require Pod::Simple::TiedOutFH;my$x=(defined($_[0])and ref($_[0]))? $_[0]: \($_[0]);$$x='' unless defined $$x;DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";$this->{'output_fh'}=Pod::Simple::TiedOutFH->handle_on($_[0]);return $this->{'output_string'}=$_[0]}sub abandon_output_string {$_[0]->abandon_output_fh;delete $_[0]{'output_string'}}sub abandon_output_fh {$_[0]->output_fh(undef)}sub new {my$class=ref($_[0])|| $_[0];my$obj=bless {'accept_codes'=>{map(($_=>$_),@Known_formatting_codes)},'accept_directives'=>{%Known_directives },'accept_targets'=>{},},$class;$obj->expand_verbatim_tabs(8);return$obj}sub _handle_element_start {my($self,$element_name,$attr_hash_r)=@_;return}sub _handle_element_end {my($self,$element_name)=@_;return}sub _handle_text {my($self,$text)=@_;return}sub accept_directive_as_verbatim {shift->_accept_directives('Verbatim',@_)}sub accept_directive_as_data {shift->_accept_directives('Data',@_)}sub accept_directive_as_processed {shift->_accept_directives('Plain',@_)}sub _accept_directives {my($this,$type)=splice @_,0,2;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "\"$d\" is already a reserved Pod directive name" if exists$Known_directives{$d};$this->{'accept_directives'}{$d}=$type;DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n"}DEBUG > 6 and print STDERR "$this\'s accept_directives : ",pretty($this->{'accept_directives'}),"\n";return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub unaccept_directive {shift->unaccept_directives(@_)};sub unaccept_directives {my$this=shift;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "But you must accept \"$d\" directives -- it's a builtin!" if exists$Known_directives{$d};delete$this->{'accept_directives'}{$d};DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n"}return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub accept_target {shift->accept_targets(@_)}sub accept_target_as_text {shift->accept_targets_as_text(@_)}sub accept_targets {shift->_accept_targets('1',@_)}sub accept_targets_as_text {shift->_accept_targets('force_resolve',@_)}sub _accept_targets {my($this,$type)=splice @_,0,2;for my$t (@_){next unless defined$t and length$t;$this->{'accept_targets'}{$t}=$type;DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}sub unaccept_target {shift->unaccept_targets(@_)}sub unaccept_targets {my$this=shift;for my$t (@_){next unless defined$t and length$t;delete$this->{'accept_targets'}{$t};DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}my$xml_name_re=my_qr('[^-.0-8:A-Z_a-z[:^ascii:]]','9');$xml_name_re=qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/ unless$xml_name_re;sub accept_code {shift->accept_codes(@_)}sub accept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ $xml_name_re or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s;$this->{'accept_codes'}{$new_code}=$new_code}return}sub unaccept_code {shift->unaccept_codes(@_)}sub unaccept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ $xml_name_re or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s;Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!" if grep$new_code eq $_,@Known_formatting_codes;delete$this->{'accept_codes'}{$new_code};DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n"}return}sub parse_string_document {my$self=shift;my@lines;for my$line_group (@_){next unless defined$line_group and length$line_group;pos($line_group)=0;while($line_group =~ m/([^\n\r]*)(\r?\n?)/g){$self->parse_lines($1)if length($1)or length($2)or pos($line_group)!=length($line_group)}}$self->parse_lines(undef);return$self}sub _init_fh_source {my($self,$source)=@_;return}sub parse_file {my($self,$source)=(@_);if(!defined$source){Carp::croak("Can't use empty-string as a source for parse_file")}elsif(ref(\$source)eq 'GLOB'){$self->{'source_filename'}='' .($source)}elsif(ref$source){$self->{'source_filename'}='' .($source)}elsif(!length$source){Carp::croak("Can't use empty-string as a source for parse_file")}else {{local*PODSOURCE;open(PODSOURCE,"<$source")|| Carp::croak("Can't open $source: $!");$self->{'source_filename'}=$source;$source=*PODSOURCE{IO}}$self->_init_fh_source($source)}$self->{'source_fh'}=$source;my($i,@lines);until($self->{'source_dead'}){splice@lines;for($i=MANY_LINES;$i--;){local $/=$NL;push@lines,scalar(<$source>);last unless defined$lines[-1]}my$at_eof=!$lines[-1];pop@lines if$at_eof;s/\r\n?/\n/g for@lines;@lines=split(/(?<=\n)/,join('',@lines));push@lines,undef if$at_eof;$self->parse_lines(@lines)}delete($self->{'source_fh'});return$self}sub parse_from_file {my($self,$source,$to)=@_;$self=$self->new unless ref($self);if(!defined$source){$source=*STDIN{IO}}elsif(ref(\$source)eq 'GLOB'){}elsif(ref($source)){}elsif(!length$source or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i){$source=*STDIN{IO}}if(!defined$to){$self->output_fh(*STDOUT{IO})}elsif(ref(\$to)eq 'GLOB'){$self->output_fh($to)}elsif(ref($to)){$self->output_fh($to)}elsif(!length$to or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i){$self->output_fh(*STDOUT{IO})}elsif($to =~ m/^>&(?:STDERR|2)$/i){$self->output_fh(*STDERR{IO})}else {require Symbol;my$out_fh=Symbol::gensym();DEBUG and print STDERR "Write-opening to $to\n";open($out_fh,">$to")or Carp::croak "Can't write-open $to: $!";binmode($out_fh)if$self->can('write_with_binmode')and $self->write_with_binmode;$self->output_fh($out_fh)}return$self->parse_file($source)}sub whine {my$self=shift(@_);++$self->{'errors_seen'};if($self->{'no_whining'}){DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";return}push @{$self->{'all_errata'}{$_[0]}},$_[1];return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub scream {my$self=shift(@_);++$self->{'errors_seen'};push @{$self->{'all_errata'}{$_[0]}},$_[1];return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub _complain_warn {my($self,$line,$complaint)=@_;return printf STDERR "%s around line %s: %s\n",$self->{'source_filename'}|| 'Pod input',$line,$complaint}sub _complain_errata {my($self,$line,$complaint)=@_;if($self->{'no_errata_section'}){DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n"}else {DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";push @{$self->{'errata'}{$line}},$complaint}return 1}sub _get_initial_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};return$para->[1]{'~type'}='text' if join("\n",@{$para}[2 .. $#$para])=~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';return$self->_get_item_type($para)}sub _get_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};my$content=join "\n",@{$para}[2 .. $#$para];if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s){splice @$para,2;$para->[1]{'~orig_content'}=$content;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*\*\s+(.+)/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'~_freaky_para_hack'}=$1;DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";splice @$para,2;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*(\d+)\.?\s*$/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'number'}=$1;splice @$para,2;return$para->[1]{'~type'}='number'}else {return$para->[1]{'~type'}='text'}}sub _make_treelet {my$self=shift;my$treelet;if(!@_){return ['']}if(ref $_[0]and ref $_[0][0]and $_[0][0][0]eq '~Top'){DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";$treelet=$_[0][0];splice @$treelet,0,2;return$treelet}else {$treelet=$self->_treelet_from_formatting_codes(@_)}if(!$self->{'_output_is_for_JustPod'}&& $self->_remap_sequences($treelet)){$self->_treat_Zs($treelet);$self->_treat_Ls($treelet);$self->_treat_Es($treelet);$self->_treat_Ss($treelet);$self->_wrap_up($treelet)}else {DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n"}splice @$treelet,0,2;return$treelet}sub _wrap_up {my($self,@stack)=@_;my$nixx=$self->{'nix_X_codes'};my$merge=$self->{'merge_text' };return unless$nixx or $merge;DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",$merge ? (" Merge mode on\n"): (),$nixx ? (" Nix-X mode on\n"): (),;my($i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){DEBUG > 3 and print STDERR " Considering child at $i ",pretty($treelet->[$i]),"\n";if($nixx and ref$treelet->[$i]and $treelet->[$i][0]eq 'X'){DEBUG > 3 and print STDERR "   Nixing X node at $i\n";splice(@$treelet,$i,1);redo}elsif($merge and $i!=2 and !ref$treelet->[$i]and!ref$treelet->[$i - 1]){DEBUG > 3 and print STDERR "   Merging ",$i-1,":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";$treelet->[$i-1].= (splice(@$treelet,$i,1))[0];DEBUG > 4 and print STDERR "    Now: ",$i-1,":[$treelet->[$i-1]]\n";--$i;next}elsif(ref$treelet->[$i]){DEBUG > 4 and print STDERR "  Enqueuing ",pretty($treelet->[$i])," for traversal.\n";push@stack,$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 4 and print STDERR "  +Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}}}}}DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";return}sub _remap_sequences {my($self,@stack)=@_;if(@stack==1 and @{$stack[0]}==3 and!ref$stack[0][2]){DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";return 0}my$map=($self->{'accept_codes'}|| die "NO accept_codes in $self?!?");my$start_line=$stack[0][1]{'start_line'};DEBUG > 2 and printf "\nAbout to start _remap_sequences on treelet from line %s.\n",$start_line || '[?]' ;DEBUG > 3 and print STDERR " Map: ",join('; ',map "$_=" .(ref($map->{$_})? join(",",@{$map->{$_}}): $map->{$_}),sort keys %$map),("B~C~E~F~I~L~S~X~Z" eq join '~',sort keys %$map)? "  (all normal)\n" : "\n" ;my($is,$was,$i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";$is=$treelet->[$i][0]=$map->{$was=$treelet->[$i][0]};if(DEBUG > 3){if(!defined$is){print STDERR "   Code $was<> is UNKNOWN!\n"}elsif($is eq $was){DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n"}else {print STDERR "   Code $was<> maps to ",ref($is)? ("tags ",map("$_<",@$is),'...',map('>',@$is),"\n"): "tag $is<...>.\n"}}if(!defined$is){$self->whine($start_line,"Deleting unknown formatting code $was<>");$is=$treelet->[$i][0]='1'}if(ref$is){my@dynasty=@$is;DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";$treelet->[$i][0]=pop@dynasty;my$nugget;while(@dynasty){DEBUG > 4 and printf "    Grafting a new %s node between %s and %s\n",$dynasty[-1],$treelet->[0],$treelet->[$i][0],;splice @$treelet,$i,1,[pop(@dynasty),{},$treelet->[$i]]}}elsif($is eq '0'){splice(@$treelet,$i,1);--$i}elsif($is eq '1'){splice(@$treelet,$i,1 =>splice @{$treelet->[$i]},2);--$i}else {unshift@stack,$treelet->[$i]}}}DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";if(@_==2 and @{$_[1]}==3 and!ref $_[1][2]){DEBUG and print STDERR "Noting that the treelet is now formatless.\n";return 0}return 1}sub _ponder_extend {my($self,$para)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";if($content =~ m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs){my$new_letter=$1;my$fallbacks_one=$2;my$elements_one;$elements_one=defined($3)? $3 : $1;DEBUG > 2 and print STDERR "Extensor has good syntax.\n";unless($new_letter =~ m/^[A-Z]$/s or $new_letter){DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";$self->whine($para->[1]{'start_line'},"You can extend only formatting codes A-Z, not like \"$new_letter\"");return}if(grep$new_letter eq $_,@Known_formatting_codes){DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";$self->whine($para->[1]{'start_line'},"You can't extend an established code like \"$new_letter\"");return}unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s or $fallbacks_one eq '0' or $fallbacks_one eq '1'){$self->whine($para->[1]{'start_line'},"Format for second =extend parameter must be like" ." M or 1 or 0 or M,N or M,N,O but you have it like " .$fallbacks_one);return}unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s){$self->whine($para->[1]{'start_line'},"Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like " .$elements_one);return}my@fallbacks=split ',',$fallbacks_one,-1;my@elements=split ',',$elements_one,-1;for my$f (@fallbacks){next if exists$Known_formatting_codes{$f}or $f eq '0' or $f eq '1';DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";$self->whine($para->[1]{'start_line'},"Can't use unknown formatting code '$f' as a fallback for '$new_letter'");return}DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",@fallbacks,@elements;my$canonical_form;for my$e (@elements){if(exists$self->{'accept_codes'}{$e}){DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";$canonical_form=$e;last}else {DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n"}}if(defined$canonical_form){$self->{'accept_codes'}{$new_letter}=$canonical_form;DEBUG > 2 and print "Extensor maps $new_letter => known element $canonical_form.\n"}else {$self->{'accept_codes'}{$new_letter}=(@fallbacks==1)? $fallbacks[0]: \@fallbacks;DEBUG > 2 and print "Extensor maps $new_letter => fallbacks @fallbacks.\n"}}else {DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";$self->whine($para->[1]{'start_line'},"Unknown =extend syntax: $content")}return}sub _treat_Zs {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'Z'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";unless(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"A non-empty Z<>")}splice(@$treelet,$i,1);--$i}}return}sub _treat_Ls {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'L'){unshift@stack,$treelet->[$i];next}my$ell=$treelet->[$i];DEBUG > 1 and print STDERR "Ogling L node " .pretty($ell)."\n";if (@{$ell}==3 and $ell->[2]=~ m!\A\s*/\s*\z!){$self->whine($start_line,"L<> contains only '/'");$treelet->[$i]='L</>';next}if(@{$ell}==2 or (@{$ell}==3 and $ell->[2]eq '')){$self->whine($start_line,"An empty L<>");$treelet->[$i]='L<>';next}if((!ref$ell->[2]&& $ell->[2]=~ /\A\s/)||(!ref$ell->[-1]&& $ell->[-1]=~ /\s\z/)){$self->whine($start_line,"L<> starts or ends with whitespace")}if (my ($url_index,$text_part,$url_part)=sub {for (2..$#$ell){next if ref$ell->[$_];next unless$ell->[$_]=~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;return ($_,$1,$2)}return}->()){$ell->[1]{'type'}='url';my@text=@{$ell}[2..$url_index-1];push@text,$text_part if defined$text_part;my@url=@{$ell}[$url_index+1..$#$ell];unshift@url,$url_part;unless (@text){$ell->[1]{'content-implicit'}='yes';@text=@url}$ell->[1]{to}=Pod::Simple::LinkSection->new(@url==1 ? $url[0]: ['',{},@url ],);splice @$ell,2,$#$ell,@text;next}if(@{$ell}==3 and!ref$ell->[2]){my$it=$ell->[2];if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s){DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";$ell->[1]{'type'}='man';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s){DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";$ell->[1]{'type'}='pod';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}}DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";my$link_text;my@ell_content=@$ell;splice@ell_content,0,2;DEBUG > 3 and print STDERR " Ell content to start: ",pretty(@ell_content),"\n";DEBUG > 3 and print STDERR "  Peering at L content for a '|' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";if($ell_content[$j]=~ m/^([^\|]*)\|(.*)$/s){my@link_text=($1);$ell_content[$j]=$2;DEBUG > 3 and print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";if ($link_text[0]=~ m{[|/]}){$self->whine($start_line,"alternative text '$link_text[0]' contains non-escaped | or /")}unshift@link_text,splice@ell_content,0,$j;@ell_content=grep ref($_)||length($_),@ell_content ;$link_text=[grep ref($_)||length($_),@link_text ];DEBUG > 3 and printf "  So link text is %s\n  and remaining ell content is %s\n",pretty($link_text),pretty(@ell_content);last}}my$section_name;DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";if($ell_content[$j]=~ m/^([^\/]*)\/(.*)$/s){my@section_name=($2);$ell_content[$j]=$1;DEBUG > 3 and print STDERR "     FOUND a '/' in it.","  Splitting to page [...$1] + section [$2...]\n";push@section_name,splice@ell_content,1+$j;@ell_content=grep ref($_)||length($_),@ell_content ;@section_name=grep ref($_)||length($_),@section_name ;if(@section_name and!ref($section_name[0])and!ref($section_name[-1])and $section_name[0]=~ m/^\"/s and $section_name[-1]=~ m/\"$/s and!(@section_name==1 and $section_name[0]eq '"')){$section_name[0]=~ s/^\"//s;$section_name[-1]=~ s/\"$//s;DEBUG > 3 and print STDERR "     Quotes removed: ",pretty(@section_name),"\n"}else {DEBUG > 3 and print STDERR "     No need to remove quotes in ",pretty(@section_name),"\n"}$section_name=\@section_name;last}}if(!$section_name and @ell_content and!ref($ell_content[0])and!ref($ell_content[-1])and $ell_content[0]=~ m/^\"/s and $ell_content[-1]=~ m/\"$/s and!(@ell_content==1 and $ell_content[0]eq '"')){$section_name=[splice@ell_content];$section_name->[0]=~ s/^\"//s;$section_name->[-1]=~ s/\"$//s;$ell->[1]{'~tolerated'}=1}if(!$section_name and!$link_text and @ell_content and grep!ref($_)&& m/ /s,@ell_content){$section_name=[splice@ell_content];$ell->[1]{'~deprecated'}=1}unless($link_text){$ell->[1]{'content-implicit'}='yes';$link_text=[];push @$link_text,'"',@$section_name,'"' if$section_name;if(@ell_content){$link_text->[-1].= ' in ' if$section_name;push @$link_text,@ell_content}}if(@ell_content==1 and!ref($ell_content[0])and $ell_content[0]=~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s){$ell->[1]{'type'}='man';DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n"}else {$ell->[1]{'type'}='pod';DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n"}if(defined$section_name){$ell->[1]{'section'}=Pod::Simple::LinkSection->new(['',{},@$section_name]);DEBUG > 3 and print STDERR "L-section content: ",pretty($ell->[1]{'section'}),"\n"}if(@ell_content){$ell->[1]{'to'}=Pod::Simple::LinkSection->new(['',{},@ell_content]);DEBUG > 3 and print STDERR "L-to content: ",pretty($ell->[1]{'to'}),"\n"}@$ell=(@$ell[0,1],defined($link_text)? splice(@$link_text): '');DEBUG > 2 and print STDERR "End of L-parsing for this node " .pretty($treelet->[$i])."\n";unshift@stack,$treelet->[$i]}}return}sub _treat_Es {my($self,@stack)=@_;my($i,$treelet,$content,$replacer,$charnum);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 2 and print STDERR "  Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}unshift@stack,$treelet->[$i];next}elsif($treelet->[$i][0]ne 'E'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print STDERR "Ogling E node ",pretty($treelet->[$i]),"\n";if(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"An empty E<>");$treelet->[$i]='E<>';next}unless(@{$treelet->[$i]}==3 and!ref($content=$treelet->[$i][2])){$self->whine($start_line,"An E<...> surrounding strange content");$replacer=$treelet->[$i];splice(@$treelet,$i,1,'E<',splice(@$replacer,2),'>');next}DEBUG > 1 and print STDERR "Ogling E<$content>\n";$charnum=Pod::Escapes::e2charnum($content);DEBUG > 1 and print STDERR " Considering E<$content> with char ",defined($charnum)? $charnum : "undef",".\n";if(!defined($charnum)){DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";$self->whine($start_line,"Unknown E content in E<$content>");$replacer="E<$content>"}elsif($charnum >= 255 and!UNICODE){$replacer=ASCII ? "\xA4" : "?";DEBUG > 1 and print STDERR "This Perl version can't handle ","E<$content> (chr $charnum), so replacing with $replacer\n"}else {$replacer=Pod::Escapes::e2char($content);DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n"}splice(@$treelet,$i,1,$replacer)}}return}sub _treat_Ss {my($self,$treelet)=@_;_change_S_to_nbsp($treelet,0)if$self->{'nbsp_for_S'};return}sub _change_S_to_nbsp {my($treelet,$in_s)=@_;my$is_s=('S' eq $treelet->[0]);$in_s ||= $is_s;for(my$i=2;$i < @$treelet;++$i){if(ref$treelet->[$i]){if(_change_S_to_nbsp($treelet->[$i],$in_s)){my$to_pull_up=$treelet->[$i];splice @$to_pull_up,0,2;splice @$treelet,$i,1,@$to_pull_up;$i += @$to_pull_up - 1}}else {$treelet->[$i]=~ s/\s/$Pod::Simple::nbsp/g if$in_s}}return$is_s}sub _accessorize {no strict 'refs';for my$attrname (@_){next if$attrname =~ m/::/;*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];(@_==1)? $_[0]->{$attrname}: ($_[0]->{$attrname}=$_[1])}}return}sub filter {my($class,$source)=@_;my$new=$class->new;$new->output_fh(*STDOUT{IO});if(ref($source || '')eq 'SCALAR'){$new->parse_string_document($$source)}elsif(ref($source)){$new->parse_file($source)}else {$new->parse_file($source)}return$new}sub _out {my$class=shift(@_);my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';DEBUG and print STDERR "\n\n",'#' x 76,"\nAbout to parse source: {{\n$_[0]\n}}\n\n";my$parser=ref$class && $class->isa(__PACKAGE__)? $class : $class->new;$parser->hide_line_numbers(1);my$out='';$parser->output_string(\$out);DEBUG and print STDERR " _out to ",\$out,"\n";$mutor->($parser)if$mutor;$parser->parse_string_document($_[0]);return$out}sub _duo {my$class=shift(@_);Carp::croak "But $class->_duo is useful only in list context!" unless wantarray;my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';Carp::croak "But $class->_duo takes two parameters, not: @_" unless @_==2;my(@out);while(@_){my$parser=$class->new;push@out,'';$parser->output_string(\($out[-1]));DEBUG and print STDERR " _duo out to ",$parser->output_string()," = $parser->{'output_string'}\n";$parser->hide_line_numbers(1);$mutor->($parser)if$mutor;$parser->parse_string_document(shift(@_))}return@out}1;
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;use integer;use strict;use Carp ();use vars qw($VERSION);$VERSION='3.42';sub my_qr ($$) {my ($input_re,$should_match)=@_;my$use_utf8=($] le 5.006002)? 'use utf8;' : "";my$re=eval "no warnings; $use_utf8 qr/$input_re/";return "" if $@;my$matches=eval "no warnings; $use_utf8 '$should_match' =~ /$re/";return "" if $@;return$re if$matches;return ""}BEGIN {require Pod::Simple;*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}my$non_ascii_re=my_qr('[[:^ascii:]]',"\xB6");$non_ascii_re=qr/[\x80-\xFF]/ unless$non_ascii_re;my$cs_re=do {no warnings;my_qr('\p{IsCs}',"\x{D800}")};my$cn_re=my_qr('\p{IsCn}',"\x{09E4}");my$rare_blocks_re=my_qr('[\p{InIPAExtensions}\p{InSpacingModifierLetters}]',"\x{250}");$rare_blocks_re=my_qr('[\x{0250}-\x{02FF}]',"\x{250}")unless$rare_blocks_re;my$script_run_re=eval 'no warnings "experimental::script_run";
                            qr/(*script_run: ^ .* $ )/x';my$latin_re=my_qr('[\p{IsLatin}\p{IsInherited}\p{IsCommon}]',"\x{100}");unless ($latin_re){$latin_re=my_qr('[\x00-\x{02E9}\x{02EC}-\x{0374}\x{037E}\x{0385}\x{0387}\x{0485}\x{0486}\x{0589}\x{060C}\x{061B}\x{061F}\x{0640}\x{064B}-\x{0655}\x{0670}\x{06DD}\x{0951}-\x{0954}\x{0964}\x{0965}\x{0E3F}\x{10FB}\x{16EB}-\x{16ED}\x{1735}\x{1736}\x{1802}\x{1803}\x{1805}\x{1D00}-\x{1D25}\x{1D2C}-\x{1D5C}\x{1D62}-\x{1D65}\x{1D6B}-\x{1D77}\x{1D79}-\x{1DBE}\x{1DC0}-\x{1EF9}\x{2000}-\x{2125}\x{2127}-\x{27FF}\x{2900}-\x{2B13}\x{2E00}-\x{2E1D}\x{2FF0}-\x{3004}\x{3006}\x{3008}-\x{3020}\x{302A}-\x{302D}\x{3030}-\x{3037}\x{303C}-\x{303F}\x{3099}-\x{309C}\x{30A0}\x{30FB}\x{30FC}\x{3190}-\x{319F}\x{31C0}-\x{31CF}\x{3220}-\x{325F}\x{327F}-\x{32CF}\x{3358}-\x{33FF}\x{4DC0}-\x{4DFF}\x{A700}-\x{A716}\x{FB00}-\x{FB06}\x{FD3E}\x{FD3F}\x{FE00}-\x{FE6B}\x{FEFF}-\x{FF65}\x{FF70}\x{FF9E}\x{FF9F}\x{FFE0}-\x{FFFD}\x{10100}-\x{1013F}\x{1D000}-\x{1D1DD}\x{1D300}-\x{1D7FF}]',"\x{100}")}my$every_char_is_latin_re=my_qr("^(?:$latin_re)*\\z","A");my$later_latin_re=my_qr('[^\P{IsLatin}\p{IsAge=1.1}]',"\x{1F6}");my$deprecated_re=my_qr('\p{IsDeprecated}',"\x{149}");$deprecated_re=qr/\x{149}/ unless$deprecated_re;my$utf8_bom;if (($] ge 5.007_003)){$utf8_bom="\x{FEFF}";utf8::encode($utf8_bom)}else {$utf8_bom="\xEF\xBB\xBF"}my$seen_legal_directive=0;sub parse_line {shift->parse_lines(@_)}sub parse_lines {my$self=shift;my$code_handler=$self->{'code_handler'};my$cut_handler=$self->{'cut_handler'};my$wl_handler=$self->{'whiteline_handler'};$self->{'line_count'}||= 0;my$scratch;DEBUG > 4 and print STDERR "# Parsing starting at line ",$self->{'line_count'},".\n";DEBUG > 5 and print STDERR "#  About to parse lines: ",join(' ',map defined($_)? "[$_]" : "EOF",@_),"\n";my$paras=($self->{'paras'}||= []);$self->{'pod_para_count'}||= 0;my$codes=join '',grep {/ ^ [A-Za-z] $/x}sort keys %{$self->{accept_codes}};my$pod_chars_re=qr/ ^ = [A-Za-z]+ | [\Q$codes\E] < /x;my$line;for my$source_line (@_){if($self->{'source_dead'}){DEBUG > 4 and print STDERR "# Source is dead.\n";last}unless(defined$source_line){DEBUG > 4 and print STDERR "# Undef-line seen.\n";push @$paras,['~end',{'start_line'=>$self->{'line_count'}}];push @$paras,$paras->[-1],$paras->[-1];$self->{'source_dead'}=1;$self->_ponder_paragraph_buffer;next}if($self->{'line_count'}++){($line=$source_line)=~ tr/\n\r//d}else {DEBUG > 2 and print STDERR "First line: [$source_line]\n";if(($line=$source_line)=~ s/^$utf8_bom//s){DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";$self->_handle_encoding_line("=encoding utf8");delete$self->{'_processed_encoding'};$line =~ tr/\n\r//d}elsif($line =~ s/^\xFE\xFF//s){DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";$self->scream($self->{'line_count'},"UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet.");splice @_;push @_,undef;next}elsif($line =~ s/^\xFF\xFE//s){DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";$self->scream($self->{'line_count'},"UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet.");splice @_;push @_,undef;next}else {DEBUG > 2 and print STDERR "First line is BOM-less.\n";($line=$source_line)=~ tr/\n\r//d}}if(!$self->{'parse_characters'}&&!$self->{'encoding'}&& ($self->{'in_pod'}|| $line =~ /^=/s)&& $line =~ /$non_ascii_re/){my$encoding;goto set_1252 if $] lt 5.006_000;my$copy;no warnings 'utf8';if ($] ge 5.007_003){$copy=$line;goto set_1252 if!utf8::decode($copy)}elsif (ord("A")!=65){goto set_utf8}else {use if $] le 5.006002,'utf8';my$char_ord;my$needed;$copy=chr(0x100);for (my$i=0;$i < length$line;$i++){my$byte=substr($line,$i,1);if ($byte !~ $non_ascii_re){$copy .= $byte;next}my$b_ord=ord$byte;my$min_cont=0x80;if ($b_ord < 0xC2){goto set_1252}elsif ($b_ord <= 0xDF){$needed=1;$char_ord=$b_ord & 0x1F}elsif ($b_ord <= 0xEF){$min_cont=0xA0 if$b_ord==0xE0;$needed=2;$char_ord=$b_ord & (0x1F >> 1)}elsif ($b_ord <= 0xF4){$min_cont=0x90 if$b_ord==0xF0;$needed=3;$char_ord=$b_ord & (0x1F >> 2)}else {goto set_1252}goto set_1252 if$i + $needed >= length$line;while ($needed-- > 0){my$cont=substr($line,++$i,1);$b_ord=ord$cont;goto set_1252 if$b_ord < $min_cont || $b_ord > 0xBF;$min_cont=0x80;$char_ord <<= 6;$char_ord |= ($b_ord & 0x3F)}$copy .= chr$char_ord}$copy=substr($copy,1)}goto set_utf8 if ord("A")==65 && $line =~ /[\x81\x8D\x8F\x90\x9D]/;goto set_1252 if ord("A")==65 && $copy =~ /[\x80-\x9F]/;DEBUG > 8 and print STDERR __LINE__,": $copy: surrogate\n" if$copy =~ $cs_re;goto set_1252 if$cs_re && $copy =~ $cs_re;DEBUG > 8 and print STDERR __LINE__,": $copy: unassigned\n" if$cn_re && $copy =~ $cn_re;goto set_1252 if$cn_re && $copy =~ $cn_re;DEBUG > 8 and print STDERR __LINE__,": $copy: deprecated\n" if$copy =~ $deprecated_re;goto set_1252 if$copy =~ $deprecated_re;DEBUG > 8 and print STDERR __LINE__,": $copy: rare\n" if$copy =~ $rare_blocks_re;goto set_1252 if$rare_blocks_re && $copy =~ $rare_blocks_re;DEBUG > 8 and print STDERR __LINE__,": $copy: later_latin\n" if$later_latin_re && $copy =~ $later_latin_re;goto set_1252 if$later_latin_re && $copy =~ $later_latin_re;$copy =~ s/$pod_chars_re//g;if ($script_run_re){goto set_utf8 if$copy =~ $script_run_re;DEBUG > 8 and print STDERR __LINE__,":  not script run\n";goto set_1252}DEBUG > 8 and print STDERR __LINE__,": $copy: not latin\n" if$copy !~ $latin_re;goto set_utf8 if$copy !~ $latin_re;DEBUG > 8 and print STDERR __LINE__,": $copy: all latin\n" if$copy =~ $every_char_is_latin_re;goto set_utf8 if$copy =~ $every_char_is_latin_re;DEBUG > 8 and print STDERR __LINE__,": $copy: mixed\n";set_1252: DEBUG > 9 and print STDERR __LINE__,": $copy: is 1252\n";$encoding='CP1252';goto done_set;set_utf8: DEBUG > 9 and print STDERR __LINE__,": $copy: is UTF-8\n";$encoding='UTF-8';done_set: $self->_handle_encoding_line("=encoding $encoding");delete$self->{'_processed_encoding'};$self->{'_transcoder'}&& $self->{'_transcoder'}->($line);my ($word)=$line =~ /(\S*$non_ascii_re\S*)/;$self->whine($self->{'line_count'},"Non-ASCII character seen before =encoding in '$word'. Assuming $encoding")}DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";if(!$self->{'in_pod'}){if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s){if($1 eq 'cut'){$self->scream($self->{'line_count'},"=cut found outside a pod block.  Skipping to next block.");next}else {$self->{'in_pod'}=$self->{'start_of_pod_block'}=$self->{'last_was_blank'}=1}}else {DEBUG > 5 and print STDERR "# It's a code-line.\n";$code_handler->(map $_,$line,$self->{'line_count'},$self)if$code_handler;if($line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/){DEBUG > 1 and print STDERR "# Setting nextline to $1\n";$self->{'line_count'}=$1 - 1}next}}$self->{'_transcoder'}&& $self->{'_transcoder'}->($line);if($line =~ m/^=encoding\s+\S+\s*$/s){next if$self->parse_characters;$line=$self->_handle_encoding_line($line)}if($line =~ m/^=cut/s){DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";$self->{'in_pod'}=0;$self->_ponder_paragraph_buffer();DEBUG > 6 and print STDERR "Processing any cut handler, line ${$self}{'line_count'}\n";$cut_handler->(map $_,$line,$self->{'line_count'},$self)if$cut_handler}elsif($line =~ m/^(\s*)$/s){if (defined $1 and $1 =~ /[^\S\r\n]/){$wl_handler->(map $_,$line,$self->{'line_count'},$self)if$wl_handler}if(!$self->{'start_of_pod_block'}and @$paras and $paras->[-1][0]eq '~Verbatim'){DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";push @{$paras->[-1]},$line}if(!$self->{'start_of_pod_block'}and!$self->{'last_was_blank'}){DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n"}$self->{'last_was_blank'}=1}elsif($self->{'last_was_blank'}){if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(\s+|$)(.*)/s){my$new=[$1,{'start_line'=>$self->{'line_count'}},$3];$new->[1]{'~orig_spacer'}=$2 if $2 && $2 ne " ";++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();push @$paras,$new;DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n"}elsif($line =~ m/^\s/s){if(!$self->{'start_of_pod_block'}and @$paras and $paras->[-1][0]eq '~Verbatim'){DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";push @{$paras->[-1]},$line}else {++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";push @$paras,['~Verbatim',{'start_line'=>$self->{'line_count'}},$line]}}else {++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();push @$paras,['~Para',{'start_line'=>$self->{'line_count'}},$line];DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n"}$self->{'last_was_blank'}=$self->{'start_of_pod_block'}=0}else {if(@$paras){DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";push @{$paras->[-1]},$line}else {die "Continuing a paragraph but \@\$paras is empty?"}$self->{'last_was_blank'}=$self->{'start_of_pod_block'}=0}}DEBUG > 1 and print STDERR (pretty(@$paras),"\n");return$self}sub _handle_encoding_line {my($self,$line)=@_;return if$self->parse_characters;return$line unless$line =~ m/^=encoding\s+(\S+)\s*$/s;DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";my$e=$1;my$orig=$e;push @{$self->{'encoding_command_reqs'}},"=encoding $orig";my$enc_error;require Pod::Simple::Transcode;if($self->{'encoding'}){my$norm_current=$self->{'encoding'};my$norm_e=$e;for my$that ($norm_current,$norm_e){$that=lc($that);$that =~ s/[-_]//g}if($norm_current eq $norm_e){DEBUG > 1 and print STDERR "The '=encoding $orig' line is ","redundant.  ($norm_current eq $norm_e).  Ignoring.\n";$enc_error=''}else {$enc_error="Encoding is already set to " .$self->{'encoding'};DEBUG > 1 and print STDERR$enc_error}}elsif (do {DEBUG > 1 and print STDERR " Setting encoding to $e\n";$self->{'encoding'}=$e;1}and $e eq 'HACKRAW'){DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n"}elsif(Pod::Simple::Transcode::->encoding_is_available($e)){die($enc_error="WHAT? _transcoder is already set?!")if$self->{'_transcoder'};require Pod::Simple::Transcode;$self->{'_transcoder'}=Pod::Simple::Transcode::->make_transcoder($e);eval {my@x=('',"abc","123");$self->{'_transcoder'}->(@x)};$@ && die($enc_error="Really unexpected error setting up encoding $e: $@\nAborting");$self->{'detected_encoding'}=$e}else {my@supported=Pod::Simple::Transcode::->all_encodings;DEBUG and print STDERR " Encoding [$e] is unsupported.","\nSupporteds: @supported\n";my$suggestion='';my$norm=lc($e);$norm =~ tr[-_][]d;my$n;for my$enc (@supported){$n=lc($enc);$n =~ tr[-_][]d;next unless$n eq $norm;$suggestion="  (Maybe \"$e\" should be \"$enc\"?)";last}my$encmodver=Pod::Simple::Transcode::->encmodver;$enc_error=join ''=>"This document probably does not appear as it should, because its ","\"=encoding $e\" line calls for an unsupported encoding.",$suggestion,"  [$encmodver\'s supported encodings are: @supported]" ;$self->scream($self->{'line_count'},$enc_error)}push @{$self->{'encoding_command_statuses'}},$enc_error;if (defined($self->{'_processed_encoding'})){$self->scream($self->{'line_count'},'Cannot have multiple =encoding directives')}$self->{'_processed_encoding'}=$orig;return$line}sub _handle_encoding_second_level {my($self,$para)=@_;my@x=@$para;my$content=join ' ',splice@x,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";if (defined($self->{'_processed_encoding'})){delete$self->{'_processed_encoding'};if(!$self->{'encoding_command_statuses'}){DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n"}elsif($self->{'encoding_command_statuses'}[-1]){$self->whine($para->[1]{'start_line'},sprintf "Couldn't do %s: %s",$self->{'encoding_command_reqs' }[-1],$self->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n"}}else {$self->whine($para->[1]{'start_line'},"Invalid =encoding syntax: $content")}return}{my$m=-321;sub _gen_errata {my$self=$_[0];return()unless$self->{'errata'}and keys %{$self->{'errata'}};my@out;for my$line (sort {$a <=> $b}keys %{$self->{'errata'}}){push@out,['=item',{'start_line'=>$m},"Around line $line:"],map(['~Para',{'start_line'=>$m,'~cooked'=>1},$_ ],@{$self->{'errata'}{$line}})}unshift@out,['=head1',{'start_line'=>$m,'errata'=>1},'POD ERRORS'],['~Para',{'start_line'=>$m,'~cooked'=>1,'errata'=>1},"Hey! ",['B',{},'The above document had some coding errors, which are explained below:' ]],['=over',{'start_line'=>$m,'errata'=>1},''],;push@out,['=back',{'start_line'=>$m,'errata'=>1},''],;DEBUG and print STDERR "\n<<\n",pretty(\@out),"\n>>\n\n";return@out}}sub _ponder_paragraph_buffer {my$self=$_[0];my$paras;return unless @{$paras=$self->{'paras'}};my$curr_open=($self->{'curr_open'}||= []);my$scratch;DEBUG > 10 and print STDERR "# Paragraph buffer: <<",pretty($paras),">>\n";unless($self->{'doc_has_started'}){$self->{'doc_has_started'}=1;my$starting_contentless;$starting_contentless=(!@$curr_open and @$paras and!grep $_->[0]ne '~end',@$paras);DEBUG and print STDERR "# Starting ",$starting_contentless ? 'contentless' : 'contentful'," document\n" ;$self->_handle_element_start(($scratch='Document'),{'start_line'=>$paras->[0][1]{'start_line'},$starting_contentless ? ('contentless'=>1): (),},)}my($para,$para_type);while(@$paras){$seen_legal_directive++ if$paras->[0][0]=~ /^=/;last if @$paras==1 and ($paras->[0][0]eq '=over' or $paras->[0][0]eq '=item' or ($paras->[0][0]eq '~Verbatim' and $self->{'in_pod'}));$para=shift @$paras;$para_type=$para->[0];DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",$self->_dump_curr_open(),")\n";if($para_type eq '=for'){next if$self->_ponder_for($para,$curr_open,$paras)}elsif($para_type eq '=begin'){next if$self->_ponder_begin($para,$curr_open,$paras)}elsif($para_type eq '=end'){next if$self->_ponder_end($para,$curr_open,$paras)}elsif($para_type eq '~end'){next if$self->_ponder_doc_end($para,$curr_open,$paras)}if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Skipping $para_type paragraph because in ignore mode.\n";next}if($para_type eq '=pod'){$self->_ponder_pod($para,$curr_open,$paras)}elsif($para_type eq '=over'){next if$self->_ponder_over($para,$curr_open,$paras)}elsif($para_type eq '=back'){next if$self->_ponder_back($para,$curr_open,$paras)}else {DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";my$i;if($para_type =~ m/^=head\d$/s and!$self->{'accept_heads_anywhere'}and @$curr_open and $curr_open->[-1][0]eq '=over'){DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";$self->whine($para->[1]{'start_line'},"You forgot a '=back' before '$para_type'");unshift @$paras,['=back',{},''],$para;next}if($para_type eq '=item'){my$over;unless(@$curr_open and $over=(grep {$_->[0]eq '=over'}@$curr_open)[-1]){$self->whine($para->[1]{'start_line'},"'=item' outside of any '=over'");unshift @$paras,['=over',{'start_line'=>$para->[1]{'start_line'}},''],$para ;next}my$over_type=$over->[1]{'~type'};if(!$over_type){die "Typeless over in stack, starting at line " .$over->[1]{'start_line'}}elsif($over_type eq 'block'){unless($curr_open->[-1][1]{'~bitched_about'}){$curr_open->[-1][1]{'~bitched_about'}=1;$self->whine($curr_open->[-1][1]{'start_line'},"You can't have =items (as at line " .$para->[1]{'start_line'}.") unless the first thing after the =over is an =item")}$para->[0]='~Para';unshift @$paras,$para;next}elsif($over_type eq 'text'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'text'){}elsif($item_type eq 'number' or $item_type eq 'bullet'){$self->whine($para->[1]{'start_line'},"Expected text after =item, not a $item_type");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}else {die "Unhandled item type $item_type"}}elsif($over_type eq 'number'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";my$expected_value=++ $curr_open->[-1][1]{'~counter'};if($item_type eq 'bullet'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'");push @$para,$para->[1]{'~orig_content'}}elsif($item_type eq 'text'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'")}elsif($item_type ne 'number'){die "Unknown item type $item_type"}elsif($expected_value==$para->[1]{'number'}){DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n"}else {DEBUG > 1 and print STDERR " Numeric item has ",$para->[1]{'number'}," instead of the expected value of $expected_value\n";$self->whine($para->[1]{'start_line'},"You have '=item " .$para->[1]{'number'}."' instead of the expected '=item $expected_value'");$para->[1]{'number'}=$expected_value}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}elsif($over_type eq 'bullet'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'bullet'){if($para->[1]{'~_freaky_para_hack'}){DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";push @$para,$para->[1]{'~_freaky_para_hack'}}}elsif($item_type eq 'number'){$self->whine($para->[1]{'start_line'},"Expected '=item *'");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}elsif($item_type eq 'text'){$self->whine($para->[1]{'start_line'},"Expected '=item *'")}else {die "Unhandled item type $item_type"}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}else {die "Unhandled =over type \"$over_type\"?"}$para_type='Plain';$para->[0].= '-' .$over_type}elsif($para_type eq '=extend'){$self->_ponder_extend($para);next}elsif($para_type eq '=encoding'){$self->_handle_encoding_second_level($para);next unless$self->keep_encoding_directive;$para_type='Plain'}elsif($para_type eq '~Verbatim'){$para->[0]='Verbatim';$para_type='?Verbatim'}elsif($para_type eq '~Para'){$para->[0]='Para';$para_type='?Plain'}elsif($para_type eq 'Data'){$para->[0]='Data';$para_type='?Data'}elsif($para_type =~ s/^=//s and defined($para_type=$self->{'accept_directives'}{$para_type})){DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n"}else {$seen_legal_directive--;DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",$para->[0],join(' ',sort keys %{$self->{'accept_directives'}});$self->whine($para->[1]{'start_line'},"Unknown directive: $para->[0]");next}if($para_type =~ s/^\?//s){if(!@$curr_open){DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n"}else {my@fors=grep $_->[0]eq '=for',@$curr_open;DEBUG > 1 and print STDERR "Containing fors: ",join(',',map $_->[1]{'target'},@fors),"\n";if(!@fors){DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n"}elsif($fors[-1][1]{'~resolve'}){if($para_type eq 'Data'){DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";$para->[0]='Para';$para_type='Plain'}else {DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n"}}else {DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";$para->[0]=$para_type='Data'}}}if($para_type eq 'Plain'){$self->_ponder_Plain($para)}elsif($para_type eq 'Verbatim'){$self->_ponder_Verbatim($para)}elsif($para_type eq 'Data'){$self->_ponder_Data($para)}else {die "\$para type is $para_type -- how did that happen?"}$para->[0]=~ s/^[~=]//s;DEBUG and print STDERR "\n",pretty($para),"\n";$self->{'content_seen'}||= 1 if$seen_legal_directive &&!$self->{'~tried_gen_errata'};$self->_traverse_treelet_bit(@$para)}}return}sub _ponder_for {my ($self,$para,$curr_open,$paras)=@_;my$target;if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";return 1}for(my$i=2;$i < @$para;++$i){if($para->[$i]=~ s/^\s*(\S+)\s*//s){$target=$1;last}}unless(defined$target){$self->whine($para->[1]{'start_line'},"=for without a target?");return 1}DEBUG > 1 and print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";$para->[0]='Data';unshift @$paras,['=begin',{'start_line'=>$para->[1]{'start_line'},'~really'=>'=for'},$target,],$para,['=end',{'start_line'=>$para->[1]{'start_line'},'~really'=>'=for'},$target,],;return 1}sub _ponder_begin {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;unless(length($content)){$self->whine($para->[1]{'start_line'},"=begin without a target?");DEBUG and print STDERR "Ignoring targetless =begin\n";return 1}my ($target,$title)=$content =~ m/^(\S+)\s*(.*)$/;$para->[1]{'title'}=$title if ($title);$para->[1]{'target'}=$target;$content=$target;$content =~ s/^:!/!:/s;my$neg;$neg=1 if$content =~ s/^!//s;my$to_resolve;$to_resolve=1 if$content =~ s/^://s;my$dont_ignore;for my$target_name (split(',',$content,-1),$neg ? (): '*'){DEBUG > 2 and print STDERR " Considering whether =begin $content matches $target_name\n";next unless$self->{'accept_targets'}{$target_name};DEBUG > 2 and print STDERR "  It DOES match the acceptable target $target_name!\n";$to_resolve=1 if$self->{'accept_targets'}{$target_name}eq 'force_resolve';$dont_ignore=1;$para->[1]{'target_matching'}=$target_name;last}if($neg){if($dont_ignore){$dont_ignore='';delete$para->[1]{'target_matching'};DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n"}else {$dont_ignore=1;$para->[1]{'target_matching'}='!';DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n"}}$para->[0]='=for';$para->[1]{'~really'}||= '=begin';$para->[1]{'~ignore'}=(!$dont_ignore)|| 0;$para->[1]{'~resolve'}=$to_resolve || 0;DEBUG > 1 and print STDERR " Making note to ",$dont_ignore ? 'not ' : '',"ignore contents of this region\n";DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",($to_resolve ? 'verbatim/plain' : 'data')," paragraphs\n";DEBUG > 1 and print STDERR " (Stack now: ",$self->_dump_curr_open(),")\n";push @$curr_open,$para;if(!$dont_ignore or scalar grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n"}else {$self->{'content_seen'}||= 1 unless$self->{'~tried_gen_errata'};$self->_handle_element_start((my$scratch='for'),$para->[1])}return 1}sub _ponder_end {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG and print STDERR "Ogling '=end $content' directive\n";unless(length($content)){$self->whine($para->[1]{'start_line'},"'=end' without a target?" .((@$curr_open and $curr_open->[-1][0]eq '=for')? (" (Should be \"=end " .$curr_open->[-1][1]{'target'}.'")'): ''));DEBUG and print STDERR "Ignoring targetless =end\n";return 1}unless($content =~ m/^\S+$/){$self->whine($para->[1]{'start_line'},"'=end $content' is invalid.  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content\n";return 1}unless(@$curr_open and $curr_open->[-1][0]eq '=for'){$self->whine($para->[1]{'start_line'},"=end $content without matching =begin.  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content\n";return 1}unless($content eq $curr_open->[-1][1]{'target'}){$self->whine($para->[1]{'start_line'},"=end $content doesn't match =begin " .$curr_open->[-1][1]{'target'}.".  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";return 1}if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n"}else {$curr_open->[-1][1]{'start_line'}=$para->[1]{'start_line'};$self->{'content_seen'}||= 1 unless$self->{'~tried_gen_errata'};$self->_handle_element_end(my$scratch='for',$para->[1])}DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";pop @$curr_open;return 1}sub _ponder_doc_end {my ($self,$para,$curr_open,$paras)=@_;if(@$curr_open){DEBUG and print STDERR "Stack is nonempty at end-document: (",$self->_dump_curr_open(),")\n";DEBUG > 9 and print STDERR "Stack: ",pretty($curr_open),"\n";unshift @$paras,$self->_closers_for_all_curr_open;@$paras=grep $_->[0]ne '~end',@$paras;push @$paras,$para,$para;return 1}else {DEBUG and print STDERR "Okay, stack is empty now.\n"}unless($self->{'~tried_gen_errata'}){$self->{'~tried_gen_errata'}=1;my@extras=$self->_gen_errata();if(@extras){unshift @$paras,@extras;DEBUG and print STDERR "Generated errata... relooping...\n";return 1}}splice @$paras;DEBUG and print STDERR "Throwing end-document event.\n";$self->_handle_element_end(my$scratch='Document');return 1}sub _ponder_pod {my ($self,$para,$curr_open,$paras)=@_;$self->whine($para->[1]{'start_line'},"=pod directives shouldn't be over one line long!  Ignoring all " .(@$para - 2)." lines of content")if @$para > 3;if (my$pod_handler=$self->{'pod_handler'}){my ($line_num,$line)=map $_,$para->[1]{'start_line'},$para->[2];$line=$line eq '' ? "=pod" : "=pod $line";$pod_handler->($line,$line_num,$self)}return}sub _ponder_over {my ($self,$para,$curr_open,$paras)=@_;return 1 unless @$paras;my$list_type;if($paras->[0][0]eq '=item'){$list_type=$self->_get_initial_item_type($paras->[0])}elsif($paras->[0][0]eq '=back'){if ($self->{'parse_empty_lists'}){$list_type='empty'}else {shift @$paras;return 1}}elsif($paras->[0][0]eq '~end'){$self->whine($para->[1]{'start_line'},"=over is the last thing in the document?!");return 1}else {$list_type='block'}$para->[1]{'~type'}=$list_type;push @$curr_open,$para;my$content=join ' ',splice @$para,2;$para->[1]{'~orig_content'}=$content;my$overness;if($content =~ m/^\s*$/s){$para->[1]{'indent'}=4}elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s){no integer;$para->[1]{'indent'}=$1;if($1==0){$self->whine($para->[1]{'start_line'},"Can't have a 0 in =over $content");$para->[1]{'indent'}=4}}else {$self->whine($para->[1]{'start_line'},"=over should be: '=over' or '=over positive_number'");$para->[1]{'indent'}=4}DEBUG > 1 and print STDERR "=over found of type $list_type\n";$self->{'content_seen'}||= 1 unless$self->{'~tried_gen_errata'};$self->_handle_element_start((my$scratch='over-' .$list_type),$para->[1]);return}sub _ponder_back {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;if($content =~ m/\S/){$self->whine($para->[1]{'start_line'},"=back doesn't take any parameters, but you said =back $content")}if(@$curr_open and $curr_open->[-1][0]eq '=over'){DEBUG > 1 and print STDERR "=back happily closes matching =over\n";$self->{'content_seen'}||= 1 unless$self->{'~tried_gen_errata'};$self->_handle_element_end(my$scratch='over-' .((pop @$curr_open)->[1]{'~type'}),$para->[1])}else {DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",join(', ',map $_->[0],@$curr_open),").\n";$self->whine($para->[1]{'start_line'},'=back without =over');return 1}}sub _ponder_item {my ($self,$para,$curr_open,$paras)=@_;my$over;unless(@$curr_open and $over=(grep {$_->[0]eq '=over'}@$curr_open)[-1]){$self->whine($para->[1]{'start_line'},"'=item' outside of any '=over'");unshift @$paras,['=over',{'start_line'=>$para->[1]{'start_line'}},''],$para ;return 1}my$over_type=$over->[1]{'~type'};if(!$over_type){die "Typeless over in stack, starting at line " .$over->[1]{'start_line'}}elsif($over_type eq 'block'){unless($curr_open->[-1][1]{'~bitched_about'}){$curr_open->[-1][1]{'~bitched_about'}=1;$self->whine($curr_open->[-1][1]{'start_line'},"You can't have =items (as at line " .$para->[1]{'start_line'}.") unless the first thing after the =over is an =item")}$para->[0]='~Para';unshift @$paras,$para;return 1}elsif($over_type eq 'text'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'text'){}elsif($item_type eq 'number' or $item_type eq 'bullet'){$self->whine($para->[1]{'start_line'},"Expected text after =item, not a $item_type");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}else {die "Unhandled item type $item_type"}}elsif($over_type eq 'number'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";my$expected_value=++ $curr_open->[-1][1]{'~counter'};if($item_type eq 'bullet'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'");push @$para,$para->[1]{'~orig_content'}}elsif($item_type eq 'text'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'")}elsif($item_type ne 'number'){die "Unknown item type $item_type"}elsif($expected_value==$para->[1]{'number'}){DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n"}else {DEBUG > 1 and print STDERR " Numeric item has ",$para->[1]{'number'}," instead of the expected value of $expected_value\n";$self->whine($para->[1]{'start_line'},"You have '=item " .$para->[1]{'number'}."' instead of the expected '=item $expected_value'");$para->[1]{'number'}=$expected_value}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}elsif($over_type eq 'bullet'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'bullet'){if($para->[1]{'~_freaky_para_hack'}){DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";push @$para,$para->[1]{'~_freaky_para_hack'}}}elsif($item_type eq 'number'){$self->whine($para->[1]{'start_line'},"Expected '=item *'");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}elsif($item_type eq 'text'){$self->whine($para->[1]{'start_line'},"Expected '=item *'")}else {die "Unhandled item type $item_type"}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}else {die "Unhandled =over type \"$over_type\"?"}$para->[0].= '-' .$over_type;return}sub _ponder_Plain {my ($self,$para)=@_;DEBUG and print STDERR " giving plain treatment...\n";unless(@$para==2 or (@$para==3 and $para->[2]eq '')or $para->[1]{'~cooked'}){push @$para,@{$self->_make_treelet(join("\n",splice(@$para,2)),$para->[1]{'start_line'})}}return}sub _ponder_Verbatim {my ($self,$para)=@_;DEBUG and print STDERR " giving verbatim treatment...\n";$para->[1]{'xml:space'}='preserve';unless ($self->{'_output_is_for_JustPod'}){$self->expand_verbatim_tabs(8)if!defined$self->expand_verbatim_tabs()|| $self->expand_verbatim_tabs()=~ /\D/;my$indent=$self->strip_verbatim_indent;if ($indent && ref$indent eq 'CODE'){my@shifted=(shift @{$para},shift @{$para});$indent=$indent->($para);unshift @{$para},@shifted}for(my$i=2;$i < @$para;$i++){for my$line ($para->[$i]){$line =~ s/^\Q$indent// if$indent;next unless$self->expand_verbatim_tabs;while($line =~ s/^([^\t]*)(\t+)/$1.(" " x ((length($2)
                                         * $self->expand_verbatim_tabs)
                                         -(length($1)&7)))/e){}}}}if($self->{'accept_codes'}and $self->{'accept_codes'}{'VerbatimFormatted'}){while(@$para > 3 and $para->[-1]!~ m/\S/){pop @$para}$self->_verbatim_format($para)}elsif ($self->{'codes_in_verbatim'}){push @$para,@{$self->_make_treelet(join("\n",splice(@$para,2)),$para->[1]{'start_line'},$para->[1]{'xml:space'})};$para->[-1]=~ s/\n+$//s}else {push @$para,join "\n",splice(@$para,2)if @$para > 3;$para->[-1]=~ s/\n+$//s}return}sub _ponder_Data {my ($self,$para)=@_;DEBUG and print STDERR " giving data treatment...\n";$para->[1]{'xml:space'}='preserve';push @$para,join "\n",splice(@$para,2)if @$para > 3;return}sub _traverse_treelet_bit {my($self,$name)=splice @_,0,2;my$scratch;$self->_handle_element_start(($scratch=$name),shift @_);while (@_){my$x=shift;if (ref($x)){&_traverse_treelet_bit($self,@$x)}else {$x .= shift while @_ &&!ref($_[0]);$self->_handle_text($x)}}$self->_handle_element_end($scratch=$name);return}sub _closers_for_all_curr_open {my$self=$_[0];my@closers;for my$still_open (@{$self->{'curr_open'}|| return}){my@copy=@$still_open;$copy[1]={%{$copy[1]}};if($copy[0]eq '=for'){$copy[0]='=end'}elsif($copy[0]eq '=over'){$self->whine($still_open->[1]{start_line},"=over without closing =back");$copy[0]='=back'}else {die "I don't know how to auto-close an open $copy[0] region"}unless(@copy > 2){push@copy,$copy[1]{'target'};$copy[-1]='' unless defined$copy[-1]}$copy[1]{'fake-closer'}=1;DEBUG and print STDERR "Queuing up fake-o event: ",pretty(\@copy),"\n";unshift@closers,\@copy}return@closers}sub _verbatim_format {my($it,$p)=@_;my$formatting;for(my$i=2;$i < @$p;$i++){DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";$p->[$i].= "\n"}if(DEBUG > 4){print STDERR "<<\n";for(my$i=$#$p;$i >= 2;$i--){print STDERR "_verbatim_format $i: $p->[$i]"}print STDERR ">>\n"}for(my$i=$#$p;$i > 2;$i--){DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";if($p->[$i]=~ m{^#:([ \^\/\%]*)\n?$}s){DEBUG > 5 and print STDERR "  It's a formatty line.  ","Peeking at previous line ",$i-1,": $$p[$i-1]: \n";if($p->[$i-1]=~ m{^#:[ \^\/\%]*\n?$}s){DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";next}else {DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n"}}else {DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";next}DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";$formatting='  ' .$1;$formatting =~ s/\s+$//s;unless(length$formatting and $p->[$i-1]=~ m/\S/){splice @$p,$i,1;$i--;next}if(length($formatting)>= length($p->[$i-1])){$formatting=substr($formatting,0,length($p->[$i-1])- 1).' '}else {$formatting .= ' ' x (length($p->[$i-1])- length($formatting))}DEBUG > 4 and print STDERR "Formatting <$formatting>    on <",$p->[$i-1],">\n";my@new_line;while($formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g){if($2){push@new_line,substr($p->[$i-1],pos($formatting)-length($1),length($1))}else {push@new_line,[($3 ? 'VerbatimB' : $4 ? 'VerbatimI' : $5 ? 'VerbatimBI' : die("Should never get called")),{},substr($p->[$i-1],pos($formatting)-length($1),length($1))]}}my@nixed=splice @$p,$i-1,2,@new_line;DEBUG > 10 and print STDERR "Nixed count: ",scalar(@nixed),"\n";DEBUG > 6 and print STDERR "New version of the above line is these tokens (",scalar(@new_line),"):",map(ref($_)?"<@$_> ":"<$_>",@new_line),"\n";$i--}$p->[0]='VerbatimFormatted';for(my$i=2;$i > $#$p;$i++ ){if(!ref($p->[$i])and!ref($p->[$i + 1])){DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";$p->[$i].= splice @$p,$i+1,1;--$i}}for(my$i=$#$p;$i >= 2;$i-- ){if(!ref($p->[$i])){if($p->[$i]=~ s/\n$//s){DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n"}else {DEBUG > 5 and print STDERR "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n"}last}}return}sub _treelet_from_formatting_codes {my($self,$para,$start_line,$preserve_space)=@_;my$treelet=['~Top',{'start_line'=>$start_line},];unless ($preserve_space || $self->{'preserve_whitespace'}){$para =~ s/\s+/ /g;$para =~ s/ $//;$para =~ s/^ //}my@stack;my@lineage=($treelet);my$raw='';my$inL=0;DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";while($para =~ m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.  ($3 can be empty if the
          # construct is empty, like C<<  >>, and all the white-space has been
          # gobbled up already, considered to be space after the opening
          # bracket.  In this case we use look-behind to verify that there are
          # at least 2 spaces in a row before the ">".)
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo){DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";if(defined $1){my$bracket_count;if(defined $2){DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";$bracket_count=length($2)+ 1;push@stack,$bracket_count}else {DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";push@stack,0;$bracket_count=1}my$code=substr($1,0,1);if ('L' eq $code){if ($inL){$raw .= $1;$self->scream($start_line,'Nested L<> are illegal.  Pretending inner one is ' .'X<...> so can continue looking for other errors.');$code="X"}else {$raw="";$inL=@stack}}else {$raw .= $1 if$inL}push@lineage,[$code,{},];if ($self->{'_output_is_for_JustPod'}&& $bracket_count > 1){$lineage[-1][1]{'~bracket_count'}=$bracket_count;my$lspacer=substr($1,1 + $bracket_count);$lineage[-1][1]{'~lspacer'}=$lspacer if$lspacer ne " "}push @{$lineage[-2]},$lineage[-1]}elsif(defined $4){DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";if(!@stack){DEBUG > 4 and print STDERR " But it's really just stuff.\n";push @{$lineage[-1]},$3,$4;next}elsif(!$stack[-1]){DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";push @{$lineage[-1]},$3;pos($para)=pos($para)- length($4)+ 1}elsif($stack[-1]==length($4)){DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n"}elsif($stack[-1]< length($4)){DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";pos($para)=pos($para)- length($4)+ $stack[-1]}else {DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";push @{$lineage[-1]},$3,$4;next}if ($3 ne " " && $self->{'_output_is_for_JustPod'}){if ($3 ne ""){$lineage[-1][1]{'~rspacer'}=$3}elsif ($lineage[-1][1]{'~lspacer'}eq "  "){delete$lineage[-1][1]{'~lspacer'}}else {$lineage[-1][1]{'~rspacer'}=substr($lineage[-1][1]{'~lspacer'},-1,1);chop$lineage[-1][1]{'~lspacer'}}}push @{$lineage[-1]},'' if 2==@{$lineage[-1]};if ($inL==@stack){$lineage[-1][1]{'raw'}=$raw;$inL=0}pop@stack;pop@lineage;$raw .= $3.$4 if$inL}elsif(defined $5){DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";if(@stack and!$stack[-1]){DEBUG > 4 and print STDERR " It's indeed an end-code.\n";if(length($5)==2){push @{$lineage[-1]},' '}elsif(2==@{$lineage[-1]}){push @{$lineage[-1]},''}if ($inL==@stack){$lineage[-1][1]{'raw'}=$raw;$inL=0}pop@stack;pop@lineage}else {DEBUG > 4 and print STDERR " It's just stuff.\n";push @{$lineage[-1]},$5}$raw .= $5 if$inL}elsif(defined $6){DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";push @{$lineage[-1]},$6;$raw .= $6 if$inL}else {DEBUG and print STDERR "AYYAYAAAAA at line ",__LINE__,"\n";die "SPORK 512512!"}}if(@stack){my$x="...";while(@stack){push @{$lineage[-1]},'' if 2==@{$lineage[-1]};my$code=(pop@lineage)->[0];my$ender_length=pop@stack;if($ender_length){--$ender_length;$x=$code .("<" x $ender_length)." $x " .(">" x $ender_length)}else {$x=$code ."<$x>"}}DEBUG > 1 and print STDERR "Unterminated $x sequence\n";$self->whine($start_line,"Unterminated $x sequence",)}return$treelet}sub text_content_of_treelet {return stringify_lol($_[1])}sub stringify_lol {my$string_form='';_stringify_lol($_[0]=>\$string_form);return$string_form}sub _stringify_lol {my($lol,$to)=@_;for(my$i=2;$i < @$lol;++$i){if(ref($lol->[$i]|| '')and UNIVERSAL::isa($lol->[$i],'ARRAY')){_stringify_lol($lol->[$i],$to)}else {$$to .= $lol->[$i]}}return}sub _dump_curr_open {my$curr_open=$_[0]{'curr_open'};return '[empty]' unless @$curr_open;return join '; ',map {;($_->[0]eq '=for')? (($_->[1]{'~really'}|| '=over').' ' .$_->[1]{'target'}): $_->[0]}@$curr_open }my%pretty_form=("\a"=>'\a',"\b"=>'\b',"\e"=>'\e',"\f"=>'\f',"\t"=>'\t',"\cm"=>'\cm',"\cj"=>'\cj',"\n"=>'\n','"'=>'\"','\\'=>'\\\\','$'=>'\\$','@'=>'\\@','%'=>'\\%','#'=>'\\#',);sub pretty {my@stuff=@_;my$x;my$out=join ", ",map {;if(!defined($_)){"undef"}elsif(ref($_)eq 'ARRAY' or ref($_)eq 'Pod::Simple::LinkSection'){$x="[ " .pretty(@$_)." ]" ;$x}elsif(ref($_)eq 'SCALAR'){$x="\\" .pretty($$_);$x}elsif(ref($_)eq 'HASH'){my$hr=$_;$x="{" .join(", ",map(pretty($_).'=>' .pretty($hr->{$_}),sort keys %$hr))."}" ;$x}elsif(!length($_)){q{''}}elsif($_ eq '0' or(m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s and $_ ne '-0')){$_}else {s<([^ !"#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;qq{"$_"}}}@stuff;return$out}sub reinit {my$self=shift;for (qw(source_dead source_filename doc_has_started start_of_pod_block content_seen last_was_blank paras curr_open line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen Title)){delete$self->{$_}}}1;
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  require 5;package Pod::Simple::Checker;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.42';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::wrap='overflow';sub any_errata_seen {return $_[1]->{'Errata_seen'}}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';$new->{'Errata_seen'}=0;return$new}sub handle_text {$_[0]{'Errata_seen'}and $_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {if($_[0]{'Errata_seen'}){$_[0]{'Thispara'}=''}else {if($_[1]{'errata'}){$_[0]{'Errata_seen'}=1;$_[0]{'Thispara'}=$_[0]{'source_filename'}? "$_[0]{'source_filename'} -- " : ''}}}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}='* '}sub start_item_number {$_[0]{'Thispara'}="$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub emit_par {return unless $_[0]{'Errata_seen'};my($self,$tweak_indent)=splice(@_,0,2);my$length=2 * $self->{'Indent'}+ ($tweak_indent||0);my$indent=' ' x ($length > 0 ? $length : 0);$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ s/$Pod::Simple::nbsp/ /g;print {$self->{'output_fh'}}$out,;$self->{'Thispara'}='';return}sub end_Verbatim {return unless $_[0]{'Errata_seen'};my$self=shift;$self->{'Thispara'}=~ s/$Pod::Simple::nbsp/ /g;$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  require 5;package Pod::Simple::Debug;use strict;use vars qw($VERSION);$VERSION='3.42';sub import {my($value,$variable);if(@_==2){$value=$_[1]}elsif(@_==3){($variable,$value)=@_[1,2];($variable,$value)=($value,$variable)if defined$value and ref($value)eq 'SCALAR' and not(defined$variable and ref($variable)eq 'SCALAR');unless(defined$variable and ref($variable)eq 'SCALAR'){require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}}else {require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined&Pod::Simple::DEBUG){require Carp;Carp::croak("It's too late to call Pod::Simple::Debug -- " ."Pod::Simple has already loaded\nAborting")}$value=0 unless defined$value;unless($value =~ m/^-?\d+$/){require Carp;Carp::croak("$value isn't a numeric value." ."\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined$variable){*Pod::Simple::DEBUG=sub () {$$variable};$$variable=$value;print STDERR "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n"}else {*Pod::Simple::DEBUG=eval " sub () { $value } ";print STDERR "# Starting Pod::Simple::DEBUG = $value\n"}require Pod::Simple;return}1;
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  require 5;package Pod::Simple::DumpAsText;$VERSION='3.42';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"++",$_[1],"\n";$_[0]{'indent'}++;while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_perly_escape($key);_perly_escape($value);printf$fh qq{%s \\ "%s" => "%s"\n},'  ' x ($_[0]{'indent'}|| 0),$key,$value}}return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_perly_escape($text);$text =~ s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \ {1,10}(?!\n)     # capture some spaces not at line-end
         /$1"\n$indent . "/gx ;print {$_[0]{'output_fh'}}$indent,'* "',$text,"\"\n"}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"--",$_[1],"\n";return}sub _perly_escape {for my$x (@_){$x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;$x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg}return}1;
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  require 5;package Pod::Simple::DumpAsXML;$VERSION='3.42';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Text::Wrap qw(wrap);BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"<",$_[1];for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh ' ',$key,'="',$value,'"'}}print$fh ">\n";$_[0]{'indent'}++;return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_xml_escape($text);local$Text::Wrap::huge='overflow';$text=wrap('',$indent,$text);print {$_[0]{'output_fh'}}$indent,$text,"\n"}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"</",$_[1],">\n";return}sub _xml_escape {for my$x (@_){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}return}1;
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  require 5;package Pod::Simple::HTML;use strict;use Pod::Simple::PullParser ();use vars qw(@ISA %Tagmap $Computerese $LamePad $Linearization_Limit $VERSION $Perldoc_URL_Prefix $Perldoc_URL_Postfix $Man_URL_Prefix $Man_URL_Postfix $Title_Prefix $Title_Postfix $HTML_EXTENSION %ToIndex $Doctype_decl $Content_decl);@ISA=('Pod::Simple::PullParser');$VERSION='3.42';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$Doctype_decl ||= '';$Content_decl ||= q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};$HTML_EXTENSION='.html' unless defined$HTML_EXTENSION;$Computerese="" unless defined$Computerese;$LamePad='' unless defined$LamePad;$Linearization_Limit=120 unless defined$Linearization_Limit;$Perldoc_URL_Prefix='https://metacpan.org/pod/' unless defined$Perldoc_URL_Prefix;$Perldoc_URL_Postfix='' unless defined$Perldoc_URL_Postfix;$Man_URL_Prefix='http://man.he.net/man';$Man_URL_Postfix='';$Title_Prefix='' unless defined$Title_Prefix;$Title_Postfix='' unless defined$Title_Postfix;%ToIndex=map {;$_=>1}qw(head1 head2 head3 head4);__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','batch_mode','batch_mode_current_level','title_prefix','title_postfix','html_h_level','html_header_before_title','html_header_after_title','html_footer','top_anchor','index','html_css','html_javascript','force_title','default_title',);my@_to_accept;%Tagmap=('Verbatim'=>"\n<pre$Computerese>",'/Verbatim'=>"</pre>\n",'VerbatimFormatted'=>"\n<pre$Computerese>",'/VerbatimFormatted'=>"</pre>\n",'VerbatimB'=>"<b>",'/VerbatimB'=>"</b>",'VerbatimI'=>"<i>",'/VerbatimI'=>"</i>",'VerbatimBI'=>"<b><i>",'/VerbatimBI'=>"</i></b>",'Data'=>"\n",'/Data'=>"\n",'head1'=>"\n<h1>",'head2'=>"\n<h2>",'head3'=>"\n<h3>",'head4'=>"\n<h4>",'head5'=>"\n<h5>",'head6'=>"\n<h6>",'/head1'=>"</a></h1>\n",'/head2'=>"</a></h2>\n",'/head3'=>"</a></h3>\n",'/head4'=>"</a></h4>\n",'/head5'=>"</a></h5>\n",'/head6'=>"</a></h6>\n",'X'=>"<!--\n\tINDEX: ",'/X'=>"\n-->",changes(qw(Para=p B=b I=i over-bullet=ul over-number=ol over-text=dl over-block=blockquote item-bullet=li item-number=li item-text=dt)),changes2(map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[sample=samp definition=dfn keyboard=kbd variable=var citation=cite abbreviation=abbr acronym=acronym subscript=sub superscript=sup big=big small=small underline=u strikethrough=s preformat=pre teletype=tt]),'/item-bullet'=>"</li>$LamePad\n",'/item-number'=>"</li>$LamePad\n",'/item-text'=>"</a></dt>$LamePad\n",'item-body'=>"\n<dd>",'/item-body'=>"</dd>\n",'B'=>"<b>",'/B'=>"</b>",'I'=>"<i>",'/I'=>"</i>",'F'=>"<em$Computerese>",'/F'=>"</em>",'C'=>"<code$Computerese>",'/C'=>"</code>",'L'=>"<a href='YOU_SHOULD_NEVER_SEE_THIS'>",'/L'=>"</a>",);sub changes {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"\n<$2>","/$1",=>"</$2>\n"): die "Funky $_"}@_}sub changes2 {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"<$2>","/$1",=>"</$2>"): die "Funky $_"}@_}sub go {Pod::Simple::HTML->parse_from_file(@ARGV);exit 0}sub new {my$new=shift->SUPER::new(@_);$new->nbsp_for_S(1);$new->accept_targets('html','HTML');$new->accept_codes('VerbatimFormatted');$new->accept_codes(@_to_accept);DEBUG > 2 and print STDERR "To accept: ",join(' ',@_to_accept),"\n";$new->perldoc_url_prefix($Perldoc_URL_Prefix);$new->perldoc_url_postfix($Perldoc_URL_Postfix);$new->man_url_prefix($Man_URL_Prefix);$new->man_url_postfix($Man_URL_Postfix);$new->title_prefix($Title_Prefix);$new->title_postfix($Title_Postfix);$new->html_header_before_title(qq[$Doctype_decl<html><head><title>]);$new->html_header_after_title(join "\n"=>"</title>",$Content_decl,"</head>\n<body class='pod'>",$new->version_tag_comment,"<!-- start doc -->\n",);$new->html_footer(qq[\n<!-- end doc -->\n\n</body></html>\n]);$new->top_anchor("<a name='___top' class='dummyTopAnchor' ></a>\n");$new->{'Tagmap'}={%Tagmap};return$new}sub __adjust_html_h_levels {my ($self)=@_;my$Tagmap=$self->{'Tagmap'};my$add=$self->html_h_level;return unless defined$add;return if ($self->{'Adjusted_html_h_levels'}||0)==$add;$add -= 1;for (1 .. 6){$Tagmap->{"head$_"}=~ s/$_/$_ + $add/e;$Tagmap->{"/head$_"}=~ s/$_/$_ + $add/e}}sub batch_mode_page_object_init {my($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;DEBUG and print STDERR "Initting $self\n  for $module\n","  in $infile\n  out $outfile\n  depth $depth\n";$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}sub do_beginning {my$self=$_[0];my$title;if(defined$self->force_title){$title=$self->force_title;DEBUG and print STDERR "Forcing title to be $title\n"}else {$title=$self->get_short_title();unless($self->content_seen){DEBUG and print STDERR "No content seen in search for title.\n";return}$self->{'Title'}=$title;if(defined$title and $title =~ m/\S/){$title=$self->title_prefix .esc($title).$self->title_postfix}else {$title=$self->default_title;$title='' unless defined$title;DEBUG and print STDERR "Title defaults to $title\n"}}my$after=$self->html_header_after_title || '';if($self->html_css){my$link=$self->html_css =~ m/</ ? $self->html_css : sprintf(qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],$self->html_css,);$after =~ s{(</head>)}{$link\n$1}i}$self->_add_top_anchor(\$after);if($self->html_javascript){my$link=$self->html_javascript =~ m/</ ? $self->html_javascript : sprintf(qq[<script type="text/javascript" src="%s"></script>\n],$self->html_javascript,);$after =~ s{(</head>)}{$link\n$1}i}print {$self->{'output_fh'}}$self->html_header_before_title || '',$title,$after,;DEBUG and print STDERR "Returning from do_beginning...\n";return 1}sub _add_top_anchor {my($self,$text_r)=@_;unless($$text_r and $$text_r =~ m/name=['"]___top['"]/){$$text_r .= $self->top_anchor || ''}return}sub version_tag_comment {my$self=shift;return sprintf "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",esc(ref($self),$self->VERSION(),$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime($ENV{SOURCE_DATE_EPOCH}|| time)),),$self->_modnote(),}sub _modnote {my$class=ref($_[0])|| $_[0];return join "\n   "=>grep m/\S/,split "\n",qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  }}sub do_end {my$self=$_[0];print {$self->{'output_fh'}}$self->html_footer || '';return 1}sub do_middle {my$self=$_[0];return$self->_do_middle_main_loop unless$self->index;if($self->output_string){my$out=$self->output_string;my$sneakytag="\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";$$out .= $sneakytag;$self->_do_middle_main_loop;$sneakytag=quotemeta($sneakytag);my$index=$self->index_as_html();if($$out =~ s/$sneakytag/$index/s){DEBUG and print STDERR "Inserted ",length($index)," bytes of index HTML into $out.\n"}else {DEBUG and print STDERR "Odd, couldn't find where to insert the index in the output!\n"}return 1}unless($self->output_fh){require Carp;Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.")}my$fh=$self->output_fh;my$content='';{$self->output_string(\$content);$self->_do_middle_main_loop;$self->abandon_output_string();$self->output_fh($fh)}print$fh $self->index_as_html();print$fh $content;return 1}sub index_as_html {my$self=$_[0];my$points=$self->{'PSHTML_index_points'}|| [];@$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];my(@out)=qq{\n<div class='indexgroup'>};my$level=0;my($target_level,$previous_tagname,$tagname,$text,$anchorname,$indent);for my$p (@$points,['head0','(end)']){($tagname,$text)=@$p;$anchorname=$self->section_escape($text);if($tagname =~ m{^head(\d+)$}){$target_level=0 + $1}else {if($previous_tagname =~ m{^head\d+$}){$target_level=$level + 1}else {$target_level=$level}}while($level > $target_level){--$level;push@out,("  " x $level)."</ul>"}while($level < $target_level){++$level;push@out,("  " x ($level-1))."<ul   class='indexList indexList$level'>"}$previous_tagname=$tagname;next unless$level;$indent='  ' x $level;push@out,sprintf "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",$indent,$level,esc($anchorname),esc($text)}push@out,"</div>\n";return join "\n",@out}sub _do_middle_main_loop {my$self=$_[0];my$fh=$self->{'output_fh'};my$tagmap=$self->{'Tagmap'};$self->__adjust_html_h_levels;my($token,$type,$tagname,$linkto,$linktype);my@stack;my$dont_wrap=0;while($token=$self->get_token){if(($type=$token->type)eq 'start'){if(($tagname=$token->tagname)eq 'L'){$linktype=$token->attr('type')|| 'insane';$linkto=$self->do_link($token);if(defined$linkto and length$linkto){esc($linkto);print$fh qq{<a href="$linkto" class="podlink$linktype"\n>}}else {print$fh "<a>"}}elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s){print$fh $tagmap->{$tagname}|| next;my@to_unget;while(1){push@to_unget,$self->get_token;last if$to_unget[-1]->is_end and $to_unget[-1]->tagname eq $tagname}my$name=$self->linearize_tokens(@to_unget);$name=$self->do_section($name,$token)if defined$name;print$fh "<a ";if ($tagname =~ m/^head\d$/s){print$fh "class='u'",$self->index ? " href='#___top' title='click to go to top of document'\n" : "\n"}if(defined$name){my$esc=esc($self->section_name_tidy($name));print$fh qq[name="$esc"];DEBUG and print STDERR "Linearized ",scalar(@to_unget)," tokens as \"$name\".\n";push @{$self->{'PSHTML_index_points'}},[$tagname,$name]if$ToIndex{$tagname }}else {DEBUG and print STDERR "Linearized ",scalar(@to_unget)," tokens, but it was too long, so nevermind.\n"}print$fh "\n>";$self->unget_token(@to_unget)}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print STDERR "    raw text ",$next->text,"\n";(my$text=$next->text)=~ s/\n\z//;print$fh $text,"\n";next}else {if($tagname =~ m/^over-/s){push@stack,''}elsif($tagname =~ m/^item-/s and @stack and $stack[-1]){print$fh $stack[-1];$stack[-1]=''}print$fh $tagmap->{$tagname}|| next;++$dont_wrap if$tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted" or $tagname eq 'X'}}elsif($type eq 'end'){if(($tagname=$token->tagname)=~ m/^over-/s){if(my$end=pop@stack){print$fh $end}}elsif($tagname =~ m/^item-/s and @stack){$stack[-1]=$tagmap->{"/$tagname"};if($tagname eq 'item-text' and defined(my$next=$self->get_token)){$self->unget_token($next);if($next->type eq 'start'){print$fh $tagmap->{"/item-text"},$tagmap->{"item-body"};$stack[-1]=$tagmap->{"/item-body"}}}next}print$fh $tagmap->{"/$tagname"}|| next;--$dont_wrap if$tagname eq 'Verbatim' or $tagname eq 'X'}elsif($type eq 'text'){esc($type=$token->text);$type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless$dont_wrap;print$fh $type}}return 1}sub do_section {my($self,$name,$token)=@_;return$name}sub do_link {my($self,$token)=@_;my$type=$token->attr('type');if(!defined$type){$self->whine("Typeless L!?",$token->attr('start_line'))}elsif($type eq 'pod'){return$self->do_pod_link($token)}elsif($type eq 'url'){return$self->do_url_link($token)}elsif($type eq 'man'){return$self->do_man_link($token)}else {$self->whine("L of unknown type $type!?",$token->attr('start_line'))}return 'FNORG'}sub do_url_link {return $_[1]->attr('to')}sub do_man_link {my ($self,$link)=@_;my$to=$link->attr('to');my$frag=$link->attr('section');return undef unless defined$to and length$to;$frag=$self->section_escape($frag)if defined$frag and length($frag .= '');DEBUG and print STDERR "Resolving \"$to/$frag\"\n\n";return$self->resolve_man_page_link($to,$frag)}sub do_pod_link {my($self,$link)=@_;my$to=$link->attr('to');my$section=$link->attr('section');return undef unless((defined$to and length$to)or (defined$section and length$section));$section=$self->section_escape($section)if defined$section and length($section .= '');DEBUG and printf STDERR "Resolving \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";{my$complete_url=$self->resolve_pod_link_by_table($to,$section);if($complete_url){DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T,S) gives ",$complete_url,"\n  (Returning that.)\n";return$complete_url}else {DEBUG > 4 and print STDERR " resolve_pod_link_by_table(T,S)"," didn't return anything interesting.\n"}}if(defined$to and length$to){my$there=$self->resolve_pod_link_by_table($to);if(defined$there and length$there){DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T) gives $there\n"}else {$there=$self->resolve_pod_page_link($to,$section);DEBUG > 1 and print STDERR "resolve_pod_page_link gives ",$there || "(nil)","\n";unless(defined$there and length$there){DEBUG and print STDERR "Can't resolve $to\n";return undef}}$to=$there}my$out=(defined$to and length$to)? $to : '';$out .= "#" .$section if defined$section and length$section;unless(length$out){DEBUG and printf STDERR "Oddly, couldn't resolve \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";return undef}DEBUG and print STDERR "Resolved to $out\n";return$out}sub section_escape {my($self,$section)=@_;return$self->section_url_escape($self->section_name_tidy($section))}sub section_name_tidy {my($self,$section)=@_;$section =~ s/^\s+//;$section =~ s/\s+$//;$section =~ tr/ /_/;if ($] ge 5.006){$section =~ s/[[:cntrl:][:^ascii:]]//g}elsif ('A' eq chr(65)){$section =~ tr/\x00-\x1F\x80-\x9F//d}$section=$self->unicode_escape_url($section);$section='_' unless length$section;return$section}sub section_url_escape {shift->general_url_escape(@_)}sub pagepath_url_escape {shift->general_url_escape(@_)}sub manpage_url_escape {shift->general_url_escape(@_)}sub general_url_escape {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;if ($] ge 5.007_003){$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',utf8::native_to_unicode(ord($1)))/eg}else {$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg}return$string}sub resolve_pod_page_link {my$self=shift;return$self->batch_mode()? $self->resolve_pod_page_link_batch_mode(@_): $self->resolve_pod_page_link_singleton_mode(@_)}sub resolve_pod_page_link_singleton_mode {my($self,$it)=@_;return undef unless defined$it and length$it;my$url=$self->pagepath_url_escape($it);$url =~ s{::$}{}s;$url =~ s{::}{/}g unless$self->perldoc_url_prefix =~ m/\?/s;return undef unless length$url;return$self->perldoc_url_prefix .$url .$self->perldoc_url_postfix}sub resolve_pod_page_link_batch_mode {my($self,$to)=@_;DEBUG > 1 and print STDERR " During batch mode, resolving $to ...\n";my@path=grep length($_),split m/::/s,$to,-1;unless(@path){DEBUG and print STDERR "Very odd!  Splitting $to gives (nil)!\n";return undef}$self->batch_mode_rectify_path(\@path);my$out=join('/',map$self->pagepath_url_escape($_),@path).$HTML_EXTENSION;DEBUG > 1 and print STDERR " => $out\n";return$out}sub batch_mode_rectify_path {my($self,$pathbits)=@_;my$level=$self->batch_mode_current_level;$level--;if($level < 1){unshift @$pathbits,'.'}else {unshift @$pathbits,('..')x $level}return}sub resolve_man_page_link {my ($self,$to,$frag)=@_;my ($page,$section)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless defined$page and length$page;$section ||= 1;return$self->man_url_prefix ."$section/" .$self->manpage_url_escape($page).$self->man_url_postfix}sub resolve_pod_link_by_table {return unless $_[0]->{'podhtml_LOT'};my($self,$to,$section)=@_;if(defined$section){$to='' unless defined$to and length$to;return$self->{'podhtml_LOT'}{"$to#$section"}}else {return$self->{'podhtml_LOT'}{$to}}return}sub linearize_tokens {my$self=shift;my$out='';my$t;while($t=shift @_){if(!ref$t or!UNIVERSAL::can($t,'is_text')){$out .= $t}elsif($t->is_text){$out .= $t->text}elsif($t->is_start and $t->tag eq 'X'){my$x_open=1;while($x_open){next if(($t=shift @_)->is_text);if($t->is_start and $t->tag eq 'X'){++$x_open}elsif($t->is_end and $t->tag eq 'X'){--$x_open}}}}return undef if length$out > $Linearization_Limit;return$out}sub unicode_escape_url {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;return$string}sub esc {if(defined wantarray){if(wantarray){@_=splice @_}else {my$x=shift;if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}return$x}}for my$x (@_){if (defined$x){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}}return @_}1;
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  require 5;package Pod::Simple::HTMLBatch;use strict;use vars qw($VERSION $HTML_RENDER_CLASS $HTML_EXTENSION $CSS $JAVASCRIPT $SLEEPY $SEARCH_CLASS @ISA);$VERSION='3.42';@ISA=();use Pod::Simple::HTML ();BEGIN {*esc=\&Pod::Simple::HTML::esc}use File::Spec ();use Pod::Simple::Search;$SEARCH_CLASS ||= 'Pod::Simple::Search';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$HTML_RENDER_CLASS ||= "Pod::Simple::HTML";Pod::Simple::_accessorize(__PACKAGE__,'verbose','html_render_class','search_class','contents_file','index','progress','contents_page_start','contents_page_end','css_flurry','_css_wad','javascript_flurry','_javascript_wad','no_contents_links','_contents',);sub go {@ARGV==2 or die sprintf("Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",__PACKAGE__,__PACKAGE__,);if(defined($ARGV[1])and length($ARGV[1])){my$d=$ARGV[1];-e $d or die "I see no output directory named \"$d\"\nAborting";-d $d or die "But \"$d\" isn't a directory!\nAborting";-w $d or die "Directory \"$d\" isn't writeable!\nAborting"}__PACKAGE__->batch_convert(@ARGV)}sub new {my$new=bless {},ref($_[0])|| $_[0];$new->html_render_class($HTML_RENDER_CLASS);$new->search_class($SEARCH_CLASS);$new->verbose(1 + DEBUG);$new->_contents([]);$new->index(1);$new-> _css_wad([]);$new->css_flurry(1);$new->_javascript_wad([]);$new->javascript_flurry(1);$new->contents_file('index' .($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION));$new->contents_page_start(join "\n",grep $_,$Pod::Simple::HTML::Doctype_decl,"<html><head>","<title>Perl Documentation</title>",$Pod::Simple::HTML::Content_decl,"</head>","\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n");$new->contents_page_end(sprintf("\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT.</p>\n\n</body></html>\n",esc(ref($new),eval {$new->VERSION}|| $VERSION,$],scalar(gmtime($ENV{SOURCE_DATE_EPOCH}|| time)),)));return$new}sub muse {my$self=shift;if($self->verbose){print 'T+',int(time()- $self->{'_batch_start_time'}),"s: ",@_,"\n"}return 1}sub batch_convert {my($self,$dirs,$outdir)=@_;$self ||= __PACKAGE__;$self=$self->new unless ref$self;if(!defined($dirs)or $dirs eq '' or $dirs eq '@INC'){$dirs=''}elsif(ref$dirs){}else {require Config;my$ps=quotemeta($Config::Config{'path_sep'}|| ":");$dirs=[grep length($_),split qr/$ps/,$dirs ]}$outdir=$self->filespecsys->curdir unless defined$outdir and length$outdir;$self->_batch_convert_main($dirs,$outdir)}sub _batch_convert_main {my($self,$dirs,$outdir)=@_;$self->{'_batch_start_time'}||= time();$self->muse("= ",scalar(localtime));$self->muse("Starting batch conversion to \"$outdir\"");my$progress=$self->progress;if(!$progress and $self->verbose > 0 and $self->verbose()<= 5){require Pod::Simple::Progress;$progress=Pod::Simple::Progress->new(($self->verbose < 2)? (): ($self->verbose==2)? 1 : 0);$self->progress($progress)}if($dirs){$self->muse(scalar(@$dirs)," dirs to scan: @$dirs")}else {$self->muse("Scanning \@INC.  This could take a minute or two.")}my$mod2path=$self->find_all_pods($dirs ? $dirs : ());$self->muse("Done scanning.");my$total=keys %$mod2path;unless($total){$self->muse("No pod found.  Aborting batch conversion.\n");return$self}$progress and $progress->goal($total);$self->muse("Now converting pod files to HTML.",($total > 25)? "  This will take a while more." : ());$self->_spray_css($outdir);$self->_spray_javascript($outdir);$self->_do_all_batch_conversions($mod2path,$outdir);$progress and $progress->done(sprintf ("Done converting %d files.",$self->{"__batch_conv_page_count"}));return$self->_batch_convert_finish($outdir);return$self}sub _do_all_batch_conversions {my($self,$mod2path,$outdir)=@_;$self->{"__batch_conv_page_count"}=0;for my$module (sort {lc($a)cmp lc($b)}keys %$mod2path){$self->_do_one_batch_conversion($module,$mod2path,$outdir);sleep($SLEEPY - 1)if$SLEEPY}return}sub _batch_convert_finish {my($self,$outdir)=@_;$self->write_contents_file($outdir);$self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");$self->muse("= ",scalar(localtime));$self->progress and $self->progress->done("All done!");return}sub _do_one_batch_conversion {my($self,$module,$mod2path,$outdir,$outfile)=@_;my$retval;my$total=scalar keys %$mod2path;my$infile=$mod2path->{$module};my@namelets=grep m/\S/,split "::",$module;my$depth=scalar@namelets;die "Contentless thingie?! $module $infile" unless@namelets;$outfile ||= do {my@n=@namelets;$n[-1].= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;$self->filespecsys->catfile($outdir,@n)};my$progress=$self->progress;my$page=$self->html_render_class->new;if(DEBUG > 5){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: ",ref($page)," render ($depth) $module => $outfile")}elsif(DEBUG > 2){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: $module => $outfile")}$page->batch_mode_page_object_init($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_init');$self->batch_mode_page_object_init($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_init');$self->makepath($outdir=>\@namelets);$progress and $progress->reach($self->{"__batch_conv_page_count"},"Rendering $module");if($retval=$page->parse_from_file($infile,$outfile)){++ $self->{"__batch_conv_page_count"};$self->note_for_contents_file(\@namelets,$infile,$outfile)}else {$self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.")}$page->batch_mode_page_object_kill($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_kill');$self->batch_mode_page_object_kill($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_kill');DEBUG > 4 and printf STDERR "%s %sb < $infile %s %sb\n",$outfile,-s $outfile,$infile,-s $infile ;undef($page);return$retval}sub filespecsys {$_[0]{'_filespecsys'}|| 'File::Spec'}sub note_for_contents_file {my($self,$namelets,$infile,$outfile)=@_;if($self->contents_file){my$c=$self->_contents();push @$c,[join("::",@$namelets),$infile,$outfile,$namelets ];DEBUG > 3 and print STDERR "Noting @$c[-1]\n"}return}sub write_contents_file {my($self,$outdir)=@_;my$outfile=$self->_contents_filespec($outdir)|| return;$self->muse("Preparing list of modules for ToC");my($toplevel,$toplevel_form_freq,)=$self->_prep_contents_breakdown;my$Contents=eval {$self->_wopen($outfile)};if($Contents){$self->muse("Writing contents file $outfile")}else {warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";return}$self->_write_contents_start($Contents,$outfile,);$self->_write_contents_middle($Contents,$outfile,$toplevel,$toplevel_form_freq);$self->_write_contents_end($Contents,$outfile,);return$outfile}sub _write_contents_start {my($self,$Contents,$outfile)=@_;my$starter=$self->contents_page_start || '';{my$css_wad=$self->_css_wad_to_markup(1);if($css_wad){$starter =~ s{(</head>)}{\n$css_wad\n$1}i}my$javascript_wad=$self->_javascript_wad_to_markup(1);if($javascript_wad){$starter =~ s{(</head>)}{\n$javascript_wad\n$1}i}}unless(print$Contents $starter,"<dl class='superindex'>\n"){warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Contents);return 0}return 1}sub _write_contents_middle {my($self,$Contents,$outfile,$toplevel2submodules,$toplevel_form_freq)=@_;for my$t (sort keys %$toplevel2submodules){my@downlines=sort {$a->[-1]cmp $b->[-1]}@{$toplevel2submodules->{$t}};printf$Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],esc($t,$toplevel_form_freq->{$t});my($path,$name);for my$e (@downlines){$name=$e->[0];$path=join("/",'.',esc(@{$e->[3]})).($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);print$Contents qq{  <a href="$path">},esc($name),"</a>&nbsp;&nbsp;\n"}print$Contents "</dd>\n\n"}return 1}sub _write_contents_end {my($self,$Contents,$outfile)=@_;unless(print$Contents "</dl>\n",$self->contents_page_end || '',){warn "Couldn't write to $outfile: $!"}close($Contents)or warn "Couldn't close $outfile: $!";return 1}sub _prep_contents_breakdown {my($self)=@_;my$contents=$self->_contents;my%toplevel;my%toplevel_form_freq;for my$entry (@$contents){my$toplevel=$entry->[0]=~ m/^perl\w*$/ ? 'perl_core_docs' : $entry->[3][0];++$toplevel_form_freq{lc$toplevel }{$toplevel };push @{$toplevel{lc$toplevel }},$entry;push @$entry,lc($entry->[0])}for my$toplevel (sort keys%toplevel){my$fgroup=$toplevel_form_freq{$toplevel};$toplevel_form_freq{$toplevel}=(sort {$fgroup->{$b}<=> $fgroup->{$a}or $a cmp $b}keys %$fgroup)[0]}return(\%toplevel,\%toplevel_form_freq)if wantarray;return \%toplevel}sub _contents_filespec {my($self,$outdir)=@_;my$outfile=$self->contents_file;return unless$outfile;return$self->filespecsys->catfile($outdir,$outfile)}sub makepath {my($self,$outdir,$namelets)=@_;return unless @$namelets > 1;for my$i (0 .. ($#$namelets - 1)){my$dir=$self->filespecsys->catdir($outdir,@$namelets[0 .. $i]);if(-e $dir){die "$dir exists but not as a directory!?" unless -d $dir;next}DEBUG > 3 and print STDERR "  Making $dir\n";mkdir$dir,0777 or die "Can't mkdir $dir: $!\nAborting" }return}sub batch_mode_page_object_init {my$self=shift;my($page,$module,$infile,$outfile,$depth)=@_;$page->default_title($module);$page->index($self->index);$page->html_css($self-> _css_wad_to_markup($depth));$page->html_javascript($self->_javascript_wad_to_markup($depth));$self->add_header_backlink($page,$module,$infile,$outfile,$depth);$self->add_footer_backlink($page,$module,$infile,$outfile,$depth);return$self}sub add_header_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_header_after_title(join '',$page->html_header_after_title || '',qq[<p class="backlinktop"><b><a name="___top" href="],$self->url_up_to_contents($depth),qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],)if$self->contents_file ;return}sub add_footer_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_footer(join '',qq[<p class="backlinkbottom"><b><a name="___bottom" href="],$self->url_up_to_contents($depth),qq[" title="All Documents">&lt;&lt;</a></b></p>\n],$page->html_footer || '',)if$self->contents_file ;return}sub url_up_to_contents {my($self,$depth)=@_;--$depth;return join '/',('..')x $depth,esc($self->contents_file)}sub find_all_pods {my($self,$dirs)=@_;return$self->modnames2paths($dirs)}sub modnames2paths {my($self,$dirs)=@_;my$m2p;{my$search=$self->search_class->new;DEBUG and print STDERR "Searching via $search\n";$search->verbose(1)if DEBUG > 10;$search->progress($self->progress->copy->goal(0))if$self->progress;$search->shadows(0);$search->inc($dirs ? 0 : 1);$search->survey($dirs ? @$dirs : ());$m2p=$search->name2path;die "What, no name2path?!" unless$m2p}$self->muse("That's odd... no modules found!")unless keys %$m2p;if(DEBUG > 4){print STDERR "Modules found (name => path):\n";for my$m (sort {lc($a)cmp lc($b)}keys %$m2p){print STDERR "  $m  $$m2p{$m}\n"}print STDERR "(total ",scalar(keys %$m2p),")\n\n"}elsif(DEBUG){print STDERR "Found ",scalar(keys %$m2p)," modules.\n"}$self->muse("Found ",scalar(keys %$m2p)," modules.");return$m2p}sub _wopen {my($self,$outpath)=@_;require Symbol;my$out_fh=Symbol::gensym();DEBUG > 5 and print STDERR "Write-opening to $outpath\n";return$out_fh if open($out_fh,"> $outpath");require Carp;Carp::croak("Can't write-open $outpath: $!")}sub add_css {my($self,$url,$is_default,$name,$content_type,$media,$_code)=@_;return unless$url;unless($name){$name=$url;if($name !~ m/\?/ and $name =~ m{([^/]+)$}s){$name=$1;$name =~ s/\.css//i}}$media ||= 'all';$content_type ||= 'text/css';my$bunch=[$url,$name,$content_type,$media,$_code];if($is_default){unshift @{$self->_css_wad},$bunch}else {push @{$self->_css_wad},$bunch}return}sub _spray_css {my($self,$outdir)=@_;return unless$self->css_flurry();$self->_gen_css_wad();my$lol=$self->_css_wad;for my$chunk (@$lol){my$url=$chunk->[0];my$outfile;if(ref($chunk->[-1])and $url =~ m{^(_[-a-z0-9_]+\.css$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print STDERR "Noting $$chunk[0] as a file I'll create.\n"}else {DEBUG > 5 and print STDERR "OK, noting $$chunk[0] as an external CSS.\n";next}my$Cssout=$self->_wopen($outfile);print$Cssout ${$chunk->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Cssout);DEBUG > 5 and print STDERR "Wrote $outfile\n"}return}sub _css_wad_to_markup {my($self,$depth)=@_;my@css=@{$self->_css_wad || return ''};return '' unless@css;my$rel='stylesheet';my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$chunk (@css){next unless$chunk and @$chunk;my($url1,$url2,$title,$type,$media)=($self->_maybe_uplink($chunk->[0],$uplink),esc(grep!ref($_),@$chunk));$out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};$rel='alternate stylesheet'}return$out}sub _maybe_uplink {my($self,$url,$uplink)=@_;($url =~ m{^\./} or $url !~ m{[/\:]})? $uplink : ''}sub _gen_css_wad {my$self=$_[0];my$css_template=$self->_css_template;for my$variation ('110n=blkbluw','010n=blkmagw','100n=blkcynw','101=whtprpk','001=whtnavk','010a=grygrnk','010b=whtgrng','101an=blkgrng','101bn=grygrnw',){my$outname=$variation;my($flipmode,@swap)=(($4 || ''),$1,$2,$3)if$outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;@swap=()if '010' eq join '',@swap;my$this_css="/* This file is autogenerated.  Do not edit.  $variation */\n\n" .$css_template;if($flipmode =~ m/n/){$this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;$this_css =~ s/\bthin\b/medium/g}$this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg if@swap;if($flipmode =~ m/a/){$this_css =~ s/#fff\b/#999/gi}elsif($flipmode =~ m/b/){$this_css =~ s/#000\b/#666/gi}my$name=$outname;$name =~ tr/-_/  /;$self->add_css("_$outname.css",0,$name,0,0,\$this_css)}for (my ($outfile,$variation)=each %{{blkbluw=>'black_with_blue_on_white',whtpurk=>'white_with_purple_on_black',whtgrng=>'white_with_green_on_grey',grygrnw=>'grey_with_green_on_white',}}){my$this_css=join "\n","/* This file is autogenerated.  Do not edit.  $outfile */\n","\@import url(\"./_$variation.css\");",".indexgroup { display: none; }","\n",;my$name=$outfile;$name =~ tr/-_/  /;$self->add_css("_$outfile.css",0,$name,0,0,\$this_css)}return}sub _color_negate {my$x=lc $_[0];$x =~ tr[0123456789abcdef]
            [fedcba9876543210];return$x}sub add_javascript {my($self,$url,$content_type,$_code)=@_;return unless$url;push @{$self->_javascript_wad},[$url,$content_type || 'text/javascript',$_code ];return}sub _spray_javascript {my($self,$outdir)=@_;return unless$self->javascript_flurry();$self->_gen_javascript_wad();my$lol=$self->_javascript_wad;for my$script (@$lol){my$url=$script->[0];my$outfile;if(ref($script->[-1])and $url =~ m{^(_[-a-z0-9_]+\.js$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print STDERR "Noting $$script[0] as a file I'll create.\n"}else {DEBUG > 5 and print STDERR "OK, noting $$script[0] as an external JavaScript.\n";next}my$Jsout=$self->_wopen($outfile);print$Jsout ${$script->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Jsout);DEBUG > 5 and print STDERR "Wrote $outfile\n"}return}sub _gen_javascript_wad {my$self=$_[0];my$js_code=$self->_javascript || return;$self->add_javascript("_podly.js",0,\$js_code);return}sub _javascript_wad_to_markup {my($self,$depth)=@_;my@scripts=@{$self->_javascript_wad || return ''};return '' unless@scripts;my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$s (@scripts){next unless$s and @$s;my($url1,$url2,$type,$media)=($self->_maybe_uplink($s->[0],$uplink),esc(grep!ref($_),@$s));$out .= qq{<script type="$type" src="$url1$url2"></script>\n}}return$out}sub _css_template {return$CSS}sub _javascript {return$JAVASCRIPT}$CSS=<<'EOCSS';$JAVASCRIPT=<<'EOJAVASCRIPT';1;
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3,
    body.pod h4, body.pod h5, body.pod h6  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
    
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
    body.pod h5  { border-top-color: #010; }
    body.pod h6  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h5 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h6 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
    
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
    
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
    
  }
  
  /* The End */
  
  EOCSS
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  require 5;package Pod::Simple::HTMLLegacy;use strict;use vars qw($VERSION);use Getopt::Long;$VERSION="5.01";sub pod2html {my@args=(@_);my($verbose,$infile,$outfile,$title);my$index=1;{my($help);my($netscape);local@ARGV=@args;GetOptions("help"=>\$help,"verbose!"=>\$verbose,"infile=s"=>\$infile,"outfile=s"=>\$outfile,"title=s"=>\$title,"index!"=>\$index,"netscape!"=>\$netscape,)or return bad_opts(@args);bad_opts(@args)if@ARGV;return help_message()if$help}for($infile,$outfile){$_=undef unless defined and length}if($verbose){warn sprintf "%s version %s\n",__PACKAGE__,$VERSION;warn "OK, processed args [@args] ...\n";warn sprintf " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",map defined($_)? $_ : "(nil)",$verbose,$index,$infile,$outfile,$title,;*Pod::Simple::HTML::DEBUG=sub(){1}}require Pod::Simple::HTML;Pod::Simple::HTML->VERSION(3);die "No such input file as $infile\n" if defined$infile and!-e $infile;my$pod=Pod::Simple::HTML->new;$pod->force_title($title)if defined$title;$pod->index($index);return$pod->parse_from_file($infile,$outfile)}sub bad_opts {die _help_message()}sub help_message {print STDOUT _help_message()}sub _help_message {join '',"[",__PACKAGE__," version ",$VERSION,qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~}1;
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/JustPod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_JUSTPOD';
  use 5;package Pod::Simple::JustPod;use strict;use warnings;use Pod::Simple::Methody ();our@ISA=('Pod::Simple::Methody');sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->accept_targets('*');$new->keep_encoding_directive(1);$new->preserve_whitespace(1);$new->complain_stderr(1);$new->_output_is_for_JustPod(1);return$new}sub check_that_all_is_closed {my$self=shift;while ($self->{inL}){$self->end_L(@_)}while ($self->{fcode_end}&& @{$self->{fcode_end}}){$self->_end_fcode(@_)}}sub handle_text {$_[0]{buffer}.= $_[1]unless $_[0]{inL}}sub spacer {my ($self,$arg)=@_;return unless$arg;my$spacer=($arg->{'~orig_spacer'})? $arg->{'~orig_spacer'}: " ";$self->handle_text($spacer)}sub _generic_start {my ($self,$text,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text($text);$self->spacer($arg)}sub start_Document {shift->_generic_start("=pod\n\n")}sub start_head1 {shift->_generic_start('=head1',@_)}sub start_head2 {shift->_generic_start('=head2',@_)}sub start_head3 {shift->_generic_start('=head3',@_)}sub start_head4 {shift->_generic_start('=head4',@_)}sub start_head5 {shift->_generic_start('=head5',@_)}sub start_head6 {shift->_generic_start('=head6',@_)}sub start_encoding {shift->_generic_start('=encoding',@_)}sub start_item_bullet {my ($self,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text('=item');if (!$arg->{'~orig_content'}){$self->handle_text("\n\n")}else {$self->spacer($arg);if ($arg->{'~_freaky_para_hack'}){my$item_text=$arg->{'~orig_content'};my$trailing=quotemeta$arg->{'~_freaky_para_hack'};$item_text =~ s/$trailing$//;$self->handle_text($item_text)}else {$self->handle_text("*\n\n")}}}sub start_item_number {my ($self,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text("=item");$self->spacer($arg);$self->handle_text("$arg->{'~orig_content'}\n\n")}sub start_item_text {my ($self,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text('=item');$self->spacer($arg)}sub _end_item {my$self=shift;$self->check_that_all_is_closed();$self->emit}*end_item_bullet=*_end_item;*end_item_number=*_end_item;*end_item_text=*_end_item;sub _start_over {my ($self,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text("=over");if ($arg->{'~orig_content'}){$self->spacer($arg);$self->handle_text("$arg->{'~orig_content'}")}$self->handle_text("\n\n")}*start_over_bullet=*_start_over;*start_over_number=*_start_over;*start_over_text=*_start_over;*start_over_block=*_start_over;sub _end_over {my$self=shift;$self->check_that_all_is_closed();$self->handle_text('=back');$self->emit}*end_over_bullet=*_end_over;*end_over_number=*_end_over;*end_over_text=*_end_over;*end_over_block=*_end_over;sub end_Document {my$self=shift;$self->emit;print {$self->{'output_fh'}}"=cut\n"}sub _end_generic {my$self=shift;$self->check_that_all_is_closed();$self->emit}*end_head1=*_end_generic;*end_head2=*_end_generic;*end_head3=*_end_generic;*end_head4=*_end_generic;*end_head5=*_end_generic;*end_head6=*_end_generic;*end_encoding=*_end_generic;*end_Para=*_end_generic;*end_Verbatim=*_end_generic;sub _start_fcode {my ($type,$self,$flags)=@_;my$bracket_count=(exists$flags->{'~bracket_count'})? $flags->{'~bracket_count'}: 1;$self->handle_text($type .("<" x $bracket_count));my$rspacer="";if ($bracket_count > 1){my$lspacer=(exists$flags->{'~lspacer'})? $flags->{'~lspacer'}: " ";$self->handle_text($lspacer);$rspacer=(exists$flags->{'~rspacer'})? $flags->{'~rspacer'}: " "}push @{$self->{'fcode_end'}},[$bracket_count,$rspacer ]}sub start_B {_start_fcode('B',@_)}sub start_C {_start_fcode('C',@_)}sub start_E {_start_fcode('E',@_)}sub start_F {_start_fcode('F',@_)}sub start_I {_start_fcode('I',@_)}sub start_S {_start_fcode('S',@_)}sub start_X {_start_fcode('X',@_)}sub start_Z {_start_fcode('Z',@_)}sub _end_fcode {my$self=shift;my$fcode_end=pop @{$self->{'fcode_end'}};my$bracket_count=1;my$rspacer="";if (!defined$fcode_end){$self->whine($self->{line_count},"Extra '>'")}else {$bracket_count=$fcode_end->[0];$rspacer=$fcode_end->[1]}$self->handle_text($rspacer)if$bracket_count > 1;$self->handle_text(">" x $bracket_count)}*end_B=*_end_fcode;*end_C=*_end_fcode;*end_E=*_end_fcode;*end_F=*_end_fcode;*end_I=*_end_fcode;*end_S=*_end_fcode;*end_X=*_end_fcode;*end_Z=*_end_fcode;sub start_L {_start_fcode('L',@_);$_[0]->handle_text($_[1]->{raw});$_[0]->{inL}++}sub end_L {my$self=shift;$self->{inL}--;if ($self->{inL}< 0){$self->whine($self->{line_count},"Extra '>' ending L<>");$self->{inL}=0}$self->_end_fcode(@_)}sub emit {my$self=shift;if ($self->{buffer}ne ""){print {$self->{'output_fh'}}"",$self->{buffer},"\n\n";$self->{buffer}=""}return}1;
POD_SIMPLE_JUSTPOD

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  require 5;package Pod::Simple::LinkSection;use strict;use Pod::Simple::BlackBox;use vars qw($VERSION);$VERSION='3.42';use overload('""'=>\&Pod::Simple::BlackBox::stringify_lol,'bool'=>\&Pod::Simple::BlackBox::stringify_lol,'fallback'=>1,);sub tack_on {$_[0]=['',{},"$_[0]" ];return $_[0][2].= $_[1]}sub as_string {goto&Pod::Simple::BlackBox::stringify_lol}sub stringify {goto&Pod::Simple::BlackBox::stringify_lol}sub new {my$class=shift;$class=ref($class)|| $class;my$new;if(@_==1){if (!ref($_[0]|| '')){return bless ['',{},$_[0]],$class}elsif(ref($_[0]|| '')eq 'ARRAY'){$new=[@{$_[0]}]}else {Carp::croak("$class new() doesn't know to clone $new")}}else {$new=['',{},@_ ]}for my$x (@$new){if(ref($x || '')eq 'ARRAY'){$x=$class->new($x)}elsif(ref($x || '')eq 'HASH'){$x={%$x }}}return bless$new,$class}1;
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  require 5;package Pod::Simple::Methody;use strict;use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.42';@ISA=('Pod::Simple');sub _handle_element_start {$_[1]=~ tr/-:./__/;($_[0]->can('start_' .$_[1])|| return)->($_[0],$_[2])}sub _handle_text {($_[0]->can('handle_text')|| return)->(@_)}sub _handle_element_end {$_[1]=~ tr/-:./__/;($_[0]->can('end_' .$_[1])|| return)->($_[0],$_[2])}1;
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  require 5;package Pod::Simple::Progress;$VERSION='3.42';use strict;sub new {my($class,$delay)=@_;my$self=bless {'quiet_until'=>1},ref($class)|| $class;$self->to(*STDOUT{IO});$self->delay(defined($delay)? $delay : 5);return$self}sub copy {my$orig=shift;bless {%$orig,'quiet_until'=>1},ref($orig)}sub reach {my($self,$point,$note)=@_;if((my$now=time)>= $self->{'quiet_until'}){my$goal;my$to=$self->{'to'};print$to join('',($self->{'quiet_until'}==1)? (): '... ',(defined$point)? ('#',($goal=$self->{'goal'})? (' ' x (length($goal)- length($point)),$point,'/',$goal,): $point,$note ? ': ' : (),): (),$note || '',"\n");$self->{'quiet_until'}=$now + $self->{'delay'}}return$self}sub done {my($self,$note)=@_;$self->{'quiet_until'}=1;return$self->reach(undef,$note)}sub delay {return $_[0]{'delay'}if @_==1;$_[0]{'delay'}=$_[1];return $_[0]}sub goal {return $_[0]{'goal' }if @_==1;$_[0]{'goal' }=$_[1];return $_[0]}sub to {return $_[0]{'to' }if @_==1;$_[0]{'to' }=$_[1];return $_[0]}unless(caller){my$p=__PACKAGE__->new->goal(5);$p->reach(1,"Primus!");sleep 1;$p->reach(2,"Secundus!");sleep 3;$p->reach(3,"Tertius!");sleep 5;$p->reach(4);$p->reach(5,"Quintus!");sleep 1;$p->done("All done")}1;
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  require 5;package Pod::Simple::PullParser;$VERSION='3.42';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserTextToken;BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('source_fh','source_scalar_ref','source_arrayref',);sub filter {my($self,$source)=@_;$self=$self->new unless ref$self;$source=*STDIN{IO}unless defined$source;$self->set_source($source);$self->output_fh(*STDOUT{IO});$self->run;return$self}sub parse_string_document {my$this=shift;$this->set_source(\ $_[0]);$this->run}sub parse_file {my($this,$filename)=@_;$this->set_source($filename);$this->run}sub run {use Carp ();if(__PACKAGE__ eq ref($_[0])|| $_[0]){Carp::croak "You can call run() only on subclasses of " .__PACKAGE__}else {Carp::croak join '',"You can't call run() because ",ref($_[0])|| $_[0]," didn't define a run() method"}}sub parse_lines {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_lines"}sub parse_line {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_line"}sub new {my$class=shift;my$self=$class->SUPER::new(@_);die "Couldn't construct for $class" unless$self;$self->{'token_buffer'}||= [];$self->{'start_token_class'}||= 'Pod::Simple::PullParserStartToken';$self->{'text_token_class'}||= 'Pod::Simple::PullParserTextToken';$self->{'end_token_class'}||= 'Pod::Simple::PullParserEndToken';DEBUG > 1 and print STDERR "New pullparser object: $self\n";return$self}sub get_token {my$self=shift;DEBUG > 1 and print STDERR "\nget_token starting up on $self.\n";DEBUG > 2 and print STDERR " Items in token-buffer (",scalar(@{$self->{'token_buffer'}}),") :\n",map("    " .$_->dump ."\n",@{$self->{'token_buffer'}}),@{$self->{'token_buffer'}}? '' : '       (no tokens)',"\n" ;until(@{$self->{'token_buffer'}}){DEBUG > 3 and print STDERR "I need to get something into my empty token buffer...\n";if($self->{'source_dead'}){DEBUG and print STDERR "$self 's source is dead.\n";push @{$self->{'token_buffer'}},undef}elsif(exists$self->{'source_fh'}){my@lines;my$fh=$self->{'source_fh'}|| Carp::croak('You have to call set_source before you can call get_token');DEBUG and print STDERR "$self 's source is filehandle $fh.\n";for(my$i=Pod::Simple::MANY_LINES;$i--;){DEBUG > 3 and print STDERR " Fetching a line from source filehandle $fh...\n";local $/=$Pod::Simple::NL;push@lines,scalar(<$fh>);DEBUG > 3 and print STDERR "  Line is: ",defined($lines[-1])? $lines[-1]: "<undef>\n";unless(defined$lines[-1]){DEBUG and print STDERR "That's it for that source fh!  Killing.\n";delete$self->{'source_fh'};last}}if(DEBUG > 8){print STDERR "* I've gotten ",scalar(@lines)," lines:\n";for my$l (@lines){if(defined$l){print STDERR "  line {$l}\n"}else {print STDERR "  line undef\n"}}print STDERR "* end of ",scalar(@lines)," lines\n"}$self->SUPER::parse_lines(@lines)}elsif(exists$self->{'source_arrayref'}){DEBUG and print STDERR "$self 's source is arrayref $self->{'source_arrayref'}, with ",scalar(@{$self->{'source_arrayref'}})," items left in it.\n";DEBUG > 3 and print STDERR "  Fetching ",Pod::Simple::MANY_LINES," lines.\n";$self->SUPER::parse_lines(splice @{$self->{'source_arrayref'}},0,Pod::Simple::MANY_LINES);unless(@{$self->{'source_arrayref'}}){DEBUG and print STDERR "That's it for that source arrayref!  Killing.\n";$self->SUPER::parse_lines(undef);delete$self->{'source_arrayref'}}}elsif(exists$self->{'source_scalar_ref'}){DEBUG and print STDERR "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",length(${$self->{'source_scalar_ref'}})- (pos(${$self->{'source_scalar_ref'}})|| 0)," characters left to parse.\n";DEBUG > 3 and print STDERR " Fetching a line from source-string...\n";if(${$self->{'source_scalar_ref'}}=~ m/([^\n\r]*)((?:\r?\n)?)/g){$self->SUPER::parse_lines($1)if length($1)or length($2)or pos(${$self->{'source_scalar_ref'}})!=length(${$self->{'source_scalar_ref'}})}else {$self->SUPER::parse_lines(undef);delete$self->{'source_scalar_ref'};DEBUG and print STDERR "That's it for that source scalarref!  Killing.\n"}}else {die "What source??"}}DEBUG and print STDERR "get_token about to return ",Pod::Simple::pretty(@{$self->{'token_buffer'}}? $self->{'token_buffer'}[-1]: undef),"\n";return shift @{$self->{'token_buffer'}}}sub unget_token {my$self=shift;DEBUG and print STDERR "Ungetting ",scalar(@_)," tokens: ",@_ ? "@_\n" : "().\n";for my$t (@_){Carp::croak "Can't unget that, because it's not a token -- it's undef!" unless defined$t;Carp::croak "Can't unget $t, because it's not a token -- it's a string!" unless ref$t;Carp::croak "Can't unget $t, because it's not a token object!" unless UNIVERSAL::can($t,'type')}unshift @{$self->{'token_buffer'}},@_;DEBUG > 1 and print STDERR "Token buffer now has ",scalar(@{$self->{'token_buffer'}})," items in it.\n";return}sub set_source {my$self=shift @_;return$self->{'source_fh'}unless @_;Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")if$self->{'source_fh'}|| $self->{'source_scalar_ref'}|| $self->{'source_arrayref'};my$handle;if(!defined $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}elsif(ref(\($_[0]))eq 'GLOB'){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print STDERR "$self 's source is glob $_[0]\n"}elsif(ref($_[0])eq 'SCALAR'){$self->{'source_scalar_ref'}=$_[0];DEBUG and print STDERR "$self 's source is scalar ref $_[0]\n";return}elsif(ref($_[0])eq 'ARRAY'){$self->{'source_arrayref'}=$_[0];DEBUG and print STDERR "$self 's source is array ref $_[0]\n";return}elsif(ref $_[0]){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print STDERR "$self 's source is fh-obj $_[0]\n"}elsif(!length $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}else {DEBUG and print STDERR "$self 's source is filename $_[0]\n";{local*PODSOURCE;open(PODSOURCE,"<$_[0]")|| Carp::croak "Can't open $_[0]: $!";$handle=*PODSOURCE{IO}}$self->{'source_filename'}=$_[0];DEBUG and print STDERR "  Its name is $_[0].\n"}$self->{'source_fh'}=$handle;DEBUG and print STDERR "  Its handle is $handle\n";return 1}sub get_title_short {shift->get_short_title(@_)}sub get_short_title {my$title=shift->get_title(@_);$title=$1 if$title =~ m/^(\S{1,60})\s+--?\s+./s;return$title}sub get_title {shift->_get_titled_section('NAME',max_token=>50,desperate=>1,@_)}sub get_version {shift->_get_titled_section('VERSION',max_token=>400,accept_verbatim=>1,max_content_length=>3_000,@_,)}sub get_description {shift->_get_titled_section('DESCRIPTION',max_token=>400,max_content_length=>3_000,@_,)}sub get_authors {shift->get_author(@_)}sub get_author {my$this=shift;$this->_get_titled_section('AUTHOR',max_token=>10_000,@_)|| $this->_get_titled_section('AUTHORS',max_token=>10_000,@_)}sub _get_titled_section {my($self,$titlename,%options)=(@_);my$max_token=delete$options{'max_token'};my$desperate_for_title=delete$options{'desperate'};my$accept_verbatim=delete$options{'accept_verbatim'};my$max_content_length=delete$options{'max_content_length'};my$nocase=delete$options{'nocase'};$max_content_length=120 unless defined$max_content_length;Carp::croak("Unknown " .((1==keys%options)? "option: " : "options: ").join " ",map "[$_]",sort keys%options)if keys%options;my%content_containers;$content_containers{'Para'}=1;if($accept_verbatim){$content_containers{'Verbatim'}=1;$content_containers{'VerbatimFormatted'}=1}my$token_count=0;my$title;my@to_unget;my$state=0;my$depth=0;Carp::croak "What kind of titlename is \"$titlename\"?!" unless defined$titlename and $titlename =~ m/^[A-Z ]{1,60}$/s;my$titlename_re=quotemeta($titlename);my$head1_text_content;my$para_text_content;my$skipX;while(++$token_count <= ($max_token || 1_000_000)and defined(my$token=$self->get_token)){push@to_unget,$token;if ($state==0){if($token->is_start and $token->tagname eq 'head1'){DEBUG and print STDERR "  Found head1.  Seeking content...\n";++$state;$head1_text_content=''}}elsif($state==1){if($token->is_text){unless ($skipX){DEBUG and print STDERR "   Adding \"",$token->text,"\" to head1-content.\n";$head1_text_content .= $token->text}}elsif($token->is_tagname('X')){$skipX=$token->is_start;DEBUG and print STDERR +($skipX ? 'Start' : 'End'),'ing ignoring of X<> tag'}elsif($token->is_end and $token->tagname eq 'head1'){DEBUG and print STDERR "  Found end of head1.  Considering content...\n";$head1_text_content=uc$head1_text_content if$nocase;if($head1_text_content eq $titlename or $head1_text_content =~ m/\($titlename_re\)/s){DEBUG and print STDERR "  Yup, it was $titlename.  Seeking next para-content...\n";++$state}elsif($desperate_for_title and $head1_text_content =~ m/\S/ and $head1_text_content !~ m/^[ A-Z]+$/s and $head1_text_content !~ m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx and ($max_content_length ? (length($head1_text_content)<= $max_content_length): 1)){($title=$head1_text_content)=~ s/\s+$//;DEBUG and print STDERR "  It looks titular: \"$title\".\n\n  Using that.\n";last}else {--$state;DEBUG and print STDERR "  Didn't look titular ($head1_text_content).\n","\n  Dropping back to seeking-head1-content mode...\n"}}}elsif($state==2){if($token->is_start and $content_containers{$token->tagname }){DEBUG and print STDERR "  Found start of Para.  Accumulating content...\n";$para_text_content='';++$state}else {DEBUG and print "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";$state=0}}elsif($state==3){if($token->is_text){DEBUG and print STDERR "   Adding \"",$token->text,"\" to para-content.\n";$para_text_content .= $token->text}elsif($token->is_end and $content_containers{$token->tagname }){DEBUG and print STDERR "  Found end of Para.  Considering content: ",$para_text_content,"\n";if($para_text_content =~ m/\S/ and ($max_content_length ? (length($para_text_content)<= $max_content_length): 1)){DEBUG and print STDERR "  It looks contentworthy, I guess.  Using it.\n";$title=$para_text_content;last}else {DEBUG and print STDERR "  Doesn't look at all contentworthy!\n  Giving up.\n";undef$title;last}}}else {die "IMPOSSIBLE STATE $state!\n"}}$self->unget_token(@to_unget);if(DEBUG){if(defined$title){print STDERR "  Returning title <$title>\n"}else {print STDERR "Returning title <>\n"}}return '' unless defined$title;$title =~ s/^\s+//;return$title}sub _handle_element_start {my$self=shift;DEBUG > 2 and print STDERR "++ $_[0] (",map("<$_> ",%{$_[1]}),")\n";push @{$self->{'token_buffer'}},$self->{'start_token_class'}->new(@_);return}sub _handle_text {my$self=shift;DEBUG > 2 and print STDERR "== $_[0]\n";push @{$self->{'token_buffer'}},$self->{'text_token_class'}->new(@_);return}sub _handle_element_end {my$self=shift;DEBUG > 2 and print STDERR "-- $_[0]\n";push @{$self->{'token_buffer'}},$self->{'end_token_class'}->new(@_);return}1;
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  require 5;package Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.42';sub new {my$class=shift;return bless ['end',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}1;
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  require 5;package Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.42';sub new {my$class=shift;return bless ['start',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}sub attr_hash {$_[0][2]||= {}}sub attr {if(@_==2){${$_[0][2]|| return undef}{$_[1]}}elsif(@_ > 2){${$_[0][2]||= {}}{$_[1]}=$_[2]}else {require Carp;Carp::croak('usage: $object->attr("val") or $object->attr("key", "newval")');return undef}}1;
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  require 5;package Pod::Simple::PullParserTextToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.42';sub new {my$class=shift;return bless ['text',@_],ref($class)|| $class}sub text {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub text_r {\ $_[0][1]}1;
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  require 5;package Pod::Simple::PullParserToken;@ISA=();$VERSION='3.42';use strict;sub new {my$class=shift;return bless [@_],ref($class)|| $class}sub type {$_[0][0]}sub dump {Pod::Simple::pretty([@{$_[0]}])}sub is_start {$_[0][0]eq 'start'}sub is_end {$_[0][0]eq 'end'}sub is_text {$_[0][0]eq 'text'}1;
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  require 5;package Pod::Simple::RTF;use strict;use vars qw($VERSION @ISA %Escape $WRAP %Tagmap);$VERSION='3.42';use Pod::Simple::PullParser ();BEGIN {@ISA=('Pod::Simple::PullParser')}use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub to_uni ($) {my$x=shift;$x=chr utf8::native_to_unicode(ord$x)if $] ge 5.007_003 && ord("A")!=65;return$x}my$map_to_self=' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEGHIJKLMNOPQRSTUVWXYZ[]^`abcdefghijklmnopqrstuvwxyz|~';$WRAP=1 unless defined$WRAP;%Escape=(map((chr($_)=>sprintf("\\'%02x",$_)),0 .. 0xFF),map((substr($map_to_self,$_,1)=>to_uni(substr($map_to_self,$_,1))),0 .. length($map_to_self)- 1),"\r"=>"\n","\cj"=>"\n","\n"=>"\n\\line ","\t"=>"\\tab ","\f"=>"\n\\page\n","-"=>"\\_",$Pod::Simple::nbsp=>"\\~",$Pod::Simple::shy=>"\\-","\n"=>"\\line\n","\r"=>"\n","\cb"=>"{\n\\cs21\\lang1024\\noproof ","\cc"=>"}",);my$escaped_sans_hyphen="";$escaped_sans_hyphen .= $_ for grep {$_ ne $Escape{$_}&& $_ ne '-'}sort keys%Escape;my$escaped="-$escaped_sans_hyphen";$escaped_sans_hyphen=qr/[\Q$escaped_sans_hyphen \E]/;$escaped=qr/[\Q$escaped\E]/;sub _openclose {return map {;m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";($1,"{\\$2\n","/$1","}")}@_}my@_to_accept;%Tagmap=(_openclose('B=cs18\b','I=cs16\i','C=cs19\f1\lang1024\noproof','F=cs17\i\lang1024\noproof','VerbatimI=cs26\i','VerbatimB=cs27\b','VerbatimBI=cs28\b\i',map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[underline=ul smallcaps=scaps shadow=shad superscript=super subscript=sub strikethrough=strike outline=outl emboss=embo engrave=impr dotted-underline=uld dash-underline=uldash dot-dash-underline=uldashd dot-dot-dash-underline=uldashdd double-underline=uldb thick-underline=ulth word-underline=ulw wave-underline=ulwave]),'L=pod'=>'{\cs22\i'."\n",'L=url'=>'{\cs23\i'."\n",'L=man'=>'{\cs24\i'."\n",'/L'=>'}','Data'=>"\n",'/Data'=>"\n",'Verbatim'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/Verbatim'=>"\n\\par}\n",'VerbatimFormatted'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/VerbatimFormatted'=>"\n\\par}\n",'Para'=>"\n{\\pard\\li#rtfindent#\\sa180\n",'/Para'=>"\n\\par}\n",'head1'=>"\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",'/head1'=>"\n}\\par}\n",'head2'=>"\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",'/head2'=>"\n}\\par}\n",'head3'=>"\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",'/head3'=>"\n}\\par}\n",'head4'=>"\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",'/head4'=>"\n}\\par}\n",'item-bullet'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-bullet'=>"\n\\par}\n",'item-number'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-number'=>"\n\\par}\n",'item-text'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-text'=>"\n\\par}\n",);sub new {my$new=shift->SUPER::new(@_);$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->accept_targets('rtf','RTF');$new->{'Tagmap'}={%Tagmap};$new->accept_codes(@_to_accept);$new->accept_codes('VerbatimFormatted');DEBUG > 2 and print STDERR "To accept: ",join(' ',@_to_accept),"\n";$new->doc_lang(($ENV{'RTFDEFLANG'}|| '')=~ m/^(\d{1,10})$/s ? $1 : ($ENV{'RTFDEFLANG'}|| '')=~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1): ($ENV{'RTFDEFLANG'}|| '')=~ m/^([a-fA-F0-9]{4})$/s ? hex($1): '1033');$new->head1_halfpoint_size(32);$new->head2_halfpoint_size(28);$new->head3_halfpoint_size(25);$new->head4_halfpoint_size(22);$new->codeblock_halfpoint_size(18);$new->header_halfpoint_size(17);$new->normal_halfpoint_size(25);return$new}__PACKAGE__->_accessorize('doc_lang','head1_halfpoint_size','head2_halfpoint_size','head3_halfpoint_size','head4_halfpoint_size','codeblock_halfpoint_size','header_halfpoint_size','normal_halfpoint_size','no_proofing_exemptions',);sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}my$id_re=Pod::Simple::BlackBox::my_qr('[\'_\p{XIDS}][\'\p{XIDC}]+',"ab");$id_re=Pod::Simple::BlackBox::my_qr('[\'_\p{IDS}][\'\p{IDC}]+',"ab")unless$id_re;$id_re=qr/['_a-zA-Z]['a-zA-Z0-9_]+/ unless$id_re;sub do_middle {my$self=$_[0];my$fh=$self->{'output_fh'};my($token,$type,$tagname,$scratch);my@stack;my@indent_stack;$self->{'rtfindent'}=0 unless defined$self->{'rtfindent'};while($token=$self->get_token){if(($type=$token->type)eq 'text'){if($self->{'rtfverbatim'}){DEBUG > 1 and print STDERR "  $type ",$token->text," in verbatim!\n";rtf_esc(0,$scratch=$token->text);print$fh $scratch;next}DEBUG > 1 and print STDERR "  $type ",$token->text,"\n";$scratch=$token->text;$scratch =~ tr/\t\cb\cc/ /d;$self->{'no_proofing_exemptions'}or $scratch =~ s/(?:
             ^
             |
             (?<=[\r\n\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             ${id_re}[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg ;rtf_esc(1,$scratch);$scratch =~ s/(
              [^\r\n]{65}        # Snare 65 characters from a line
              [^\r\n ]{0,50}     #  and finish any current word
             )
             (\ {1,10})(?![\r\n]) # capture some spaces not at line-end
            /$1$2\n/gx if$WRAP;print$fh $scratch}elsif($type eq 'start'){DEBUG > 1 and print STDERR "  +$type ",$token->tagname," (",map("<$_> ",%{$token->attr_hash}),")\n";if(($tagname=$token->tagname)eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){++$self->{'rtfverbatim'};my$next=$self->get_token;next unless defined$next;my$line_count=1;if($next->type eq 'text'){my$t=$next->text_r;while($$t =~ m/$/mg){last if ++$line_count > 15}DEBUG > 3 and print STDERR "    verbatim line count: $line_count\n"}$self->unget_token($next);$self->{'rtfkeep'}=($line_count > 15)? '' : '\keepn' }elsif($tagname =~ m/^item-/s){my@to_unget;my$text_count_here=0;$self->{'rtfitemkeepn'}='';while(1){push@to_unget,$self->get_token;pop(@to_unget),last unless defined$to_unget[-1];if($to_unget[-1]->type eq 'text'){if(($text_count_here += length ${$to_unget[-1]->text_r})> 150){DEBUG > 1 and print STDERR "    item-* is too long to be keepn'd.\n";last}}elsif (@to_unget > 1 and $to_unget[-2]->type eq 'end' and $to_unget[-2]->tagname =~ m/^item-/s){$self->{'rtfitemkeepn'}='\keepn' if $to_unget[-1]->type eq 'start' and $to_unget[-1]->tagname eq 'Para';DEBUG > 1 and printf STDERR "    item-* before %s(%s) %s keepn'd.\n",$to_unget[-1]->type,$to_unget[-1]->can('tagname')? $to_unget[-1]->tagname : '',$self->{'rtfitemkeepn'}? "gets" : "doesn't get";last}elsif (@to_unget > 40){DEBUG > 1 and print STDERR "    item-* now has too many tokens (",scalar(@to_unget),(DEBUG > 4)? (q<: >,map($_->dump,@to_unget)): (),") to be keepn'd.\n";last}}$self->unget_token(@to_unget)}elsif($tagname =~ m/^over-/s){push@stack,$1;push@indent_stack,int($token->attr('indent')* 4 * $self->normal_halfpoint_size);DEBUG and print STDERR "Indenting over $indent_stack[-1] twips.\n";$self->{'rtfindent'}+= $indent_stack[-1]}elsif ($tagname eq 'L'){$tagname .= '=' .($token->attr('type')|| 'pod')}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print STDERR "    raw text ",$next->text,"\n";printf$fh "\n" .$next->text ."\n";next}defined($scratch=$self->{'Tagmap'}{$tagname})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch;if ($tagname eq 'item-number'){print$fh $token->attr('number'),". \n"}elsif ($tagname eq 'item-bullet'){print$fh "\\'",ord("_"),"\n"}}elsif($type eq 'end'){DEBUG > 1 and print STDERR "  -$type ",$token->tagname,"\n";if(($tagname=$token->tagname)=~ m/^over-/s){DEBUG and print STDERR "Indenting back $indent_stack[-1] twips.\n";$self->{'rtfindent'}-= pop@indent_stack;pop@stack}elsif($tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){--$self->{'rtfverbatim'}}defined($scratch=$self->{'Tagmap'}{"/$tagname"})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch}}return 1}sub do_beginning {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh join '',$self->doc_init,$self->font_table,$self->stylesheet,$self->color_table,$self->doc_info,$self->doc_start,"\n" }sub do_end {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh '}'}sub stylesheet {return sprintf <<'END',$_[0]->codeblock_halfpoint_size(),$_[0]->head1_halfpoint_size(),$_[0]->head2_halfpoint_size(),$_[0]->head3_halfpoint_size(),$_[0]->head4_halfpoint_size(),}sub font_table {return <<'END'}sub doc_init {return <<'END'}sub color_table {return <<'END'}sub doc_info {my$self=$_[0];my$class=ref($self)|| $self;my$tag=__PACKAGE__ .' ' .$VERSION;unless($class eq __PACKAGE__){$tag=" ($tag)";$tag=" v" .$self->VERSION .$tag if defined$self->VERSION;$tag=$class .$tag}return sprintf <<'END',$tag,$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime($ENV{SOURCE_DATE_EPOCH}|| time)),}sub doc_start {my$self=$_[0];my$title=$self->get_short_title();DEBUG and print STDERR "Short Title: <$title>\n";$title .= ' ' if length$title;$title =~ s/ *$/ /s;$title =~ s/^ //s;$title =~ s/ $/, /s;my$is_obviously_module_name;$is_obviously_module_name=1 if$title =~ m/^\S+$/s and $title =~ m/::/s;DEBUG and print STDERR "Title0: <$title>\n";$title=rtf_esc(1,$title);DEBUG and print STDERR "Title1: <$title>\n";$title='\lang1024\noproof ' .$title if$is_obviously_module_name;return sprintf <<'END',($self->doc_lang)x 2,$self->header_halfpoint_size,$title,$self->normal_halfpoint_size,}use integer;my$question_mark_code_points=Pod::Simple::BlackBox::my_qr('([^\x00-\x{D7FF}\x{E000}-\x{10FFFF}])',"\x{110000}");my$plane0=Pod::Simple::BlackBox::my_qr('([\x{100}-\x{FFFF}])',"\x{100}");my$other_unicode=Pod::Simple::BlackBox::my_qr('([\x{10000}-\x{10FFFF}])',"\x{10000}");sub esc_uni($) {use if $] le 5.006002,'utf8';my$x=shift;$x =~ s/$question_mark_code_points/?/g if$question_mark_code_points;$x =~ s/$plane0/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg if$plane0;$x =~ s/$other_unicode/'\\uc1\\u' . ((ord($1) >> 10) + 0xD7C0 - 65536) . '\\u' . (((ord$1) & 0x03FF) + 0xDC00 - 65536) . '?'/eg if$other_unicode;return$x}sub rtf_esc ($$) {my$escape_re=((shift)? $escaped : $escaped_sans_hyphen);my$x;if(!defined wantarray){for(@_){s/($escape_re)/$Escape{$1}/g;$_=esc_uni($_)}return}elsif(wantarray){return map {;($x=$_)=~ s/($escape_re)/$Escape{$1}/g;$x=esc_uni($x);$x}@_}else {($x=((@_==1)? $_[0]: join '',@_))=~ s/($escape_re)/$Escape{$1}/g;$x=esc_uni($x);return$x}}1;
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  {\rtf1\ansi\deff0
  
  END
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  require 5.005;package Pod::Simple::Search;use strict;use vars qw($VERSION $MAX_VERSION_WITHIN $SLEEPY);$VERSION='3.42';BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use Carp ();$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$MAX_VERSION_WITHIN ||= 60;use File::Spec ();use File::Basename qw(basename dirname);use Config ();use Cwd qw(cwd);__PACKAGE__->_accessorize('callback','progress','dir_prefix','inc','laborious','limit_glob','limit_re','shadows','verbose','name2path','path2name','recurse','ciseen','is_case_insensitive');sub new {my$class=shift;my$self=bless {},ref($class)|| $class;$self->init;return$self}sub init {my$self=shift;$self->inc(1);$self->recurse(1);$self->verbose(DEBUG);$self->is_case_insensitive(-e uc __FILE__ && -e lc __FILE__);return$self}sub survey {my($self,@search_dirs)=@_;$self=$self->new unless ref$self;$self->_expand_inc(\@search_dirs);$self->{'_scan_count'}=0;$self->{'_dirs_visited'}={};$self->path2name({});$self->name2path({});$self->ciseen({});$self->limit_re($self->_limit_glob_to_limit_re)if$self->{'limit_glob'};my$cwd=cwd();my$verbose=$self->verbose;local $_;for my$try (@search_dirs){unless(File::Spec->file_name_is_absolute($try)){$try=File::Spec->catfile($cwd,$try)}$try=File::Spec->canonpath($try);my$start_in;my$modname_prefix;if($self->{'dir_prefix'}){$start_in=File::Spec->catdir($try,grep length($_),split '[\\/:]+',$self->{'dir_prefix'});$modname_prefix=[grep length($_),split m{[:/\\]},$self->{'dir_prefix'}];$verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ","giving $start_in (= @$modname_prefix)\n"}else {$start_in=$try}if($self->{'_dirs_visited'}{$start_in}){$verbose and print "Directory '$start_in' already seen, skipping.\n";next}else {$self->{'_dirs_visited'}{$start_in}=1}unless(-e $start_in){$verbose and print "Skipping non-existent $start_in\n";next}my$closure=$self->_make_search_callback;if(-d $start_in){$verbose and print "Beginning excursion under $start_in\n";$self->_recurse_dir($start_in,$closure,$modname_prefix);$verbose and print "Back from excursion under $start_in\n\n"}elsif(-f _){$_=basename($start_in);$verbose and print "Pondering $start_in ($_)\n";$closure->($start_in,$_,0,[])}else {$verbose and print "Skipping mysterious $start_in\n"}}$self->progress and $self->progress->done("Noted $$self{'_scan_count'} Pod files total");$self->ciseen({});return unless defined wantarray;return$self->name2path unless wantarray;return$self->name2path,$self->path2name}sub _make_search_callback {my$self=$_[0];my($laborious,$verbose,$shadows,$limit_re,$callback,$progress,$path2name,$name2path,$recurse,$ciseen,$is_case_insensitive)=map scalar($self->$_()),qw(laborious verbose shadows limit_re callback progress path2name name2path recurse ciseen is_case_insensitive);my ($seen,$remember,$files_for);if ($is_case_insensitive){$seen=sub {$ciseen->{lc $_[0]}};$remember=sub {$name2path->{$_[0]}=$ciseen->{lc $_[0]}=$_[1]};$files_for=sub {my$n=lc $_[0];grep {lc$path2name->{$_}eq $n}%{$path2name}}}else {$seen=sub {$name2path->{$_[0]}};$remember=sub {$name2path->{$_[0]}=$_[1]};$files_for=sub {my$n=$_[0];grep {$path2name->{$_}eq $n}%{$path2name}}}my($file,$shortname,$isdir,$modname_bits);return sub {($file,$shortname,$isdir,$modname_bits)=@_;if($isdir){unless($recurse){$verbose and print "Not recursing into '$file' as per requested.\n";return 'PRUNE'}if($self->{'_dirs_visited'}{$file}){$verbose and print "Directory '$file' already seen, skipping.\n";return 'PRUNE'}print "Looking in dir $file\n" if$verbose;unless ($laborious){if(m/^(\d+\.[\d_]{3,})\z/s and do {my$x=$1;$x =~ tr/_//d;$x!=$]}){$verbose and print "Perl $] version mismatch on $_, skipping.\n";return 'PRUNE'}if(m/^([A-Za-z][a-zA-Z0-9_]*)\z/s){$verbose and print "$_ is a well-named module subdir.  Looking....\n"}else {$verbose and print "$_ is a fishy directory name.  Skipping.\n";return 'PRUNE'}}$self->{'_dirs_visited'}{$file}=1;return}if($laborious){unless(m/\.(pod|pm|plx?)\z/i || -x _ and -T _){$verbose > 1 and print " Brushing off uninteresting $file\n";return}}else {unless(m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is){$verbose > 1 and print " Brushing off oddly-named $file\n";return}}$verbose and print "Considering item $file\n";my$name=$self->_path2modname($file,$shortname,$modname_bits);$verbose > 0.01 and print " Nominating $file as $name\n";if($limit_re and $name !~ m/$limit_re/i){$verbose and print "Shunning $name as not matching $limit_re\n";return}if(!$shadows and $seen->($name)){$verbose and print "Not worth considering $file ","-- already saw $name as ",join(' ',$files_for->($name)),"\n";return}$progress and $progress->reach($self->{'_scan_count'},"Scanning $file");return unless$self->contains_pod($file);++ $self->{'_scan_count'};if (my$prev=$seen->($name)){$verbose and print "Duplicate POD found (shadowing?): $name ($file)\n","    Already seen in ",join(' ',$files_for->($name)),"\n"}else {$remember->($name,$file)}$verbose and print "  Noting $name = $file\n";if($callback){local $_=$_;$callback->($file,$name)}$path2name->{$file}=$name;return}}sub _path2modname {my($self,$file,$shortname,$modname_bits)=@_;my@m=@$modname_bits;my$x;my$verbose=$self->verbose;while(@m and defined($x=lc($m[0]))and($x eq 'site_perl' or($x =~ m/^pods?$/ and @m==1 and $shortname =~ m{^perl.*\.pod$}s)or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?} or $x eq lc($Config::Config{'archname'}))){shift@m}my$name=join '::',@m,$shortname;$self->_simplify_base($name);if ($^O eq 'VMS' && ($name eq lc($name)|| $name eq uc($name))){open PODFILE,"<$file" or die "_path2modname: Can't open $file: $!";my$in_pod=0;my$in_name=0;my$line;while ($line=<PODFILE>){chomp$line;$in_pod=1 if ($line =~ m/^=\w/);$in_pod=0 if ($line =~ m/^=cut/);next unless$in_pod;next if ($line =~ m/^\s*\z/);next if ($in_pod && ($line =~ m/^X</));if ($in_name){if ($line =~ m/(\w+::)?(\w+)/){my$podname=$2;my$prefix=$1 || '';$verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";unless ($name =~ s/$prefix$podname/$prefix$podname/i){$verbose and print "Attempting case restore of '$name' from '$podname'\n";$name =~ s/$podname/$podname/i}last}}$in_name=1 if ($line =~ m/^=head1 NAME/)}close PODFILE}return$name}sub _recurse_dir {my($self,$startdir,$callback,$modname_bits)=@_;my$maxdepth=$self->{'fs_recursion_maxdepth'}|| 10;my$verbose=$self->verbose;my$here_string=File::Spec->curdir;my$up_string=File::Spec->updir;$modname_bits ||= [];my$recursor;$recursor=sub {my($dir_long,$dir_bare)=@_;if(@$modname_bits >= 10){$verbose and print "Too deep! [@$modname_bits]\n";return}unless(-d $dir_long){$verbose > 2 and print "But it's not a dir! $dir_long\n";return}unless(opendir(INDIR,$dir_long)){$verbose > 2 and print "Can't opendir $dir_long : $!\n";closedir(INDIR);return}my@items=map {$_->[0]}sort {$a->[1]cmp $b->[1]|| $b->[2]cmp $a->[2]}map {(my$t=$_)=~ s/[.]p(m|lx?|od)\z//;[$_,$t,lc($1 || 'z')]}readdir(INDIR);closedir(INDIR);push @$modname_bits,$dir_bare unless$dir_bare eq '';my$i_full;for my$i (@items){next if$i eq $here_string or $i eq $up_string or $i eq '';$i_full=File::Spec->catfile($dir_long,$i);if(!-r $i_full){$verbose and print "Skipping unreadable $i_full\n"}elsif(-f $i_full){$_=$i;$callback->($i_full,$i,0,$modname_bits)}elsif(-d _){$i =~ s/\.DIR\z//i if $^O eq 'VMS';$_=$i;my$rv=$callback->($i_full,$i,1,$modname_bits)|| '';if($rv eq 'PRUNE'){$verbose > 1 and print "OK, pruning"}else {$recursor->(File::Spec->catdir($dir_long,$i),$i)}}else {$verbose > 1 and print "Skipping oddity $i_full\n"}}pop @$modname_bits;return};;local $_;$recursor->($startdir,'');undef$recursor;return}sub run {my$self=__PACKAGE__->new;$self->limit_glob($ARGV[0])if@ARGV;$self->callback(sub {my($file,$name)=@_;my$version='';if($file =~ m/\.pod$/i){DEBUG and print "Not looking for \$VERSION in .pod $file\n"}elsif(!open(INPOD,$file)){DEBUG and print "Couldn't open $file: $!\n";close(INPOD)}else {my$lines=0;while(<INPOD>){last if$lines++ > $MAX_VERSION_WITHIN;if(s/^\s*\$VERSION\s*=\s*//s and m/\d/){DEBUG and print "Found version line (#$lines): $_";s/\s*\#.*//s;s/\;\s*$//s;s/\s+$//s;s/\t+/ /s;$_="v$1" if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s ;$_=sprintf("v%d.%s",map {s/_//g;$_}$1 =~ m/-(\d+)_([\d_]+)/)if m{\$Name:\s*([^\$]+)\$}s ;$version=$_;DEBUG and print "Noting $version as version\n";last}}close(INPOD)}print "$name\t$version\t$file\n";return});$self->survey}sub simplify_name {my($self,$str)=@_;if ($^O eq 'MacOS'){$str =~ s{^.*:+}{}s}else {$str =~ s{^.*/+}{}s}$self->_simplify_base($str);return$str}sub _simplify_base {$_[1]=~ s/\.(pod|pm|plx?)\z//i;$_[1]=~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;$_[1]=~ s/\.(com)\z//i if $^O eq 'VMS';return}sub _expand_inc {my($self,$search_dirs)=@_;return unless$self->{'inc'};my%seen=map {File::Spec->rel2abs($_)=>1}@{$search_dirs};if ($^O eq 'MacOS'){push @$search_dirs,grep {!$seen{File::Spec->rel2abs($_)}++}$self->_mac_whammy(@INC)}else {push @$search_dirs,grep {!$seen{File::Spec->rel2abs($_)}++}@INC}$self->{'laborious'}=0;return}sub _mac_whammy {my@them;(undef,@them)=@_;for $_ (@them){if ($_ eq '.'){$_=':'}elsif ($_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e){$_=':'.$_}else {$_ =~ s|^\./|:|}}return@them}sub _limit_glob_to_limit_re {my$self=$_[0];my$limit_glob=$self->{'limit_glob'}|| return;my$limit_re='^' .quotemeta($limit_glob).'$';$limit_re =~ s/\\\?/./g;$limit_re =~ s/\\\*/.*?/g;$limit_re =~ s/\.\*\?\$$//s;$self->{'verbose'}and print "Turning limit_glob $limit_glob into re $limit_re\n";if(!exists($self->{'dir_prefix'})and $limit_glob =~ m/^(?:\w+\:\:)+/s){$self->{'dir_prefix'}=join "::",$limit_glob =~ m/^(?:\w+::)+/sg;$self->{'verbose'}and print " and setting dir_prefix to $self->{'dir_prefix'}\n"}return$limit_re}sub _actual_filenames {my$dir=shift;my$fn=lc shift;opendir my ($dh),$dir or return;return map {File::Spec->catdir($dir,$_)}grep {lc $_ eq $fn}readdir$dh}sub find {my($self,$pod,@search_dirs)=@_;$self=$self->new unless ref$self;Carp::carp 'Usage: \$self->find($podname, ...)' unless defined$pod and length$pod;my$verbose=$self->verbose;my@parts=split /::/,$pod;$verbose and print "Chomping {$pod} => {@parts}\n";$self->_expand_inc(\@search_dirs);push@search_dirs,$Config::Config{'scriptdir'}if$self->inc;my%seen_dir;while (my$dir=shift@search_dirs){next unless defined$dir and length$dir;next if$seen_dir{$dir};$seen_dir{$dir}=1;unless(-d $dir){print "Directory $dir does not exist\n" if$verbose}print "Looking in directory $dir\n" if$verbose;my$fullname=File::Spec->catfile($dir,@parts);print "Filename is now $fullname\n" if$verbose;for my$ext ('','.pod','.pm','.pl'){my$fullext=$fullname .$ext;if (-f $fullext and $self->contains_pod($fullext)){print "FOUND: $fullext\n" if$verbose;if (@parts > 1 && lc$parts[0]eq 'pod' && $self->is_case_insensitive()&& $ext eq '.pod'){my$subdir=dirname$fullext;unless (grep {$fullext eq $_}_actual_filenames$subdir,"$parts[-1].pod"){print "# Looking for alternate spelling in $subdir\n" if$verbose;my$pm=$fullname .'.pm';if (-f $pm and $self->contains_pod($pm)){if (grep {$pm eq $_}_actual_filenames$subdir,"$parts[-1].pm"){print "FOUND: $fullext\n" if$verbose;return$pm}}}}return$fullext}}for my$subdir (_actual_filenames($dir,'pods'),_actual_filenames($dir,'pod')){if (-d $subdir){$verbose and print "Noticing $subdir and looking there...\n";unshift@search_dirs,$subdir}}}return undef}sub contains_pod {my($self,$file)=@_;my$verbose=$self->{'verbose'};$verbose > 1 and print " Scanning $file for pod...\n";unless(open(MAYBEPOD,"<$file")){print "Error: $file is unreadable: $!\n";return undef}sleep($SLEEPY - 1)if$SLEEPY;local $_;while(<MAYBEPOD>){if(m/^=(head\d|pod|over|item)\b/s){close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";chomp;$verbose > 1 and print "  Found some pod ($_) in $file\n";return 1}}close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";$verbose > 1 and print "  No POD in $file, skipping.\n";return 0}sub _accessorize {shift;no strict 'refs';for my$attrname (@_){*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];return $_[0]->{$attrname}if @_==1;$_[0]->{$attrname}=$_[1];return $_[0]}}return}sub _state_as_string {my$self=$_[0];return '' unless ref$self;my@out="{\n  # State of $self ...\n";for my$k (sort keys %$self){push@out,"  ",_esc($k)," => ",_esc($self->{$k}),",\n"}push@out,"}\n";my$x=join '',@out;$x =~ s/^/#/mg;return$x}sub _esc {my$in=$_[0];return 'undef' unless defined$in;$in =~ s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;return qq{"$in"}}run()unless caller;1;
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  require 5;package Pod::Simple::SimpleTree;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.42';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('root',);sub _handle_element_start {DEBUG > 2 and print STDERR "Handling $_[1] start-event\n";my$x=[$_[1],$_[2]];if($_[0]{'_currpos'}){push @{$_[0]{'_currpos'}[0]},$x;unshift @{$_[0]{'_currpos'}},$x}else {DEBUG and print STDERR " And oo, it gets to be root!\n";$_[0]{'_currpos'}=[$_[0]{'root'}=$x ]}DEBUG > 3 and print STDERR "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_element_end {DEBUG > 2 and print STDERR "Handling $_[1] end-event\n";shift @{$_[0]{'_currpos'}};DEBUG > 3 and print STDERR "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_text {DEBUG > 2 and print STDERR "Handling $_[1] text-event\n";push @{$_[0]{'_currpos'}[0]},$_[1];return}sub _traverse_treelet_bit {DEBUG > 2 and print STDERR "Handling $_[1] paragraph event\n";my$self=shift;push @{$self->{'_currpos'}[0]},[@_];return}1;
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  require 5;package Pod::Simple::Text;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION $FREAKYMODE);$VERSION='3.42';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::huge='overflow';sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_target_as_text(qw(text plaintext plain));$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';return$new}sub handle_text {$_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {$_[0]{'Thispara'}=''}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}=$FREAKYMODE ? '' : '* '}sub start_item_number {$_[0]{'Thispara'}=$FREAKYMODE ? '' : "$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub start_L {$_[0]{'Link'}=$_[1]if $_[1]->{type}eq 'url'}sub end_L {if (my$link=delete $_[0]{'Link'}){$_[0]{'Thispara'}.= " <$link->{to}>" unless $_[0]{'Thispara'}=~ /\b\Q$link->{to}/}}sub emit_par {my($self,$tweak_indent)=splice(@_,0,2);my$indent=' ' x (2 * $self->{'Indent'}+ 4 + ($tweak_indent||0));$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ s/$Pod::Simple::nbsp/ /g;print {$self->{'output_fh'}}$out,"\n";$self->{'Thispara'}='';return}sub end_Verbatim {my$self=shift;$self->{'Thispara'}=~ s/$Pod::Simple::nbsp/ /g;$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  require 5;package Pod::Simple::TextContent;use strict;use Carp ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.42';@ISA=('Pod::Simple');sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->nix_X_codes(1);return$new}sub _handle_element_start {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}sub _handle_text {$_[1]=~ s/$Pod::Simple::shy//g;$_[1]=~ s/$Pod::Simple::nbsp/ /g;print {$_[0]{'output_fh'}}$_[1];return}sub _handle_element_end {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}1;
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  use strict;package Pod::Simple::TiedOutFH;use Symbol ('gensym');use Carp ();use vars qw($VERSION);$VERSION='3.42';sub handle_on {my$class=shift;$class=ref($class)|| $class;Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;my$x=(defined($_[0])and ref($_[0]))? $_[0]: (\($_[0]))[0];$$x='' unless defined $$x;my$new=gensym();tie *$new,$class,$x;return$new}sub TIEHANDLE {my($class,$scalar_ref)=@_;$$scalar_ref='' unless defined $$scalar_ref;return bless \$scalar_ref,ref($class)|| $class}sub PRINT {my$it=shift;for my$x (@_){$$$it .= $x}return 1}sub FETCH {return ${$_[0]}}sub PRINTF {my$it=shift;my$format=shift;$$$it .= sprintf$format,@_;return 1}sub FILENO {${$_[0]}+ 100}sub CLOSE {1}1;
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  require 5;package Pod::Simple::Transcode;use strict;use vars qw($VERSION @ISA);$VERSION='3.42';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}for my$class ('Pod::Simple::TranscodeSmart','Pod::Simple::TranscodeDumb','',){$class or die "Couldn't load any encoding classes";DEBUG and print STDERR "About to try loading $class...\n";eval "require $class;";if($@){DEBUG and print STDERR "Couldn't load $class: $@\n"}else {DEBUG and print STDERR "OK, loaded $class.\n";@ISA=($class);last}}sub _blorp {return}1;
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  require 5;package Pod::Simple::TranscodeDumb;use strict;use vars qw($VERSION %Supported);$VERSION='3.42';%Supported=('ascii'=>1,'ascii-ctrl'=>1,'iso-8859-1'=>1,'cp1252'=>1,'null'=>1,'latin1'=>1,'latin-1'=>1,%Supported,);sub is_dumb {1}sub is_smart {0}sub all_encodings {return sort keys%Supported}sub encoding_is_available {return exists$Supported{lc $_[1]}}sub encmodver {return __PACKAGE__ ." v" .($VERSION || '?')}sub make_transcoder {my ($e)=$_[1];die "WHAT ENCODING!?!?" unless$e;return sub {}if$e !~ /^cp-?1252$/i;return sub {my%ascii_for=("\x80"=>'e',"\x82"=>',',"\x83"=>'f',"\x84"=>',,',"\x85"=>'...',"\x86"=>'+',"\x87"=>'++',"\x88"=>'^',"\x89"=>'%',"\x8a"=>'S',"\x8b"=>'<',"\x8c"=>'OE',"\x8e"=>'Z',"\x91"=>"'","\x92"=>"'","\x93"=>'"',"\x94"=>'"',"\x95"=>'*',"\x96"=>'-',"\x97"=>'--',"\x98"=>'~',"\x99"=>'(tm)',"\x9a"=>'s',"\x9b"=>'>',"\x9c"=>'oe',"\x9e"=>'z',"\x9f"=>'Y',);s{([\x80-\x9f])}{$ascii_for{$1} || $1}emxsg for @_}}1;
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  require 5;use 5.008;package Pod::Simple::TranscodeSmart;use strict;use Pod::Simple;require Encode;use vars qw($VERSION);$VERSION='3.42';sub is_dumb {0}sub is_smart {1}sub all_encodings {return Encode::->encodings(':all')}sub encoding_is_available {return Encode::resolve_alias($_[1])}sub encmodver {return "Encode.pm v" .($Encode::VERSION || '?')}sub make_transcoder {my$e=Encode::find_encoding($_[1]);die "WHAT ENCODING!?!?" unless$e;my$x;return sub {for$x (@_){$x=$e->decode($x)unless Encode::is_utf8($x)}return}}1;
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  package Pod::Simple::XHTML;use strict;use vars qw($VERSION @ISA $HAS_HTML_ENTITIES);$VERSION='3.42';use Pod::Simple::Methody ();@ISA=('Pod::Simple::Methody');BEGIN {$HAS_HTML_ENTITIES=eval "require HTML::Entities; 1"}my%entities=(q{>}=>'gt',q{<}=>'lt',q{'}=>'#39',q{"}=>'quot',q{&}=>'amp',);sub encode_entities {my$self=shift;my$ents=$self->html_encode_chars;return HTML::Entities::encode_entities($_[0],$ents)if$HAS_HTML_ENTITIES;if (defined$ents){$ents =~ s,(?<!\\)([]/]),\\$1,g;$ents =~ s,(?<!\\)\\\z,\\\\,}else {$ents=join '',keys%entities}my$str=$_[0];$str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;return$str}__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','title_prefix','title_postfix','html_css','html_javascript','html_doctype','html_charset','html_encode_chars','html_h_level','title','default_title','force_title','html_header','html_footer','index','anchor_items','backlink','batch_mode','batch_mode_current_level',);sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->perldoc_url_prefix('https://metacpan.org/pod/');$new->man_url_prefix('http://man.he.net/man');$new->html_charset('ISO-8859-1');$new->nix_X_codes(1);$new->{'scratch'}='';$new->{'to_index'}=[];$new->{'output'}=[];$new->{'saved'}=[];$new->{'ids'}={'_podtop_'=>1 };$new->{'in_li'}=[];$new->{'__region_targets'}=[];$new->{'__literal_targets'}={};$new->accept_targets_as_html('html','HTML');return$new}sub html_header_tags {my$self=shift;return$self->{html_header_tags}=shift if @_;return$self->{html_header_tags}||= '<meta http-equiv="Content-Type" content="text/html; charset=' .$self->html_charset .'" />'}sub __in_literal_xhtml_region {return unless @{$_[0]{__region_targets}};my$target=$_[0]{__region_targets}[-1];return $_[0]{__literal_targets}{$target }}sub accept_targets_as_html {my ($self,@targets)=@_;$self->accept_targets(@targets);$self->{__literal_targets}{$_}=1 for@targets}sub handle_text {my$text=$_[0]->__in_literal_xhtml_region ? $_[1]: $_[0]->encode_entities($_[1]);if ($_[0]{'in_code'}&& @{$_[0]{'in_code'}}){$_[0]->handle_code($_[1],$_[0]{'in_code'}[-1])}else {if ($_[0]->{in_for}){my$newlines=$_[0]->__in_literal_xhtml_region ? "\n\n" : '';if ($_[0]->{started_for}){if ($text =~ /\S/){delete $_[0]->{started_for};$_[0]{'scratch'}.= $text .$newlines}}else {$text =~ s/\n\z//;$_[0]{'scratch'}.= $text .$newlines}}else {$_[0]{'scratch'}.= $text}}$_[0]{htext}.= $text if $_[0]{'in_head'}}sub start_code {$_[0]{'scratch'}.= '<code>'}sub end_code {$_[0]{'scratch'}.= '</code>'}sub handle_code {$_[0]{'scratch'}.= $_[0]->encode_entities($_[1])}sub start_Para {$_[0]{'scratch'}.= '<p>'}sub start_Verbatim {$_[0]{'scratch'}='<pre>';push(@{$_[0]{'in_code'}},'Verbatim');$_[0]->start_code($_[0]{'in_code'}[-1])}sub start_head1 {$_[0]{'in_head'}=1;$_[0]{htext}=''}sub start_head2 {$_[0]{'in_head'}=2;$_[0]{htext}=''}sub start_head3 {$_[0]{'in_head'}=3;$_[0]{htext}=''}sub start_head4 {$_[0]{'in_head'}=4;$_[0]{htext}=''}sub start_head5 {$_[0]{'in_head'}=5;$_[0]{htext}=''}sub start_head6 {$_[0]{'in_head'}=6;$_[0]{htext}=''}sub start_item_number {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_bullet {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_text {}sub start_over_bullet {$_[0]{'scratch'}='<ul>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_block {$_[0]{'scratch'}='<ul>';$_[0]->emit}sub start_over_number {$_[0]{'scratch'}='<ol>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_text {$_[0]{'scratch'}='<dl>';$_[0]{'dl_level'}++;$_[0]{'in_dd'}||= [];$_[0]->emit}sub end_over_block {$_[0]{'scratch'}.= '</ul>';$_[0]->emit}sub end_over_number {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ol>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_bullet {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ul>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_text {if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= '</dl>';$_[0]{'dl_level'}--;$_[0]->emit}sub end_Para {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_Verbatim {$_[0]->end_code(pop(@{$_[0]->{'in_code'}}));$_[0]{'scratch'}.= '</pre>';$_[0]->emit}sub _end_head {my$h=delete $_[0]{in_head};my$add=$_[0]->html_h_level;$add=1 unless defined$add;$h += $add - 1;my$id=$_[0]->idify($_[0]{htext});my$text=$_[0]{scratch};$_[0]{'scratch'}=$_[0]->backlink && ($h - $add==0)? qq{<a href="#_podtop_"><h$h id="$id">$text</h$h></a>} : qq{<h$h id="$id">$text</h$h>};$_[0]->emit;push @{$_[0]{'to_index'}},[$h,$id,delete $_[0]{'htext'}]}sub end_head1 {shift->_end_head(@_)}sub end_head2 {shift->_end_head(@_)}sub end_head3 {shift->_end_head(@_)}sub end_head4 {shift->_end_head(@_)}sub end_head5 {shift->_end_head(@_)}sub end_head6 {shift->_end_head(@_)}sub end_item_bullet {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_number {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_text {my$dt_id=$_[0]{'anchor_items'}? ' id="'.$_[0]->idify($_[0]{'scratch'}).'"' : '';my$text=$_[0]{scratch};$_[0]{'scratch'}='';if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= qq{<dt$dt_id>$text</dt>\n<dd>};$_[0]{'in_dd'}[$_[0]{'dl_level'}]=1;$_[0]->emit}sub start_for {my ($self,$flags)=@_;push @{$self->{__region_targets}},$flags->{target_matching};$self->{started_for}=1;$self->{in_for}=1;unless ($self->__in_literal_xhtml_region){$self->{scratch}.= '<div';$self->{scratch}.= qq( class="$flags->{target}") if$flags->{target};$self->{scratch}.= ">\n\n"}}sub end_for {my ($self)=@_;delete$self->{started_for};delete$self->{in_for};if ($self->__in_literal_xhtml_region){$self->{'scratch'}=~ s/\s+\z//s}else {$self->{'scratch'}.= '</div>'}pop @{$self->{__region_targets}};$self->emit}sub start_Document {my ($self)=@_;if (defined$self->html_header){$self->{'scratch'}.= $self->html_header;$self->emit unless$self->html_header eq ""}else {my ($doctype,$title,$metatags,$bodyid);$doctype=$self->html_doctype || '';$title=$self->force_title || $self->title || $self->default_title || '';$metatags=$self->html_header_tags || '';if (my$css=$self->html_css){if ($css !~ /<link/){$metatags .= '<link rel="stylesheet" href="' .$self->encode_entities($css).'" type="text/css" />'}else {$metatags .= $css}}if ($self->html_javascript){$metatags .= qq{\n<script type="text/javascript" src="} .$self->html_javascript .'"></script>'}$bodyid=$self->backlink ? ' id="_podtop_"' : '';$self->{'scratch'}.= <<"HTML";$self->emit}}sub end_Document {my ($self)=@_;my$to_index=$self->{'to_index'};if ($self->index && @{$to_index}){my@out;my$level=0;my$indent=-1;my$space='';my$id=' id="index"';for my$h (@{$to_index},[0]){my$target_level=$h->[0];if ($level==$target_level){$out[-1].= '</li>'}elsif ($level > $target_level){$out[-1].= '</li>' if$out[-1]=~ /^\s+<li>/;while ($level > $target_level){--$level;push@out,('  ' x --$indent).'</li>' if@out && $out[-1]=~ m{^\s+<\/ul};push@out,('  ' x --$indent).'</ul>'}push@out,('  ' x --$indent).'</li>' if$level}else {while ($level < $target_level){++$level;push@out,('  ' x ++$indent).'<li>' if@out && $out[-1]=~ /^\s*<ul/;push@out,('  ' x ++$indent)."<ul$id>";$id=''}++$indent}next unless$level;$space='  ' x $indent;push@out,sprintf '%s<li><a href="#%s">%s</a>',$space,$h->[1],$h->[2]}my$offset=defined$self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;splice @{$self->{'output'}},$offset,0,join "\n",@out}if (defined$self->html_footer){$self->{'scratch'}.= $self->html_footer;$self->emit unless$self->html_footer eq ""}else {$self->{'scratch'}.= "</body>\n</html>";$self->emit}if ($self->index){print {$self->{'output_fh'}}join ("\n\n",@{$self->{'output'}}),"\n\n";@{$self->{'output'}}=()}}sub start_B {$_[0]{'scratch'}.= '<b>'}sub end_B {$_[0]{'scratch'}.= '</b>'}sub start_C {push(@{$_[0]{'in_code'}},'C');$_[0]->start_code($_[0]{'in_code'}[-1])}sub end_C {$_[0]->end_code(pop(@{$_[0]{'in_code'}}))}sub start_F {$_[0]{'scratch'}.= '<i>'}sub end_F {$_[0]{'scratch'}.= '</i>'}sub start_I {$_[0]{'scratch'}.= '<i>'}sub end_I {$_[0]{'scratch'}.= '</i>'}sub start_L {my ($self,$flags)=@_;my ($type,$to,$section)=@{$flags}{'type','to','section'};my$url=$self->encode_entities($type eq 'url' ? $to : $type eq 'pod' ? $self->resolve_pod_page_link($to,$section): $type eq 'man' ? $self->resolve_man_page_link($to,$section): undef);$self->{'scratch'}.= '<a' .($url ? ' href="'.$url .'">' : '>')}sub end_L {$_[0]{'scratch'}.= '</a>'}sub start_S {$_[0]{'scratch'}.= '<span style="white-space: nowrap;">'}sub end_S {$_[0]{'scratch'}.= '</span>'}sub emit {my($self)=@_;if ($self->index){push @{$self->{'output'}},$self->{'scratch'}}else {print {$self->{'output_fh'}}$self->{'scratch'},"\n\n"}$self->{'scratch'}='';return}sub resolve_pod_page_link {my ($self,$to,$section)=@_;return undef unless defined$to || defined$section;if (defined$section){$section='#' .$self->idify($self->encode_entities($section),1);return$section unless defined$to}else {$section=''}return ($self->perldoc_url_prefix || '').$self->encode_entities($to).$section .($self->perldoc_url_postfix || '')}sub resolve_man_page_link {my ($self,$to,$section)=@_;return undef unless defined$to;my ($page,$part)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless$page;return ($self->man_url_prefix || '').($part || 1)."/" .$self->encode_entities($page).($self->man_url_postfix || '')}sub idify {my ($self,$t,$not_unique)=@_;for ($t){s/<[^>]+>//g;s/&[^;]+;//g;s/^\s+//;s/\s+$//;s/^([^a-zA-Z]+)$/pod$1/;s/^[^a-zA-Z]+//;s/[^-a-zA-Z0-9_:.]+/-/g;s/[-:.]+$//}return$t if$not_unique;my$i='';$i++ while$self->{ids}{"$t$i"}++;return "$t$i"}sub batch_mode_page_object_init {my ($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub html_header_after_title {}1;
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  require 5;package Pod::Simple::XMLOutStream;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.42';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}$ATTR_PAD="\n" unless defined$ATTR_PAD;$SORT_ATTRS=0 unless defined$SORT_ATTRS;sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh "<",$_[1];if($SORT_ATTRS){for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh $ATTR_PAD,$key,'="',$value,'"'}}}else {while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value);print$fh $ATTR_PAD,$key,'="',$value,'"'}}}print$fh ">";return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$text=$_[1];_xml_escape($text);print {$_[0]{'output_fh'}}$text}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}"</",$_[1],">";return}sub _xml_escape {for my$x (@_){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}return}1;
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Pod/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT';
  package Pod::Text;use 5.008;use strict;use warnings;use vars qw(@ISA @EXPORT %ESCAPES $VERSION);use Carp qw(carp croak);use Encode qw(encode);use Exporter ();use Pod::Simple ();@ISA=qw(Pod::Simple Exporter);@EXPORT=qw(pod2text);$VERSION='4.14';my ($NBSP,$SHY);if ($Pod::Simple::VERSION ge 3.30){$NBSP=$Pod::Simple::nbsp;$SHY=$Pod::Simple::shy}else {$NBSP=chr utf8::unicode_to_native(0xA0);$SHY=chr utf8::unicode_to_native(0xAD)}sub handle_code {my ($line,$number,$parser)=@_;$parser->output_code ($line ."\n")}sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if ($self->can ('preserve_whitespace')){$self->preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/text TEXT/);$self->merge_text (1);my%opts=@_;my@opts=map {("opt_$_",$opts{$_})}keys%opts;%$self=(%$self,@opts);if ($$self{opt_stderr}and not $$self{opt_errors}){$$self{opt_errors}='stderr'}delete $$self{opt_stderr};if (not defined $$self{opt_errors}){$$self{opt_errors}='pod'}if ($$self{opt_errors}eq 'stderr' || $$self{opt_errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{opt_errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{opt_errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{opt_errors}eq 'none'){$self->no_errata_section (1);$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};$$self{opt_alt}=0 unless defined $$self{opt_alt};$$self{opt_indent}=4 unless defined $$self{opt_indent};$$self{opt_margin}=0 unless defined $$self{opt_margin};$$self{opt_loose}=0 unless defined $$self{opt_loose};$$self{opt_sentence}=0 unless defined $$self{opt_sentence};$$self{opt_width}=76 unless defined $$self{opt_width};$$self{opt_quotes}||= '"';if ($$self{opt_quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{opt_quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{opt_quotes}}elsif (length ($$self{opt_quotes})% 2==0){my$length=length ($$self{opt_quotes})/ 2;$$self{LQUOTE}=substr ($$self{opt_quotes},0,$length);$$self{RQUOTE}=substr ($$self{opt_quotes},$length)}else {croak qq(Invalid quote specification "$$self{opt_quotes}")}$self->code_handler (\&handle_code)if $$self{opt_code};return$self}sub _handle_text {my ($self,$text)=@_;my$tag=$$self{PENDING}[-1];$$tag[1].= $text}sub method_for_element {my ($self,$element)=@_;$element =~ tr/-/_/;$element =~ tr/A-Z/a-z/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){push (@{$$self{PENDING}},[$attrs,'' ])}elsif ($self->can ("start_$method")){my$method='start_' .$method;$self->$method ($attrs,'')}}sub _handle_element_end {my ($self,$element)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){my$tag=pop @{$$self{PENDING}};my$method='cmd_' .$method;my$text=$self->$method (@$tag);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][1].= $text}else {$self->output ($text)}}}elsif ($self->can ("end_$method")){my$method='end_' .$method;$self->$method ()}}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){if (s/^([^\n]{0,$width})[ \t\n]+// || s/^([^\n]{$width})//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}sub reformat {my$self=shift;local $_=shift;if ($$self{opt_sentence}){s/ +$//mg;s/\.\n/. \n/g;s/\n/ /g;s/   +/  /g}else {s/[ \t\n]+/ /g}return$self->wrap ($_)}sub output {my ($self,@text)=@_;my$text=join ('',@text);if ($NBSP){$text =~ s/$NBSP/ /g}if ($SHY){$text =~ s/$SHY//g}unless ($$self{opt_utf8}){my$encoding=$$self{encoding}|| '';if ($encoding && $encoding ne $$self{ENCODING}){$$self{ENCODING}=$encoding;eval {binmode ($$self{output_fh},":encoding($encoding)")}}}if ($$self{ENCODE}){print {$$self{output_fh}}encode ('UTF-8',$text)}else {print {$$self{output_fh}}$text}}sub output_code {$_[0]->output ($_[1])}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}my$margin=$$self{opt_indent}+ $$self{opt_margin};$$self{INDENTS}=[];$$self{MARGIN}=$margin;$$self{PENDING}=[[]];$$self{ENCODING}='';$$self{ENCODE}=0;if ($$self{opt_utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my$flag=(PerlIO::get_layers ($$self{output_fh},@options))[-1];if ($flag && ($flag & PerlIO::F_UTF8 ())){$$self{ENCODE}=0;$$self{ENCODING}='UTF-8'}}}return ''}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}}sub strip_format {my ($self,$string)=@_;return$string}sub item {my ($self,$text)=@_;my$tag=$$self{ITEM};unless (defined$tag){carp "Item called without tag";return}undef $$self{ITEM};my$indent=$$self{INDENTS}[-1];$indent=$$self{opt_indent}unless defined$indent;my$margin=' ' x $$self{opt_margin};my$tag_length=length ($self->strip_format ($tag));my$fits=($$self{MARGIN}- $indent >= $tag_length + 1);if (!$text || $text =~ /^\s+$/ ||!$fits){my$realindent=$$self{MARGIN};$$self{MARGIN}=$indent;my$output=$self->reformat ($tag);$output =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);$output =~ s/\n*$/\n/;$output .= "\n" if$text && $text =~ /^\s*$/;$self->output ($output);$$self{MARGIN}=$realindent;$self->output ($self->reformat ($text))if ($text && $text =~ /\S/)}else {my$space=' ' x $indent;$space =~ s/^$margin /$margin:/ if $$self{opt_alt};$text=$self->reformat ($text);$text =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);my$tagspace=' ' x $tag_length;$text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";$self->output ($text)}}sub cmd_para {my ($self,$attrs,$text)=@_;$text =~ s/\s+$/\n/;if (defined $$self{ITEM}){$self->item ($text ."\n")}else {$self->output ($self->reformat ($text ."\n"))}return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;$self->item if defined $$self{ITEM};return if$text =~ /^\s*$/;$text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;$text =~ s/\s*$/\n\n/;$self->output ($text);return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text =~ s/\s+$//;if ($$self{opt_alt}){my$closemark=reverse (split (//,$marker));my$margin=' ' x $$self{opt_margin};$self->output ("\n" ."$margin$marker $text $closemark" ."\n\n")}else {$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n")}return ''}sub cmd_head1 {my ($self,$attrs,$text)=@_;$self->heading ($text,0,'====')}sub cmd_head2 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}/ 2,'==  ')}sub cmd_head3 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 2 / 3 + 0.5,'=   ')}sub cmd_head4 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 3 / 4 + 0.5,'-   ')}sub over_common_start {my ($self,$attrs)=@_;$self->item ("\n\n")if defined $$self{ITEM};my$indent=$$attrs{indent};unless (defined ($indent)&& $indent =~ /^\s*[-+]?\d{1,4}\s*$/){$indent=$$self{opt_indent}}push (@{$$self{INDENTS}},$$self{MARGIN});$$self{MARGIN}+= ($indent + 0);return ''}sub over_common_end {my ($self)=@_;$self->item ("\n\n")if defined $$self{ITEM};$$self{MARGIN}=pop @{$$self{INDENTS}};return ''}sub start_over_bullet {$_[0]->over_common_start ($_[1])}sub start_over_number {$_[0]->over_common_start ($_[1])}sub start_over_text {$_[0]->over_common_start ($_[1])}sub start_over_block {$_[0]->over_common_start ($_[1])}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;$self->item if defined $$self{ITEM};$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item='*'}elsif ($type eq 'number'){$item=$$attrs{'~orig_content'}}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text=''}$$self{ITEM}=$item;if ($text){$text =~ s/\s*$/\n/;$self->item ($text)}return ''}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub cmd_b {return $_[0]{alt}? "``$_[2]''" : $_[2]}sub cmd_f {return $_[0]{alt}? "\"$_[2]\"" : $_[2]}sub cmd_i {return '*' .$_[2].'*'}sub cmd_x {return ''}sub cmd_c {my ($self,$attrs,$text)=@_;my$index='(?: \[.*\] | \{.*\} )?';$text =~ m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \` .* \'                                       # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xo && return$text;return $$self{opt_alt}? "``$text''" : "$$self{LQUOTE}$text$$self{RQUOTE}"}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){if (not defined($$attrs{to})or $$attrs{to}eq $text){return "<$text>"}elsif ($$self{opt_nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub pod2text {my@args;while ($_[0]=~ /^-/){my$flag=shift;if ($flag eq '-a'){push (@args,alt=>1)}elsif ($flag =~ /^-(\d+)$/){push (@args,width=>$1)}else {unshift (@_,$flag);last}}my$parser=Pod::Text->new (@args);if (defined $_[1]){my@fhs=@_;local*IN;unless (open (IN,$fhs[0])){croak ("Can't open $fhs[0] for reading: $!\n");return}$fhs[0]=\*IN;$parser->output_fh ($fhs[1]);my$retval=$parser->parse_file ($fhs[0]);my$fh=$parser->output_fh ();close$fh;return$retval}else {$parser->output_fh (\*STDOUT);return$parser->parse_file (@_)}}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->Pod::Simple::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}1;
POD_TEXT

$fatpacked{"Pod/Text/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_COLOR';
  package Pod::Text::Color;use 5.008;use strict;use warnings;use Pod::Text ();use Term::ANSIColor qw(color colored);use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='4.14';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;local$Term::ANSIColor::EACHLINE="\n";$self->SUPER::cmd_head1 ($attrs,colored ($text,'bold'))}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,colored ($text,'bold'))}sub cmd_b {return colored ($_[2],'bold')}sub cmd_f {return colored ($_[2],'cyan')}sub cmd_i {return colored ($_[2],'yellow')}sub end_format {my ($self,$line)=@_;my$reset=color ('reset');my$current;while ($line =~ /(\e\[[\d;]+m)/g){my$code=$1;if ($code eq $reset){undef$current}else {$current .= $code}}return$current}sub output_code {my ($self,$code)=@_;local$Term::ANSIColor::EACHLINE="\n";$code=colored ($code,'green');$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/\e\[[\d;]*m//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$code='(?:\e\[[\d;]+m)';my$char="(?>$code*[^\\n])";my$shortchar='^(' .$char ."{0,$width}(?>$code*)" .')(?:\s+|\z)';my$longchar='^(' .$char ."{$width})";while (length > $width){if (s/$shortchar// || s/$longchar//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;if ($output =~ /\n/){my@lines=split (/\n/,$output);my$start_format;for my$line (@lines){if ($start_format && $line =~ /\S/){$line =~ s/^(\s*)(\S)/$1$start_format$2/}$start_format=$self->end_format ($line);if ($start_format){$line .= color ('reset')}}$output=join ("\n",@lines)}$output =~ s/\s+$/\n\n/;$output}1;
POD_TEXT_COLOR

$fatpacked{"Pod/Text/Overstrike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_OVERSTRIKE';
  package Pod::Text::Overstrike;use 5.008;use strict;use warnings;use vars qw(@ISA $VERSION);use Pod::Text ();@ISA=qw(Pod::Text);$VERSION='4.14';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head1 ($attrs,$text)}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head2 ($attrs,$text)}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head3 ($attrs,$text)}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head4 ($attrs,$text)}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n");return ''}sub cmd_b {local $_=$_[0]->strip_format ($_[2]);s/(.)/$1\b$1/g;$_}sub cmd_f {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub cmd_i {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub output_code {my ($self,$code)=@_;$code =~ s/(.)/$1\b$1/g;$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/(.)[\b]\1/$1/g;$text =~ s/_[\b]//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){my$char='(?:[^\n][\b])?[^\n]';if (s/^((?>$char){0,$width})(?:\Z|\s+)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_OVERSTRIKE

$fatpacked{"Pod/Text/Termcap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_TERMCAP';
  package Pod::Text::Termcap;use 5.008;use strict;use warnings;use Pod::Text ();use POSIX ();use Term::Cap;use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='4.14';sub new {my ($self,%args)=@_;my ($ospeed,$term,$termios);eval {$termios=POSIX::Termios->new};if ($@){$ospeed=9600}else {$termios->getattr;$ospeed=$termios->getospeed || 9600}my ($bold,$undl,$norm,$width);eval {my$term=Tgetent Term::Cap {TERM=>undef,OSPEED=>$ospeed};$bold=$term->Tputs('md');$undl=$term->Tputs('us');$norm=$term->Tputs('me');if (defined $$term{_co}){$width=$$term{_co};$width =~ s/^\#//}};unless (defined$args{width}){$args{width}=$ENV{COLUMNS}|| $width || 80;$args{width}-= 2}$self=$self->SUPER::new (%args);$$self{BOLD}=$bold || q{};$$self{UNDL}=$undl || q{};$$self{NORM}=$norm || q{};return$self}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head1 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_b {my$self=shift;return "$$self{BOLD}$_[1]$$self{NORM}"}sub cmd_i {my$self=shift;return "$$self{UNDL}$_[1]$$self{NORM}"}sub format_regex {my ($self)=@_;my@codes=($self->{BOLD},$self->{UNDL},$self->{NORM});return join(q{|},map {$_ eq q{} ? (): "\Q$_\E"}@codes)}sub end_format {my ($self,$line)=@_;my$pattern="(" .$self->format_regex().")";my$current;while ($line =~ /$pattern/g){my$code=$1;if ($code eq $$self{NORM}){undef$current}else {$current .= $code}}return$current}sub output_code {my ($self,$code)=@_;$self->output ($$self{BOLD}.$code .$$self{NORM})}sub strip_format {my ($self,$text)=@_;$text =~ s/\Q$$self{BOLD}//g;$text =~ s/\Q$$self{UNDL}//g;$text =~ s/\Q$$self{NORM}//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};if ($self->{BOLD}eq q{} && $self->{UNDL}eq q{} && $self->{NORM}eq q{}){return$self->SUPER::wrap($_)}my$code="(?:" .$self->format_regex().")";my$char="(?>$code*[^\\n])";my$shortchar='^(' .$char ."{0,$width}(?>$code*)" .')(?:\s+|\z)';my$longchar='^(' .$char ."{$width})";while (length > $width){if (s/$shortchar// || s/$longchar//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;if ($output =~ /\n/){my@lines=split (/\n/,$output);my$start_format;for my$line (@lines){if ($start_format && $line =~ /\S/){$line =~ s/^(\s*)(\S)/$1$start_format$2/}$start_format=$self->end_format ($line);if ($start_format){$line .= $$self{NORM}}}$output=join ("\n",@lines)}$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_TERMCAP

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  package Pod::Usage;use strict;require 5.006;use Carp;use Config;use Exporter;use File::Spec;our$VERSION='2.01';our@EXPORT=qw(&pod2usage);our@ISA;BEGIN {$Pod::Usage::Formatter ||= 'Pod::Text';eval "require $Pod::Usage::Formatter";die $@ if $@;@ISA=($Pod::Usage::Formatter)}our$MAX_HEADING_LEVEL=3;sub pod2usage {local($_)=shift;my%opts;if (@_ > 0){%opts=($_,@_)}elsif (!defined $_){$_=''}elsif (ref $_){%opts=%{$_}if (ref($_)eq 'HASH')}elsif (/^[-+]?\d+$/){$opts{'-exitval'}=$_}else {$_ and $opts{'-message'}=$_}%opts=map {my ($key,$val)=($_,$opts{$_});$key =~ s/^(?=\w)/-/;$key =~ /^-msg/i and $key='-message';$key =~ /^-exit/i and $key='-exitval';lc($key)=>$val}(keys%opts);if ((!defined$opts{'-exitval'})&& (!defined$opts{'-verbose'})){$opts{'-exitval'}=2;$opts{'-verbose'}=0}elsif (!defined$opts{'-exitval'}){$opts{'-exitval'}=($opts{'-verbose'}> 0)? 1 : 2}elsif (!defined$opts{'-verbose'}){$opts{'-verbose'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)}$opts{'-output'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)? \*STDOUT : \*STDERR unless (defined$opts{'-output'});$opts{'-input'}=$0 unless (defined$opts{'-input'});unless ((ref$opts{'-input'})|| (-e $opts{'-input'})){my$basename=$opts{'-input'};my$pathsep=($^O =~ /^(?:dos|os2|MSWin32)$/i)? ';' : (($^O eq 'MacOS' || $^O eq 'VMS')? ',' : ':');my$pathspec=$opts{'-pathlist'}|| $ENV{PATH}|| $ENV{PERL5LIB};my@paths=(ref$pathspec)? @$pathspec : split($pathsep,$pathspec);for my$dirname (@paths){$_=length($dirname)? File::Spec->catfile($dirname,$basename): $basename;last if (-e $_)&& ($opts{'-input'}=$_)}}my$parser=Pod::Usage->new(USAGE_OPTIONS=>\%opts);if ($opts{'-verbose'}==0){$parser->select('(?:SYNOPSIS|USAGE)\s*')}elsif ($opts{'-verbose'}==1){my$opt_re='(?i)' .'(?:OPTIONS|ARGUMENTS)' .'(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';$parser->select('(?:SYNOPSIS|USAGE)\s*',$opt_re,"DESCRIPTION/$opt_re")}elsif ($opts{'-verbose'}>= 2 && $opts{'-verbose'}!=99){$parser->select('.*')}elsif ($opts{'-verbose'}==99){my$sections=$opts{'-sections'};$parser->select((ref$sections)? @$sections : $sections);$opts{'-verbose'}=1}my$progpath=$opts{'-perldoc'}? $opts{'-perldoc'}: File::Spec->catfile($Config{scriptdirexp}|| $Config{scriptdir},'perldoc');my$version=sprintf("%vd",$^V);if ($Config{versiononly}and $Config{startperl}=~ /\Q$version\E$/){$progpath .= $version}$opts{'-noperldoc'}=1 unless -e $progpath;if (!$opts{'-noperldoc'}and $opts{'-verbose'}>= 2 and!ref($opts{'-input'})and $opts{'-output'}==\*STDOUT){print {$opts{'-output'}}($opts{'-message'},"\n")if($opts{'-message'});if(defined$opts{-input}&& $opts{-input}=~ /^\s*(\S.*?)\s*$/){my$f=$1;my@perldoc_cmd=($progpath);if ($opts{'-perldocopt'}){$opts{'-perldocopt'}=~ s/^\s+|\s+$//g;push@perldoc_cmd,split(/\s+/,$opts{'-perldocopt'})}push@perldoc_cmd,('-F',$f);unshift@perldoc_cmd,$opts{'-perlcmd'}if$opts{'-perlcmd'};system(@perldoc_cmd);if($?){my$pager=$ENV{PAGER}|| $Config{pager};if(defined($pager)&& length($pager)){my$cmd=$pager .' ' .($^O =~ /win/i ? qq("$f") : quotemeta($f));system($cmd)}else {system('more',$f)}}}else {croak "Unspecified input file or insecure argument.\n"}}else {$parser->parse_from_file($opts{'-input'},$opts{'-output'})}exit($opts{'-exitval'})unless (lc($opts{'-exitval'})eq 'noexit')}sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;if ($self->can('initialize')){$self->initialize()}else {my%opts;for (qw(alt code indent loose margin quotes sentence stderr utf8 width)){my$val=$params{USAGE_OPTIONS}{"-$_"};$opts{$_}=$val if defined$val}$self=$self->SUPER::new(%opts);%$self=(%$self,%params)}return$self}sub _compile_section_spec {my ($section_spec)=@_;my (@regexs,$negated);local $_=$section_spec;s{\\\\}{\001}g;s{\\/}{\002}g;@regexs=split(/\//,$_,$MAX_HEADING_LEVEL);for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$regexs[$i]='.*' unless ((defined$regexs[$i])&& (length$regexs[$i]))}my$bad_regexs=0;for (@regexs){$_ .= '.+' if ($_ eq '!');s{\001}{\\\\}g;s{\002}{\\/}g;$negated=s/^\!//;eval "m{$_}";if ($@){++$bad_regexs;carp qq{Bad regular expression /$_/ in "$section_spec": $@\n}}else {$_='^' .$_ unless (/^\^/);$_=$_ .'$' unless (/\$$/);$_='!' .$_ if ($negated)}}return (!$bad_regexs)? [@regexs ]: undef}sub select {my ($self,@sections)=@_;if ($ISA[0]->can('select')){$self->SUPER::select(@sections)}else {my$add=($sections[0]eq '+')? shift(@sections): '';unless (@sections){delete$self->{USAGE_SELECT}unless ($add);return}$self->{USAGE_SELECT}=[]unless ($add && $self->{USAGE_SELECT});my$sref=$self->{USAGE_SELECT};for my$spec (@sections){my$cs=_compile_section_spec($spec);if (defined$cs){push(@$sref,$cs)}else {carp qq{Ignoring section spec "$spec"!\n}}}}}sub seq_i {return $_[1]}sub cmd_i {my$self=shift;return$self->SUPER::cmd_i(@_)if$self->isa('Pod::Text::Termcap');return $_[1]}sub _handle_element_end {my ($self,$element)=@_;if ($element eq 'head1'){$self->{USAGE_HEADINGS}=[$$self{PENDING}[-1][1]];if ($self->{USAGE_OPTIONS}->{-verbose}< 2){$$self{PENDING}[-1][1]=~ s/^\s*SYNOPSIS\s*$/USAGE/}}elsif ($element =~ /^head(\d+)$/ && $1){my$idx=$1 - 1;$self->{USAGE_HEADINGS}=[]unless($self->{USAGE_HEADINGS});$self->{USAGE_HEADINGS}->[$idx]=$$self{PENDING}[-1][1];splice(@{$self->{USAGE_HEADINGS}},$idx+1)}if ($element =~ /^head\d+$/){$$self{USAGE_SKIPPING}=1;if (!$$self{USAGE_SELECT}||!@{$$self{USAGE_SELECT}}){$$self{USAGE_SKIPPING}=0}else {my@headings=@{$$self{USAGE_HEADINGS}};for my$section_spec (@{$$self{USAGE_SELECT}}){my$match=1;for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$headings[$i]='' unless defined$headings[$i];my$regex=$section_spec->[$i];my$negated=($regex =~ s/^\!//);$match &= ($negated ? ($headings[$i]!~ /${regex}/): ($headings[$i]=~ /${regex}/));last unless ($match)}if ($match){$$self{USAGE_SKIPPING}=0;last}}}if($self->{USAGE_OPTIONS}->{-verbose}< 2){local $_=$$self{PENDING}[-1][1];s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n";$$self{PENDING}[-1][1]=$_}}if ($$self{USAGE_SKIPPING}&& $element !~ m/^over-|^[BCFILSZ]$/){pop @{$$self{PENDING}}}else {$self->SUPER::_handle_element_end($element)}}sub start_document {my$self=shift;$self->SUPER::start_document();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_fh();print$out_fh "$msg\n"}sub begin_pod {my$self=shift;$self->SUPER::begin_pod();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_handle();print$out_fh "$msg\n"}sub preprocess_paragraph {my$self=shift;local $_=shift;my$line=shift;if (($self->{USAGE_OPTIONS}->{-verbose}< 2)&& /^=head/){s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n"}return$self->SUPER::preprocess_paragraph($_)}1;
POD_USAGE

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;use strict;our$VERSION='0.238';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}};1;
PARENT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use Perl::Build;
use Devel::PatchPerl;
use Getopt::Long;
use Pod::Usage;
use File::Spec;

my $test = undef;
my $patches;
my $build_dir;
my $symlink_devel_executables;
my (@D, @A, @U);
Getopt::Long::Configure(
    'pass_through',
    'no_ignore_case',
    'bundling',
);
GetOptions(
    'h|help' => \my $help,
    'test!' => \$test,
    'D=s@'  => \@D,
    'A=s@'  => \@A,
    'U=s@'  => \@U,
    'definitions' => \my $definitions,
    'patches=s' => \$patches,
    'build-dir=s' => \$build_dir,
    'j|jobs=i' => \my $jobs,
    'tarball-dir=s' => \my $tarball_dir,
    'version' => \my $show_version,
    'symlink-devel-executables!' => \$symlink_devel_executables,
    'noman' => \my $noman,
);
for (@D, @A, @U) {
    s/^=//;
}

if ($show_version) {
    print "perl-build $Perl::Build::VERSION ($0)\n";
    print "perl $] ($^X)\n";
    print "Devel::PatchPerl $Devel::PatchPerl::VERSION\n";
    exit 0;
}

pod2usage(1) if $help;

if ($definitions) {
    for (Perl::Build->available_perls()) {
        print "$_\n";
    }
    exit 0;
}

shift @ARGV if @ARGV >= 1 && $ARGV[0] eq '--';

my $stuff   = shift @ARGV or pod2usage();
my $dest    = shift @ARGV or pod2usage();
   $dest    = File::Spec->rel2abs($dest);

my @configure_options = @ARGV ? @ARGV : ('-de');
push @configure_options, map { "-D$_" } @D;
push @configure_options, map { "-A$_" } @A;
push @configure_options, map { "-U$_" } @U;
push @configure_options, "-Dman1dir=none", "-Dman3dir=none" if $noman;

$ENV{PERL5_PATCHPERL_PLUGIN} = $patches if defined $patches;

if ($stuff eq 'blead') {
    my $url = "https://github.com/Perl/perl5/archive/blead.tar.gz";
    Perl::Build->install_from_url(
        $url => (
            dst_path          => $dest,
            configure_options => ['-Dusedevel', @configure_options],
            test              => $test,
            build_dir         => $build_dir,
            jobs              => $jobs,
            tarball_dir       => $tarball_dir,
        )
    );
} elsif ($stuff =~ m{^https?://}) {
    Perl::Build->install_from_url(
        $stuff => (
            dst_path          => $dest,
            configure_options => \@configure_options,
            test              => $test,
            build_dir         => $build_dir,
            jobs              => $jobs,
            tarball_dir       => $tarball_dir,
        )
    );
} elsif ($stuff =~ /\.(gz|bz2|xz)$/) {
    Perl::Build->install_from_tarball(
        $stuff => (
            dst_path          => $dest,
            configure_options => \@configure_options,
            test              => $test,
            build_dir         => $build_dir,
            jobs              => $jobs,
        )
    );
} else {
    my $version = $stuff;
    Perl::Build->install_from_cpan(
        $version => (
            dst_path          => $dest,
            configure_options => \@configure_options,
            test              => $test,
            build_dir         => $build_dir,
            jobs              => $jobs,
            tarball_dir       => $tarball_dir,
        )
    );
}

if ($symlink_devel_executables) {
    Perl::Build->symlink_devel_executables(
        File::Spec->catdir($dest, 'bin')
    );
}

__END__

=head1 NAME

perl-build - perl binary builder

=head1 SYNOPSIS 

    # perl-build command is FatPacker ready
    % curl -L https://raw.github.com/tokuhirom/Perl-Build/master/perl-build | perl - 5.16.2 /opt/perl-5.16/

    # Or, just install from CPAN
    % cpanm Perl::Build

    # And run it.
    % perl-build 5.16.2 /usr/local/perl-5.16.2
    % perl-build path/to/perl-5.16.2.tar.gz /usr/local/perl-5.16.2

=head1 DESCRIPTION

This script fetch/build/install perl5 from CPAN or tar ball.

=head1 OPTIONS

=over 4

=item -D, -A, -U

-Dxxx, -Axxx, -Uxxx options are pass through to ./Configure script.

=item --test

This option enables C<< make test >> after building.

(Default: disabled)

=item --patches=Asan

You can set I<PERL5_PATCHPERL_PLUGIN> environment variable by this option.

=item --build-dir=path

Specify perl build path. optional. (Default: temporary directory)

=item -j n

=item --jobs n

Parallel building and testing.

=item --tarball-dir

Specify the tar ball saving directory.

(Default: temporary directory, will remove after building)

=item --definitions

    % perl-build --definitions

Display the available perl versions and exit.

=item --version

Show version number and exit.

=item --symlink-devel-executables

Create symlinks for development version perl commands.

=item --noman

Skip installation of manpages.
This is equivalent to specifying C<-Dman1dir=none> and C<-Dman3dir=none>.

=back

=head1 FAQ

=over 4

=item How can I apply security fixes like CVE-2013-1667?

RURBAN provides L<Devel::PatchPerl::Plugin::Asan>. Install it and run C<< perl-build --patches=Asan 5.16.1 /opt/perl/5.16/ >>.

=back

=head1 SEE ALSO

L<perlbrew>, L<plenv>

